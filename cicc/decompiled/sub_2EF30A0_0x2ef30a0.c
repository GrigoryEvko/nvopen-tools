// Function: sub_2EF30A0
// Address: 0x2ef30a0
//
void __fastcall sub_2EF30A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // r15
  int v6; // eax
  unsigned __int16 *v7; // r14
  unsigned int v8; // ebx
  unsigned int v9; // eax
  __int64 v10; // rbx
  __int64 v11; // rax
  int v12; // r12d
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // r9
  _QWORD *v16; // rdx
  _QWORD *i; // rcx
  __int64 v18; // r9
  int v19; // edx
  unsigned __int64 v20; // rdi
  bool v21; // dl
  bool v22; // cl
  char v23; // si
  __int64 v24; // rdi
  __int64 v25; // r8
  __int64 *v26; // r11
  __int64 v27; // r12
  int v28; // ecx
  __int64 v29; // rbx
  unsigned int v30; // eax
  __int64 v31; // rdx
  __int64 v32; // rdi
  __int64 (*v33)(); // rax
  int v34; // ebx
  __int16 v35; // r12
  __int64 v36; // rcx
  __int64 v37; // rdx
  unsigned __int64 v38; // rdi
  char v39; // cl
  __int64 v40; // rbx
  __int64 v41; // r12
  __int64 v42; // rax
  int v43; // eax
  __int64 v44; // rax
  _BYTE *v45; // rax
  _BYTE *v46; // rdx
  __int64 v47; // rbx
  __int64 v48; // r12
  unsigned __int64 v49; // r14
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // r12
  char v52; // bl
  unsigned __int64 v53; // rax
  unsigned __int64 v54; // rdx
  __int16 v55; // cx
  __int64 v56; // r14
  __int64 v57; // r12
  __int64 v58; // rbx
  __int64 v59; // rax
  char v60; // dl
  __int64 v61; // r14
  __int64 v62; // r12
  __int64 v63; // rax
  __int64 v64; // rax
  _DWORD *v65; // rdx
  int v66; // eax
  __int64 v67; // r12
  int v68; // eax
  __int64 v69; // rax
  unsigned __int64 v70; // r14
  int v71; // eax
  __int64 v72; // rbx
  __int64 v73; // r14
  unsigned __int64 v74; // r12
  unsigned __int64 v75; // rax
  unsigned __int64 v76; // rax
  int v77; // edx
  __int64 v78; // rbx
  char v79; // al
  __int64 v80; // rax
  int *v81; // rdx
  int v82; // eax
  __int64 *v83; // rsi
  __int64 v84; // r14
  const char *v85; // r12
  size_t v86; // rax
  size_t v87; // rcx
  __int64 v88; // r14
  __int16 v89; // ax
  unsigned __int64 v90; // rax
  const char *v91; // rax
  unsigned __int64 v92; // rdi
  __int64 v93; // r8
  const char *v94; // rax
  __int64 v95; // rdx
  char v96; // al
  const char *v97; // rax
  int *v98; // r12
  __int64 v99; // rbx
  char v100; // r14
  __int64 v101; // rbx
  __int64 v102; // rax
  __int64 v103; // r12
  __int64 v104; // rbx
  unsigned __int64 v105; // r14
  unsigned __int64 v106; // rax
  __int64 v107; // r14
  __int64 v108; // r12
  unsigned __int64 v109; // rbx
  unsigned __int64 v110; // rax
  __int64 v111; // r14
  __int64 v112; // r12
  unsigned __int64 v113; // rbx
  unsigned __int64 v114; // rax
  __int64 v115; // r12
  __int64 v116; // rbx
  __int64 v117; // rax
  __int64 v118; // rcx
  __int64 v119; // rdx
  __int64 v120; // rsi
  __int64 v121; // rdx
  __int64 v122; // rdi
  int v123; // edx
  unsigned __int64 v124; // r9
  bool v125; // r8
  bool v126; // dl
  unsigned __int8 v127; // r10
  __int64 v128; // rdx
  int *v129; // rbx
  __int64 v130; // r14
  __int64 v131; // r12
  int *v132; // r12
  __int64 v133; // r14
  __int64 v134; // rbx
  __int64 v135; // r14
  __int64 v136; // r14
  __int64 v137; // r12
  __int64 v138; // rdx
  __int64 v139; // rbx
  __int64 v140; // rbx
  int *v141; // r12
  __int64 v142; // rbx
  __int64 v143; // r14
  __int64 v144; // rax
  char v145; // bl
  __int64 v146; // r12
  __int64 v147; // rax
  __int64 v148; // rax
  __int64 v149; // rbx
  __int64 v150; // rax
  __int64 v151; // rax
  unsigned __int64 v152; // rax
  unsigned __int64 v153; // rax
  __int64 v154; // rbx
  __int64 v155; // rax
  __int64 v156; // rax
  int *v157; // rbx
  __int64 v158; // r14
  unsigned __int64 v159; // r12
  __int64 v160; // rax
  __int64 v161; // r12
  __int64 v162; // r14
  __int64 v163; // r12
  __int64 v164; // rbx
  int v165; // ebx
  __int64 v166; // rdx
  char v167; // r14
  __int64 v168; // r12
  __int64 v169; // rdx
  unsigned int v170; // r12d
  unsigned __int64 v171; // rcx
  bool v172; // dl
  bool v173; // al
  unsigned __int8 v174; // si
  __int64 v175; // rax
  int v176; // eax
  __int64 v177; // rdx
  __int64 v178; // rax
  unsigned __int64 v179; // rcx
  char v180; // al
  __int64 v181; // rbx
  __int64 v182; // r14
  unsigned __int64 v183; // r12
  unsigned __int64 v184; // rax
  __int64 v185; // rax
  __int64 v186; // rax
  __int64 v187; // r14
  __int64 v188; // r14
  __int64 v189; // r12
  __int64 v190; // rbx
  __int64 v191; // rax
  __int64 v192; // r8
  __int64 v193; // r9
  unsigned __int8 v194; // r11
  int *v195; // rdi
  unsigned __int64 v196; // rcx
  bool v197; // dl
  bool v198; // al
  unsigned __int8 v199; // si
  __int64 v200; // rax
  int v201; // eax
  unsigned __int64 v202; // rcx
  bool v203; // dl
  bool v204; // al
  unsigned __int8 v205; // si
  __int64 v206; // rax
  unsigned __int64 v207; // rax
  __int64 v208; // r14
  __int64 v209; // r12
  __int64 v210; // rax
  unsigned __int64 v211; // r12
  unsigned int v212; // r8d
  __int64 v213; // rdi
  __int64 v214; // rax
  int v215; // r8d
  __int64 v216; // rdx
  __int64 v217; // r14
  __int64 v218; // rbx
  unsigned __int64 v219; // rsi
  bool v220; // dl
  bool v221; // al
  unsigned __int8 v222; // r8
  __int64 v223; // rax
  int v224; // edx
  __int64 v225; // rax
  unsigned __int64 v226; // rsi
  bool v227; // cl
  bool v228; // dl
  unsigned __int8 v229; // di
  __int64 v230; // rdx
  int v231; // eax
  __int64 v232; // rcx
  __int64 v233; // rax
  unsigned __int64 v234; // rsi
  char v235; // al
  __int64 v236; // r14
  __int64 v237; // rax
  __int64 v238; // r12
  __int64 v239; // rax
  __int64 v240; // r14
  __int64 v241; // r12
  __int64 v242; // rax
  __int64 v243; // rax
  __int64 v244; // rdx
  __int64 v245; // rbx
  __int64 v246; // r12
  unsigned __int64 v247; // rsi
  bool v248; // r8
  bool v249; // al
  unsigned __int8 v250; // di
  __int64 v251; // rdx
  int v252; // eax
  unsigned __int64 v253; // rsi
  bool v254; // cl
  bool v255; // al
  unsigned __int8 v256; // di
  __int64 v257; // rax
  int v258; // eax
  __int64 v259; // rcx
  __int64 v260; // rax
  unsigned __int64 v261; // rdx
  __int64 v262; // r14
  __int64 v263; // r12
  __int64 v264; // rbx
  __int64 v265; // rax
  char v266; // al
  __int64 v267; // rdx
  __int64 v268; // rdx
  __int64 v269; // r14
  __int64 v270; // r12
  __int64 v271; // rbx
  __int64 v272; // rax
  __int64 v273; // r12
  __int64 v274; // rax
  unsigned __int64 v275; // rdx
  __int64 v276; // rax
  __int64 v277; // rbx
  __int64 v278; // rax
  __int64 v279; // rdx
  __int64 v280; // r14
  __int64 v281; // rcx
  __int64 j; // rbx
  __int64 v283; // r13
  __int64 v284; // rax
  __int64 v285; // r8
  int v286; // edx
  unsigned __int64 v287; // r9
  bool v288; // r10
  bool v289; // dl
  unsigned __int8 v290; // r11
  __int64 v291; // rdx
  int v292; // edx
  unsigned __int64 v293; // r9
  bool v294; // r10
  bool v295; // dl
  unsigned __int8 v296; // r11
  __int64 v297; // rdx
  int v298; // edx
  unsigned __int64 v299; // r9
  bool v300; // r10
  bool v301; // dl
  unsigned __int8 v302; // r11
  __int64 v303; // rdx
  __int64 v304; // rdx
  int v305; // edx
  unsigned __int64 v306; // r8
  bool v307; // di
  bool v308; // dl
  unsigned __int8 v309; // r9
  __int64 v310; // rdx
  __int64 v311; // rax
  unsigned __int64 v312; // rcx
  char v313; // al
  __int64 v314; // rdx
  unsigned __int64 v315; // rsi
  char v316; // dl
  __int64 v317; // rax
  unsigned __int64 v318; // rsi
  char v319; // al
  __int64 v320; // rdx
  unsigned __int64 v321; // r9
  char v322; // dl
  __int64 v323; // rdx
  unsigned __int64 v324; // r9
  char v325; // dl
  __int64 v326; // rdx
  unsigned __int64 v327; // r9
  char v328; // dl
  __int64 v329; // rdx
  unsigned __int64 v330; // r9
  char v331; // dl
  __m128i v332; // rax
  unsigned __int64 v333; // rbx
  __int64 v334; // rdx
  __int64 v335; // rbx
  __int64 v336; // rdx
  char v337; // r12
  __int64 v338; // rdx
  unsigned __int64 v339; // rcx
  __int64 v340; // rbx
  __int64 v341; // rdx
  char v342; // r12
  __int64 v343; // rdx
  __int64 (*v344)(); // rax
  __int64 v345; // r12
  __m128i v346; // rax
  __int64 v347; // rbx
  __int64 (__fastcall *v348)(__int64, __int64); // r14
  __int64 v349; // rax
  unsigned __int16 v350; // ax
  __int64 v351; // r12
  __int64 v352; // rbx
  __int64 v353; // rax
  unsigned __int64 v354; // rbx
  unsigned __int64 v355; // rax
  int v356; // r12d
  unsigned __int64 v357; // rax
  int v358; // eax
  unsigned __int64 v359; // rax
  int *v360; // rbx
  __int64 v361; // r14
  int *v362; // r14
  int k; // r12d
  __int64 v364; // rsi
  unsigned int v365; // r12d
  __int64 v366; // rdi
  __int64 v367; // rax
  __int64 v368; // rax
  __int64 v369; // r12
  unsigned __int64 v370; // rbx
  unsigned __int64 v371; // rax
  __int64 v372; // rax
  unsigned int v373; // ebx
  bool v374; // al
  unsigned int v375; // r14d
  unsigned int v376; // r12d
  unsigned __int64 v377; // rax
  unsigned __int64 v378; // rcx
  __int64 v379; // rsi
  unsigned __int64 v380; // rax
  unsigned __int64 v381; // rax
  __int64 v382; // rbx
  int v383; // r14d
  __int64 v384; // rbx
  int v385; // r14d
  __int64 *v386; // rax
  char v387; // al
  const char *v388; // rbx
  size_t v389; // rax
  __m128i v390; // rax
  __m128i v391; // rax
  unsigned int v392; // eax
  unsigned int v393; // edx
  unsigned int v394; // eax
  __int64 v395; // rdi
  __int64 v396; // rax
  unsigned __int64 v397; // rcx
  char v398; // al
  __int64 v399; // r14
  __int64 v400; // r12
  __int64 v401; // rax
  __int64 v402; // r12
  __int64 v403; // rax
  __int64 v404; // rbx
  __int64 v405; // rdx
  __int64 *v406; // rax
  int v407; // eax
  const char *v408; // rbx
  size_t v409; // rax
  __int64 v410; // rax
  __m128i v411; // rax
  unsigned int v412; // r12d
  __int64 v413; // rdx
  unsigned int v414; // ebx
  unsigned __int64 v415; // r14
  __int64 v416; // rdx
  __int64 v417; // r12
  __int16 v418; // ax
  __int64 v419; // rdi
  __int16 v420; // ax
  __int64 v421; // rax
  int v422; // ebx
  __int64 v423; // rdx
  __int64 (*v424)(); // rax
  __int64 v425; // r12
  __m128i v426; // rax
  __int64 v427; // rbx
  __int64 (__fastcall *v428)(__int64, __int64); // r14
  __int64 v429; // rax
  unsigned __int16 v430; // ax
  __int64 v431; // r14
  __int64 v432; // r12
  __int64 v433; // rax
  __int64 v434; // r12
  __int64 v435; // rax
  bool v436; // al
  __int64 v437; // rax
  __m128i v438; // rax
  unsigned int v439; // ebx
  __int64 v440; // rdx
  unsigned int v441; // r12d
  __int64 v442; // rax
  const char *v443; // rdx
  unsigned __int64 v444; // rsi
  unsigned __int64 v445; // rcx
  unsigned __int64 v446; // rdi
  __int64 v447; // rdx
  unsigned __int64 v448; // r8
  char v449; // dl
  __int64 v450; // rbx
  __int64 v451; // rdx
  char v452; // r12
  __int64 v453; // rdx
  unsigned __int64 v454; // r12
  __int64 v455; // r12
  __int64 v456; // rax
  unsigned __int64 v457; // r12
  __int64 v458; // rax
  __int64 v459; // rcx
  __int64 v460; // rax
  __int64 v461; // rcx
  __int64 v462; // rdx
  __int64 v463; // rdx
  int v464; // esi
  char v465; // si
  int v466; // esi
  char v467; // si
  int v468; // esi
  char v469; // si
  int v470; // esi
  char v471; // si
  __int64 v472; // rdx
  int v473; // edx
  char v474; // dl
  __int64 v475; // rsi
  __int64 v476; // rsi
  __int64 v477; // rsi
  __int64 v478; // rsi
  __int64 v479; // rdx
  int v480; // edx
  char v481; // dl
  int v482; // edx
  char v483; // dl
  __int64 v484; // rdx
  __int64 v485; // rdx
  __int64 v486; // rcx
  __int64 v487; // r8
  __int64 v488; // r9
  __int64 v489; // rax
  const char *v490; // rbx
  size_t v491; // rax
  int v492; // ebx
  unsigned __int64 v493; // rax
  unsigned __int64 v494; // rax
  unsigned __int64 v495; // r14
  __m128i v496; // rax
  int v497; // edx
  unsigned __int64 v498; // r8
  bool v499; // di
  bool v500; // dl
  unsigned __int8 v501; // r9
  __int64 v502; // rdx
  int v503; // edx
  unsigned __int64 v504; // r8
  bool v505; // di
  bool v506; // dl
  unsigned __int8 v507; // r9
  __int64 v508; // rdx
  __int64 v509; // rdx
  unsigned __int64 v510; // r8
  char v511; // dl
  __int64 v512; // rdx
  unsigned __int64 v513; // r8
  char v514; // dl
  unsigned __int64 v515; // rsi
  unsigned __int64 v516; // rcx
  unsigned __int64 v517; // rdi
  __int64 v518; // rdx
  unsigned __int64 v519; // rax
  __int64 v520; // rdx
  unsigned __int8 v521; // al
  __int64 v522; // rax
  unsigned int v523; // r14d
  unsigned __int64 v524; // rax
  unsigned __int64 v525; // r14
  unsigned __int32 v526; // eax
  unsigned __int64 v527; // r14
  __m128i v528; // rax
  bool v529; // zf
  __int64 v530; // rax
  const char *v531; // rbx
  size_t v532; // rax
  __int64 v533; // [rsp+8h] [rbp-158h]
  __int64 v534; // [rsp+10h] [rbp-150h]
  __int64 v535; // [rsp+18h] [rbp-148h]
  __int64 v536; // [rsp+18h] [rbp-148h]
  __int64 v537; // [rsp+18h] [rbp-148h]
  __int64 v538; // [rsp+18h] [rbp-148h]
  unsigned __int64 v539; // [rsp+18h] [rbp-148h]
  __int64 v540; // [rsp+18h] [rbp-148h]
  __int64 v541; // [rsp+18h] [rbp-148h]
  __int64 v542; // [rsp+18h] [rbp-148h]
  __int64 v543; // [rsp+18h] [rbp-148h]
  __int64 v544; // [rsp+28h] [rbp-138h]
  char v545; // [rsp+28h] [rbp-138h]
  __int64 v546; // [rsp+28h] [rbp-138h]
  __int64 v547; // [rsp+28h] [rbp-138h]
  __int64 v548; // [rsp+28h] [rbp-138h]
  __int64 v549; // [rsp+28h] [rbp-138h]
  int v550; // [rsp+28h] [rbp-138h]
  unsigned __int64 v551; // [rsp+28h] [rbp-138h]
  char v552; // [rsp+28h] [rbp-138h]
  unsigned __int64 v553; // [rsp+28h] [rbp-138h]
  __int64 v554; // [rsp+28h] [rbp-138h]
  __int64 v555; // [rsp+28h] [rbp-138h]
  __int64 v556; // [rsp+28h] [rbp-138h]
  __int64 v557; // [rsp+28h] [rbp-138h]
  unsigned __int64 v558; // [rsp+28h] [rbp-138h]
  unsigned __int64 v559; // [rsp+28h] [rbp-138h]
  __int64 v560; // [rsp+38h] [rbp-128h] BYREF
  char *v561[2]; // [rsp+40h] [rbp-120h] BYREF
  __m128i v562; // [rsp+50h] [rbp-110h] BYREF
  char v563[16]; // [rsp+60h] [rbp-100h] BYREF
  __m128i v564; // [rsp+70h] [rbp-F0h] BYREF
  char *v565; // [rsp+80h] [rbp-E0h]
  __int16 v566; // [rsp+90h] [rbp-D0h]
  __m128i v567; // [rsp+A0h] [rbp-C0h] BYREF
  __int64 v568; // [rsp+B0h] [rbp-B0h] BYREF
  int v569; // [rsp+B8h] [rbp-A8h]
  char v570; // [rsp+BCh] [rbp-A4h]
  char v571; // [rsp+BDh] [rbp-A3h]
  char v572; // [rsp+C0h] [rbp-A0h]
  char v573; // [rsp+C1h] [rbp-9Fh]
  __m128i v574; // [rsp+D0h] [rbp-90h] BYREF
  const char *v575; // [rsp+E0h] [rbp-80h]
  __int16 v576; // [rsp+F0h] [rbp-70h]
  _BYTE *v577; // [rsp+100h] [rbp-60h] BYREF
  __int64 v578; // [rsp+108h] [rbp-58h]
  _BYTE v579[80]; // [rsp+110h] [rbp-50h] BYREF

  v4 = a1;
  if ( *(_BYTE *)(a1 + 81) )
    sub_2EF06E0(a1, "Unexpected generic instruction in a Selected function", a2);
  v6 = *(_DWORD *)(a2 + 44);
  v7 = *(unsigned __int16 **)(a2 + 16);
  v8 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
  if ( (v6 & 4) == 0 && (v6 & 8) != 0 )
  {
    if ( !sub_2E88A90(a2, 1024, 1) )
      goto LABEL_6;
LABEL_51:
    v43 = *(_DWORD *)(a2 + 44);
    if ( (v43 & 4) != 0 || (v43 & 8) == 0 )
      v44 = (*(_QWORD *)(*(_QWORD *)(a2 + 16) + 24LL) >> 11) & 1LL;
    else
      LOBYTE(v44) = sub_2E88A90(a2, 2048, 1);
    if ( !(_BYTE)v44 )
    {
      v45 = *(_BYTE **)(a2 + 32);
      v46 = &v45[40 * (*(_DWORD *)(a2 + 40) & 0xFFFFFF)];
      if ( v46 == v45 )
      {
LABEL_57:
        sub_2EF06E0(a1, "Branch instruction is missing a basic block operand or isIndirectBranch property", a2);
      }
      else
      {
        while ( *v45 != 4 )
        {
          v45 += 40;
          if ( v46 == v45 )
            goto LABEL_57;
        }
      }
    }
    goto LABEL_6;
  }
  if ( (*((_QWORD *)v7 + 3) & 0x400LL) != 0 )
    goto LABEL_51;
LABEL_6:
  v577 = v579;
  v578 = 0x400000000LL;
  v9 = v7[1];
  if ( v9 > v8 )
    v9 = v8;
  v10 = 0;
  v544 = v9;
  if ( v9 )
  {
    v11 = a1;
    do
    {
      v12 = HIBYTE(v7[20 * *v7 + 21 + 3 * v7[8] + 3 * v10]);
      if ( (unsigned __int8)(v12 - 6) <= 5u )
      {
        v13 = (unsigned int)(v12 - 5);
        v14 = (unsigned int)v578;
        v15 = (int)v13;
        if ( (int)v13 > (unsigned __int64)(unsigned int)v578 )
        {
          if ( (int)v13 > (unsigned __int64)HIDWORD(v578) )
          {
            v533 = v11;
            v538 = (int)v13;
            sub_C8D5F0((__int64)&v577, v579, (int)v13, 8u, v13, (int)v13);
            v14 = (unsigned int)v578;
            v11 = v533;
            LODWORD(v13) = v12 - 5;
            v15 = v538;
          }
          v16 = &v577[8 * v14];
          for ( i = &v577[8 * v15]; i != v16; ++v16 )
          {
            if ( v16 )
              *v16 = 0;
          }
          LODWORD(v578) = v13;
        }
        v18 = *(_QWORD *)(a2 + 32) + 40 * v10;
        if ( *(_BYTE *)v18 )
        {
          v537 = v11;
          sub_2EF06E0(v11, "generic instruction must use register operands", a2);
          v11 = v537;
        }
        else
        {
          v19 = *(_DWORD *)(v18 + 8);
          if ( v19 >= 0
            || (v36 = *(_QWORD *)(v11 + 64), v37 = v19 & 0x7FFFFFFF, (unsigned int)v37 >= *(_DWORD *)(v36 + 464)) )
          {
            v20 = 0;
            v21 = 0;
            v22 = 0;
            v23 = 0;
          }
          else
          {
            v38 = *(_QWORD *)(*(_QWORD *)(v36 + 456) + 8 * v37);
            v39 = v38;
            v23 = v38 & 1;
            v21 = (v38 & 4) != 0;
            v20 = v38 >> 3;
            v22 = (v39 & 2) != 0;
          }
          v24 = 8 * v20;
          v25 = v24 | (4LL * v21) | v23 & 1 | (2LL * v22);
          if ( v24 & 0xFFFFFFFFFFFFFFF9LL
             | (unsigned __int8)(4 * v21) & 0xF9
             | v23 & 1
             | (unsigned __int64)((unsigned __int8)(2 * v22) & 0xF9) )
          {
            v26 = (__int64 *)&v577[8 * v12 - 48];
            v27 = *v26;
            if ( (*v26 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
            {
              if ( (((unsigned __int8)v25 ^ (unsigned __int8)v27) & 7) != 0 || ((v27 ^ v25) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
              {
                v535 = v11;
                sub_2EF0A60(v11, "Type mismatch in generic instruction", v18, v10, v25);
                v11 = v535;
              }
            }
            else
            {
              *(_BYTE *)v26 = *(_BYTE *)v26 & 0xF8 | v23 & 0xFB | (2 * v22) & 0xFB | (4 * v21);
              *v26 = *v26 & 7 | v24;
            }
          }
          else
          {
            v536 = v11;
            sub_2EF0A60(v11, "Generic instruction is missing a virtual register type", v18, v10, 0);
            v11 = v536;
          }
        }
      }
      ++v10;
    }
    while ( v544 != v10 );
    v4 = v11;
  }
  v28 = *(_DWORD *)(a2 + 40);
  v29 = 0;
  v30 = 0;
  if ( (v28 & 0xFFFFFF) != 0 )
  {
    do
    {
      while ( 1 )
      {
        v31 = *(_QWORD *)(a2 + 32) + 40 * v29;
        if ( !*(_BYTE *)v31 && (unsigned int)(*(_DWORD *)(v31 + 8) - 1) <= 0x3FFFFFFE )
          break;
        ++v29;
        v30 = v28 & 0xFFFFFF;
        if ( (v28 & 0xFFFFFFu) <= (unsigned int)v29 )
          goto LABEL_33;
      }
      sub_2EF0A60(v4, "Generic instruction cannot have physical register", v31, v29, 0);
      v28 = *(_DWORD *)(a2 + 40);
      ++v29;
      v30 = v28 & 0xFFFFFF;
    }
    while ( (v28 & 0xFFFFFFu) > (unsigned int)v29 );
  }
LABEL_33:
  if ( v7[1] > v30 )
    goto LABEL_47;
  v561[0] = 0;
  v32 = *(_QWORD *)(v4 + 48);
  v561[1] = 0;
  v33 = *(__int64 (**)())(*(_QWORD *)v32 + 1208LL);
  if ( v33 != sub_2EEE490 && !((unsigned __int8 (__fastcall *)(__int64, __int64, char **))v33)(v32, a2, v561) )
    sub_2EF06E0(v4, v561[0], a2);
  v34 = *(unsigned __int16 *)(a2 + 68);
  v35 = *(_WORD *)(a2 + 68);
  switch ( (__int16)v34 )
  {
    case 50:
    case 51:
      v93 = *(_QWORD *)(a2 + 32);
      v94 = "G_ASSERT_ZEXT";
      if ( v34 != 51 )
        v94 = "G_ASSERT_SEXT";
      v567.m128i_i64[1] = 13;
      v567.m128i_i64[0] = (__int64)&v568;
      v95 = *(_QWORD *)v94;
      v571 = 0;
      v568 = v95;
      LODWORD(v95) = *((_DWORD *)v94 + 2);
      v96 = v94[12];
      v569 = v95;
      v570 = v96;
      if ( *(_BYTE *)(v93 + 80) != 1 )
      {
        v574.m128i_i64[0] = (__int64)&v568;
        v574.m128i_i64[1] = 13;
        v576 = 773;
        v97 = " expects an immediate operand #2";
LABEL_132:
        v575 = v97;
        sub_2EF0910(v4, (void **)&v574, a2);
        goto LABEL_133;
      }
      v375 = *(_DWORD *)(v93 + 48);
      v542 = v93;
      v376 = *(_DWORD *)(v93 + 8);
      v555 = *(_QWORD *)(v4 + 64);
      v377 = sub_2E865D0(v555, v375);
      v378 = v377;
      v379 = *(_QWORD *)(v542 + 104);
      if ( v379 <= 0 )
      {
        v574.m128i_i64[0] = (__int64)&v568;
        v576 = 773;
        v97 = " size must be >= 1";
        v574.m128i_i64[1] = 13;
        goto LABEL_132;
      }
      v380 = v377 >> 3;
      if ( (v378 & 2) != 0 && (v378 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
        LODWORD(v381) = HIWORD(v378);
      else
        v381 = v380 >> 29;
      if ( (unsigned int)v381 <= v379 )
      {
        v574.m128i_i64[0] = (__int64)&v568;
        v576 = 773;
        v97 = " size must be less than source bit width";
        v574.m128i_i64[1] = 13;
        goto LABEL_132;
      }
      v556 = sub_2F5FCF0(*(_QWORD *)(v4 + 72), v375, v555, *(_QWORD *)(v4 + 56));
      v410 = sub_2F5FCF0(*(_QWORD *)(v4 + 72), v376, *(_QWORD *)(v4 + 64), *(_QWORD *)(v4 + 56));
      if ( v556 )
      {
        if ( v410 && v556 != v410 )
          goto LABEL_564;
      }
      else if ( v410 )
      {
LABEL_564:
        v576 = 773;
        v574 = v567;
        v97 = " cannot change register bank";
        goto LABEL_132;
      }
      v557 = *(_QWORD *)(v4 + 64);
      v454 = sub_2EF3070(v557, v376);
      if ( v454 && v454 != sub_2EF3070(v557, v375) )
      {
        v576 = 773;
        v574 = v567;
        v97 = " source and destination register classes must match";
        goto LABEL_132;
      }
LABEL_133:
      v92 = v567.m128i_i64[0];
      if ( (__int64 *)v567.m128i_i64[0] != &v568 )
        goto LABEL_849;
      goto LABEL_47;
    case 52:
      if ( *(__int64 *)(*(_QWORD *)(a2 + 32) + 104LL) <= 0 )
        sub_2EF06E0(v4, "alignment immediate must be >= 1", a2);
      goto LABEL_47;
    case 68:
      v115 = *(_QWORD *)(a2 + 32);
      v116 = *(_QWORD *)(v4 + 64);
      if ( (sub_2E865D0(v116, *(_DWORD *)(v115 + 8)) & 0xFFFFFFFFFFFFFFF9LL) == 0 )
        goto LABEL_169;
      v117 = sub_2EEE790(v115, v115 + 40LL * (*(_DWORD *)(a2 + 40) & 0xFFFFFF), 1);
      v120 = v119;
      v121 = (__int64)(0xCCCCCCCCCCCCCCCDLL * ((v119 - v117) >> 3)) >> 2;
      if ( v121 <= 0 )
        goto LABEL_382;
      v122 = v117 + 160 * v121;
      while ( 1 )
      {
        if ( !*(_BYTE *)v117 )
        {
          v123 = *(_DWORD *)(v117 + 8);
          if ( v123 >= 0 || (v323 = v123 & 0x7FFFFFFF, (unsigned int)v323 >= *(_DWORD *)(v116 + 464)) )
          {
            v124 = 0;
            v125 = 0;
            v126 = 0;
            v127 = 0;
          }
          else
          {
            v324 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v323);
            v325 = v324;
            v127 = v324 & 1;
            v125 = (v324 & 4) != 0;
            v124 = v324 >> 3;
            v126 = (v325 & 2) != 0;
          }
          v128 = (8 * v124) | (4LL * v125) | v127 | (2LL * v126);
          if ( (v128 & 0xFFFFFFFFFFFFFFF9LL) == 0
            || (((unsigned __int8)v118 ^ (unsigned __int8)v128) & 7) != 0
            || ((v118 ^ v128) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          {
            break;
          }
        }
        v285 = v117 + 40;
        if ( !*(_BYTE *)(v117 + 40) )
        {
          v286 = *(_DWORD *)(v117 + 48);
          if ( v286 >= 0 || (v320 = v286 & 0x7FFFFFFF, (unsigned int)v320 >= *(_DWORD *)(v116 + 464)) )
          {
            v287 = 0;
            v288 = 0;
            v289 = 0;
            v290 = 0;
          }
          else
          {
            v321 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v320);
            v322 = v321;
            v290 = v321 & 1;
            v288 = (v321 & 4) != 0;
            v287 = v321 >> 3;
            v289 = (v322 & 2) != 0;
          }
          v291 = (8 * v287) | (4LL * v288) | v290 | (2LL * v289);
          if ( (v291 & 0xFFFFFFFFFFFFFFF9LL) == 0
            || (((unsigned __int8)v118 ^ (unsigned __int8)v291) & 7) != 0
            || ((v118 ^ v291) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          {
            goto LABEL_392;
          }
        }
        v285 = v117 + 80;
        if ( !*(_BYTE *)(v117 + 80) )
        {
          v292 = *(_DWORD *)(v117 + 88);
          if ( v292 >= 0 || (v326 = v292 & 0x7FFFFFFF, (unsigned int)v326 >= *(_DWORD *)(v116 + 464)) )
          {
            v293 = 0;
            v294 = 0;
            v295 = 0;
            v296 = 0;
          }
          else
          {
            v327 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v326);
            v328 = v327;
            v296 = v327 & 1;
            v294 = (v327 & 4) != 0;
            v293 = v327 >> 3;
            v295 = (v328 & 2) != 0;
          }
          v297 = (8 * v293) | (4LL * v294) | v296 | (2LL * v295);
          if ( (v297 & 0xFFFFFFFFFFFFFFF9LL) == 0
            || (((unsigned __int8)v118 ^ (unsigned __int8)v297) & 7) != 0
            || ((v118 ^ v297) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          {
            goto LABEL_392;
          }
        }
        v285 = v117 + 120;
        if ( !*(_BYTE *)(v117 + 120) )
        {
          v298 = *(_DWORD *)(v117 + 128);
          if ( v298 >= 0 || (v329 = v298 & 0x7FFFFFFF, (unsigned int)v329 >= *(_DWORD *)(v116 + 464)) )
          {
            v299 = 0;
            v300 = 0;
            v301 = 0;
            v302 = 0;
          }
          else
          {
            v330 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v329);
            v331 = v330;
            v302 = v330 & 1;
            v300 = (v330 & 4) != 0;
            v299 = v330 >> 3;
            v301 = (v331 & 2) != 0;
          }
          v303 = (8 * v299) | (4LL * v300) | v302 | (2LL * v301);
          if ( (v303 & 0xFFFFFFFFFFFFFFF9LL) == 0
            || (((unsigned __int8)v118 ^ (unsigned __int8)v303) & 7) != 0
            || ((v118 ^ v303) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          {
LABEL_392:
            v117 = v285;
            break;
          }
        }
        v117 += 160;
        if ( v117 == v122 )
        {
LABEL_382:
          v304 = v120 - v117;
          if ( v120 - v117 != 80 )
          {
            if ( v304 != 120 )
            {
              if ( v304 != 40 )
                goto LABEL_47;
LABEL_385:
              if ( *(_BYTE *)v117 )
                goto LABEL_47;
              v305 = *(_DWORD *)(v117 + 8);
              if ( v305 >= 0 || (v447 = v305 & 0x7FFFFFFF, (unsigned int)v447 >= *(_DWORD *)(v116 + 464)) )
              {
                v306 = 0;
                v307 = 0;
                v308 = 0;
                v309 = 0;
              }
              else
              {
                v448 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v447);
                v449 = v448;
                v309 = v448 & 1;
                v307 = (v448 & 4) != 0;
                v306 = v448 >> 3;
                v308 = (v449 & 2) != 0;
              }
              v310 = (8 * v306) | (4LL * v307) | v309 | (2LL * v308);
              if ( (v310 & 0xFFFFFFFFFFFFFFF9LL) != 0
                && (((unsigned __int8)v118 ^ (unsigned __int8)v310) & 7) == 0
                && ((v118 ^ v310) & 0xFFFFFFFFFFFFFFF8LL) == 0 )
              {
                goto LABEL_47;
              }
              break;
            }
            if ( !*(_BYTE *)v117 )
            {
              v497 = *(_DWORD *)(v117 + 8);
              if ( v497 >= 0 || (v509 = v497 & 0x7FFFFFFF, (unsigned int)v509 >= *(_DWORD *)(v116 + 464)) )
              {
                v498 = 0;
                v499 = 0;
                v500 = 0;
                v501 = 0;
              }
              else
              {
                v510 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v509);
                v511 = v510;
                v501 = v510 & 1;
                v499 = (v510 & 4) != 0;
                v498 = v510 >> 3;
                v500 = (v511 & 2) != 0;
              }
              v502 = (8 * v498) | (4LL * v499) | v501 | (2LL * v500);
              if ( (v502 & 0xFFFFFFFFFFFFFFF9LL) == 0
                || (((unsigned __int8)v118 ^ (unsigned __int8)v502) & 7) != 0
                || ((v118 ^ v502) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
              {
                break;
              }
            }
            v117 += 40;
          }
          if ( !*(_BYTE *)v117 )
          {
            v503 = *(_DWORD *)(v117 + 8);
            if ( v503 >= 0 || (v512 = v503 & 0x7FFFFFFF, (unsigned int)v512 >= *(_DWORD *)(v116 + 464)) )
            {
              v504 = 0;
              v505 = 0;
              v506 = 0;
              v507 = 0;
            }
            else
            {
              v513 = *(_QWORD *)(*(_QWORD *)(v116 + 456) + 8 * v512);
              v514 = v513;
              v507 = v513 & 1;
              v505 = (v513 & 4) != 0;
              v504 = v513 >> 3;
              v506 = (v514 & 2) != 0;
            }
            v508 = (8 * v504) | (4LL * v505) | v507 | (2LL * v506);
            if ( (v508 & 0xFFFFFFFFFFFFFFF9LL) == 0
              || (((unsigned __int8)v118 ^ (unsigned __int8)v508) & 7) != 0
              || ((v118 ^ v508) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
            {
              break;
            }
          }
          v117 += 40;
          goto LABEL_385;
        }
      }
      if ( v120 != v117 )
LABEL_169:
        sub_2EF06E0(v4, "Generic Instruction G_PHI has operands with incompatible/missing types", a2);
      goto LABEL_47;
    case 71:
      v237 = *(_QWORD *)(a2 + 32);
      v238 = v237 + 40;
      if ( *(_BYTE *)(v237 + 40)
        || (v239 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v237 + 48)), (v239 & 0xFFFFFFFFFFFFFFF9LL) == 0)
        || (v239 & 6) != 2 )
      {
        sub_2EF0A60(v4, "addr operand must be a pointer", v238, 1u, 0);
      }
      goto LABEL_47;
    case 72:
      v185 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v185 + 40) != 6 )
      {
        sub_2EF06E0(v4, "Src operand 1 must be a constant pool index", a2);
        v185 = *(_QWORD *)(a2 + 32);
      }
      v186 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v185 + 8));
      if ( (v186 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v186 & 6) != 2 )
        sub_2EF06E0(v4, "Dst operand 0 must be a pointer", a2);
      goto LABEL_47;
    case 73:
      v187 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v187 + 40) )
      {
        sub_2EF06E0(v4, "extract source must be a register", a2);
      }
      else if ( *(_BYTE *)(v187 + 80) == 1 )
      {
        v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v187 + 8));
        v438.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574 = v438;
        v439 = sub_CA1930(&v574);
        v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v187 + 48));
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574.m128i_i64[1] = v440;
        v441 = sub_CA1930(&v574);
        if ( v439 == v441 )
          sub_2EF06E0(v4, "extract source must be larger than result", a2);
        if ( *(_QWORD *)(v187 + 104) + v439 > (__int64)v441 )
          sub_2EF06E0(v4, "extract reads past end of register", a2);
      }
      else
      {
        sub_2EF06E0(v4, "extract offset must be a constant", a2);
      }
      goto LABEL_47;
    case 74:
      v188 = *(_QWORD *)(a2 + 32);
      v189 = *(_QWORD *)(v4 + 64);
      v550 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
      v190 = (unsigned int)(v550 - 1);
      v191 = sub_2E865D0(v189, *(_DWORD *)(v188 + 8));
      v562.m128i_i64[0] = v191;
      v192 = v191;
      v193 = v191;
      if ( (unsigned int)v190 <= 1 )
        goto LABEL_274;
      v194 = v191;
      v195 = (int *)(v188 + 48);
      while ( 1 )
      {
        if ( *v195 >= 0 || (v311 = *v195 & 0x7FFFFFFF, (unsigned int)v311 >= *(_DWORD *)(v189 + 464)) )
        {
          v196 = 0;
          v197 = 0;
          v198 = 0;
          v199 = 0;
        }
        else
        {
          v312 = *(_QWORD *)(*(_QWORD *)(v189 + 456) + 8 * v311);
          v313 = v312;
          v199 = v312 & 1;
          v197 = (v312 & 4) != 0;
          v196 = v312 >> 3;
          v198 = (v313 & 2) != 0;
        }
        v200 = (8 * v196) | (4LL * v197) | v199 | (2LL * v198);
        if ( (((unsigned __int8)v200 ^ v194) & 7) != 0 || ((v192 ^ v200) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          break;
        v195 += 10;
        if ( v195 == (int *)(v188 + 40LL * (unsigned int)(v550 - 3) + 88) )
          goto LABEL_274;
      }
      sub_2EF06E0(v4, "G_UNMERGE_VALUES destination types do not match", a2);
      v189 = *(_QWORD *)(v4 + 64);
      v193 = v562.m128i_i64[0];
      v188 = *(_QWORD *)(a2 + 32);
LABEL_274:
      v201 = *(_DWORD *)(v188 + 40 * v190 + 8);
      if ( v201 >= 0 || (v396 = v201 & 0x7FFFFFFF, (unsigned int)v396 >= *(_DWORD *)(v189 + 464)) )
      {
        v202 = 0;
        v203 = 0;
        v204 = 0;
        v205 = 0;
      }
      else
      {
        v397 = *(_QWORD *)(*(_QWORD *)(v189 + 456) + 8 * v396);
        v398 = v397;
        v205 = v397 & 1;
        v203 = (v397 & 4) != 0;
        v202 = v397 >> 3;
        v204 = (v398 & 2) != 0;
      }
      v206 = (8 * v202) | (4LL * v203) | v205 | (2LL * v204);
      v564.m128i_i64[0] = v206;
      if ( (v193 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v562.m128i_i8[0] & 4) != 0 )
      {
        if ( (v206 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
          goto LABEL_285;
        if ( (v564.m128i_i8[0] & 4) == 0 )
          goto LABEL_285;
        v551 = sub_2EF2BA0((unsigned __int64 *)&v562);
        v207 = sub_2EF2BA0((unsigned __int64 *)&v564);
        if ( sub_2EEE7A0(v207, v551)
          && ((v564.m128i_i8[0] & 2) == 0
           || (v564.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) == 0
           || (v564.m128i_i8[0] & 4) == 0) )
        {
          goto LABEL_285;
        }
        v552 = sub_2EF2A10(&v564);
        if ( v552 != (unsigned __int8)sub_2EF2A10(&v562)
          || (v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562),
              v450 = v574.m128i_i64[0] * v190,
              v574.m128i_i64[1] = v451,
              v452 = v451,
              v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564),
              v567.m128i_i64[1] = v453,
              v567.m128i_i64[0] != v450)
          || v567.m128i_i8[8] != v452 )
        {
LABEL_285:
          sub_2EF06E0(v4, "G_UNMERGE_VALUES source operand does not match vector destination operands", a2);
        }
      }
      else if ( (v564.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v564.m128i_i8[0] & 4) != 0 )
      {
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
        v335 = v574.m128i_i64[0] * v190;
        v574.m128i_i64[1] = v336;
        v337 = v336;
        v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
        v567.m128i_i64[1] = v338;
        if ( v567.m128i_i64[0] != v335 || v567.m128i_i8[8] != v337 )
          sub_2EF06E0(v4, "G_UNMERGE_VALUES vector source operand does not match scalar destination operands", a2);
      }
      else
      {
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
        v340 = v574.m128i_i64[0] * v190;
        v574.m128i_i64[1] = v341;
        v342 = v341;
        v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
        v567.m128i_i64[1] = v343;
        if ( v567.m128i_i64[0] != v340 || v567.m128i_i8[8] != v342 )
          sub_2EF06E0(v4, "G_UNMERGE_VALUES scalar source operand does not match scalar destination operands", a2);
      }
      goto LABEL_47;
    case 75:
      v236 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v236 + 80) )
      {
        sub_2EF06E0(v4, "insert source must be a register", a2);
      }
      else if ( *(_BYTE *)(v236 + 120) == 1 )
      {
        v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v236 + 8));
        v411.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574 = v411;
        v412 = sub_CA1930(&v574);
        v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v236 + 88));
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574.m128i_i64[1] = v413;
        v414 = sub_CA1930(&v574);
        if ( v412 <= v414 )
          sub_2EF06E0(v4, "inserted size must be smaller than total register", a2);
        if ( *(_QWORD *)(v236 + 144) + v414 > (__int64)v412 )
          sub_2EF06E0(v4, "insert writes past end of register", a2);
      }
      else
      {
        sub_2EF06E0(v4, "insert offset must be a constant", a2);
      }
      goto LABEL_47;
    case 76:
      v162 = *(_QWORD *)(a2 + 32);
      v163 = *(_QWORD *)(v4 + 64);
      v562.m128i_i64[0] = sub_2E865D0(v163, *(_DWORD *)(v162 + 8));
      v164 = v562.m128i_i64[0];
      v564.m128i_i64[0] = sub_2E865D0(v163, *(_DWORD *)(v162 + 48));
      if ( (v164 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v562.m128i_i8[0] & 4) != 0
        || (v564.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v564.m128i_i8[0] & 4) != 0 )
      {
        sub_2EF06E0(v4, "G_MERGE_VALUES cannot operate on vectors", a2);
      }
      v165 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
      v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
      v574.m128i_i64[1] = v166;
      v167 = v166;
      v168 = v574.m128i_i64[0] * (unsigned int)(v165 - 1);
      v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
      v567.m128i_i64[1] = v169;
      if ( v567.m128i_i64[0] != v168 || v567.m128i_i8[8] != v167 )
        sub_2EF06E0(v4, "G_MERGE_VALUES result size is inconsistent", a2);
      v170 = 2;
      if ( v165 != 2 )
      {
        do
        {
          v176 = *(_DWORD *)(*(_QWORD *)(a2 + 32) + 40LL * v170 + 8);
          if ( v176 >= 0
            || (v177 = *(_QWORD *)(v4 + 64), v178 = v176 & 0x7FFFFFFF, (unsigned int)v178 >= *(_DWORD *)(v177 + 464)) )
          {
            v171 = 0;
            v172 = 0;
            v173 = 0;
            v174 = 0;
          }
          else
          {
            v179 = *(_QWORD *)(*(_QWORD *)(v177 + 456) + 8 * v178);
            v180 = v179;
            v174 = v179 & 1;
            v172 = (v179 & 4) != 0;
            v171 = v179 >> 3;
            v173 = (v180 & 2) != 0;
          }
          v175 = (8 * v171) | (4LL * v172) | v174 | (2LL * v173);
          if ( ((v564.m128i_i8[0] ^ (unsigned __int8)v175) & 7) != 0
            || ((v564.m128i_i64[0] ^ v175) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          {
            sub_2EF06E0(v4, "G_MERGE_VALUES source types do not match", a2);
          }
          ++v170;
        }
        while ( v170 != v165 );
      }
      goto LABEL_47;
    case 77:
      v269 = *(_QWORD *)(a2 + 32);
      v270 = *(_QWORD *)(v4 + 64);
      v574.m128i_i64[0] = sub_2E865D0(v270, *(_DWORD *)(v269 + 8));
      v271 = v574.m128i_i64[0];
      v272 = sub_2E865D0(v270, *(_DWORD *)(v269 + 48));
      v273 = v272;
      if ( (v271 & 0xFFFFFFFFFFFFFFF9LL) == 0
        || (v574.m128i_i8[0] & 4) == 0
        || (v272 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v272 & 4) != 0 )
      {
        sub_2EF06E0(v4, "G_BUILD_VECTOR must produce a vector from scalar operands", a2);
      }
      else
      {
        v274 = sub_2EF2C00((unsigned __int64 *)&v574);
        if ( sub_2EEE7A0(v274, v273) )
          sub_2EF06E0(v4, "G_BUILD_VECTOR result element type must match source type", a2);
        v275 = (unsigned __int64)v574.m128i_i64[0] >> 3;
        if ( (v574.m128i_i8[0] & 8) != 0 )
        {
          sub_CA17B0(
            "Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use LLT::"
            "getElementCount() instead");
          v275 = (unsigned __int64)v574.m128i_i64[0] >> 3;
        }
        v276 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
        if ( (unsigned __int16)(v275 >> 5) != (_DWORD)v276 - 1 )
        {
          sub_2EF06E0(v4, "G_BUILD_VECTOR must have an operand for each elemement", a2);
          v276 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
        }
        v277 = *(_QWORD *)(a2 + 32);
        v278 = sub_2EEE790(v277, v277 + 40 * v276, 2);
        v554 = v279;
        v280 = v278;
        if ( v279 != v278 )
        {
          v281 = v277;
          for ( j = a2; ; v281 = *(_QWORD *)(j + 32) )
          {
            v283 = *(_QWORD *)(v4 + 64);
            v534 = v281;
            v541 = sub_2E865D0(v283, *(_DWORD *)(v280 + 8));
            v284 = sub_2E865D0(v283, *(_DWORD *)(v534 + 48));
            if ( (((unsigned __int8)v541 ^ (unsigned __int8)v284) & 7) != 0
              || ((v541 ^ v284) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
            {
              sub_2EF06E0(v4, "G_BUILD_VECTOR source operand types are not homogeneous", j);
            }
            v280 += 40;
            if ( v554 == v280 )
              break;
          }
        }
      }
      goto LABEL_47;
    case 78:
      v240 = *(_QWORD *)(a2 + 32);
      v241 = *(_QWORD *)(v4 + 64);
      v560 = sub_2E865D0(v241, *(_DWORD *)(v240 + 8));
      v242 = sub_2E865D0(v241, *(_DWORD *)(v240 + 48));
      v562.m128i_i64[0] = v242;
      if ( (v560 & 0xFFFFFFFFFFFFFFF9LL) == 0
        || (v560 & 4) == 0
        || (v242 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v562.m128i_i8[0] & 4) != 0 )
      {
        sub_2EF06E0(v4, "G_BUILD_VECTOR_TRUNC must produce a vector from scalar operands", a2);
        v240 = *(_QWORD *)(a2 + 32);
      }
      v243 = sub_2EEE790(v240, v240 + 40LL * (*(_DWORD *)(a2 + 40) & 0xFFFFFF), 2);
      v245 = v244;
      v246 = v243;
      if ( v244 != v243 )
      {
        while ( 1 )
        {
          v258 = *(_DWORD *)(v246 + 8);
          v259 = *(_QWORD *)(v4 + 64);
          if ( v258 >= 0 || (v260 = v258 & 0x7FFFFFFF, (unsigned int)v260 >= *(_DWORD *)(v259 + 464)) )
          {
            v247 = 0;
            v248 = 0;
            v249 = 0;
            v250 = 0;
          }
          else
          {
            v261 = *(_QWORD *)(*(_QWORD *)(v259 + 456) + 8 * v260);
            v250 = v261 & 1;
            v249 = (v261 & 2) != 0;
            v248 = (v261 & 4) != 0;
            v247 = v261 >> 3;
          }
          v251 = (4LL * v248) | v250 | (2LL * v249) | (8 * v247);
          v252 = *(_DWORD *)(v240 + 48);
          if ( v252 >= 0 || (v317 = v252 & 0x7FFFFFFF, (unsigned int)v317 >= *(_DWORD *)(v259 + 464)) )
          {
            v253 = 0;
            v254 = 0;
            v255 = 0;
            v256 = 0;
          }
          else
          {
            v318 = *(_QWORD *)(*(_QWORD *)(v259 + 456) + 8 * v317);
            v319 = v318;
            v256 = v318 & 1;
            v254 = (v318 & 4) != 0;
            v253 = v318 >> 3;
            v255 = (v319 & 2) != 0;
          }
          v257 = (8 * v253) | (4LL * v254) | v256 | (2LL * v255);
          if ( (((unsigned __int8)v251 ^ (unsigned __int8)v257) & 7) != 0 || ((v251 ^ v257) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
            sub_2EF06E0(v4, "G_BUILD_VECTOR_TRUNC source operand types are not homogeneous", a2);
          v246 += 40;
          if ( v246 == v245 )
            break;
          v240 = *(_QWORD *)(a2 + 32);
        }
      }
      v332.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
      v567 = v332;
      v333 = sub_CA1930(&v567);
      v564.m128i_i64[0] = sub_2EF2C00((unsigned __int64 *)&v560);
      v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
      v574.m128i_i64[1] = v334;
      if ( v333 <= sub_CA1930(&v574) )
        sub_2EF06E0(v4, "G_BUILD_VECTOR_TRUNC source operand types are not larger than dest elt type", a2);
      goto LABEL_47;
    case 79:
      v208 = *(_QWORD *)(a2 + 32);
      v209 = *(_QWORD *)(v4 + 64);
      v553 = sub_2E865D0(v209, *(_DWORD *)(v208 + 8));
      v210 = sub_2E865D0(v209, *(_DWORD *)(v208 + 48));
      v211 = v210;
      if ( (v553 & 0xFFFFFFFFFFFFFFF9LL) == 0
        || (v553 & 4) == 0
        || (v210 & 0xFFFFFFFFFFFFFFF9LL) == 0
        || (v210 & 4) == 0 )
      {
        sub_2EF06E0(v4, "G_CONCAT_VECTOR requires vector source and destination operands", a2);
      }
      v212 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
      if ( v212 <= 2 )
      {
        sub_2EF06E0(v4, "G_CONCAT_VECTOR requires at least 2 source operands", a2);
        v212 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
      }
      v213 = *(_QWORD *)(a2 + 32);
      v214 = sub_2EEE790(v213, v213 + 40LL * v212, 2);
      v217 = v216;
      v218 = v214;
      if ( v216 != v214 )
      {
        while ( 1 )
        {
          v231 = *(_DWORD *)(v218 + 8);
          v232 = *(_QWORD *)(v4 + 64);
          if ( v231 >= 0 || (v233 = v231 & 0x7FFFFFFF, (unsigned int)v233 >= *(_DWORD *)(v232 + 464)) )
          {
            v219 = 0;
            v220 = 0;
            v221 = 0;
            v222 = 0;
          }
          else
          {
            v234 = *(_QWORD *)(*(_QWORD *)(v232 + 456) + 8 * v233);
            v235 = v234;
            v222 = v234 & 1;
            v220 = (v234 & 4) != 0;
            v219 = v234 >> 3;
            v221 = (v235 & 2) != 0;
          }
          v223 = (4LL * v220) | v222 | (2LL * v221);
          v224 = *(_DWORD *)(v213 + 48);
          v225 = (8 * v219) | v223;
          if ( v224 >= 0 || (v314 = v224 & 0x7FFFFFFF, (unsigned int)v314 >= *(_DWORD *)(v232 + 464)) )
          {
            v226 = 0;
            v227 = 0;
            v228 = 0;
            v229 = 0;
          }
          else
          {
            v315 = *(_QWORD *)(*(_QWORD *)(v232 + 456) + 8 * v314);
            v316 = v315;
            v229 = v315 & 1;
            v227 = (v315 & 4) != 0;
            v226 = v315 >> 3;
            v228 = (v316 & 2) != 0;
          }
          v230 = (8 * v226) | (4LL * v227) | v229 | (2LL * v228);
          if ( (((unsigned __int8)v225 ^ (unsigned __int8)v230) & 7) != 0 || ((v230 ^ v225) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
            sub_2EF06E0(v4, "G_CONCAT_VECTOR source operand types are not homogeneous", a2);
          v218 += 40;
          if ( v218 == v217 )
            break;
          v213 = *(_QWORD *)(a2 + 32);
        }
        v215 = *(_DWORD *)(a2 + 40) & 0xFFFFFF;
      }
      if ( (unsigned __int16)((unsigned int)v211 >> 8) * (v215 - 1) != (unsigned __int16)((unsigned int)v553 >> 8)
        || (((unsigned __int8)(v211 >> 3) ^ (unsigned __int8)(v553 >> 3)) & 1) != 0 )
      {
        sub_2EF06E0(v4, "G_CONCAT_VECTOR num dest and source elements should match", a2);
      }
      goto LABEL_47;
    case 80:
    case 81:
    case 263:
      v72 = *(_QWORD *)(a2 + 32);
      v73 = *(_QWORD *)(v4 + 64);
      v567.m128i_i64[0] = sub_2E865D0(v73, *(_DWORD *)(v72 + 8));
      v74 = v567.m128i_i64[0];
      v75 = sub_2E865D0(v73, *(_DWORD *)(v72 + 48));
      v574.m128i_i64[0] = v75;
      if ( (v74 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v75 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        sub_2EF0960(v4, v74, v75, a2);
        v567.m128i_i64[0] = sub_2EF2BA0((unsigned __int64 *)&v567);
        v76 = sub_2EF2BA0((unsigned __int64 *)&v574);
        v77 = *(unsigned __int16 *)(a2 + 68);
        v574.m128i_i64[0] = v76;
        if ( v77 == 81 )
        {
          if ( (v567.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v567.m128i_i8[0] & 6) != 2 )
            sub_2EF06E0(v4, "inttoptr result type must be a pointer", a2);
          if ( (v574.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v574.m128i_i8[0] & 6) == 2 )
            sub_2EF06E0(v4, "inttoptr source type must not be a pointer", a2);
        }
        else if ( v77 == 80 )
        {
          if ( (v76 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v574.m128i_i8[0] & 6) != 2 )
            sub_2EF06E0(v4, "ptrtoint source type must be a pointer", a2);
          if ( (v567.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v567.m128i_i8[0] & 6) == 2 )
            sub_2EF06E0(v4, "ptrtoint result type must not be a pointer", a2);
        }
        else if ( (v76 & 0xFFFFFFFFFFFFFFF9LL) != 0
               && (v574.m128i_i8[0] & 6) == 2
               && (v567.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0
               && (v567.m128i_i8[0] & 6) == 2 )
        {
          if ( ((v76 >> 24) & 0xFFFFFF) == (((unsigned __int64)v567.m128i_i64[0] >> 24) & 0xFFFFFF) )
            sub_2EF06E0(v4, "addrspacecast must convert different address spaces", a2);
        }
        else
        {
          sub_2EF06E0(v4, "addrspacecast types must be pointers", a2);
        }
      }
      goto LABEL_47;
    case 82:
      v262 = *(_QWORD *)(a2 + 32);
      v263 = *(_QWORD *)(v4 + 64);
      v562.m128i_i64[0] = sub_2E865D0(v263, *(_DWORD *)(v262 + 8));
      v264 = v562.m128i_i64[0];
      v265 = sub_2E865D0(v263, *(_DWORD *)(v262 + 48));
      v564.m128i_i64[0] = v265;
      if ( (v264 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v265 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
        goto LABEL_47;
      v266 = v562.m128i_i8[0] & 6;
      if ( (v564.m128i_i8[0] & 6) == 2 )
      {
        if ( v266 == 2 )
          goto LABEL_337;
      }
      else if ( v266 != 2 )
      {
        goto LABEL_337;
      }
      sub_2EF06E0(v4, "bitcast cannot convert between pointers and other types", a2);
LABEL_337:
      v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
      v574.m128i_i64[1] = v267;
      v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
      v567.m128i_i64[1] = v268;
      if ( v574.m128i_i64[0] != v567.m128i_i64[0] || v574.m128i_i8[8] != v567.m128i_i8[8] )
        sub_2EF06E0(v4, "bitcast sizes must match", a2);
      if ( ((v564.m128i_i8[0] ^ v562.m128i_i8[0]) & 7) == 0
        && ((v562.m128i_i64[0] ^ v564.m128i_i64[0]) & 0xFFFFFFFFFFFFFFF8LL) == 0 )
      {
        sub_2EF06E0(v4, "bitcast must change the type", a2);
      }
      goto LABEL_47;
    case 93:
    case 94:
    case 95:
    case 99:
      v61 = *(_QWORD *)(a2 + 32);
      v62 = *(_QWORD *)(v4 + 64);
      v564.m128i_i64[0] = sub_2E865D0(v62, *(_DWORD *)(v61 + 8));
      v63 = sub_2E865D0(v62, *(_DWORD *)(v61 + 48));
      if ( (v63 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v63 & 6) != 2 )
        sub_2EF06E0(v4, "Generic memory instruction must access a pointer", a2);
      v64 = *(_QWORD *)(a2 + 48);
      v65 = (_DWORD *)(v64 & 0xFFFFFFFFFFFFFFF8LL);
      if ( (v64 & 0xFFFFFFFFFFFFFFF8LL) == 0 )
        goto LABEL_429;
      v66 = v64 & 7;
      if ( v66 )
      {
        if ( v66 != 3 || *v65 != 1 )
        {
LABEL_429:
          sub_2EF06E0(v4, "Generic instruction accessing memory must have one mem operand", a2);
          goto LABEL_47;
        }
      }
      else
      {
        *(_QWORD *)(a2 + 48) = v65;
      }
      v67 = *(_QWORD *)sub_2E864A0(a2);
      v68 = *(unsigned __int16 *)(a2 + 68);
      if ( (unsigned int)(v68 - 94) > 1 )
      {
        if ( v68 == 93 )
        {
          v574.m128i_i64[0] = sub_2EF2AF0((unsigned __int64 *)&v564);
          v574.m128i_i64[1] = v518;
          v519 = sub_2EF2C60(v67);
          if ( ((v519 & 0x4000000000000000LL) != 0 || !v574.m128i_i8[8])
            && (v519 & 0x3FFFFFFFFFFFFFFFLL) > v574.m128i_i64[0] )
          {
            sub_2EF06E0(v4, "load memory size cannot exceed result size", a2);
          }
          v520 = *(_QWORD *)(v67 + 72);
          if ( v520 )
          {
            v521 = *(_BYTE *)(v520 - 16);
            v522 = (v521 & 2) != 0 ? *(_QWORD *)(v520 - 32) : v520 - 8LL * ((v521 >> 2) & 0xF) - 16;
            v523 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v522 + 136LL) + 8LL) + 8LL) >> 8;
            v574.m128i_i64[0] = *(_QWORD *)(v67 + 24);
            v524 = sub_2EF2BA0((unsigned __int64 *)&v574);
            if ( sub_2EEE7A0(v524, ((unsigned __int64)v523 << 32) | 1)
              || (v564.m128i_i8[0] & 1) != (v574.m128i_i8[0] & 1) )
            {
              goto LABEL_830;
            }
            v525 = v564.m128i_i64[0];
            if ( (v564.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v564.m128i_i8[0] & 4) != 0 )
            {
              if ( (v564.m128i_i8[0] & 8) != 0 )
              {
                sub_CA17B0(
                  "Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use"
                  " LLT::getElementCount() instead");
                v525 = v564.m128i_i64[0];
              }
              v526 = v574.m128i_i32[0];
              v527 = v525 >> 8;
              if ( (v574.m128i_i8[0] & 8) != 0 )
              {
                sub_CA17B0(
                  "Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use"
                  " LLT::getElementCount() instead");
                v526 = v574.m128i_i32[0];
              }
              if ( (_WORD)v527 != (unsigned __int16)(v526 >> 8) )
LABEL_830:
                sub_2EF06E0(v4, "range is incompatible with the result type", a2);
            }
          }
        }
        else if ( v68 == 99 )
        {
          v495 = sub_2EF2C60(v67);
          v496.m128i_i64[0] = sub_2EF2AF0((unsigned __int64 *)&v564);
          v574 = v496;
          if ( (v496.m128i_i8[8] != 1 || (v495 & 0x4000000000000000LL) != 0)
            && v574.m128i_i64[0] < (v495 & 0x3FFFFFFFFFFFFFFFLL) )
          {
            sub_2EF06E0(v4, "store memory size cannot exceed value size", a2);
          }
        }
        goto LABEL_89;
      }
      v415 = 0x3FFFFFFFFFFFFFFFLL;
      v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
      v567.m128i_i64[1] = v416;
      if ( (*(_QWORD *)(v67 + 24) & 0xFFFFFFFFFFFFFFF9LL) == 0 )
        goto LABEL_577;
      v528.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)(v67 + 24));
      v574 = v528;
      if ( v528.m128i_i64[0] > 0x3FFFFFFFFFFFFFFBuLL )
      {
        v415 = 0x3FFFFFFFFFFFFFFELL;
      }
      else
      {
        v529 = v528.m128i_i8[8] == 0;
        v528.m128i_i64[1] = 0;
        if ( !v529 )
          v528.m128i_i64[1] = 0x4000000000000000LL;
        v530 = v528.m128i_i64[1] | v528.m128i_i64[0];
        v415 = v530 & 0x3FFFFFFFFFFFFFFFLL;
        if ( (v530 & 0x4000000000000000LL) != 0 )
          goto LABEL_577;
      }
      if ( v567.m128i_i8[8] )
        goto LABEL_89;
LABEL_577:
      if ( v567.m128i_i64[0] <= v415 )
        sub_2EF06E0(v4, "Generic extload must have a narrower memory type", a2);
LABEL_89:
      if ( v34 == 99 )
      {
        if ( (*(_BYTE *)(v67 + 37) & 0xD) == 4 )
          sub_2EF06E0(v4, "atomic store cannot use acquire ordering", a2);
      }
      else if ( (*(_BYTE *)(v67 + 37) & 0xFu) - 5 <= 1 )
      {
        sub_2EF06E0(v4, "atomic load cannot use release ordering", a2);
      }
      goto LABEL_47;
    case 123:
      v146 = *(_QWORD *)(a2 + 32);
      if ( !*(_BYTE *)v146
        && (v147 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v146 + 8)), (v147 & 0xFFFFFFFFFFFFFFF9LL) != 0)
        && (v147 & 6) == 2 )
      {
        if ( *(_BYTE *)(v146 + 40) == 1 && *(_QWORD *)(v146 + 64) <= 1u )
        {
          if ( *(_BYTE *)(v146 + 80) == 1 && *(_QWORD *)(v146 + 104) <= 3u )
          {
            if ( *(_BYTE *)(v146 + 120) != 1 || *(_QWORD *)(v146 + 144) > 1u )
              sub_2EF0A60(v4, "cache type operand must be an immediate 0-1", v146 + 120, 3u, 0);
          }
          else
          {
            sub_2EF0A60(v4, "locality operand must be an immediate 0-3", v146 + 80, 2u, 0);
          }
        }
        else
        {
          sub_2EF0A60(v4, "rw operand must be an immediate 0-1", v146 + 40, 1u, 0);
        }
      }
      else
      {
        sub_2EF0A60(v4, "addr operand must be a pointer", v146, 0, 0);
      }
      goto LABEL_47;
    case 127:
    case 128:
    case 129:
    case 130:
      if ( *(_BYTE *)(*(_QWORD *)(a2 + 32) + 40LL * (unsigned int)sub_2E88FE0(a2)) != 17 )
      {
        sub_2EF06E0(v4, "G_INTRINSIC first src operand must be an intrinsic ID", a2);
        goto LABEL_47;
      }
      v382 = *(unsigned __int16 *)(a2 + 68);
      v383 = *(_DWORD *)(*(_QWORD *)(a2 + 32) + 40LL * (unsigned int)sub_2E88FE0(a2) + 24);
      if ( (unsigned int)(v383 - 1) > 0x3EEE )
        goto LABEL_506;
      v406 = (__int64 *)sub_B2BE50(**(_QWORD **)(v4 + 32));
      v564.m128i_i64[0] = sub_B612D0(v406, v383);
      v407 = sub_A746F0(&v564);
      if ( (((_WORD)v382 - 127) & 0xFFFD) != 0 )
      {
        if ( v407 )
          goto LABEL_506;
        v408 = (const char *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 24LL)
                            + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 16LL) + 4 * v382));
        if ( v408 )
          v409 = strlen(v408);
        else
          v409 = 0;
        v574.m128i_i64[1] = v409;
        v575 = " used with readnone intrinsic";
        v576 = 773;
        v574.m128i_i64[0] = (__int64)v408;
        sub_CA0F50(v567.m128i_i64, (void **)&v574);
        sub_2EF06E0(v4, (char *)v567.m128i_i64[0], a2);
        v92 = v567.m128i_i64[0];
        if ( (__int64 *)v567.m128i_i64[0] == &v568 )
          goto LABEL_47;
      }
      else
      {
        if ( !v407 )
        {
LABEL_506:
          v384 = *(unsigned __int16 *)(a2 + 68);
          v385 = *(_DWORD *)(*(_QWORD *)(a2 + 32) + 40LL * (unsigned int)sub_2E88FE0(a2) + 24);
          if ( (unsigned int)(v385 - 1) > 0x3EEE )
            goto LABEL_47;
          v386 = (__int64 *)sub_B2BE50(**(_QWORD **)(v4 + 32));
          v564.m128i_i64[0] = sub_B612D0(v386, v385);
          v387 = sub_A73ED0(&v564, 6);
          if ( (unsigned int)(unsigned __int16)v384 - 127 > 1 )
          {
            if ( v387 == 1 )
              goto LABEL_47;
            v388 = (const char *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 24LL)
                                + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 16LL) + 4 * v384));
            v389 = v388 ? strlen(v388) : 0LL;
            v574.m128i_i64[1] = v389;
            v575 = " used with a non-convergent intrinsic";
            v576 = 773;
            v574.m128i_i64[0] = (__int64)v388;
            sub_CA0F50(v567.m128i_i64, (void **)&v574);
            sub_2EF06E0(v4, (char *)v567.m128i_i64[0], a2);
            v92 = v567.m128i_i64[0];
            if ( (__int64 *)v567.m128i_i64[0] == &v568 )
              goto LABEL_47;
          }
          else
          {
            if ( !v387 )
              goto LABEL_47;
            v531 = (const char *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 24LL)
                                + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 16LL) + 4 * v384));
            v532 = v531 ? strlen(v531) : 0LL;
            v574.m128i_i64[1] = v532;
            v575 = " used with a convergent intrinsic";
            v576 = 773;
            v574.m128i_i64[0] = (__int64)v531;
            sub_CA0F50(v567.m128i_i64, (void **)&v574);
            sub_2EF06E0(v4, (char *)v567.m128i_i64[0], a2);
            v92 = v567.m128i_i64[0];
            if ( (__int64 *)v567.m128i_i64[0] == &v568 )
              goto LABEL_47;
          }
          goto LABEL_849;
        }
        v490 = (const char *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 24LL)
                            + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 16LL) + 4 * v382));
        if ( v490 )
          v491 = strlen(v490);
        else
          v491 = 0;
        v574.m128i_i64[1] = v491;
        v575 = " used with intrinsic that accesses memory";
        v576 = 773;
        v574.m128i_i64[0] = (__int64)v490;
        sub_CA0F50(v567.m128i_i64, (void **)&v574);
        sub_2EF06E0(v4, (char *)v567.m128i_i64[0], a2);
        v92 = v567.m128i_i64[0];
        if ( (__int64 *)v567.m128i_i64[0] == &v568 )
          goto LABEL_47;
      }
      goto LABEL_849;
    case 131:
    case 132:
    case 137:
    case 139:
    case 196:
    case 197:
      v47 = *(_QWORD *)(a2 + 32);
      v48 = *(_QWORD *)(v4 + 64);
      v49 = sub_2E865D0(v48, *(_DWORD *)(v47 + 8));
      v50 = sub_2E865D0(v48, *(_DWORD *)(v47 + 48));
      v51 = v50;
      if ( (v49 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v50 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        v539 = v50 >> 3;
        v52 = v50 & 2;
        if ( (v49 & 2) != 0 )
        {
          sub_2EF06E0(v4, "Generic extend/truncate can not operate on pointers", a2);
          sub_2EF0960(v4, v49, v51, a2);
          v53 = HIWORD(v49);
        }
        else
        {
          if ( v52 )
            sub_2EF06E0(v4, "Generic extend/truncate can not operate on pointers", a2);
          sub_2EF0960(v4, v49, v51, a2);
          v53 = HIDWORD(v49);
        }
        v54 = v539 >> 45;
        if ( !v52 )
          LODWORD(v54) = v539 >> 29;
        v55 = *(_WORD *)(a2 + 68);
        if ( v55 == 132 || v55 == 197 )
        {
          if ( (unsigned int)v54 <= (unsigned int)v53 )
            sub_2EF06E0(v4, "Generic truncate has destination type no smaller than source", a2);
        }
        else if ( (unsigned int)v54 >= (unsigned int)v53 )
        {
          sub_2EF06E0(v4, "Generic extend has destination type no larger than source", a2);
        }
      }
      goto LABEL_47;
    case 133:
    case 134:
      v78 = *(_QWORD *)(a2 + 32);
      v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v78 + 8));
      if ( (v567.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v567.m128i_i8[0] & 4) != 0 )
      {
        sub_2EF06E0(v4, "Instruction cannot use a vector result type", a2);
        v35 = *(_WORD *)(a2 + 68);
        v78 = *(_QWORD *)(a2 + 32);
      }
      v79 = *(_BYTE *)(v78 + 40);
      if ( v35 == 133 )
      {
        if ( v79 != 2 )
        {
          sub_2EF06E0(v4, "G_CONSTANT operand must be cimm", a2);
          goto LABEL_47;
        }
        v404 = *(unsigned int *)(*(_QWORD *)(v78 + 64) + 32LL);
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574.m128i_i64[1] = v405;
        if ( v404 != sub_CA1930(&v574) )
          goto LABEL_548;
      }
      else
      {
        if ( v79 != 3 )
        {
          sub_2EF06E0(v4, "G_FCONSTANT operand must be fpimm", a2);
          goto LABEL_47;
        }
        v422 = sub_C33740(*(_QWORD *)(*(_QWORD *)(v78 + 64) + 24LL));
        v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v567);
        v574.m128i_i64[1] = v423;
        if ( v422 != sub_CA1930(&v574) )
        {
LABEL_548:
          sub_2EF06E0(v4, "inconsistent constant size", a2);
          goto LABEL_47;
        }
      }
      goto LABEL_47;
    case 138:
      v161 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v161 + 80) == 1 )
      {
        v368 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v161 + 48));
        v369 = *(_QWORD *)(v161 + 104);
        v370 = v368;
        if ( v369 <= 0 )
          sub_2EF06E0(v4, "G_SEXT_INREG size must be >= 1", a2);
        if ( (v370 & 2) != 0 && (v370 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
          LODWORD(v371) = HIWORD(v370);
        else
          v371 = HIDWORD(v370);
        if ( (unsigned int)v371 <= v369 )
          sub_2EF06E0(v4, "G_SEXT_INREG size must be less than source bit width", a2);
      }
      else
      {
        sub_2EF06E0(v4, "G_SEXT_INREG expects an immediate operand #2", a2);
      }
      goto LABEL_47;
    case 140:
    case 141:
    case 142:
    case 145:
    case 146:
      v56 = *(_QWORD *)(a2 + 32);
      v57 = *(_QWORD *)(v4 + 64);
      v58 = sub_2E865D0(v57, *(_DWORD *)(v56 + 48));
      v59 = sub_2E865D0(v57, *(_DWORD *)(v56 + 88));
      if ( (v58 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v58 & 4) != 0 )
      {
        if ( (v59 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
        {
LABEL_79:
          sub_2EF06E0(v4, "Shifts and rotates require operands to be either all scalars or all vectors", a2);
          goto LABEL_47;
        }
        v60 = 1;
LABEL_78:
        if ( ((v59 & 4) != 0) == v60 )
          goto LABEL_47;
        goto LABEL_79;
      }
      if ( (v59 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        v60 = 0;
        goto LABEL_78;
      }
      goto LABEL_47;
    case 147:
    case 148:
      v107 = *(_QWORD *)(a2 + 32);
      v108 = *(_QWORD *)(v4 + 64);
      v109 = sub_2E865D0(v108, *(_DWORD *)(v107 + 8));
      v110 = sub_2E865D0(v108, *(_DWORD *)(v107 + 88));
      if ( (v109 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        if ( (v109 & 4) != 0 )
        {
          if ( (v110 & 0xFFFFFFFFFFFFFFF9LL) != 0
            && (v110 & 4) != 0
            && (unsigned __int16)((unsigned int)v110 >> 8) == (unsigned __int16)((unsigned int)v109 >> 8)
            && (((unsigned __int8)(v110 >> 3) ^ (unsigned __int8)(v109 >> 3)) & 1) == 0 )
          {
            goto LABEL_47;
          }
        }
        else if ( (v110 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v110 & 4) == 0 )
        {
          goto LABEL_47;
        }
      }
      else if ( (v110 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v110 & 4) == 0 )
      {
        goto LABEL_47;
      }
      sub_2EF06E0(v4, "Generic vector icmp/fcmp must preserve number of lanes", a2);
      goto LABEL_47;
    case 149:
    case 150:
      v111 = *(_QWORD *)(a2 + 32);
      v112 = *(_QWORD *)(v4 + 64);
      v113 = sub_2E865D0(v112, *(_DWORD *)(v111 + 8));
      v114 = sub_2E865D0(v112, *(_DWORD *)(v111 + 48));
      if ( (v114 & 2) != 0 && (v114 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        sub_2EF06E0(v4, "Generic scmp/ucmp does not support pointers as operands", a2);
        goto LABEL_47;
      }
      if ( (v113 & 2) == 0 )
      {
        if ( HIDWORD(v113) > 1 )
        {
          v339 = v114 & 0xFFFFFFFFFFFFFFF9LL;
          if ( (v113 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v113 & 4) != 0 )
          {
            if ( v339
              && (v114 & 4) != 0
              && (unsigned __int16)((unsigned int)v114 >> 8) == (unsigned __int16)((unsigned int)v113 >> 8)
              && (((unsigned __int8)(v113 >> 3) ^ (unsigned __int8)(v114 >> 3)) & 1) == 0 )
            {
              goto LABEL_47;
            }
LABEL_426:
            sub_2EF06E0(v4, "Generic vector scmp/ucmp must preserve number of lanes", a2);
            goto LABEL_47;
          }
LABEL_523:
          if ( !v339 || (v114 & 4) == 0 )
            goto LABEL_47;
          goto LABEL_426;
        }
        goto LABEL_557;
      }
      if ( (v113 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
      {
        v339 = v114 & 0xFFFFFFFFFFFFFFF9LL;
        if ( HIDWORD(v113) > 1 )
          goto LABEL_523;
LABEL_557:
        sub_2EF06E0(v4, "Result type must be at least 2 bits wide", a2);
        goto LABEL_47;
      }
      sub_2EF06E0(v4, "Generic scmp/ucmp does not support pointers as a result", a2);
      goto LABEL_47;
    case 151:
      v181 = *(_QWORD *)(a2 + 32);
      v182 = *(_QWORD *)(v4 + 64);
      v183 = sub_2E865D0(v182, *(_DWORD *)(v181 + 8));
      v184 = sub_2E865D0(v182, *(_DWORD *)(v181 + 48));
      if ( (v183 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v184 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v184 & 4) != 0 )
        sub_2EF0960(v4, v183, v184, a2);
      goto LABEL_47;
    case 206:
      v567.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 8LL));
      if ( (sub_2EF2BA0((unsigned __int64 *)&v567) & 1) != 0 )
      {
        v574.m128i_i64[0] = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 48LL));
        if ( (sub_2EF2BA0((unsigned __int64 *)&v574) & 1) != 0 )
        {
          if ( (unsigned __int8)sub_2EF0960(v4, v567.m128i_u64[0], v574.m128i_u64[0], a2) )
          {
            v421 = *(_QWORD *)(a2 + 32);
            if ( *(_BYTE *)(v421 + 80) == 1 )
            {
              if ( *(_QWORD *)(v421 + 104) > 0x3FFu )
                sub_2EF06E0(v4, "Incorrect floating-point class set (operand 2)", a2);
            }
            else
            {
              sub_2EF06E0(v4, "floating-point class set (operand 2) must be an immediate", a2);
            }
          }
        }
        else
        {
          sub_2EF06E0(v4, "Source must be a scalar or vector of scalars", a2);
        }
      }
      else
      {
        sub_2EF06E0(v4, "Destination must be a scalar or vector of scalars", a2);
      }
      goto LABEL_47;
    case 220:
      v141 = *(int **)(a2 + 32);
      v142 = *(_QWORD *)(v4 + 64);
      v548 = sub_2E865D0(v142, v141[2]);
      v143 = sub_2E865D0(v142, v141[12]);
      v144 = sub_2E865D0(v142, v141[22]);
      v145 = v144;
      if ( (v548 & 0xFFFFFFFFFFFFFFF9LL) != 0
        && (v143 & 0xFFFFFFFFFFFFFFF9LL) != 0
        && (v144 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        if ( (v143 & 2) == 0 )
          sub_2EF06E0(v4, "gep first operand must be a pointer", a2);
        if ( (v145 & 2) != 0 )
          sub_2EF06E0(v4, "gep offset operand must not be a pointer", a2);
      }
      goto LABEL_47;
    case 221:
      v157 = *(int **)(a2 + 32);
      v158 = *(_QWORD *)(v4 + 64);
      v159 = sub_2E865D0(v158, v157[2]);
      v549 = sub_2E865D0(v158, v157[12]);
      v160 = sub_2E865D0(v158, v157[22]);
      v574.m128i_i64[0] = v160;
      if ( (v159 & 0xFFFFFFFFFFFFFFF9LL) != 0
        && (v549 & 0xFFFFFFFFFFFFFFF9LL) != 0
        && (v160 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
      {
        if ( (v159 & 2) == 0 )
          sub_2EF06E0(v4, "ptrmask result type must be a pointer", a2);
        if ( (sub_2EF2BA0((unsigned __int64 *)&v574) & 1) == 0 )
          sub_2EF06E0(v4, "ptrmask mask type must be an integer", a2);
        sub_2EF0960(v4, v159, v574.m128i_u64[0], a2);
      }
      goto LABEL_47;
    case 227:
    case 228:
      v103 = *(_QWORD *)(a2 + 32);
      v104 = *(_QWORD *)(v4 + 64);
      v105 = sub_2E865D0(v104, *(_DWORD *)(v103 + 8));
      v106 = sub_2E865D0(v104, *(_DWORD *)(v103 + 48));
      if ( (v105 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v106 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
        goto LABEL_47;
      if ( (v106 & 6) == 2 )
      {
        v442 = 6;
        v443 = "Source";
      }
      else
      {
        if ( (v105 & 6) != 2 )
        {
          if ( (v106 & 1) == 0 )
          {
            if ( (v106 & 4) != 0 )
              sub_2EF0960(v4, v106, v105, a2);
            goto LABEL_47;
          }
          v459 = (unsigned int)sub_2E88F80(a2);
          v460 = *(_QWORD *)(a2 + 32);
          v461 = v103 + 40 * v459;
          v462 = (__int64)(0xCCCCCCCCCCCCCCCDLL * ((v461 - v460) >> 3)) >> 2;
          if ( v462 > 0 )
          {
            v463 = v460 + 160 * v462;
            do
            {
              if ( !*(_BYTE *)v460 )
              {
                v464 = *(_DWORD *)(v460 + 8);
                if ( (unsigned int)(v464 - 1) > 0x3FFFFFFE )
                {
                  if ( v464 >= 0 || (v477 = v464 & 0x7FFFFFFF, (unsigned int)v477 >= *(_DWORD *)(v104 + 464)) )
                    v465 = 0;
                  else
                    v465 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v477) & 1;
                  if ( !v465 )
                    goto LABEL_692;
                }
              }
              if ( !*(_BYTE *)(v460 + 40) )
              {
                v466 = *(_DWORD *)(v460 + 48);
                if ( (unsigned int)(v466 - 1) > 0x3FFFFFFE )
                {
                  if ( v466 >= 0 || (v478 = v466 & 0x7FFFFFFF, (unsigned int)v478 >= *(_DWORD *)(v104 + 464)) )
                    v467 = 0;
                  else
                    v467 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v478) & 1;
                  if ( !v467 )
                  {
                    v460 += 40;
                    goto LABEL_692;
                  }
                }
              }
              if ( !*(_BYTE *)(v460 + 80) )
              {
                v468 = *(_DWORD *)(v460 + 88);
                if ( (unsigned int)(v468 - 1) > 0x3FFFFFFE )
                {
                  if ( v468 >= 0 || (v475 = v468 & 0x7FFFFFFF, (unsigned int)v475 >= *(_DWORD *)(v104 + 464)) )
                    v469 = 0;
                  else
                    v469 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v475) & 1;
                  if ( !v469 )
                  {
                    v460 += 80;
                    goto LABEL_692;
                  }
                }
              }
              if ( !*(_BYTE *)(v460 + 120) )
              {
                v470 = *(_DWORD *)(v460 + 128);
                if ( (unsigned int)(v470 - 1) > 0x3FFFFFFE )
                {
                  if ( v470 >= 0 || (v476 = v470 & 0x7FFFFFFF, (unsigned int)v476 >= *(_DWORD *)(v104 + 464)) )
                    v471 = 0;
                  else
                    v471 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v476) & 1;
                  if ( !v471 )
                  {
                    v460 += 120;
                    goto LABEL_692;
                  }
                }
              }
              v460 += 160;
            }
            while ( v463 != v460 );
          }
          v472 = v461 - v460;
          if ( v461 - v460 != 80 )
          {
            if ( v472 != 120 )
            {
              if ( v472 != 40 )
                goto LABEL_47;
LABEL_716:
              if ( *(_BYTE *)v460 )
                goto LABEL_47;
              v473 = *(_DWORD *)(v460 + 8);
              if ( (unsigned int)(v473 - 1) <= 0x3FFFFFFE )
                goto LABEL_47;
              if ( v473 >= 0 || (v479 = v473 & 0x7FFFFFFF, (unsigned int)v479 >= *(_DWORD *)(v104 + 464)) )
                v474 = 0;
              else
                v474 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v479) & 1;
              if ( v474 )
                goto LABEL_47;
              goto LABEL_692;
            }
            if ( !*(_BYTE *)v460 )
            {
              v480 = *(_DWORD *)(v460 + 8);
              if ( (unsigned int)(v480 - 1) > 0x3FFFFFFE )
              {
                if ( v480 >= 0 || (v485 = v480 & 0x7FFFFFFF, (unsigned int)v485 >= *(_DWORD *)(v104 + 464)) )
                  v481 = 0;
                else
                  v481 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v485) & 1;
                if ( !v481 )
                {
LABEL_692:
                  if ( v461 != v460 )
                    sub_2EF06E0(v4, "All register operands must have scalar types", a2);
                  goto LABEL_47;
                }
              }
            }
            v460 += 40;
          }
          if ( *(_BYTE *)v460
            || (v482 = *(_DWORD *)(v460 + 8), (unsigned int)(v482 - 1) <= 0x3FFFFFFE)
            || (v482 >= 0 || (v484 = v482 & 0x7FFFFFFF, (unsigned int)v484 >= *(_DWORD *)(v104 + 464))
              ? (v483 = 0)
              : (v483 = *(_BYTE *)(*(_QWORD *)(v104 + 456) + 8 * v484) & 1),
                v483) )
          {
            v460 += 40;
            goto LABEL_716;
          }
          goto LABEL_692;
        }
        v442 = 11;
        v443 = "Destination";
      }
      v574.m128i_i64[0] = (__int64)v443;
      v574.m128i_i64[1] = v442;
      v576 = 773;
      v575 = " operand must not be a pointer type";
      sub_2EF0910(v4, (void **)&v574, a2);
      goto LABEL_47;
    case 230:
      v154 = *(_QWORD *)(a2 + 32);
      v155 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v154 + 8));
      if ( (v155 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v155 & 6) != 2 )
      {
        sub_2EF06E0(v4, "G_BRJT src operand 0 must be a pointer type", a2);
        v154 = *(_QWORD *)(a2 + 32);
      }
      if ( *(_BYTE *)(v154 + 40) != 8 )
      {
        sub_2EF06E0(v4, "G_BRJT src operand 1 must be a jump table index", a2);
        v154 = *(_QWORD *)(a2 + 32);
      }
      if ( *(_BYTE *)(v154 + 80)
        || (v156 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v154 + 88)), (v156 & 0xFFFFFFFFFFFFFFF9LL) != 0)
        && (v156 & 6) == 2 )
      {
        sub_2EF06E0(v4, "G_BRJT src operand 2 must be a scalar reg type", a2);
      }
      goto LABEL_47;
    case 231:
      v148 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v148 + 40) == 2 )
      {
        v372 = *(_QWORD *)(v148 + 64);
        v373 = *(_DWORD *)(v372 + 32);
        if ( v373 <= 0x40 )
          v374 = *(_QWORD *)(v372 + 24) == 0;
        else
          v374 = v373 == (unsigned int)sub_C444A0(v372 + 24);
        if ( v374 )
          sub_2EF06E0(v4, "G_VSCALE immediate cannot be zero", a2);
      }
      else
      {
        sub_2EF06E0(v4, "G_VSCALE operand must be cimm", a2);
      }
      goto LABEL_47;
    case 232:
      v149 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v149 + 40) )
      {
        sub_2EF06E0(v4, "G_INSERT_SUBVECTOR first source must be a register", a2);
        goto LABEL_47;
      }
      if ( *(_BYTE *)(v149 + 80) )
      {
        sub_2EF06E0(v4, "G_INSERT_SUBVECTOR second source must be a register", a2);
        goto LABEL_47;
      }
      if ( *(_BYTE *)(v149 + 120) != 1 )
      {
        sub_2EF06E0(v4, "G_INSERT_SUBVECTOR index must be an immediate", a2);
        goto LABEL_47;
      }
      v431 = *(_QWORD *)(v4 + 64);
      v567.m128i_i64[0] = sub_2E865D0(v431, *(_DWORD *)(v149 + 8));
      v432 = v567.m128i_i64[0];
      v433 = sub_2E865D0(v431, *(_DWORD *)(v149 + 88));
      v574.m128i_i64[0] = v433;
      if ( (v432 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v567.m128i_i8[0] & 4) == 0 )
        goto LABEL_634;
      if ( (v433 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v574.m128i_i8[0] & 4) == 0 )
      {
        sub_2EF06E0(v4, "Second source must be a vector", a2);
        goto LABEL_47;
      }
      v434 = sub_2EF2C00((unsigned __int64 *)&v574);
      v435 = sub_2EF2C00((unsigned __int64 *)&v567);
      if ( sub_2EEE7A0(v435, v434) )
        goto LABEL_654;
      if ( ((v567.m128i_i8[0] & 8) != 0) != ((v574.m128i_i8[0] & 8) != 0) )
        goto LABEL_545;
      v444 = (unsigned __int16)((unsigned __int32)v567.m128i_i32[0] >> 8);
      v445 = (unsigned __int16)((unsigned __int32)v574.m128i_i32[0] >> 8);
      if ( (unsigned __int16)((unsigned __int32)v574.m128i_i32[0] >> 8) > (unsigned int)v444 )
      {
        sub_2EF06E0(v4, "Second source must be smaller than destination vector", a2);
      }
      else
      {
        v446 = *(_QWORD *)(v149 + 144);
        if ( v446 % v445 )
        {
          sub_2EF06E0(v4, "Index must be a multiple of the second source vector's minimum vector length", a2);
        }
        else if ( v446 >= v444 || v446 + v445 > v444 )
        {
          sub_2EF06E0(
            v4,
            "Subvector type and index must not cause insert to overrun the vector being inserted into",
            a2);
        }
      }
      goto LABEL_47;
    case 233:
      v140 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v140 + 40) )
      {
        sub_2EF06E0(v4, "G_EXTRACT_SUBVECTOR first source must be a register", a2);
      }
      else if ( *(_BYTE *)(v140 + 80) == 1 )
      {
        v399 = *(_QWORD *)(v4 + 64);
        v567.m128i_i64[0] = sub_2E865D0(v399, *(_DWORD *)(v140 + 8));
        v400 = v567.m128i_i64[0];
        v401 = sub_2E865D0(v399, *(_DWORD *)(v140 + 48));
        v574.m128i_i64[0] = v401;
        if ( (v400 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v567.m128i_i8[0] & 4) != 0 )
        {
          if ( (v401 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v574.m128i_i8[0] & 4) != 0 )
          {
            v402 = sub_2EF2C00((unsigned __int64 *)&v574);
            v403 = sub_2EF2C00((unsigned __int64 *)&v567);
            if ( sub_2EEE7A0(v403, v402) )
            {
LABEL_654:
              sub_2EF06E0(v4, "Element type of vectors must be the same", a2);
            }
            else if ( ((v567.m128i_i8[0] & 8) != 0) == ((v574.m128i_i8[0] & 8) != 0) )
            {
              v515 = (unsigned __int16)((unsigned __int32)v574.m128i_i32[0] >> 8);
              v516 = (unsigned __int16)((unsigned __int32)v567.m128i_i32[0] >> 8);
              if ( (unsigned __int16)((unsigned __int32)v567.m128i_i32[0] >> 8) > (unsigned int)v515 )
              {
                sub_2EF06E0(v4, "Destination vector must be smaller than source vector", a2);
              }
              else
              {
                v517 = *(_QWORD *)(v140 + 104);
                if ( v517 % v516 )
                {
                  sub_2EF06E0(v4, "Index must be a multiple of the destination vector's minimum vector length", a2);
                }
                else if ( v517 >= v515 || v517 + v516 > v515 )
                {
                  sub_2EF06E0(v4, "Destination type and index must not cause extract to overrun the source vector", a2);
                }
              }
            }
            else
            {
LABEL_545:
              sub_2EF06E0(v4, "Vector types must both be fixed or both be scalable", a2);
            }
          }
          else
          {
            sub_2EF06E0(v4, "Source must be a vector", a2);
          }
        }
        else
        {
LABEL_634:
          sub_2EF06E0(v4, "Destination type must be a vector", a2);
        }
      }
      else
      {
        sub_2EF06E0(v4, "G_EXTRACT_SUBVECTOR index must be an immediate", a2);
      }
      goto LABEL_47;
    case 234:
      v129 = *(int **)(a2 + 32);
      v130 = *(_QWORD *)(v4 + 64);
      v131 = sub_2E865D0(v130, v129[2]);
      v540 = sub_2E865D0(v130, v129[12]);
      v546 = sub_2E865D0(v130, v129[22]);
      v564.m128i_i64[0] = sub_2E865D0(v130, v129[32]);
      if ( (v131 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v131 & 4) == 0 )
        goto LABEL_634;
      if ( sub_2EEE7A0(v540, v131) )
      {
        sub_2EF06E0(v4, "Destination type and vector type must match", a2);
      }
      else
      {
        if ( (v546 & 1) == 0 && ((v546 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v546 & 6) != 2) )
        {
          sub_2EF06E0(v4, "Inserted element must be a scalar or pointer", a2);
          goto LABEL_47;
        }
        v424 = *(__int64 (**)())(**(_QWORD **)(*(_QWORD *)(v4 + 32) + 16LL) + 144LL);
        if ( v424 == sub_2C8F680 )
        {
          v574.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
          v574.m128i_i64[1] = v3;
          sub_CA1930(&v574);
          BUG();
        }
        v425 = v424();
        v426.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
        v574 = v426;
        v427 = sub_CA1930(&v574);
        v428 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v425 + 72LL);
        v429 = sub_2E79000(*(__int64 **)(v4 + 32));
        v430 = v428(v425, v429);
        if ( v430 <= 1u || (unsigned __int16)(v430 - 504) <= 7u )
LABEL_860:
          BUG();
        if ( v427 != *(_QWORD *)&byte_444C4A0[16 * v430 - 16] )
        {
LABEL_451:
          sub_2EF06E0(v4, "Index type must match VectorIdxTy", a2);
          goto LABEL_47;
        }
      }
      goto LABEL_47;
    case 235:
      v132 = *(int **)(a2 + 32);
      v133 = *(_QWORD *)(v4 + 64);
      v134 = sub_2E865D0(v133, v132[2]);
      v547 = sub_2E865D0(v133, v132[12]);
      v562.m128i_i64[0] = sub_2E865D0(v133, v132[22]);
      if ( (v134 & 1) == 0 && ((v134 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v134 & 6) != 2) )
      {
        sub_2EF06E0(v4, "Destination type must be a scalar or pointer", a2);
        goto LABEL_47;
      }
      if ( (v547 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v547 & 4) == 0 )
      {
        sub_2EF06E0(v4, "First source must be a vector", a2);
        goto LABEL_47;
      }
      v344 = *(__int64 (**)())(**(_QWORD **)(*(_QWORD *)(v4 + 32) + 16LL) + 144LL);
      if ( v344 == sub_2C8F680 )
      {
        v567.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
        v567.m128i_i64[1] = v2;
        sub_CA1930(&v567);
        BUG();
      }
      v345 = v344();
      v346.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
      v567 = v346;
      v347 = sub_CA1930(&v567);
      v348 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v345 + 72LL);
      v349 = sub_2E79000(*(__int64 **)(v4 + 32));
      v350 = v348(v345, v349);
      if ( v350 <= 1u || (unsigned __int16)(v350 - 504) <= 7u )
        goto LABEL_860;
      if ( v347 == *(_QWORD *)&byte_444C4A0[16 * v350 - 16] )
        goto LABEL_47;
      goto LABEL_451;
    case 236:
      v135 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v135 + 120) == 19 )
      {
        v351 = *(_QWORD *)(v4 + 64);
        v567.m128i_i64[0] = sub_2E865D0(v351, *(_DWORD *)(v135 + 8));
        v574.m128i_i64[0] = sub_2E865D0(v351, *(_DWORD *)(v135 + 48));
        v352 = v574.m128i_i64[0];
        v353 = sub_2E865D0(v351, *(_DWORD *)(v135 + 88));
        if ( (((unsigned __int8)v353 ^ (unsigned __int8)v352) & 7) != 0 || ((v353 ^ v352) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          sub_2EF06E0(v4, "Source operands must be the same type", a2);
        v354 = sub_2EF2BA0((unsigned __int64 *)&v567);
        v355 = sub_2EF2BA0((unsigned __int64 *)&v574);
        if ( (((unsigned __int8)v354 ^ (unsigned __int8)v355) & 7) != 0 || ((v354 ^ v355) & 0xFFFFFFFFFFFFFFF8LL) != 0 )
          sub_2EF06E0(v4, "G_SHUFFLE_VECTOR cannot change element type", a2);
        v356 = 1;
        if ( (v574.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v574.m128i_i8[0] & 4) != 0 )
        {
          v357 = (unsigned __int64)v574.m128i_i64[0] >> 3;
          if ( (v574.m128i_i8[0] & 8) != 0 )
          {
            sub_CA17B0(
              "Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use LLT"
              "::getElementCount() instead");
            v357 = (unsigned __int64)v574.m128i_i64[0] >> 3;
          }
          v356 = (unsigned __int16)(v357 >> 5);
        }
        v358 = 1;
        if ( (v567.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v567.m128i_i8[0] & 4) != 0 )
        {
          v359 = (unsigned __int64)v567.m128i_i64[0] >> 3;
          if ( (v567.m128i_i8[0] & 8) != 0 )
          {
            sub_CA17B0(
              "Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use LLT"
              "::getElementCount() instead");
            v359 = (unsigned __int64)v567.m128i_i64[0] >> 3;
          }
          v358 = (unsigned __int16)(v359 >> 5);
        }
        v360 = *(int **)(v135 + 144);
        v361 = *(_QWORD *)(v135 + 152);
        if ( v358 != (_DWORD)v361 )
          sub_2EF06E0(v4, "Wrong result type for shufflemask", a2);
        v362 = &v360[v361];
        for ( k = 2 * v356; v362 != v360; ++v360 )
        {
          if ( *v360 >= 0 && k <= *v360 )
            sub_2EF06E0(v4, "Out of bounds shuffle index", a2);
        }
      }
      else
      {
        sub_2EF06E0(v4, "Incorrect mask operand type for G_SHUFFLE_VECTOR", a2);
      }
      goto LABEL_47;
    case 237:
      v136 = *(_QWORD *)(a2 + 32);
      v137 = *(_QWORD *)(v4 + 64);
      v560 = sub_2E865D0(v137, *(_DWORD *)(v136 + 8));
      v562.m128i_i64[0] = sub_2E865D0(v137, *(_DWORD *)(v136 + 48));
      if ( (v560 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v560 & 4) == 0 || (v560 & 8) == 0 )
        goto LABEL_184;
      if ( (v562.m128i_i8[0] & 1) != 0 || (v562.m128i_i64[0] & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v562.m128i_i8[0] & 6) == 2 )
      {
        v390.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v562);
        v574 = v390;
        v564.m128i_i64[0] = sub_2EF2C00((unsigned __int64 *)&v560);
        v391.m128i_i64[0] = sub_2EF2A30((unsigned __int64 *)&v564);
        v567 = v391;
        if ( (v391.m128i_i8[8] || !v574.m128i_i8[8]) && v567.m128i_i64[0] > (unsigned __int64)v574.m128i_i64[0] )
          sub_2EF06E0(v4, "Element type of the destination must be the same size or smaller than the source type", a2);
      }
      else
      {
        sub_2EF06E0(v4, "Source type must be a scalar or pointer", a2);
      }
      goto LABEL_47;
    case 238:
      v139 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v139 + 40) != 2 )
      {
        sub_2EF06E0(v4, "operand must be cimm", a2);
        goto LABEL_47;
      }
      v364 = *(_QWORD *)(v139 + 64);
      v365 = *(_DWORD *)(v364 + 32);
      v366 = *(_QWORD *)(v364 + 24);
      v367 = 1LL << ((unsigned __int8)v365 - 1);
      if ( v365 > 0x40 )
      {
        if ( (*(_QWORD *)(v366 + 8LL * ((v365 - 1) >> 6)) & v367) != 0 )
          goto LABEL_483;
        v436 = v365 == (unsigned int)sub_C444A0(v364 + 24);
      }
      else
      {
        if ( (v367 & v366) != 0 )
        {
LABEL_483:
          sub_2EF06E0(v4, "step must be > 0", a2);
          goto LABEL_47;
        }
        v436 = v366 == 0;
      }
      if ( v436 )
        goto LABEL_483;
      v437 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v139 + 8));
      v574.m128i_i64[0] = v437;
      if ( (v437 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v574.m128i_i8[0] & 4) != 0 && (v437 & 8) != 0 )
      {
        if ( (sub_2EF2C00((unsigned __int64 *)&v574) & 1) != 0 )
        {
          v492 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 64LL) + 32LL);
          v493 = sub_2EF2C00((unsigned __int64 *)&v574);
          if ( (v493 & 2) != 0 && (v493 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
            v494 = HIWORD(v493);
          else
            v494 = HIDWORD(v493);
          if ( v492 != (_DWORD)v494 )
            sub_2EF06E0(v4, "step bitwidth differs from result type element bitwidth", a2);
        }
        else
        {
          sub_2EF06E0(v4, "Destination element type must be scalar", a2);
        }
      }
      else
      {
LABEL_184:
        sub_2EF06E0(v4, "Destination type must be a scalable vector", a2);
      }
      goto LABEL_47;
    case 245:
      v152 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 8LL));
      if ( (v152 & 2) != 0 && (v152 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
        v153 = HIWORD(v152);
      else
        v153 = HIDWORD(v152);
      if ( (v153 & 0xF) != 0 )
        sub_2EF06E0(v4, "G_BSWAP size must be a multiple of 16 bits", a2);
      goto LABEL_47;
    case 265:
      v150 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)(v150 + 40) != 8 )
      {
        sub_2EF06E0(v4, "G_JUMP_TABLE source operand must be a jump table index", a2);
        v150 = *(_QWORD *)(a2 + 32);
      }
      v151 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(v150 + 8));
      if ( (v151 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v151 & 6) != 2 )
        sub_2EF06E0(v4, "G_JUMP_TABLE dest operand must have a pointer type", a2);
      goto LABEL_47;
    case 266:
      v40 = *(_QWORD *)(a2 + 32);
      if ( !*(_BYTE *)v40
        && (v41 = *(_QWORD *)(v4 + 64), v42 = sub_2E865D0(v41, *(_DWORD *)(v40 + 8)), (v42 & 0xFFFFFFFFFFFFFFF9LL) != 0)
        && (v42 & 6) == 2 )
      {
        if ( *(_BYTE *)(v40 + 40) || (sub_2E865D0(v41, *(_DWORD *)(v40 + 48)) & 1) == 0 )
        {
          sub_2EF06E0(v4, "src operand 1 must be a scalar reg type", a2);
        }
        else if ( *(_BYTE *)(v40 + 80) != 1 )
        {
          sub_2EF06E0(v4, "src operand 2 must be an immediate type", a2);
        }
      }
      else
      {
        sub_2EF06E0(v4, "dst operand 0 must be a pointer type", a2);
      }
      goto LABEL_47;
    case 279:
    case 280:
    case 281:
      v69 = *(_QWORD *)(a2 + 48);
      v70 = v69 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v69 & 0xFFFFFFFFFFFFFFF8LL) == 0 )
        goto LABEL_97;
      v71 = v69 & 7;
      if ( !v71 )
      {
        *(_QWORD *)(a2 + 48) = v70;
LABEL_97:
        sub_2EF06E0(v4, "memcpy/memmove must have 2 memory operands", a2);
        goto LABEL_47;
      }
      if ( v71 != 3 || *(_DWORD *)v70 != 2 )
        goto LABEL_97;
      v417 = *(_QWORD *)(v70 + 16);
      v418 = *(_WORD *)(v417 + 32);
      if ( (v418 & 2) != 0
        && (v418 & 1) == 0
        && (v419 = *(_QWORD *)(v70 + 24), v420 = *(_WORD *)(v419 + 32), (v420 & 2) == 0)
        && (v420 & 1) != 0 )
      {
        v558 = sub_2EF2C60(v419);
        if ( sub_2EF2C60(v417) != v558 )
          sub_2EF06E0(v4, "inconsistent memory operand sizes", a2);
        v455 = *(_QWORD *)(v4 + 64);
        v543 = *(_QWORD *)(a2 + 32);
        v559 = sub_2E865D0(v455, *(_DWORD *)(v543 + 8));
        v456 = sub_2E865D0(v455, *(_DWORD *)(v543 + 48));
        v457 = v456;
        if ( (v559 & 0xFFFFFFFFFFFFFFF9LL) != 0
          && (v559 & 6) == 2
          && (v456 & 0xFFFFFFFFFFFFFFF9LL) != 0
          && (v456 & 6) == 2 )
        {
          if ( (unsigned int)sub_2EAC1E0(*(_QWORD *)(v70 + 16)) != ((v559 >> 24) & 0xFFFFFF) )
            sub_2EF06E0(v4, "inconsistent store address space", a2);
          if ( (unsigned int)sub_2EAC1E0(*(_QWORD *)(v70 + 24)) != ((v457 >> 24) & 0xFFFFFF) )
            sub_2EF06E0(v4, "inconsistent load address space", a2);
          if ( v34 != 280 )
          {
            v458 = *(_QWORD *)(a2 + 32);
            if ( *(_BYTE *)(v458 + 120) != 1 || (*(_QWORD *)(v458 + 144) & 0xFFFFFFFFFFFFFFFELL) != 0 )
              sub_2EF06E0(v4, "'tail' flag (operand 3) must be an immediate 0 or 1", a2);
          }
        }
        else
        {
          sub_2EF06E0(v4, "memory instruction operand must be a pointer", a2);
        }
      }
      else
      {
        sub_2EF06E0(v4, "wrong memory operand types", a2);
      }
      goto LABEL_47;
    case 282:
    case 283:
      v80 = *(_QWORD *)(a2 + 48);
      v81 = (int *)(v80 & 0xFFFFFFFFFFFFFFF8LL);
      if ( (v80 & 0xFFFFFFFFFFFFFFF8LL) == 0 )
        goto LABEL_491;
      v82 = v80 & 7;
      if ( v82 )
      {
        if ( v82 == 3 )
        {
          v85 = "memset";
          v84 = *v81;
          v83 = (__int64 *)(v81 + 4);
          if ( v34 != 282 )
            v85 = "bzero";
        }
        else
        {
LABEL_491:
          if ( v34 == 282 )
          {
            strcpy(v563, "memset");
            v562.m128i_i64[0] = (__int64)v563;
            v562.m128i_i64[1] = 6;
            goto LABEL_477;
          }
          v84 = 0;
          v83 = 0;
          v85 = "bzero";
        }
LABEL_114:
        v562.m128i_i64[0] = (__int64)v563;
        v86 = strlen(v85);
        v87 = v86;
        if ( (unsigned int)v86 >= 8 )
        {
          *(__int64 *)((char *)&v562.m128i_i64[1] + (unsigned int)v86) = *(_QWORD *)&v85[(unsigned int)v86 - 8];
          v392 = v86 - 1;
          if ( v392 >= 8 )
          {
            v393 = v392 & 0xFFFFFFF8;
            v394 = 0;
            do
            {
              v395 = v394;
              v394 += 8;
              *(_QWORD *)&v563[v395] = *(_QWORD *)&v85[v395];
            }
            while ( v394 < v393 );
          }
        }
        else if ( (v86 & 4) != 0 )
        {
          *(_DWORD *)v563 = *(_DWORD *)v85;
          *(__int32 *)((char *)&v562.m128i_i32[3] + (unsigned int)v86) = *(_DWORD *)&v85[(unsigned int)v86 - 4];
        }
        else if ( (_DWORD)v86 )
        {
          v563[0] = *v85;
          if ( (v86 & 2) != 0 )
            *(__int16 *)((char *)&v562.m128i_i16[7] + (unsigned int)v86) = *(_WORD *)&v85[(unsigned int)v86 - 2];
        }
        v562.m128i_i64[1] = v87;
        v563[v87] = 0;
        if ( v84 == 1 )
          goto LABEL_120;
LABEL_477:
        v576 = 773;
        v574 = v562;
        v91 = " must have 1 memory operand";
        goto LABEL_125;
      }
      *(_QWORD *)(a2 + 48) = v81;
      v83 = (__int64 *)(a2 + 48);
      v84 = 1;
      v85 = "bzero";
      if ( v34 != 282 )
        goto LABEL_114;
      strcpy(v563, "memset");
      v562.m128i_i64[0] = (__int64)v563;
      v562.m128i_i64[1] = 6;
LABEL_120:
      v88 = *v83;
      v89 = *(_WORD *)(*v83 + 32);
      if ( (v89 & 2) == 0 || (v89 & 1) != 0 )
      {
        v576 = 773;
        v574 = v562;
        v91 = " memory operand must be a store";
        goto LABEL_125;
      }
      v90 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 8LL));
      if ( (v90 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v90 & 6) != 2 )
      {
        v576 = 773;
        v574 = v562;
        v91 = " operand must be a pointer";
LABEL_125:
        v575 = v91;
        sub_2EF0910(v4, (void **)&v574, a2);
        goto LABEL_126;
      }
      if ( (unsigned int)sub_2EAC1E0(v88) != ((v90 >> 24) & 0xFFFFFF) )
      {
        v566 = 773;
        v573 = 1;
        v564 = v562;
        v572 = 3;
        v565 = " address space";
        v567.m128i_i64[0] = (__int64)"inconsistent ";
        sub_9C6370(&v574, &v567, &v564, v486, v487, v488);
        sub_2EF0910(v4, (void **)&v574, a2);
      }
      v489 = *(_QWORD *)(a2 + 32) + 40LL * ((*(_DWORD *)(a2 + 40) & 0xFFFFFFu) - 1);
      if ( *(_BYTE *)v489 != 1 || (*(_QWORD *)(v489 + 24) & 0xFFFFFFFFFFFFFFFELL) != 0 )
        sub_2EF06E0(v4, "'tail' flag (last operand) must be an immediate 0 or 1", a2);
LABEL_126:
      v92 = v562.m128i_i64[0];
      if ( (char *)v562.m128i_i64[0] != v563 )
LABEL_849:
        j_j___libc_free_0(v92);
LABEL_47:
      if ( v577 != v579 )
        _libc_free((unsigned __int64)v577);
      return;
    case 286:
      v138 = *(_QWORD *)(a2 + 32);
      if ( *(_BYTE *)v138 == 1 )
      {
        if ( (char)*(_QWORD *)(v138 + 24) != *(_QWORD *)(v138 + 24) )
          sub_2EF0A60(v4, "Crash kind must be 8 bit wide", v138, 0, 0);
      }
      else
      {
        sub_2EF0A60(v4, "Crash kind must be an immediate", v138, 0, 0);
      }
      goto LABEL_47;
    case 287:
    case 288:
      v98 = *(int **)(a2 + 32);
      v99 = *(_QWORD *)(v4 + 64);
      v545 = sub_2E865D0(v99, v98[2]);
      v100 = sub_2E865D0(v99, v98[12]);
      v101 = sub_2E865D0(v99, v98[22]);
      if ( (v545 & 1) == 0 )
        sub_2EF06E0(v4, "Vector reduction requires a scalar destination type", a2);
      if ( (v100 & 1) == 0 )
        sub_2EF06E0(v4, "Sequential FADD/FMUL vector reduction requires a scalar 1st operand", a2);
      if ( (v101 & 0xFFFFFFFFFFFFFFF9LL) == 0 || (v101 & 4) == 0 )
        sub_2EF06E0(v4, "Sequential FADD/FMUL vector reduction must have a vector 2nd operand", a2);
      goto LABEL_47;
    case 289:
    case 290:
    case 291:
    case 292:
    case 293:
    case 294:
    case 295:
    case 296:
    case 297:
    case 298:
    case 299:
    case 300:
    case 301:
    case 302:
    case 303:
      if ( (sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 8LL)) & 1) == 0 )
        sub_2EF06E0(v4, "Vector reduction requires a scalar destination type", a2);
      goto LABEL_47;
    case 304:
    case 305:
      v102 = sub_2E865D0(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(a2 + 32) + 8LL));
      if ( (v102 & 0xFFFFFFFFFFFFFFF9LL) != 0 && (v102 & 4) != 0 )
        sub_2EF06E0(v4, "Bitfield extraction is not supported on vectors", a2);
      goto LABEL_47;
    default:
      goto LABEL_47;
  }
}
