// Function: sub_2F02A10
// Address: 0x2f02a10
//
char __fastcall sub_2F02A10(__int64 a1, const char *a2)
{
  __int64 v2; // r15
  char *v3; // rbx
  __int64 (*v4)(void); // rdx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 (*v9)(void); // rdx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  int i; // eax
  int v26; // eax
  __int64 v27; // rax
  __int64 v28; // r12
  __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // r8
  _QWORD *v32; // r9
  __int64 v33; // r14
  bool v34; // bl
  __int64 v35; // r10
  void *v36; // rdx
  int v37; // edx
  unsigned __int64 v38; // r8
  __int64 v39; // rbx
  __int64 v40; // r9
  __int64 v41; // rcx
  __int64 v42; // rax
  char v43; // al
  int v44; // r10d
  unsigned int v45; // r11d
  _QWORD *v46; // rax
  _QWORD *v47; // r13
  __int64 v48; // rdx
  __int64 v49; // rax
  int v50; // edx
  char v51; // al
  __int64 v52; // r12
  unsigned __int64 v53; // r14
  unsigned __int16 *v54; // r13
  char v55; // al
  __int64 v56; // rdx
  unsigned int v57; // esi
  __int64 v58; // rdi
  __int64 v59; // r10
  unsigned __int16 *v60; // r11
  char v61; // al
  char v62; // dl
  unsigned __int16 v63; // dx
  char *v64; // rsi
  __int64 v65; // rdx
  unsigned int v66; // ecx
  char v67; // bl
  _QWORD *v68; // rbx
  __int64 v69; // rax
  void *v70; // rax
  __int64 v71; // rdx
  __int64 v72; // rbx
  __int64 v73; // rcx
  __int64 v74; // rax
  int v75; // r13d
  unsigned int v76; // eax
  __int64 v77; // rbx
  __int64 v78; // rdx
  __int64 v79; // r14
  __int64 v80; // r12
  _QWORD *v81; // rdi
  int v82; // edx
  int v83; // ebx
  unsigned int v84; // eax
  unsigned __int64 v85; // rdx
  unsigned __int64 v86; // rax
  _QWORD *v87; // rax
  __int64 v88; // rdx
  _QWORD *ii; // rdx
  __int64 v90; // rax
  __int64 v91; // r12
  __int64 v92; // rcx
  unsigned __int64 v93; // rdi
  int v94; // r13d
  __int64 *v95; // rax
  unsigned __int64 v96; // r10
  __int64 *v97; // r11
  __int64 *v98; // rcx
  int v99; // esi
  __int64 v100; // rax
  int v101; // eax
  __int64 v102; // rsi
  int v103; // edx
  unsigned int v104; // ecx
  __int64 v105; // rax
  unsigned __int64 v106; // rsi
  __int64 v107; // rax
  unsigned int v108; // eax
  __int64 v109; // rdx
  int v110; // edx
  bool v111; // r10
  int v112; // eax
  __int64 v113; // rax
  __int64 *v114; // rax
  __int64 v115; // rdi
  __int64 v116; // r13
  __int64 *v117; // rax
  __int64 v118; // r12
  bool v119; // al
  unsigned int v120; // edx
  __int64 v121; // rax
  unsigned int v122; // esi
  __int64 v123; // rdi
  unsigned int v124; // r8d
  unsigned int v125; // eax
  __int64 v126; // rcx
  __int64 v127; // rcx
  unsigned __int64 v128; // rax
  __int64 m; // r9
  __int16 v130; // dx
  unsigned int v131; // ecx
  __int64 *v132; // rdx
  __int64 v133; // r9
  __int64 v134; // rbx
  char v135; // al
  __int64 v136; // rax
  __int64 v137; // rdx
  unsigned int v138; // eax
  __int64 v139; // rax
  __int64 v140; // rdi
  __int64 (__fastcall *v141)(__int64, __int64); // rax
  __int64 v142; // rax
  _QWORD *v143; // r13
  unsigned int v144; // r11d
  __int64 *v145; // rdi
  unsigned __int64 v146; // rsi
  __int64 v147; // rax
  __int64 (__fastcall *v148)(__int64, __int64); // rcx
  __int64 v149; // rax
  int v150; // eax
  __int64 v151; // rax
  __int64 v152; // rax
  __int64 v153; // rax
  __int64 v154; // rax
  __int64 v155; // rdi
  __int64 (*v156)(); // rax
  unsigned int v158; // eax
  int v159; // r10d
  __int64 v160; // r9
  int v161; // eax
  __int64 v162; // rdi
  unsigned __int64 v163; // rcx
  unsigned __int64 v164; // rdx
  __int64 n; // rdx
  __int64 v166; // r10
  __m128i *v167; // rdx
  __m128i v168; // xmm0
  int v169; // esi
  int v170; // eax
  char v171; // al
  __int64 v172; // rax
  unsigned int v173; // eax
  __int64 v174; // rdi
  __int64 v175; // rdx
  __int64 v176; // rax
  __int64 v177; // rax
  __int64 v178; // r14
  __int64 v179; // rax
  __int64 v180; // r14
  __int64 (*v181)(); // rax
  unsigned __int64 v182; // r14
  __int64 v183; // r10
  __int64 v184; // rdx
  unsigned __int64 v185; // rax
  __int64 v186; // rax
  __int64 v187; // rax
  __int64 v188; // rax
  __int64 v189; // rax
  __int64 v190; // r12
  unsigned __int64 v191; // rax
  __int64 v192; // r9
  __int64 v193; // rdx
  __int64 v194; // rdi
  __int64 v195; // r13
  void *v196; // rdx
  __m128i *v197; // rdx
  __m128i v198; // xmm0
  _BYTE *v199; // rax
  __int64 v200; // r14
  __int64 v201; // rdx
  __int64 v202; // rax
  __int64 v203; // rax
  unsigned __int64 v204; // rax
  __int64 v205; // rdx
  __int64 **v206; // rcx
  __int64 **v207; // rdx
  __int64 v208; // rax
  unsigned __int64 v209; // rax
  __int64 v210; // rax
  __int64 v211; // r12
  __int64 v212; // r14
  __int64 v213; // rax
  __int64 v214; // rax
  __int64 v215; // r12
  __m128i *v216; // rdx
  __m128i si128; // xmm0
  unsigned __int64 v218; // r14
  __int64 v219; // rax
  unsigned __int64 v220; // r14
  __int64 v221; // rax
  const char *v222; // rsi
  __int64 v223; // rdi
  __int64 v224; // rax
  __int64 v225; // rax
  bool v226; // al
  __int64 v227; // rax
  _BYTE *v228; // rax
  int v229; // r9d
  int v230; // edx
  __int64 v231; // rdx
  __int64 v232; // rax
  __int64 v233; // rax
  unsigned int k; // eax
  __int64 v235; // rdi
  int v236; // eax
  __int64 v237; // rax
  __int64 v238; // rcx
  __int64 v239; // rdi
  unsigned int j; // eax
  int v241; // eax
  __int64 v242; // rax
  _QWORD *v243; // rax
  __int64 v244; // rax
  int v245; // r10d
  __int64 v246; // rax
  __int64 v247; // [rsp+0h] [rbp-C0h]
  char *v248; // [rsp+8h] [rbp-B8h]
  __int64 v249; // [rsp+10h] [rbp-B0h]
  bool v250; // [rsp+10h] [rbp-B0h]
  __int64 v251; // [rsp+10h] [rbp-B0h]
  __int64 v252; // [rsp+10h] [rbp-B0h]
  int v253; // [rsp+10h] [rbp-B0h]
  __int64 v254; // [rsp+10h] [rbp-B0h]
  int v255; // [rsp+10h] [rbp-B0h]
  int v256; // [rsp+10h] [rbp-B0h]
  __int64 v257; // [rsp+10h] [rbp-B0h]
  __int64 v258; // [rsp+18h] [rbp-A8h]
  int v259; // [rsp+18h] [rbp-A8h]
  int v260; // [rsp+18h] [rbp-A8h]
  __int64 v261; // [rsp+18h] [rbp-A8h]
  __int64 v262; // [rsp+18h] [rbp-A8h]
  __int64 v263; // [rsp+18h] [rbp-A8h]
  unsigned int v264; // [rsp+18h] [rbp-A8h]
  __int64 v265; // [rsp+18h] [rbp-A8h]
  __int64 v266; // [rsp+18h] [rbp-A8h]
  int v267; // [rsp+18h] [rbp-A8h]
  __int64 v268; // [rsp+20h] [rbp-A0h]
  bool v269; // [rsp+20h] [rbp-A0h]
  __int64 v270; // [rsp+20h] [rbp-A0h]
  __int64 v271; // [rsp+20h] [rbp-A0h]
  __int64 v272; // [rsp+20h] [rbp-A0h]
  __int64 v273; // [rsp+20h] [rbp-A0h]
  __int64 v274; // [rsp+20h] [rbp-A0h]
  __int64 v275; // [rsp+20h] [rbp-A0h]
  int v276; // [rsp+20h] [rbp-A0h]
  unsigned __int16 *v277; // [rsp+20h] [rbp-A0h]
  __int64 v278; // [rsp+20h] [rbp-A0h]
  int v279; // [rsp+20h] [rbp-A0h]
  unsigned __int16 *v280; // [rsp+20h] [rbp-A0h]
  unsigned int v281; // [rsp+20h] [rbp-A0h]
  __int64 v282; // [rsp+20h] [rbp-A0h]
  unsigned __int16 *v283; // [rsp+20h] [rbp-A0h]
  int v284; // [rsp+20h] [rbp-A0h]
  int v285; // [rsp+20h] [rbp-A0h]
  __int64 v286; // [rsp+20h] [rbp-A0h]
  __int64 v287; // [rsp+20h] [rbp-A0h]
  bool v288; // [rsp+20h] [rbp-A0h]
  int v289; // [rsp+20h] [rbp-A0h]
  int v290; // [rsp+20h] [rbp-A0h]
  unsigned int v291; // [rsp+20h] [rbp-A0h]
  __int64 v292; // [rsp+28h] [rbp-98h]
  _QWORD *v293; // [rsp+30h] [rbp-90h]
  char *v294; // [rsp+38h] [rbp-88h]
  unsigned int v295; // [rsp+40h] [rbp-80h]
  unsigned int v296; // [rsp+40h] [rbp-80h]
  __int64 *v297; // [rsp+40h] [rbp-80h]
  unsigned __int64 v298; // [rsp+40h] [rbp-80h]
  __int64 v299; // [rsp+40h] [rbp-80h]
  int v300; // [rsp+40h] [rbp-80h]
  __int64 v301; // [rsp+40h] [rbp-80h]
  __int64 v302; // [rsp+40h] [rbp-80h]
  __int64 v303; // [rsp+40h] [rbp-80h]
  int v304; // [rsp+40h] [rbp-80h]
  __int64 v305; // [rsp+48h] [rbp-78h]
  __int64 v306; // [rsp+48h] [rbp-78h]
  __int64 v307; // [rsp+48h] [rbp-78h]
  __int64 v308; // [rsp+48h] [rbp-78h]
  __int64 v309; // [rsp+48h] [rbp-78h]
  __int64 *v310; // [rsp+48h] [rbp-78h]
  __int64 v311; // [rsp+48h] [rbp-78h]
  __int64 v312; // [rsp+48h] [rbp-78h]
  __int64 v313; // [rsp+48h] [rbp-78h]
  unsigned __int16 v314; // [rsp+48h] [rbp-78h]
  __int64 v315; // [rsp+48h] [rbp-78h]
  unsigned int v316; // [rsp+48h] [rbp-78h]
  __int64 v317; // [rsp+48h] [rbp-78h]
  __int64 v318; // [rsp+48h] [rbp-78h]
  __int64 v319; // [rsp+48h] [rbp-78h]
  unsigned int v320; // [rsp+48h] [rbp-78h]
  __int64 v321; // [rsp+48h] [rbp-78h]
  __int64 v322; // [rsp+48h] [rbp-78h]
  __int64 v323; // [rsp+48h] [rbp-78h]
  __int64 v324; // [rsp+48h] [rbp-78h]
  int v325; // [rsp+48h] [rbp-78h]
  __int64 v326; // [rsp+48h] [rbp-78h]
  __int64 v327; // [rsp+48h] [rbp-78h]
  __int64 v328; // [rsp+48h] [rbp-78h]
  unsigned __int64 v329; // [rsp+48h] [rbp-78h]
  __int64 v330; // [rsp+48h] [rbp-78h]
  __int64 v331; // [rsp+48h] [rbp-78h]
  __int64 v332; // [rsp+48h] [rbp-78h]
  __int64 v333; // [rsp+48h] [rbp-78h]
  __int64 v334; // [rsp+48h] [rbp-78h]
  int v335; // [rsp+48h] [rbp-78h]
  __int64 v336; // [rsp+48h] [rbp-78h]
  int v337; // [rsp+48h] [rbp-78h]
  __int64 v338; // [rsp+48h] [rbp-78h]
  __int64 v339; // [rsp+48h] [rbp-78h]
  __int64 v340; // [rsp+48h] [rbp-78h]
  __int64 v341; // [rsp+48h] [rbp-78h]
  __int64 v342; // [rsp+48h] [rbp-78h]
  __int64 v343; // [rsp+48h] [rbp-78h]
  int v344; // [rsp+54h] [rbp-6Ch]
  __int64 v345; // [rsp+58h] [rbp-68h]
  __int64 v346; // [rsp+58h] [rbp-68h]
  __int64 v347; // [rsp+68h] [rbp-58h] BYREF
  unsigned __int64 v348; // [rsp+70h] [rbp-50h] BYREF
  __int64 v349; // [rsp+78h] [rbp-48h]
  void (__fastcall *v350)(unsigned __int64 *, unsigned __int64 *, __int64); // [rsp+80h] [rbp-40h]
  void (__fastcall *v351)(unsigned __int64 *, __int64); // [rsp+88h] [rbp-38h]

  v2 = a1;
  v3 = (char *)a2;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 1);
  v4 = *(__int64 (**)(void))(**((_QWORD **)a2 + 2) + 128LL);
  v5 = 0;
  if ( v4 != sub_2DAC790 )
    v5 = v4();
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 56) = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a2 + 2) + 200LL))(*((_QWORD *)a2 + 2));
  v9 = *(__int64 (**)(void))(**((_QWORD **)a2 + 2) + 208LL);
  v10 = 0;
  if ( v9 != sub_2EEE460 )
    v10 = v9();
  *(_QWORD *)(a1 + 72) = v10;
  *(_QWORD *)(a1 + 64) = *((_QWORD *)a2 + 4);
  if ( (*((_QWORD *)a2 + 43) & 0x10) != 0 )
    return 1;
  *(_BYTE *)(a1 + 80) = (*((_QWORD *)a2 + 43) & 0x40LL) != 0;
  *(_BYTE *)(a1 + 81) = (unsigned __int8)a2[344] >> 7;
  *(_BYTE *)(a1 + 82) = (*((_QWORD *)a2 + 43) & 0x800LL) != 0;
  v11 = *(_QWORD *)(a1 + 8);
  if ( !v11 )
    goto LABEL_19;
  v12 = sub_B82360(*(_QWORD *)(v11 + 8), (__int64)&unk_501EACC);
  if ( v12 && (v13 = (*(__int64 (__fastcall **)(__int64, void *))(*(_QWORD *)v12 + 104LL))(v12, &unk_501EACC)) != 0 )
    v14 = v13 + 200;
  else
    v14 = 0;
  *(_QWORD *)(a1 + 640) = v14;
  v15 = sub_B82360(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL), (__int64)&unk_501EB14);
  if ( v15 )
  {
    v16 = (*(__int64 (__fastcall **)(__int64, void *))(*(_QWORD *)v15 + 104LL))(v15, &unk_501EB14);
    if ( *(_QWORD *)(a1 + 640) )
      goto LABEL_12;
    if ( v16 )
    {
      v237 = v16 + 200;
LABEL_416:
      *(_QWORD *)(a1 + 632) = v237;
      goto LABEL_12;
    }
LABEL_434:
    v237 = 0;
    goto LABEL_416;
  }
  if ( !*(_QWORD *)(a1 + 640) )
    goto LABEL_434;
LABEL_12:
  v17 = sub_B82360(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL), (__int64)&unk_501EB0C);
  if ( v17 && (v18 = (*(__int64 (__fastcall **)(__int64, void *))(*(_QWORD *)v17 + 104LL))(v17, &unk_501EB0C)) != 0 )
    v19 = v18 + 200;
  else
    v19 = 0;
  *(_QWORD *)(a1 + 648) = v19;
  a2 = (const char *)&unk_5025C1C;
  v20 = sub_B82360(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL), (__int64)&unk_5025C1C);
  if ( v20
    && (a2 = (const char *)&unk_5025C1C,
        (v21 = (*(__int64 (__fastcall **)(__int64, void *))(*(_QWORD *)v20 + 104LL))(v20, &unk_5025C1C)) != 0) )
  {
    v22 = v21 + 200;
  }
  else
  {
    v22 = 0;
  }
  *(_QWORD *)(a1 + 656) = v22;
LABEL_19:
  v23 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    v24 = *(unsigned int *)(v23 + 88);
    a2 = *(const char **)(v23 + 72);
    if ( !(_DWORD)v24 )
      goto LABEL_419;
    v8 = 1;
    for ( i = (v24 - 1)
            & (((0xBF58476D1CE4E5B9LL
               * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)
                | ((unsigned __int64)(((unsigned int)&unk_501EAD0 >> 9) ^ ((unsigned int)&unk_501EAD0 >> 4)) << 32))) >> 31)
             ^ (484763065 * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)))); ; i = (v24 - 1) & v26 )
    {
      v7 = (__int64)&a2[24 * i];
      if ( *(_UNKNOWN **)v7 == &unk_501EAD0 && v3 == *(char **)(v7 + 8) )
        break;
      if ( *(_QWORD *)v7 == -4096 && *(_QWORD *)(v7 + 8) == -4096 )
        goto LABEL_419;
      v26 = v8 + i;
      v8 = (unsigned int)(v8 + 1);
    }
    if ( (const char *)v7 != &a2[24 * v24] && (v233 = *(_QWORD *)(*(_QWORD *)(v7 + 16) + 24LL)) != 0 )
    {
      *(_QWORD *)(a1 + 640) = v233 + 8;
    }
    else
    {
LABEL_419:
      *(_QWORD *)(a1 + 640) = 0;
      v238 = *(unsigned int *)(v23 + 88);
      v239 = *(_QWORD *)(v23 + 72);
      if ( !(_DWORD)v238 )
        goto LABEL_436;
      a2 = (const char *)&unk_501EB18;
      v8 = 1;
      for ( j = (v238 - 1)
              & (((0xBF58476D1CE4E5B9LL
                 * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)
                  | ((unsigned __int64)(((unsigned int)&unk_501EB18 >> 9) ^ ((unsigned int)&unk_501EB18 >> 4)) << 32))) >> 31)
               ^ (484763065 * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)))); ; j = (v238 - 1) & v241 )
      {
        v7 = v239 + 24LL * j;
        if ( *(_UNKNOWN **)v7 == &unk_501EB18 && v3 == *(char **)(v7 + 8) )
          break;
        if ( *(_QWORD *)v7 == -4096 && *(_QWORD *)(v7 + 8) == -4096 )
          goto LABEL_436;
        v241 = v8 + j;
        v8 = (unsigned int)(v8 + 1);
      }
      if ( v7 == v239 + 24 * v238 )
      {
LABEL_436:
        v242 = 0;
      }
      else
      {
        v242 = *(_QWORD *)(*(_QWORD *)(v7 + 16) + 24LL);
        if ( v242 )
          v242 += 8;
      }
      *(_QWORD *)(v2 + 632) = v242;
    }
    v6 = *(_QWORD *)(v23 + 72);
    v23 = *(unsigned int *)(v23 + 88);
    if ( !(_DWORD)v23 )
      goto LABEL_425;
    a2 = (const char *)&unk_5025C20;
    v8 = (unsigned int)(v23 - 1);
    v7 = 1;
    for ( k = v8
            & (((0xBF58476D1CE4E5B9LL
               * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)
                | ((unsigned __int64)(((unsigned int)&unk_5025C20 >> 9) ^ ((unsigned int)&unk_5025C20 >> 4)) << 32))) >> 31)
             ^ (484763065 * (((unsigned int)v3 >> 9) ^ ((unsigned int)v3 >> 4)))); ; k = v8 & v236 )
    {
      v235 = v6 + 24LL * k;
      if ( *(_UNKNOWN **)v235 == &unk_5025C20 && v3 == *(char **)(v235 + 8) )
        break;
      if ( *(_QWORD *)v235 == -4096 && *(_QWORD *)(v235 + 8) == -4096 )
        goto LABEL_425;
      v236 = v7 + k;
      v7 = (unsigned int)(v7 + 1);
    }
    if ( v235 == v6 + 24 * v23 )
    {
LABEL_425:
      v27 = 0;
    }
    else
    {
      v27 = *(_QWORD *)(*(_QWORD *)(v235 + 16) + 24LL);
      v23 = v27 + 8;
      if ( v27 )
        v27 += 8;
    }
    *(_QWORD *)(v2 + 656) = v27;
  }
  if ( (v3[344] & 8) != 0 && *(_DWORD *)(*(_QWORD *)(v2 + 64) + 64LL) )
  {
    a2 = "Function has NoVRegs property but there are VReg operands";
    sub_2EEFF60(v2, "Function has NoVRegs property but there are VReg operands", (__int64 *)v3);
  }
  v28 = v2 + 272;
  sub_2EFC610(v2, (__int64)a2, v23, v6, v7, v8);
  v248 = v3 + 320;
  v294 = (char *)*((_QWORD *)v3 + 41);
  if ( v3 + 320 == v294 )
    goto LABEL_119;
  do
  {
    sub_2EFAB50(v2, (__int64)v294, v29, v30, v31, v32);
    v33 = *((_QWORD *)v294 + 7);
    v34 = 0;
    v293 = v294 + 48;
    v292 = 0;
    if ( v294 + 48 == (char *)v33 )
      goto LABEL_112;
    do
    {
      while ( *(char **)(v33 + 24) != v294 )
      {
        sub_2EF03A0(v2, "Bad instruction parent pointer", (unsigned __int64)v294);
        v35 = *(_QWORD *)(v2 + 16);
        v36 = *(void **)(v35 + 32);
        if ( *(_QWORD *)(v35 + 24) - (_QWORD)v36 <= 0xCu )
        {
          v35 = sub_CB6200(*(_QWORD *)(v2 + 16), (unsigned __int8 *)"Instruction: ", 0xDu);
        }
        else
        {
          qmemcpy(v36, "Instruction: ", 13);
          *(_QWORD *)(v35 + 32) += 13LL;
        }
        sub_2E91850(v33, v35, 1u, 0, 0, 1, 0);
        v33 = *(_QWORD *)(v33 + 8);
        if ( v293 == (_QWORD *)v33 )
          goto LABEL_109;
      }
      v37 = *(_DWORD *)(v33 + 44);
      if ( v34 )
      {
        if ( (v37 & 4) != 0 )
        {
          if ( !v292 )
            goto LABEL_291;
          goto LABEL_42;
        }
        sub_2EF06E0(v2, "Missing BundledPred flag, BundledSucc was set on predecessor", v33);
      }
      else
      {
        if ( (v37 & 4) == 0 )
          goto LABEL_206;
        sub_2EF06E0(v2, "BundledPred flag is set, but BundledSucc not set on predecessor", v33);
      }
      v37 = *(_DWORD *)(v33 + 44);
      if ( (v37 & 4) == 0 )
      {
LABEL_206:
        if ( v292 )
        {
          sub_2EF99C0(v2, *(_QWORD *)(v292 + 24));
          v121 = *(_QWORD *)(v2 + 656);
          v37 = *(_DWORD *)(v33 + 44);
          if ( v121 )
          {
LABEL_208:
            v122 = *(_DWORD *)(v121 + 144);
            v123 = *(_QWORD *)(v121 + 128);
            if ( v122 )
            {
              v124 = v122 - 1;
              v125 = (v122 - 1) & (((unsigned int)v33 >> 9) ^ ((unsigned int)v33 >> 4));
              v126 = *(_QWORD *)(v123 + 16LL * v125);
              if ( v126 == v33 )
              {
LABEL_210:
                v127 = v33;
                v128 = v33;
                if ( (v37 & 4) != 0 )
                {
                  do
                    v128 = *(_QWORD *)v128 & 0xFFFFFFFFFFFFFFF8LL;
                  while ( (*(_BYTE *)(v128 + 44) & 4) != 0 );
                }
                if ( (v37 & 8) != 0 )
                {
                  do
                    v127 = *(_QWORD *)(v127 + 8);
                  while ( (*(_BYTE *)(v127 + 44) & 8) != 0 );
                }
                for ( m = *(_QWORD *)(v127 + 8); m != v128; v128 = *(_QWORD *)(v128 + 8) )
                {
                  v130 = *(_WORD *)(v128 + 68);
                  if ( (unsigned __int16)(v130 - 14) > 4u && v130 != 24 )
                    break;
                }
                v131 = v124 & (((unsigned int)v128 >> 9) ^ ((unsigned int)v128 >> 4));
                v132 = (__int64 *)(v123 + 16LL * v131);
                v133 = *v132;
                if ( *v132 != v128 )
                {
                  v230 = 1;
                  while ( v133 != -4096 )
                  {
                    v245 = v230 + 1;
                    v131 = v124 & (v230 + v131);
                    v132 = (__int64 *)(v123 + 16LL * v131);
                    v133 = *v132;
                    if ( v128 == *v132 )
                      goto LABEL_219;
                    v230 = v245;
                  }
                  v132 = (__int64 *)(v123 + 16LL * v122);
                }
LABEL_219:
                v134 = v132[1];
                if ( (*(_DWORD *)((v134 & 0xFFFFFFFFFFFFFFF8LL) + 24) | (unsigned int)(v134 >> 1) & 3) <= (*(_DWORD *)((*(_QWORD *)(v2 + 592) & 0xFFFFFFFFFFFFFFF8LL) + 24) | (unsigned int)(*(__int64 *)(v2 + 592) >> 1) & 3) )
                {
                  sub_2EF06E0(v2, "Instruction index out of order", v33);
                  v215 = *(_QWORD *)(v2 + 16);
                  v216 = *(__m128i **)(v215 + 32);
                  if ( *(_QWORD *)(v215 + 24) - (_QWORD)v216 <= 0x17u )
                  {
                    v215 = sub_CB6200(*(_QWORD *)(v2 + 16), "Last instruction was at ", 0x18u);
                  }
                  else
                  {
                    si128 = _mm_load_si128((const __m128i *)&xmmword_4453ED0);
                    v216[1].m128i_i64[0] = 0x2074612073617720LL;
                    *v216 = si128;
                    *(_QWORD *)(v215 + 32) += 24LL;
                  }
                  v348 = *(_QWORD *)(v2 + 592);
                  sub_2FAD600(&v348, v215);
                  v228 = *(_BYTE **)(v215 + 32);
                  if ( (unsigned __int64)v228 >= *(_QWORD *)(v215 + 24) )
                  {
                    sub_CB5D20(v215, 10);
                  }
                  else
                  {
                    *(_QWORD *)(v215 + 32) = v228 + 1;
                    *v228 = 10;
                  }
                }
                *(_QWORD *)(v2 + 592) = v134;
                v37 = *(_DWORD *)(v33 + 44);
              }
              else
              {
                v229 = 1;
                while ( v126 != -4096 )
                {
                  v125 = v124 & (v229 + v125);
                  v126 = *(_QWORD *)(v123 + 16LL * v125);
                  if ( v126 == v33 )
                    goto LABEL_210;
                  ++v229;
                }
              }
            }
          }
          v135 = v37;
          if ( (v37 & 4) != 0 )
          {
LABEL_222:
            v136 = (*(_QWORD *)(*(_QWORD *)(v33 + 16) + 24LL) >> 9) & 1LL;
            goto LABEL_223;
          }
        }
        else
        {
          v121 = *(_QWORD *)(v2 + 656);
          if ( v121 )
            goto LABEL_208;
          v135 = v37;
        }
        if ( (v135 & 8) == 0 )
          goto LABEL_222;
        LOBYTE(v136) = sub_2E88A90(v33, 512, 1);
LABEL_223:
        v292 = v33;
        v137 = *(_QWORD *)(v2 + 96);
        if ( (_BYTE)v136 )
        {
          if ( !v137 )
            *(_QWORD *)(v2 + 96) = v33;
        }
        else if ( v137 && *(_WORD *)(v137 + 68) != 126 )
        {
          sub_2EF06E0(v2, "Non-terminator instruction after the first terminator", v33);
          v166 = *(_QWORD *)(v2 + 16);
          v167 = *(__m128i **)(v166 + 32);
          if ( *(_QWORD *)(v166 + 24) - (_QWORD)v167 <= 0x15u )
          {
            v166 = sub_CB6200(*(_QWORD *)(v2 + 16), "First terminator was:\t", 0x16u);
          }
          else
          {
            v168 = _mm_load_si128((const __m128i *)&xmmword_4453EE0);
            v167[1].m128i_i32[0] = 1935767328;
            v167[1].m128i_i16[2] = 2362;
            *v167 = v168;
            *(_QWORD *)(v166 + 32) += 22LL;
          }
          sub_2E91850(*(_QWORD *)(v2 + 96), v166, 1u, 0, 0, 1, 0);
          v292 = v33;
        }
        goto LABEL_42;
      }
      if ( !v292 )
LABEL_291:
        sub_2EF06E0(v2, "No bundle header", v33);
LABEL_42:
      sub_2EF7830((__int64 *)v2, v33);
      v344 = *(_DWORD *)(v33 + 40) & 0xFFFFFF;
      if ( !v344 )
        goto LABEL_108;
      v39 = 0;
      v345 = v33;
      v40 = v2;
      do
      {
        while ( 2 )
        {
          v52 = *(_QWORD *)(v345 + 32) + 40 * v39;
          v53 = v345;
          if ( *(_QWORD *)(v52 + 16) != v345 )
          {
            v307 = v40;
            sub_2EF06E0(v40, "Instruction has operand with wrong parent set", v345);
            v53 = *(_QWORD *)(v52 + 16);
            v40 = v307;
          }
          v54 = *(unsigned __int16 **)(v53 + 16);
          v55 = *(_BYTE *)v52;
          v56 = *v54;
          v41 = *((unsigned __int8 *)v54 + 4);
          if ( (_WORD)v56 == 28 )
          {
            if ( !v39 && !v55 && *((_BYTE *)v54 + 4) )
            {
              v42 = (__int64)&v54[3 * v54[8] + 580];
LABEL_47:
              if ( (*(_BYTE *)(v52 + 3) & 0x10) != 0 || (*(_BYTE *)(v42 + 2) & 4) != 0 )
              {
                if ( (*(_BYTE *)(v52 + 3) & 0x20) == 0 )
                  goto LABEL_50;
                LODWORD(v41) = v39;
                v64 = "Explicit definition marked as implicit";
                v65 = v52;
              }
              else
              {
                LODWORD(v41) = v39;
                v64 = "Explicit definition marked as use";
                v65 = v52;
              }
              goto LABEL_103;
            }
          }
          else if ( (unsigned int)v41 > (unsigned int)v39 )
          {
            v41 = v54[8];
            if ( v55 )
            {
              LODWORD(v41) = v39;
              v64 = "Explicit definition must be a register";
              v65 = v52;
              goto LABEL_103;
            }
            v42 = (__int64)&v54[20 * v56 + 20 + 3 * v39 + 3 * (unsigned __int16)v41];
            goto LABEL_47;
          }
          v38 = *((_QWORD *)v54 + 3);
          v57 = v54[1];
          v41 = (v38 >> 1) & 1;
          if ( v57 > (unsigned int)v39 )
          {
            v58 = v54[8];
            v59 = 6 * v39;
            v60 = &v54[20 * v56 + 20 + 3 * v39 + 3 * v58];
            if ( (v38 & 2) != 0 && v57 - 1 == (_DWORD)v39 )
              goto LABEL_99;
            if ( v55 )
            {
              if ( *((_BYTE *)v60 + 3) != 2 )
                goto LABEL_99;
            }
            else
            {
              v61 = *(_BYTE *)(v52 + 3);
              if ( (v61 & 0x10) != 0 && (v60[1] & 4) == 0 && (v38 & 0x8000000000LL) == 0 )
              {
                v283 = &v54[20 * v56 + 20 + 3 * v39 + 3 * v58];
                v333 = v40;
                sub_2EF0A60(v40, "Explicit operand marked as def", v52, v39, 0);
                v61 = *(_BYTE *)(v52 + 3);
                v59 = 6 * v39;
                v60 = v283;
                v40 = v333;
              }
              if ( (v61 & 0x20) != 0 )
              {
                v262 = v59;
                v277 = v60;
                v322 = v40;
                sub_2EF0A60(v40, "Explicit operand marked as implicit", v52, v39, 0);
                v59 = v262;
                v60 = v277;
                v40 = v322;
              }
              if ( *((_BYTE *)v60 + 3) != 2 )
              {
                v55 = *(_BYTE *)v52;
                if ( !*(_BYTE *)v52 )
                  goto LABEL_95;
LABEL_300:
                if ( v54[1] <= (unsigned int)v39 )
                  goto LABEL_104;
LABEL_98:
                v58 = v54[8];
LABEL_99:
                v41 = 5LL * *v54 + 5;
                v63 = *(unsigned __int16 *)((char *)&v54[4 * v41 + 2 + 3 * v58] + v59);
                if ( (v63 & 1) != 0 )
                {
                  if ( v55 )
                  {
                    LODWORD(v41) = v39;
                    v64 = "Tied use must be a register";
                    v65 = v52;
                  }
                  else
                  {
                    if ( (*(_WORD *)(v52 + 2) & 0xFF0) == 0 )
                    {
                      LODWORD(v41) = v39;
                      v64 = "Operand should be tied";
                      v65 = v52;
                      goto LABEL_103;
                    }
                    v272 = v40;
                    v314 = (unsigned __int8)(v63 >> 4);
                    v138 = sub_2E89F40(v53, v39);
                    v40 = v272;
                    v41 = v138;
                    if ( v138 == v314 )
                    {
                      v169 = *(_DWORD *)(v52 + 8);
                      if ( (unsigned int)(v169 - 1) <= 0x3FFFFFFE )
                      {
                        v65 = *(_QWORD *)(v53 + 32) + 40LL * v314;
                        if ( *(_BYTE *)v65 )
                        {
                          v64 = "Tied counterpart must be a register";
                          goto LABEL_103;
                        }
                        v170 = *(_DWORD *)(v65 + 8);
                        if ( (unsigned int)(v170 - 1) <= 0x3FFFFFFE && v169 != v170 )
                        {
                          v64 = "Tied physical registers must match.";
                          goto LABEL_103;
                        }
                      }
                      v55 = *(_BYTE *)v52;
                      goto LABEL_104;
                    }
                    LODWORD(v41) = v39;
                    v64 = "Tied def doesn't match MCInstrDesc";
                    v65 = v52;
                  }
LABEL_103:
                  v308 = v40;
                  sub_2EF0A60(v40, v64, v65, v41, 0);
                  v55 = *(_BYTE *)v52;
                  v40 = v308;
                  goto LABEL_104;
                }
LABEL_197:
                if ( v55 )
                  goto LABEL_104;
LABEL_198:
                if ( (*(_WORD *)(v52 + 2) & 0xFF0) == 0 )
                  goto LABEL_50;
                LODWORD(v41) = v39;
                v64 = "Explicit operand should not be tied";
                v65 = v52;
                goto LABEL_103;
              }
              v55 = *(_BYTE *)v52;
            }
            if ( v55 != 5 && v55 )
            {
              v263 = v59;
              v280 = v60;
              v327 = v40;
              sub_2EF0A60(v40, "Expected a register operand.", v52, v39, 0);
              v55 = *(_BYTE *)v52;
              v59 = v263;
              v60 = v280;
              v40 = v327;
              if ( *(_BYTE *)v52 )
                goto LABEL_300;
LABEL_95:
              v62 = *((_BYTE *)v60 + 3);
              if ( v62 == 1 )
                goto LABEL_243;
              if ( v62 != 4 )
              {
                if ( (unsigned int)v39 < v54[1] )
                  goto LABEL_98;
                goto LABEL_198;
              }
              v155 = *(_QWORD *)(v40 + 48);
              v156 = *(__int64 (**)())(*(_QWORD *)v155 + 504LL);
              if ( v156 == sub_2EEE470
                || (v278 = v40,
                    v323 = v59,
                    v171 = ((__int64 (__fastcall *)(__int64, __int64))v156)(v155, v52),
                    v59 = v323,
                    v40 = v278,
                    !v171) )
              {
LABEL_243:
                v274 = v59;
                v319 = v40;
                sub_2EF0A60(v40, "Expected a non-register operand.", v52, v39, 0);
                v55 = *(_BYTE *)v52;
                v120 = v54[1];
                v59 = v274;
                v40 = v319;
              }
              else
              {
                v55 = *(_BYTE *)v52;
                v120 = v54[1];
              }
            }
            else
            {
              v120 = v54[1];
            }
            if ( v120 > (unsigned int)v39 )
              goto LABEL_98;
            goto LABEL_197;
          }
          if ( (v38 & 2) != 0 )
            goto LABEL_104;
          if ( v55 )
          {
            if ( v55 == 12 )
            {
LABEL_142:
              v90 = *(unsigned int *)(v40 + 552);
              v91 = *(_QWORD *)(v52 + 24);
              if ( v90 + 1 > (unsigned __int64)*(unsigned int *)(v40 + 556) )
              {
                v328 = v40;
                sub_C8D5F0(v40 + 544, (const void *)(v40 + 560), v90 + 1, 8u, v38, v40);
                v40 = v328;
                v90 = *(unsigned int *)(v328 + 552);
              }
              *(_QWORD *)(*(_QWORD *)(v40 + 544) + 8 * v90) = v91;
              ++*(_DWORD *)(v40 + 552);
              goto LABEL_75;
            }
            if ( (unsigned __int8)(v55 - 14) > 1u )
            {
LABEL_188:
              LODWORD(v41) = v39;
              v64 = "Extra explicit operand on non-variadic instruction";
              v65 = v52;
              goto LABEL_103;
            }
LABEL_104:
            switch ( v55 )
            {
              case 0:
                goto LABEL_50;
              case 4:
                if ( !*(_WORD *)(v53 + 68) || *(_WORD *)(v53 + 68) == 68 )
                {
                  v312 = v40;
                  v119 = sub_2E322C0(*(_QWORD *)(v52 + 24), *(_QWORD *)(v53 + 24));
                  v40 = v312;
                  if ( !v119 )
                  {
                    sub_2EF0A60(v312, "PHI operand is not in the CFG", v52, v39, 0);
                    v40 = v312;
                  }
                }
                goto LABEL_75;
              case 5:
                v92 = *(_QWORD *)(v40 + 648);
                if ( !v92 )
                  goto LABEL_75;
                v93 = *(_QWORD *)(v92 + 112);
                v94 = *(_DWORD *)(v52 + 24);
                v95 = *(__int64 **)(*(_QWORD *)(v92 + 104) + 8 * (v94 % v93));
                v96 = v94 % v93;
                v310 = v95;
                if ( !v95 )
                  goto LABEL_75;
                v97 = (__int64 *)*v95;
                if ( !*v95 )
                  goto LABEL_75;
                v38 = 0;
                v98 = (__int64 *)*v95;
                v99 = *((_DWORD *)v97 + 2);
                break;
              case 12:
                goto LABEL_142;
              case 16:
                if ( *(unsigned int *)(v52 + 24) < (unsigned __int64)(0x4EC4EC4EC4EC4EC5LL
                                                                    * ((__int64)(*(_QWORD *)(*(_QWORD *)(v40 + 32)
                                                                                           + 368LL)
                                                                               - *(_QWORD *)(*(_QWORD *)(v40 + 32)
                                                                                           + 360LL)) >> 3)) )
                  goto LABEL_75;
                v66 = v39;
                v309 = v40;
                ++v39;
                sub_2EF0A60(v40, "CFI instruction has invalid index", v52, v66, 0);
                v40 = v309;
                if ( v344 == (_DWORD)v39 )
                  goto LABEL_107;
                continue;
              default:
                goto LABEL_75;
            }
            while ( 1 )
            {
              if ( v99 == v94 )
              {
                v98 = (__int64 *)*v98;
                ++v38;
                if ( !v98 )
                  goto LABEL_154;
              }
              else
              {
                if ( v38 )
                  goto LABEL_155;
                v98 = (__int64 *)*v98;
                if ( !v98 )
                {
LABEL_154:
                  if ( !v38 )
                    goto LABEL_75;
LABEL_155:
                  v100 = *(_QWORD *)(v40 + 640);
                  if ( v100 )
                  {
                    v38 = *(_QWORD *)(v100 + 32);
                    v101 = *(_DWORD *)(v38 + 144);
                    v102 = *(_QWORD *)(v38 + 128);
                    if ( v101 )
                    {
                      v103 = v101 - 1;
                      v104 = (v101 - 1) & (((unsigned int)v53 >> 9) ^ ((unsigned int)v53 >> 4));
                      v105 = *(_QWORD *)(v102 + 16LL * v104);
                      if ( v105 == v53 )
                      {
LABEL_158:
                        if ( v94 == *((_DWORD *)v97 + 2) )
                        {
LABEL_162:
                          v311 = *v310;
                        }
                        else
                        {
                          while ( *v97 )
                          {
                            v310 = v97;
                            v106 = *(int *)(*v97 + 8);
                            if ( v96 != v106 % v93 )
                            {
                              v311 = 0;
                              goto LABEL_163;
                            }
                            v97 = (__int64 *)*v97;
                            if ( v94 == (_DWORD)v106 )
                              goto LABEL_162;
                          }
                          v311 = 0;
                        }
LABEL_163:
                        v268 = v40;
                        v297 = (__int64 *)(v311 + 16);
                        v107 = sub_2DF8360(v38, v53, 0);
                        v40 = v268;
                        v258 = v107;
                        v108 = *(unsigned __int16 *)(v53 + 68) - 1;
                        if ( v108 <= 1 && (v109 = *(_QWORD *)(*(_QWORD *)(v53 + 32) + 64LL), (v109 & 0x10) != 0) )
                        {
                          v111 = 1;
                          if ( (v109 & 8) == 0 )
                            goto LABEL_169;
LABEL_338:
                          v286 = v40;
                          v204 = sub_2E864A0(v53);
                          v40 = v286;
                          v206 = (__int64 **)(v204 + 8 * v205);
                          v207 = (__int64 **)v204;
                          if ( (__int64 **)v204 == v206 )
                          {
LABEL_358:
                            sub_2EF06E0(v286, "Missing fixed stack memoperand.", v53);
                            v40 = v286;
                            v111 = 1;
                            goto LABEL_174;
                          }
                          while ( 1 )
                          {
                            v208 = **v207;
                            if ( v208 )
                            {
                              if ( (v208 & 4) != 0 )
                              {
                                v209 = v208 & 0xFFFFFFFFFFFFFFF8LL;
                                if ( v209 )
                                {
                                  if ( *(_DWORD *)(v209 + 8) == 4 && v94 == *(_DWORD *)(v209 + 16) )
                                    break;
                                }
                              }
                            }
                            if ( v206 == ++v207 )
                              goto LABEL_358;
                          }
                          if ( ((*v207)[4] & 2) == 0 )
                          {
                            v111 = 0;
                            goto LABEL_174;
                          }
LABEL_178:
                          v271 = v40;
                          v117 = (__int64 *)sub_2E09D00(v297, v258 & 0xFFFFFFFFFFFFFFF8LL | 4);
                          v40 = v271;
                          if ( v117 == (__int64 *)(*(_QWORD *)(v311 + 16) + 24LL * *(unsigned int *)(v311 + 24))
                            || (*(_DWORD *)((*v117 & 0xFFFFFFFFFFFFFFF8LL) + 24) | (unsigned int)(*v117 >> 1) & 3) > (*(_DWORD *)((v258 & 0xFFFFFFFFFFFFFFF8LL) + 24) | 2u) )
                          {
                            sub_2EF0A60(v271, "Instruction stores to dead spill slot", v52, v39, 0);
                            v118 = sub_904010(*(_QWORD *)(v271 + 16), "Live stack: ");
                            sub_2E0B730((__int64)v297, v118);
                            sub_A51310(v118, 0xAu);
                            v40 = v271;
                          }
                        }
                        else
                        {
                          v110 = *(_DWORD *)(v53 + 44);
                          if ( (v110 & 4) == 0 && (v110 & 8) != 0 )
                          {
                            v226 = sub_2E88A90(v53, 0x100000, 1);
                            v40 = v268;
                            v111 = v226;
                            v108 = *(unsigned __int16 *)(v53 + 68) - 1;
                          }
                          else
                          {
                            v111 = (*(_QWORD *)(*(_QWORD *)(v53 + 16) + 24LL) & 0x100000LL) != 0;
                          }
                          if ( v108 <= 1 && (*(_BYTE *)(*(_QWORD *)(v53 + 32) + 64LL) & 8) != 0 )
                          {
                            if ( v111 )
                              goto LABEL_338;
LABEL_174:
                            v249 = v40;
                            v269 = v111;
                            v114 = (__int64 *)sub_2E09D00(v297, v258 & 0xFFFFFFFFFFFFFFF8LL | 2);
                            v111 = v269;
                            v40 = v249;
                            if ( v114 == (__int64 *)(*(_QWORD *)(v311 + 16) + 24LL * *(unsigned int *)(v311 + 24))
                              || (*(_DWORD *)((*v114 & 0xFFFFFFFFFFFFFFF8LL) + 24) | (unsigned int)(*v114 >> 1) & 3) > (*(_DWORD *)((v258 & 0xFFFFFFFFFFFFFFF8LL) + 24) | 1u) )
                            {
                              v115 = v249;
                              v250 = v269;
                              v270 = v40;
                              sub_2EF0A60(v115, "Instruction loads from dead spill slot", v52, v39, 0);
                              v116 = sub_904010(*(_QWORD *)(v270 + 16), "Live stack: ");
                              sub_2E0B730((__int64)v297, v116);
                              sub_A51310(v116, 0xAu);
                              v40 = v270;
                              v111 = v250;
                            }
                            goto LABEL_177;
                          }
LABEL_169:
                          v112 = *(_DWORD *)(v53 + 44);
                          if ( (v112 & 4) == 0 && (v112 & 8) != 0 )
                          {
                            v257 = v40;
                            v288 = v111;
                            LOBYTE(v113) = sub_2E88A90(v53, 0x80000, 1);
                            v111 = v288;
                            v40 = v257;
                          }
                          else
                          {
                            v113 = (*(_QWORD *)(*(_QWORD *)(v53 + 16) + 24LL) >> 19) & 1LL;
                          }
                          if ( (_BYTE)v113 )
                          {
                            if ( v111 )
                              goto LABEL_338;
                            goto LABEL_174;
                          }
LABEL_177:
                          if ( v111 )
                            goto LABEL_178;
                        }
                      }
                      else
                      {
                        v290 = 1;
                        while ( v105 != -4096 )
                        {
                          v104 = v103 & (v290 + v104);
                          v105 = *(_QWORD *)(v102 + 16LL * v104);
                          if ( v105 == v53 )
                            goto LABEL_158;
                          ++v290;
                        }
                      }
                    }
                  }
                  goto LABEL_75;
                }
              }
              v99 = *((_DWORD *)v98 + 2);
              if ( v96 != v99 % v93 )
                goto LABEL_154;
            }
          }
          break;
        }
        if ( (*(_BYTE *)(v52 + 3) & 0x20) == 0 )
          goto LABEL_188;
LABEL_50:
        v43 = *(_BYTE *)(v52 + 4) & 8;
        if ( (unsigned __int16)(*(_WORD *)(v53 + 68) - 14) > 4u || (*(_BYTE *)(v52 + 3) & 0x10) != 0 )
        {
          if ( v43 )
          {
            v313 = v40;
            sub_2EF0A60(v40, "Register operand must not be marked debug", v52, v39, 0);
            v40 = v313;
          }
        }
        else if ( !v43 )
        {
          v331 = v40;
          sub_2EF0A60(v40, "Register operand must be marked debug", v52, v39, 0);
          v40 = v331;
        }
        v44 = *(_DWORD *)(v52 + 8);
        if ( !v44 )
          goto LABEL_75;
        if ( (*(_BYTE *)(**(_QWORD **)(v40 + 64) + 344LL) & 4) != 0
          && (unsigned __int16)(*(_WORD *)(v53 + 68) - 14) > 4u )
        {
          v279 = *(_DWORD *)(v52 + 8);
          v324 = v40;
          sub_2EFDF10(v40, v52, v39, v41, v38, v40);
          v44 = v279;
          v40 = v324;
        }
        if ( (*(_BYTE *)(v52 + 3) & 0x10) != 0
          && (*(_BYTE *)(v52 + 4) & 1) != 0
          && (*(_DWORD *)v52 & 0xFFF00) == 0
          && *(int *)(v52 + 8) < 0 )
        {
          v289 = v44;
          v339 = v40;
          sub_2EF0A60(v40, "Undef virtual register def operands require a subregister", v52, v39, 0);
          v44 = v289;
          v40 = v339;
        }
        if ( (*(_WORD *)(v52 + 2) & 0xFF0) != 0 )
        {
          v251 = v40;
          v259 = v44;
          v158 = sub_2E89F40(v53, v39);
          v159 = v259;
          v160 = v251;
          v320 = v158;
          v247 = v158;
          v275 = *(_QWORD *)(v53 + 32) + 40LL * v158;
          if ( *(_BYTE *)v275 )
          {
            v194 = v251;
            v256 = v259;
            v266 = v160;
            sub_2EF0A60(v194, "Must be tied to a register", v52, v39, 0);
            v159 = v256;
            v160 = v266;
          }
          if ( (*(_WORD *)(v275 + 2) & 0xFF0) == 0 )
          {
            v255 = v159;
            v265 = v160;
            sub_2EF0A60(v160, "Missing tie flags on tied operand", v52, v39, 0);
            v159 = v255;
            v160 = v265;
          }
          v252 = v160;
          v260 = v159;
          v161 = sub_2E89F40(v53, v320);
          v44 = v260;
          v40 = v252;
          if ( v161 != (_DWORD)v39 )
          {
            v162 = v252;
            v253 = v260;
            v261 = v40;
            sub_2EF0A60(v162, "Inconsistent tie links", v52, v39, 0);
            v44 = v253;
            v40 = v261;
          }
          if ( *((unsigned __int8 *)v54 + 4) > (unsigned int)v39 )
          {
            if ( v320 < v54[1] )
            {
              if ( (v54[20 * *v54 + 22 + 3 * v54[8] + 3 * v247] & 1) == 0 )
              {
                v284 = v44;
                v334 = v40;
                sub_2EF0A60(v40, "Explicit def tied to explicit use without tie constraint", v52, v39, 0);
                v40 = v334;
                v44 = v284;
              }
            }
            else if ( (*(_BYTE *)(v275 + 3) & 0x20) == 0 )
            {
              v276 = v44;
              v321 = v40;
              sub_2EF0A60(v40, "Explicit def should be tied to implicit use", v52, v39, 0);
              v44 = v276;
              v40 = v321;
            }
          }
        }
        if ( (*(_BYTE *)(*(_QWORD *)(v40 + 32) + 345LL) & 1) != 0 && (*(_BYTE *)(v52 + 3) & 0x10) == 0 )
        {
          v172 = *(_QWORD *)(v53 + 32) + 40 * v39;
          if ( !*(_BYTE *)v172 && (*(_BYTE *)(v172 + 3) & 0x10) == 0 && (*(_WORD *)(v172 + 2) & 0xFF0) != 0 )
          {
            v299 = v40;
            v325 = v44;
            v173 = sub_2E89F40(v53, v39);
            v44 = v325;
            v40 = v299;
            if ( v325 != *(_DWORD *)(*(_QWORD *)(v53 + 32) + 40LL * v173 + 8) )
            {
              v174 = v299;
              v300 = v325;
              v326 = v40;
              sub_2EF0A60(v174, "Two-address instruction operands must be identical", v52, v39, 0);
              v44 = v300;
              v40 = v326;
            }
          }
        }
        v45 = (*(_DWORD *)v52 >> 8) & 0xFFF;
        if ( (unsigned int)(v44 - 1) <= 0x3FFFFFFE )
        {
          if ( v45 )
          {
            v332 = v40;
            sub_2EF0A60(v40, "Illegal subregister index for physical register", v52, v39, 0);
            v40 = v332;
          }
          else
          {
            if ( v54[1] > (unsigned int)v39 )
            {
              v295 = v44;
              v305 = v40;
              v46 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v40 + 48) + 16LL))(
                                *(_QWORD *)(v40 + 48),
                                v54,
                                (unsigned int)v39,
                                *(_QWORD *)(v40 + 56),
                                *(_QWORD *)(v40 + 32));
              v40 = v305;
              v44 = v295;
              v47 = v46;
              if ( v46 )
              {
                v48 = *v46;
                v49 = v295 >> 3;
                if ( (unsigned int)v49 >= *(unsigned __int16 *)(v48 + 22)
                  || (v50 = *(unsigned __int8 *)(*(_QWORD *)(v48 + 8) + v49), !_bittest(&v50, v295 & 7)) )
                {
                  sub_2EF0A60(v305, "Illegal physical register for instruction", v52, v39, 0);
                  v200 = *(_QWORD *)(v305 + 16);
                  sub_2FF6320(&v348, v295, *(_QWORD *)(v305 + 56), 0, 0);
                  if ( !v350 )
                    sub_4263D6(&v348, v295, v201);
                  v351(&v348, v200);
                  v202 = sub_904010(v200, " is not a ");
                  v203 = sub_904010(
                           v202,
                           (const char *)(*(_QWORD *)(*(_QWORD *)(v305 + 56) + 80LL) + *(unsigned int *)(*v47 + 16LL)));
                  sub_904010(v203, " register.\n");
                  v40 = v305;
                  v44 = v295;
                  if ( v350 )
                  {
                    v303 = v305;
                    v335 = v44;
                    v350(&v348, &v348, 3);
                    v40 = v303;
                    v44 = v335;
                  }
                }
              }
            }
            v306 = v40;
            v296 = v44;
            v51 = sub_2EAB300(v52);
            v40 = v306;
            if ( v51
              && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v306 + 64) + 384LL) + 8LL * (v296 >> 6)) & (1LL << v296)) != 0 )
            {
              sub_2EF0A60(v306, "isRenamable set on reserved register", v52, v39, 0);
              v40 = v306;
            }
          }
          goto LABEL_75;
        }
        v315 = 16LL * (v44 & 0x7FFFFFFF);
        v139 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v40 + 64) + 56LL) + v315);
        if ( !v139 || (v139 & 4) != 0 || (v298 = v139 & 0xFFFFFFFFFFFFFFF8LL, (v139 & 0xFFFFFFFFFFFFFFF8LL) == 0) )
        {
          if ( (*(_BYTE *)(v52 + 4) & 1) != 0 )
          {
            v267 = (*(_DWORD *)v52 >> 8) & 0xFFF;
            v285 = v44;
            v302 = v40;
            sub_2EF0A60(v40, "Generic virtual register use cannot be undef", v52, v39, 0);
            v45 = v267;
            v44 = v285;
            v40 = v302;
          }
          if ( !*(_BYTE *)(v40 + 82)
            && (*(_BYTE *)(v52 + 3) & 0x10) == 0
            && (unsigned __int16)(*(_WORD *)(v53 + 68) - 14) <= 1u )
          {
            v175 = *(_QWORD *)(v40 + 64);
            v176 = v44 < 0
                 ? *(_QWORD *)(*(_QWORD *)(v175 + 56) + v315 + 8)
                 : *(_QWORD *)(*(_QWORD *)(v175 + 304) + 8LL * (unsigned int)v44);
            if ( !v176 )
              goto LABEL_349;
            if ( (*(_BYTE *)(v176 + 3) & 0x10) == 0 )
            {
              v177 = *(_QWORD *)(v176 + 32);
              if ( !v177 || (*(_BYTE *)(v177 + 3) & 0x10) == 0 )
                goto LABEL_349;
            }
          }
          if ( *(_BYTE *)(v40 + 81) )
          {
            v340 = v40;
            sub_2EF0A60(v40, "Generic virtual register invalid in a Selected function", v52, v39, 0);
            v40 = v340;
            goto LABEL_75;
          }
          v178 = *(_QWORD *)(v40 + 64);
          v281 = v45;
          v301 = v40;
          v179 = sub_2E865D0(v178, v44);
          v40 = v301;
          v45 = v281;
          v347 = v179;
          if ( (v179 & 0xFFFFFFFFFFFFFFF9LL) == 0 )
          {
            sub_2EF0A60(v301, "Generic virtual register must have a valid type", v52, v39, 0);
            v40 = v301;
            goto LABEL_75;
          }
          v180 = *(_QWORD *)(*(_QWORD *)(v178 + 56) + v315);
          v181 = *(__int64 (**)())(**(_QWORD **)(*(_QWORD *)(v301 + 32) + 16LL) + 208LL);
          if ( v180 && (v180 & 4) != 0 )
          {
            v182 = v180 & 0xFFFFFFFFFFFFFFF8LL;
            if ( v181 == sub_2EEE460 )
            {
              v183 = 0;
              if ( v182 )
                goto LABEL_319;
              goto LABEL_348;
            }
            v246 = v181();
            v45 = v281;
            v40 = v301;
            v183 = v246;
            if ( v182 )
            {
              if ( (v347 & 0xFFFFFFFFFFFFFFF9LL) != 0 )
              {
LABEL_319:
                if ( (v347 & 4) == 0 || (v347 & 8) == 0 )
                {
                  v254 = v40;
                  v264 = v45;
                  v282 = v183;
                  v329 = *(unsigned int *)(*(_QWORD *)(v183 + 24)
                                         + 4LL
                                         * (unsigned int)(*(_DWORD *)v182
                                                        + *(_DWORD *)(v183 + 16) * *(_DWORD *)(v183 + 32)));
                  v348 = sub_2EF2A30((unsigned __int64 *)&v347);
                  v349 = v184;
                  v185 = sub_CA1930(&v348);
                  v45 = v264;
                  v40 = v254;
                  if ( v329 < v185 )
                  {
                    sub_2EF0A60(v254, "Register bank is too small for virtual register", v52, v39, 0);
                    v186 = sub_904010(*(_QWORD *)(v254 + 16), "Register bank ");
                    v187 = sub_904010(v186, *(const char **)(v182 + 8));
                    v188 = sub_904010(v187, " too small(");
                    v189 = sub_CB59D0(
                             v188,
                             *(unsigned int *)(*(_QWORD *)(v282 + 24)
                                             + 4LL
                                             * (unsigned int)(*(_DWORD *)v182
                                                            + *(_DWORD *)(v282 + 16) * *(_DWORD *)(v282 + 32))));
                    v190 = sub_904010(v189, ") to fit ");
                    v191 = sub_2EF2A30((unsigned __int64 *)&v347);
                    v192 = v254;
                    v349 = v193;
                    v348 = v191;
                    if ( (_BYTE)v193 )
                    {
                      v244 = *(_QWORD *)(v190 + 32);
                      if ( (unsigned __int64)(*(_QWORD *)(v190 + 24) - v244) <= 8 )
                      {
                        sub_CB6200(v190, "vscale x ", 9u);
                        v192 = v254;
                      }
                      else
                      {
                        *(_BYTE *)(v244 + 8) = 32;
                        *(_QWORD *)v244 = 0x7820656C61637376LL;
                        *(_QWORD *)(v190 + 32) += 9LL;
                      }
                    }
                    v330 = v192;
                    sub_CB59D0(v190, v348);
                    sub_904010(v190, "-bits\n");
                    v40 = v330;
                    goto LABEL_75;
                  }
                }
              }
LABEL_349:
              if ( v45 )
              {
                v341 = v40;
                sub_2EF0A60(v40, "Generic virtual register does not allow subregister index", v52, v39, 0);
                v40 = v341;
              }
              else if ( (unsigned int)*v54 - 53 > 0xFC && v54[1] > (unsigned int)v39 )
              {
                v336 = v40;
                v210 = (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v40 + 48) + 16LL))(
                         *(_QWORD *)(v40 + 48),
                         v54,
                         (unsigned int)v39,
                         *(_QWORD *)(v40 + 56),
                         *(_QWORD *)(v40 + 32));
                v40 = v336;
                if ( v210 )
                {
                  sub_2EF0A60(v336, "Virtual register does not match instruction constraint", v52, v39, 0);
                  v211 = sub_904010(*(_QWORD *)(v336 + 16), "Expect register class ");
                  v212 = *(_QWORD *)(v336 + 56);
                  v213 = (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, _QWORD, __int64, _QWORD))(**(_QWORD **)(v336 + 48) + 16LL))(
                           *(_QWORD *)(v336 + 48),
                           v54,
                           (unsigned int)v39,
                           v212,
                           *(_QWORD *)(v336 + 32));
                  v214 = sub_904010(
                           v211,
                           (const char *)(*(_QWORD *)(v212 + 80) + *(unsigned int *)(*(_QWORD *)v213 + 16LL)));
                  sub_904010(v214, " but got nothing\n");
                  v40 = v336;
                }
              }
              goto LABEL_75;
            }
          }
          else if ( v181 != sub_2EEE460 )
          {
            v181();
            v45 = v281;
            v40 = v301;
          }
LABEL_348:
          if ( *(_BYTE *)(v40 + 80) )
          {
            v343 = v40;
            sub_2EF0A60(v40, "Generic virtual register must have a bank in a RegBankSelected function", v52, v39, 0);
            v40 = v343;
            goto LABEL_75;
          }
          goto LABEL_349;
        }
        if ( v45 )
        {
          v140 = *(_QWORD *)(v40 + 56);
          v141 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v140 + 272LL);
          if ( v141 != sub_2E85430 )
          {
            v218 = v298;
            v287 = v40;
            v337 = (*(_DWORD *)v52 >> 8) & 0xFFF;
            v219 = ((__int64 (__fastcall *)(__int64, unsigned __int64, _QWORD))v141)(v140, v298, v45);
            v45 = v337;
            v40 = v287;
            if ( v219 )
            {
              v220 = v298;
              if ( v219 == v298 )
                goto LABEL_234;
              v304 = v337;
              v338 = v287;
              sub_2EF0A60(v287, "Invalid register class for subregister index", v52, v39, 0);
              v221 = sub_904010(*(_QWORD *)(v287 + 16), "Register class ");
              v222 = " does not fully support subreg index ";
              v223 = sub_904010(
                       v221,
                       (const char *)(*(_QWORD *)(*(_QWORD *)(v287 + 56) + 80LL)
                                    + *(unsigned int *)(*(_QWORD *)v220 + 16LL)));
            }
            else
            {
              v304 = v337;
              v338 = v287;
              sub_2EF0A60(v287, "Invalid subregister index for virtual register", v52, v39, 0);
              v227 = sub_904010(*(_QWORD *)(v287 + 16), "Register class ");
              v222 = " does not support subreg index ";
              v223 = sub_904010(
                       v227,
                       (const char *)(*(_QWORD *)(*(_QWORD *)(v287 + 56) + 80LL)
                                    + *(unsigned int *)(*(_QWORD *)v218 + 16LL)));
            }
            v224 = sub_904010(v223, v222);
            v225 = sub_904010(
                     v224,
                     *(const char **)(*(_QWORD *)(*(_QWORD *)(v338 + 56) + 256LL) + 8LL * (unsigned int)(v304 - 1)));
            sub_A51310(v225, 0xAu);
            v40 = v338;
            goto LABEL_75;
          }
        }
LABEL_234:
        v316 = v45;
        if ( v54[1] > (unsigned int)v39 )
        {
          v273 = v40;
          v142 = (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v40 + 48)
                                                                                               + 16LL))(
                   *(_QWORD *)(v40 + 48),
                   v54,
                   (unsigned int)v39,
                   *(_QWORD *)(v40 + 56),
                   *(_QWORD *)(v40 + 32));
          v40 = v273;
          v143 = (_QWORD *)v142;
          if ( v142 )
          {
            v144 = v316;
            if ( !v316 )
              goto LABEL_239;
            v145 = *(__int64 **)(v273 + 56);
            v146 = v298;
            v147 = *v145;
            v148 = *(__int64 (__fastcall **)(__int64, __int64))(*v145 + 352);
            if ( v148 != sub_2EBDF80 )
            {
              v342 = v273;
              v231 = *(_QWORD *)(v273 + 32);
              v291 = v144;
              v232 = ((__int64 (__fastcall *)(__int64 *, unsigned __int64, __int64))v148)(v145, v298, v231);
              v40 = v342;
              v146 = v232;
              if ( !v232 )
              {
                sub_2EF0A60(v342, "No largest legal super class exists.", v52, v39, 0);
                v40 = v342;
                goto LABEL_75;
              }
              v145 = *(__int64 **)(v342 + 56);
              v144 = v291;
              v147 = *v145;
            }
            v317 = v40;
            v149 = (*(__int64 (__fastcall **)(__int64 *, unsigned __int64, _QWORD *, _QWORD))(v147 + 256))(
                     v145,
                     v146,
                     v143,
                     v144);
            v40 = v317;
            v143 = (_QWORD *)v149;
            if ( !v149 )
            {
              sub_2EF0A60(v317, "No matching super-reg register class.", v52, v39, 0);
              v40 = v317;
            }
            else
            {
LABEL_239:
              v150 = *(_DWORD *)(v143[1] + 4 * ((unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)v298 + 24LL) >> 5));
              if ( !_bittest(&v150, *(unsigned __int16 *)(*(_QWORD *)v298 + 24LL)) )
              {
                v318 = v40;
                sub_2EF0A60(v40, "Illegal virtual register for instruction", v52, v39, 0);
                v151 = sub_904010(*(_QWORD *)(v318 + 16), "Expected a ");
                v152 = sub_904010(
                         v151,
                         (const char *)(*(_QWORD *)(*(_QWORD *)(v318 + 56) + 80LL) + *(unsigned int *)(*v143 + 16LL)));
                v153 = sub_904010(v152, " register, but got a ");
                v154 = sub_904010(
                         v153,
                         (const char *)(*(_QWORD *)(*(_QWORD *)(v318 + 56) + 80LL)
                                      + *(unsigned int *)(*(_QWORD *)v298 + 16LL)));
                sub_904010(v154, " register\n");
                v40 = v318;
              }
            }
          }
        }
LABEL_75:
        ++v39;
      }
      while ( v344 != (_DWORD)v39 );
LABEL_107:
      v33 = v345;
      v2 = v40;
LABEL_108:
      v67 = *(_BYTE *)(v33 + 44);
      v33 = *(_QWORD *)(v33 + 8);
      v34 = (v67 & 8) != 0;
    }
    while ( v293 != (_QWORD *)v33 );
LABEL_109:
    if ( v292 )
      sub_2EF99C0(v2, *(_QWORD *)(v292 + 24));
    if ( v34 )
    {
      v346 = *((_QWORD *)v294 + 6);
      v163 = v346 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v346 & 0xFFFFFFFFFFFFFFF8LL) == 0 )
        BUG();
      v164 = v346 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (*(_QWORD *)v163 & 4) == 0 && (*(_BYTE *)(v163 + 44) & 4) != 0 )
      {
        for ( n = *(_QWORD *)v163; ; n = *(_QWORD *)v164 )
        {
          v164 = n & 0xFFFFFFFFFFFFFFF8LL;
          if ( (*(_BYTE *)(v164 + 44) & 4) == 0 )
            break;
        }
      }
      sub_2EF06E0(v2, "BundledSucc flag set on last instruction in block", v164);
    }
LABEL_112:
    v28 = v2 + 272;
    v347 = (__int64)v294;
    v68 = sub_2EEFC50(v2 + 600, &v347);
    if ( (_QWORD *)(v2 + 272) != v68 + 9 )
    {
      sub_C7D6A0(v68[10], 4LL * *((unsigned int *)v68 + 24), 4);
      v69 = *(unsigned int *)(v2 + 296);
      *((_DWORD *)v68 + 24) = v69;
      if ( (_DWORD)v69 )
      {
        v70 = (void *)sub_C7D670(4 * v69, 4);
        v71 = *((unsigned int *)v68 + 24);
        v68[10] = v70;
        *((_DWORD *)v68 + 22) = *(_DWORD *)(v2 + 288);
        *((_DWORD *)v68 + 23) = *(_DWORD *)(v2 + 292);
        memcpy(v70, *(const void **)(v2 + 280), 4 * v71);
      }
      else
      {
        v68[10] = 0;
        v68[11] = 0;
      }
    }
    sub_2EF8FC0(v2 + 272);
    v29 = *(_QWORD *)(v2 + 656);
    if ( v29 )
    {
      v31 = v347;
      v72 = *(_QWORD *)(*(_QWORD *)(v29 + 152) + 16LL * *(unsigned int *)(v347 + 24) + 8);
      v29 = *(_DWORD *)((v72 & 0xFFFFFFFFFFFFFFF8LL) + 24) | (unsigned int)(v72 >> 1) & 3;
      v73 = *(_QWORD *)(v2 + 592);
      v74 = v73 >> 1;
      v30 = v73 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (unsigned int)v29 <= (*(_DWORD *)(v30 + 24) | (unsigned int)(v74 & 3)) )
      {
        sub_2EF03A0(v2, "Block ends before last instruction index", v347);
        v195 = *(_QWORD *)(v2 + 16);
        v196 = *(void **)(v195 + 32);
        if ( *(_QWORD *)(v195 + 24) - (_QWORD)v196 <= 0xDu )
        {
          v195 = sub_CB6200(*(_QWORD *)(v2 + 16), "Block ends at ", 0xEu);
        }
        else
        {
          qmemcpy(v196, "Block ends at ", 14);
          *(_QWORD *)(v195 + 32) += 14LL;
        }
        v348 = v72;
        sub_2FAD600(&v348, v195);
        v197 = *(__m128i **)(v195 + 32);
        if ( *(_QWORD *)(v195 + 24) - (_QWORD)v197 <= 0x18u )
        {
          v195 = sub_CB6200(v195, " last instruction was at ", 0x19u);
        }
        else
        {
          v198 = _mm_load_si128((const __m128i *)&xmmword_4453EF0);
          v197[1].m128i_i8[8] = 32;
          v197[1].m128i_i64[0] = 0x746120736177206ELL;
          *v197 = v198;
          *(_QWORD *)(v195 + 32) += 25LL;
        }
        v348 = *(_QWORD *)(v2 + 592);
        sub_2FAD600(&v348, v195);
        v199 = *(_BYTE **)(v195 + 32);
        if ( (unsigned __int64)v199 >= *(_QWORD *)(v195 + 24) )
        {
          sub_CB5D20(v195, 10);
        }
        else
        {
          v29 = (__int64)(v199 + 1);
          *(_QWORD *)(v195 + 32) = v199 + 1;
          *v199 = 10;
        }
      }
      *(_QWORD *)(v2 + 592) = v72;
    }
    v294 = (char *)*((_QWORD *)v294 + 1);
  }
  while ( v248 != v294 );
LABEL_119:
  sub_2EFFE00(v2);
  sub_2EF8FC0(v28);
  v75 = *(_DWORD *)(v2 + 616);
  ++*(_QWORD *)(v2 + 600);
  *(_DWORD *)(v2 + 312) = 0;
  *(_DWORD *)(v2 + 392) = 0;
  *(_DWORD *)(v2 + 472) = 0;
  *(_DWORD *)(v2 + 552) = 0;
  if ( !v75 && !*(_DWORD *)(v2 + 620) )
    return *(_DWORD *)(v2 + 664) == 0;
  v76 = 4 * v75;
  v77 = *(_QWORD *)(v2 + 608);
  v78 = *(unsigned int *)(v2 + 624);
  v79 = 368 * v78;
  if ( (unsigned int)(4 * v75) < 0x40 )
    v76 = 64;
  v80 = v77 + v79;
  if ( v76 >= (unsigned int)v78 )
  {
    while ( 1 )
    {
      if ( v80 == v77 )
        goto LABEL_252;
      if ( *(_QWORD *)v77 != -4096 )
        break;
LABEL_250:
      v77 += 368;
    }
    if ( *(_QWORD *)v77 == -8192 )
    {
LABEL_249:
      *(_QWORD *)v77 = -4096;
      goto LABEL_250;
    }
    if ( *(_BYTE *)(v77 + 300) )
    {
      if ( *(_BYTE *)(v77 + 204) )
      {
LABEL_248:
        sub_C7D6A0(*(_QWORD *)(v77 + 152), 4LL * *(unsigned int *)(v77 + 168), 4);
        sub_C7D6A0(*(_QWORD *)(v77 + 120), 4LL * *(unsigned int *)(v77 + 136), 4);
        sub_C7D6A0(*(_QWORD *)(v77 + 88), 4LL * *(unsigned int *)(v77 + 104), 4);
        sub_C7D6A0(*(_QWORD *)(v77 + 56), 4LL * *(unsigned int *)(v77 + 72), 4);
        sub_C7D6A0(*(_QWORD *)(v77 + 24), 16LL * *(unsigned int *)(v77 + 40), 8);
        goto LABEL_249;
      }
    }
    else
    {
      _libc_free(*(_QWORD *)(v77 + 280));
      if ( *(_BYTE *)(v77 + 204) )
        goto LABEL_248;
    }
    _libc_free(*(_QWORD *)(v77 + 184));
    goto LABEL_248;
  }
  do
  {
    if ( *(_QWORD *)v77 != -4096 && *(_QWORD *)v77 != -8192 )
    {
      if ( !*(_BYTE *)(v77 + 300) )
        _libc_free(*(_QWORD *)(v77 + 280));
      if ( !*(_BYTE *)(v77 + 204) )
        _libc_free(*(_QWORD *)(v77 + 184));
      sub_C7D6A0(*(_QWORD *)(v77 + 152), 4LL * *(unsigned int *)(v77 + 168), 4);
      sub_C7D6A0(*(_QWORD *)(v77 + 120), 4LL * *(unsigned int *)(v77 + 136), 4);
      sub_C7D6A0(*(_QWORD *)(v77 + 88), 4LL * *(unsigned int *)(v77 + 104), 4);
      sub_C7D6A0(*(_QWORD *)(v77 + 56), 4LL * *(unsigned int *)(v77 + 72), 4);
      sub_C7D6A0(*(_QWORD *)(v77 + 24), 16LL * *(unsigned int *)(v77 + 40), 8);
    }
    v77 += 368;
  }
  while ( v80 != v77 );
  v81 = *(_QWORD **)(v2 + 608);
  v82 = *(_DWORD *)(v2 + 624);
  if ( v75 )
  {
    v83 = 64;
    if ( v75 != 1 )
    {
      _BitScanReverse(&v84, v75 - 1);
      v83 = 1 << (33 - (v84 ^ 0x1F));
      if ( v83 < 64 )
        v83 = 64;
    }
    if ( v83 == v82 )
    {
      *(_QWORD *)(v2 + 616) = 0;
      v243 = &v81[46 * (unsigned int)v83];
      do
      {
        if ( v81 )
          *v81 = -4096;
        v81 += 46;
      }
      while ( v243 != v81 );
    }
    else
    {
      sub_C7D6A0((__int64)v81, v79, 8);
      v85 = ((((((((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
               | (4 * v83 / 3u + 1)
               | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 4)
             | (((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
             | (4 * v83 / 3u + 1)
             | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 8)
           | (((((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
             | (4 * v83 / 3u + 1)
             | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 4)
           | (((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
           | (4 * v83 / 3u + 1)
           | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 16;
      v86 = (v85
           | (((((((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
               | (4 * v83 / 3u + 1)
               | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 4)
             | (((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
             | (4 * v83 / 3u + 1)
             | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 8)
           | (((((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
             | (4 * v83 / 3u + 1)
             | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 4)
           | (((4 * v83 / 3u + 1) | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1)) >> 2)
           | (4 * v83 / 3u + 1)
           | ((unsigned __int64)(4 * v83 / 3u + 1) >> 1))
          + 1;
      *(_DWORD *)(v2 + 624) = v86;
      v87 = (_QWORD *)sub_C7D670(368 * v86, 8);
      v88 = *(unsigned int *)(v2 + 624);
      *(_QWORD *)(v2 + 616) = 0;
      *(_QWORD *)(v2 + 608) = v87;
      for ( ii = &v87[46 * v88]; ii != v87; v87 += 46 )
      {
        if ( v87 )
          *v87 = -4096;
      }
    }
  }
  else if ( v82 )
  {
    sub_C7D6A0((__int64)v81, v79, 8);
    *(_QWORD *)(v2 + 608) = 0;
    *(_QWORD *)(v2 + 616) = 0;
    *(_DWORD *)(v2 + 624) = 0;
  }
  else
  {
LABEL_252:
    *(_QWORD *)(v2 + 616) = 0;
  }
  return *(_DWORD *)(v2 + 664) == 0;
}
