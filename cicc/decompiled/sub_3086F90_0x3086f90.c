// Function: sub_3086F90
// Address: 0x3086f90
//
void __fastcall sub_3086F90(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rbx
  char v5; // al
  __int64 v6; // rdx
  __int64 v7; // r12
  int v8; // ebx
  unsigned __int64 v9; // r13
  unsigned int v10; // edi
  unsigned __int64 v11; // rax
  bool v12; // r13
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  unsigned __int64 i; // rcx
  unsigned __int64 v16; // rdx
  __int64 v17; // rdx
  int v18; // r12d
  unsigned int v19; // r14d
  __int64 v20; // rax
  __int64 v21; // r12
  unsigned int v22; // ebx
  __int64 v23; // rdx
  int v24; // eax
  int v25; // esi
  unsigned __int64 v26; // rdx
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned __int64 v29; // rbx
  char v30; // bl
  unsigned int v31; // edi
  unsigned __int64 v32; // rax
  unsigned __int64 j; // rcx
  unsigned __int64 v34; // rdx
  _BYTE *v35; // r15
  __int64 v36; // r13
  __int64 v37; // rax
  char v38; // r14
  _QWORD *v39; // rax
  _BYTE *v40; // rbx
  unsigned int *v41; // r15
  unsigned int *v42; // r12
  __int64 v43; // rdx
  unsigned int v44; // esi
  __int64 *v45; // rsi
  _QWORD *v46; // rax
  __int64 v47; // rax
  unsigned __int8 *v48; // r12
  _BYTE *v49; // r9
  __int64 (__fastcall *v50)(__int64, _BYTE *, _BYTE *, unsigned __int8 *); // rax
  __int64 v51; // rax
  __int64 *v52; // rbx
  __int64 *v53; // r12
  __int64 v54; // rsi
  __int64 v55; // r14
  __int64 v56; // r15
  unsigned __int64 v57; // rax
  char v58; // bl
  _QWORD *v59; // rax
  __int64 v60; // r12
  unsigned int *v61; // r14
  unsigned int *v62; // rbx
  __int64 v63; // rdx
  unsigned int v64; // esi
  unsigned __int64 *v65; // r14
  __int64 v66; // rsi
  __int64 v67; // rax
  _QWORD *v68; // rax
  _QWORD *v69; // rdx
  _QWORD *v70; // r12
  char v71; // r13
  __int64 v72; // rax
  unsigned int *v73; // rdi
  __int64 v74; // rsi
  unsigned __int8 *v75; // rsi
  unsigned __int16 v76; // ax
  __int64 v77; // rdx
  unsigned __int64 v78; // rcx
  __int64 v79; // rax
  __int64 v80; // r8
  __int64 v81; // r9
  __int64 v82; // r13
  __int64 v83; // rax
  unsigned __int64 v84; // rdx
  __int64 **v85; // rdi
  const char *v86; // rax
  _BYTE *v87; // rdx
  __int64 v88; // rdx
  __int64 *v89; // r13
  __int64 *v90; // rbx
  __int64 v91; // rsi
  _QWORD *v92; // rax
  _QWORD *v93; // rdx
  _QWORD *v94; // r13
  char v95; // r14
  _QWORD *v96; // r15
  __int64 v97; // rax
  _QWORD *v98; // rax
  __int64 v99; // r9
  __int64 v100; // rbx
  unsigned int *v101; // r15
  unsigned int *v102; // r12
  __int64 v103; // rdx
  unsigned int v104; // esi
  _QWORD *v105; // rax
  __int64 v106; // rax
  __int64 v107; // rax
  char v108; // al
  char v109; // bl
  _QWORD *v110; // rax
  __int64 v111; // r9
  _BYTE *v112; // r12
  unsigned int *v113; // r13
  unsigned int *v114; // rbx
  __int64 v115; // rdx
  unsigned int v116; // esi
  __int64 *v117; // rsi
  __int64 v118; // rbx
  _BYTE *v119; // r14
  __int64 v120; // rax
  unsigned __int8 *v121; // r12
  __int64 (__fastcall *v122)(__int64, _BYTE *, _BYTE *, unsigned __int8 *); // rax
  __int64 v123; // rdi
  __int64 v124; // rax
  unsigned __int8 *v125; // r13
  __int64 (__fastcall *v126)(__int64, _BYTE *, unsigned __int8 *); // rax
  _QWORD *v127; // rax
  unsigned int *v128; // r13
  unsigned int *v129; // r12
  __int64 v130; // rdx
  unsigned int v131; // esi
  _QWORD *v132; // rax
  __int64 v133; // r9
  unsigned int *v134; // r13
  unsigned int *v135; // r12
  __int64 v136; // rdx
  unsigned int v137; // esi
  _QWORD *v138; // rax
  __int64 v139; // rax
  __int64 v140; // [rsp-10h] [rbp-260h]
  __int64 v141; // [rsp-8h] [rbp-258h]
  __int64 *v144; // [rsp+28h] [rbp-228h]
  __int64 v146; // [rsp+38h] [rbp-218h]
  __int64 v148; // [rsp+58h] [rbp-1F8h]
  __int64 v149; // [rsp+60h] [rbp-1F0h]
  unsigned int v150; // [rsp+70h] [rbp-1E0h]
  unsigned int v151; // [rsp+74h] [rbp-1DCh]
  _BYTE *v152; // [rsp+80h] [rbp-1D0h]
  _BYTE *v153; // [rsp+80h] [rbp-1D0h]
  __int64 v154; // [rsp+90h] [rbp-1C0h]
  __int64 v155; // [rsp+B0h] [rbp-1A0h]
  unsigned int v156; // [rsp+B8h] [rbp-198h]
  _BYTE *v157; // [rsp+B8h] [rbp-198h]
  unsigned __int16 v158; // [rsp+B8h] [rbp-198h]
  _BYTE *v159; // [rsp+C8h] [rbp-188h] BYREF
  __int64 *v160; // [rsp+D0h] [rbp-180h] BYREF
  __int64 *v161; // [rsp+D8h] [rbp-178h]
  __int64 *v162; // [rsp+E0h] [rbp-170h]
  _BYTE *v163[4]; // [rsp+F0h] [rbp-160h] BYREF
  __int16 v164; // [rsp+110h] [rbp-140h]
  unsigned __int64 v165[2]; // [rsp+120h] [rbp-130h] BYREF
  unsigned int *v166; // [rsp+130h] [rbp-120h]
  __int64 v167; // [rsp+138h] [rbp-118h]
  _WORD v168[8]; // [rsp+140h] [rbp-110h] BYREF
  _BYTE *v169; // [rsp+150h] [rbp-100h] BYREF
  __int64 v170; // [rsp+158h] [rbp-F8h]
  _BYTE v171[32]; // [rsp+160h] [rbp-F0h] BYREF
  __int64 v172; // [rsp+180h] [rbp-D0h]
  int v173; // [rsp+188h] [rbp-C8h]
  int v174; // [rsp+18Ch] [rbp-C4h]
  unsigned int *v175; // [rsp+190h] [rbp-C0h] BYREF
  __int64 v176; // [rsp+198h] [rbp-B8h]
  _BYTE v177[32]; // [rsp+1A0h] [rbp-B0h] BYREF
  __int64 v178; // [rsp+1C0h] [rbp-90h]
  __int64 v179; // [rsp+1C8h] [rbp-88h]
  __int64 v180; // [rsp+1D0h] [rbp-80h]
  __int64 *v181; // [rsp+1D8h] [rbp-78h]
  __int64 v182; // [rsp+1E0h] [rbp-70h]
  __int64 v183; // [rsp+1E8h] [rbp-68h]
  void *v184; // [rsp+210h] [rbp-40h]

  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_BYTE *)(v4 + 8);
  if ( v5 == 15 )
  {
    v165[0] = a1;
    v165[1] = v4;
    v167 = 0x400000000LL;
    v170 = 0x400000000LL;
    v166 = (unsigned int *)v168;
    v169 = v171;
    sub_23D0AB0((__int64)&v175, a2, 0, 0, 0);
    v160 = 0;
    v161 = 0;
    v162 = 0;
    if ( !sub_B46500((unsigned __int8 *)a2) )
    {
      v76 = *(_WORD *)(a2 + 2);
      if ( (v76 & 1) == 0 )
      {
        v77 = *(_QWORD *)(a2 - 32);
        v174 = 0;
        v172 = v77;
        _BitScanReverse64(&v78, 1LL << (v76 >> 1));
        v173 = 0x8000000000000000LL >> ((unsigned __int8)v78 ^ 0x3Fu);
        v79 = sub_BCB2D0(v181);
        v82 = sub_ACD640(v79, 0, 0);
        v83 = (unsigned int)v170;
        v84 = (unsigned int)v170 + 1LL;
        if ( v84 > HIDWORD(v170) )
        {
          sub_C8D5F0((__int64)&v169, v171, v84, 8u, v80, v81);
          v83 = (unsigned int)v170;
        }
        *(_QWORD *)&v169[8 * v83] = v82;
        v85 = *(__int64 ***)(a2 + 8);
        LODWORD(v170) = v170 + 1;
        v159 = (_BYTE *)sub_ACA8A0(v85);
        v86 = sub_BD5D20(a2);
        v163[1] = v87;
        v88 = *(_QWORD *)(a2 + 8);
        v164 = 261;
        v163[0] = v86;
        sub_3085D00((__int64)v165, (__int64)&v175, v88, (__int64 *)&v159, (__int64)v163, (__int64)&v160);
        sub_BD84D0(a2, (__int64)v159);
        v89 = v161;
        LODWORD(v167) = 0;
        LODWORD(v170) = 0;
        if ( v160 != v161 )
        {
          v90 = v160;
          do
          {
            v91 = *v90++;
            sub_3086F90(a1, v91, a3, a4);
          }
          while ( v89 != v90 );
        }
        v163[0] = (_BYTE *)a2;
        v92 = sub_2D11AF0(a3, (unsigned __int64 *)v163);
        v94 = v93;
        if ( v93 )
        {
          v95 = 1;
          v96 = (_QWORD *)(a3 + 8);
          if ( !v92 && v93 != v96 )
            v95 = a2 < v93[4];
          v97 = sub_22077B0(0x28u);
          *(_BYTE **)(v97 + 32) = v163[0];
          sub_220F040(v95, v97, v94, v96);
          ++*(_QWORD *)(a3 + 40);
        }
        if ( v160 )
          j_j___libc_free_0((unsigned __int64)v160);
      }
    }
    nullsub_61();
    v184 = &unk_49DA100;
    nullsub_63();
    if ( v175 != (unsigned int *)v177 )
      _libc_free((unsigned __int64)v175);
    if ( v169 != v171 )
      _libc_free((unsigned __int64)v169);
    v73 = v166;
    if ( v166 == (unsigned int *)v168 )
      return;
LABEL_66:
    _libc_free((unsigned __int64)v73);
    return;
  }
  if ( v5 != 17 )
    goto LABEL_54;
  v175 = (unsigned int *)sub_BCAE30(*(_QWORD *)(v4 + 24));
  v176 = v6;
  if ( (unsigned int)sub_CA1930(&v175) <= 7 )
    goto LABEL_54;
  v7 = *(_QWORD *)(v4 + 24);
  v8 = *(_DWORD *)(v4 + 32);
  _BitScanReverse64(&v9, 1LL << (*(_WORD *)(a2 + 2) >> 1));
  LOBYTE(v9) = v9 ^ 0x3F;
  v10 = v8 * (1LL << sub_AE5020(a1, v7));
  v11 = (unsigned int)(0x8000000000000000LL >> v9);
  if ( (unsigned int)(0x8000000000000000LL >> v9) )
  {
    v12 = 0;
    if ( v10 )
    {
      v13 = v11 % v10;
      v14 = v10;
      for ( i = v13; i; i = v16 )
      {
        v16 = v14 % i;
        v14 = i;
      }
      v12 = v10 == (_DWORD)v14;
    }
  }
  else
  {
    v12 = 1;
  }
  v175 = (unsigned int *)sub_BCAE30(v7);
  v176 = v17;
  v18 = sub_CA1930(&v175);
  v19 = sub_DFE150(a4);
  if ( v8 )
  {
    if ( v12 && (v8 & (v8 - 1)) == 0 && v19 >= v18 * v8 )
    {
LABEL_54:
      v55 = *(_QWORD *)(a2 - 32);
      sub_23D0AB0((__int64)&v175, a2, 0, 0, 0);
      v56 = *(_QWORD *)(a2 + 8);
      v158 = *(_WORD *)(a2 + 2);
      v164 = 259;
      _BitScanReverse64(&v57, 1LL << (v158 >> 1));
      v163[0] = "LDG";
      v168[0] = 257;
      v58 = 63 - (v57 ^ 0x3F);
      v59 = sub_BD2C40(80, 1u);
      v60 = (__int64)v59;
      if ( v59 )
        sub_B4D190((__int64)v59, v56, v55, (__int64)v165, 0, v58, 0, 0);
      (*(void (__fastcall **)(__int64, __int64, _BYTE **, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
        v183,
        v60,
        v163,
        v179,
        v180);
      v61 = v175;
      v62 = &v175[4 * (unsigned int)v176];
      if ( v175 != v62 )
      {
        do
        {
          v63 = *((_QWORD *)v61 + 1);
          v64 = *v61;
          v61 += 4;
          sub_B99FD0(v60, v64, v63);
        }
        while ( v62 != v61 );
      }
      v65 = (unsigned __int64 *)(v60 + 48);
      v66 = *(_QWORD *)(a2 + 48);
      v165[0] = v66;
      if ( v66 )
      {
        sub_B96E90((__int64)v165, v66, 1);
        if ( v65 == v165 )
        {
          if ( v165[0] )
            sub_B91220((__int64)v165, v165[0]);
          goto LABEL_62;
        }
        v74 = *(_QWORD *)(v60 + 48);
        if ( !v74 )
        {
LABEL_71:
          v75 = (unsigned __int8 *)v165[0];
          *(_QWORD *)(v60 + 48) = v165[0];
          if ( v75 )
            sub_B976B0((__int64)v165, v75, v60 + 48);
LABEL_62:
          v67 = sub_B9C770(v181, 0, 0, 0, 1);
          sub_B99FD0(v60, 6u, v67);
          sub_BD84D0(a2, v60);
          v165[0] = a2;
          v68 = sub_2D11AF0(a3, v165);
          v70 = v69;
          if ( v69 )
          {
            v71 = 1;
            if ( !v68 && (_QWORD *)(a3 + 8) != v69 )
              v71 = a2 < v69[4];
            v72 = sub_22077B0(0x28u);
            *(_QWORD *)(v72 + 32) = v165[0];
            sub_220F040(v71, v72, v70, (_QWORD *)(a3 + 8));
            ++*(_QWORD *)(a3 + 40);
          }
          nullsub_61();
          v184 = &unk_49DA100;
          nullsub_63();
          v73 = v175;
          if ( v175 == (unsigned int *)v177 )
            return;
          goto LABEL_66;
        }
      }
      else
      {
        if ( v65 == v165 )
          goto LABEL_62;
        v74 = *(_QWORD *)(v60 + 48);
        if ( !v74 )
          goto LABEL_62;
      }
      sub_B91220(v60 + 48, v74);
      goto LABEL_71;
    }
  }
  v160 = 0;
  v161 = 0;
  v20 = *(_QWORD *)(a2 + 40);
  v21 = *(_QWORD *)(a2 + 8);
  v162 = 0;
  v22 = *(_DWORD *)(v21 + 32);
  v146 = *(_QWORD *)(v20 + 72);
  v144 = *(__int64 **)(v21 + 24);
  v149 = *(_QWORD *)(a2 - 32);
  v150 = v22;
  v175 = (unsigned int *)sub_BCAE30((__int64)v144);
  v176 = v23;
  v24 = sub_CA1930(&v175);
  v156 = 0;
  v25 = v24;
  if ( v22 )
  {
    if ( ((v22 - 1) & v22) != 0 )
    {
      _BitScanReverse64(&v26, v22);
      v156 = 1LL << (63 - ((unsigned __int8)v26 ^ 0x3Fu));
      v27 = v156 * v24;
    }
    else
    {
      v27 = v22 * v24;
      v156 = v22;
    }
    if ( v19 < v27 )
    {
      v28 = v156;
      do
        v28 >>= 1;
      while ( v19 < v28 * v25 );
      v156 = v28;
    }
  }
  _BitScanReverse64(&v29, 1LL << (*(_WORD *)(a2 + 2) >> 1));
  v30 = v29 ^ 0x3F;
  v31 = v156 * (1LL << sub_AE5020(a1, (__int64)v144));
  if ( (unsigned int)(0x8000000000000000LL >> v30) )
  {
    if ( !v31 )
      goto LABEL_27;
    v32 = v31;
    for ( j = (unsigned int)(0x8000000000000000LL >> v30) % (unsigned __int64)v31; j; j = v34 )
    {
      v34 = v32 % j;
      v32 = j;
    }
    if ( v31 != (_DWORD)v32 )
    {
LABEL_27:
      sub_23D0AB0((__int64)&v175, a2, 0, 0, 0);
      v151 = 0;
      v35 = (_BYTE *)sub_ACA8A0((__int64 **)v21);
      goto LABEL_28;
    }
  }
  sub_23D0AB0((__int64)&v175, a2, 0, 0, 0);
  v151 = 0;
  v35 = (_BYTE *)sub_ACA8A0((__int64 **)v21);
  if ( v156 > 1 )
  {
    do
    {
      v148 = sub_BCDA70(v144, v156);
      if ( v156 + v151 > v150 )
        goto LABEL_147;
      v151 += v156;
      while ( 2 )
      {
        v164 = 259;
        v163[0] = "splitVec";
        v107 = sub_AA4E30(v178);
        v108 = sub_AE5020(v107, v148);
        v168[0] = 257;
        v109 = v108;
        v110 = sub_BD2C40(80, 1u);
        v112 = v110;
        if ( v110 )
        {
          sub_B4D190((__int64)v110, v148, v149, (__int64)v165, 0, v109, 0, 0);
          v111 = v140;
        }
        (*(void (__fastcall **)(__int64, _BYTE *, _BYTE **, __int64, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
          v183,
          v112,
          v163,
          v179,
          v180,
          v111);
        v113 = v175;
        v114 = &v175[4 * (unsigned int)v176];
        if ( v175 != v114 )
        {
          do
          {
            v115 = *((_QWORD *)v113 + 1);
            v116 = *v113;
            v113 += 4;
            sub_B99FD0((__int64)v112, v116, v115);
          }
          while ( v114 != v113 );
        }
        v159 = v112;
        v117 = v161;
        if ( v161 == v162 )
        {
          sub_27D05B0((__int64)&v160, v161, &v159);
          v112 = v159;
        }
        else
        {
          if ( v161 )
          {
            *v161 = (__int64)v112;
            v117 = v161;
          }
          v161 = v117 + 1;
        }
        v155 = (__int64)v35;
        v118 = 0;
        while ( 1 )
        {
          v163[0] = "extractSplitVec";
          v164 = 259;
          v124 = sub_BCB2E0(v181);
          v125 = (unsigned __int8 *)sub_ACD640(v124, v118, 0);
          v126 = *(__int64 (__fastcall **)(__int64, _BYTE *, unsigned __int8 *))(*(_QWORD *)v182 + 96LL);
          if ( v126 != sub_948070 )
          {
            v119 = (_BYTE *)v126(v182, v112, v125);
LABEL_117:
            if ( v119 )
              goto LABEL_118;
            goto LABEL_130;
          }
          if ( *v112 <= 0x15u && *v125 <= 0x15u )
          {
            v119 = (_BYTE *)sub_AD5840((__int64)v112, v125, 0);
            goto LABEL_117;
          }
LABEL_130:
          v168[0] = 257;
          v127 = sub_BD2C40(72, 2u);
          v119 = v127;
          if ( v127 )
            sub_B4DE80((__int64)v127, (__int64)v112, (__int64)v125, (__int64)v165, 0, 0);
          (*(void (__fastcall **)(__int64, _BYTE *, _BYTE **, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
            v183,
            v119,
            v163,
            v179,
            v180);
          v128 = v175;
          v129 = &v175[4 * (unsigned int)v176];
          if ( v175 != v129 )
          {
            do
            {
              v130 = *((_QWORD *)v128 + 1);
              v131 = *v128;
              v128 += 4;
              sub_B99FD0((__int64)v119, v131, v130);
            }
            while ( v129 != v128 );
          }
LABEL_118:
          v164 = 259;
          v163[0] = "insertSplitVec";
          v120 = sub_BCB2E0(v181);
          v121 = (unsigned __int8 *)sub_ACD640(v120, v151 - v156 + (unsigned int)v118, 0);
          v122 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, unsigned __int8 *))(*(_QWORD *)v182 + 104LL);
          if ( v122 == sub_948040 )
          {
            v123 = 0;
            if ( *v35 <= 0x15u )
              v123 = (__int64)v35;
            if ( *v119 > 0x15u || *v121 > 0x15u || !v123 )
              goto LABEL_135;
            v35 = (_BYTE *)sub_AD5A90(v123, v119, v121, 0);
          }
          else
          {
            v35 = (_BYTE *)v122(v182, v35, v119, v121);
          }
          if ( v35 )
            goto LABEL_126;
LABEL_135:
          v168[0] = 257;
          v132 = sub_BD2C40(72, 3u);
          v133 = 0;
          v35 = v132;
          if ( v132 )
            sub_B4DFA0((__int64)v132, v155, (__int64)v119, (__int64)v121, (__int64)v165, 0, 0, 0);
          (*(void (__fastcall **)(__int64, _BYTE *, _BYTE **, __int64, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
            v183,
            v35,
            v163,
            v179,
            v180,
            v133);
          v134 = v175;
          v135 = &v175[4 * (unsigned int)v176];
          if ( v175 != v135 )
            break;
LABEL_126:
          if ( v156 <= (unsigned int)++v118 )
            goto LABEL_140;
LABEL_127:
          v155 = (__int64)v35;
          v112 = v159;
        }
        do
        {
          v136 = *((_QWORD *)v134 + 1);
          v137 = *v134;
          v134 += 4;
          sub_B99FD0((__int64)v35, v137, v136);
        }
        while ( v135 != v134 );
        if ( v156 > (unsigned int)++v118 )
          goto LABEL_127;
LABEL_140:
        if ( v151 < v150 )
        {
          v138 = (_QWORD *)sub_B2BE50(v146);
          v139 = sub_BCB2D0(v138);
          v163[0] = (_BYTE *)sub_ACD640(v139, 1, 0);
          v165[0] = (unsigned __int64)"splitVecGEP";
          v168[0] = 259;
          v149 = sub_921130(&v175, v148, v149, v163, 1, (__int64)v165, 0);
        }
        if ( v156 + v151 <= v150 )
        {
          v151 += v156;
          continue;
        }
        break;
      }
LABEL_147:
      v156 >>= 1;
    }
    while ( v156 != 1 );
  }
LABEL_28:
  if ( v150 <= v151 )
    goto LABEL_47;
  v157 = v35;
  v36 = v151;
  do
  {
    v163[0] = "splitVec";
    v164 = 259;
    v37 = sub_AA4E30(v178);
    v38 = sub_AE5020(v37, (__int64)v144);
    v168[0] = 257;
    v39 = sub_BD2C40(80, 1u);
    v40 = v39;
    if ( v39 )
      sub_B4D190((__int64)v39, (__int64)v144, v149, (__int64)v165, 0, v38, 0, 0);
    (*(void (__fastcall **)(__int64, _BYTE *, _BYTE **, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
      v183,
      v40,
      v163,
      v179,
      v180);
    v41 = v175;
    v42 = &v175[4 * (unsigned int)v176];
    if ( v175 != v42 )
    {
      do
      {
        v43 = *((_QWORD *)v41 + 1);
        v44 = *v41;
        v41 += 4;
        sub_B99FD0((__int64)v40, v44, v43);
      }
      while ( v42 != v41 );
    }
    v159 = v40;
    v45 = v161;
    if ( v161 == v162 )
    {
      sub_27D05B0((__int64)&v160, v161, &v159);
    }
    else
    {
      if ( v161 )
      {
        *v161 = (__int64)v40;
        v45 = v161;
      }
      v161 = v45 + 1;
    }
    v46 = (_QWORD *)sub_B2BE50(v146);
    v47 = sub_BCB2D0(v46);
    v48 = (unsigned __int8 *)sub_ACD640(v47, v36, 0);
    v164 = 259;
    v49 = v159;
    v163[0] = "insertSplitVec";
    v50 = *(__int64 (__fastcall **)(__int64, _BYTE *, _BYTE *, unsigned __int8 *))(*(_QWORD *)v182 + 104LL);
    if ( v50 == sub_948040 )
    {
      if ( *v157 > 0x15u || *v159 > 0x15u || *v48 > 0x15u )
        goto LABEL_91;
      v152 = v159;
      v51 = sub_AD5A90((__int64)v157, v159, v48, 0);
      v49 = v152;
    }
    else
    {
      v153 = v159;
      v51 = v50(v182, v157, v159, v48);
      v49 = v153;
    }
    if ( v51 )
    {
      v157 = (_BYTE *)v51;
      if ( v150 <= (int)v36 + 1 )
        goto LABEL_45;
LABEL_96:
      v105 = (_QWORD *)sub_B2BE50(v146);
      v106 = sub_BCB2D0(v105);
      v163[0] = (_BYTE *)sub_ACD640(v106, 1, 0);
      v165[0] = (unsigned __int64)"splitVecGEP";
      v168[0] = 259;
      v149 = sub_921130(&v175, (__int64)v144, v149, v163, 1, (__int64)v165, 0);
      goto LABEL_45;
    }
LABEL_91:
    v168[0] = 257;
    v154 = (__int64)v49;
    v98 = sub_BD2C40(72, 3u);
    v99 = v154;
    v100 = (__int64)v98;
    if ( v98 )
    {
      sub_B4DFA0((__int64)v98, (__int64)v157, v154, (__int64)v48, (__int64)v165, v154, 0, 0);
      v99 = v141;
    }
    (*(void (__fastcall **)(__int64, __int64, _BYTE **, __int64, __int64, __int64))(*(_QWORD *)v183 + 16LL))(
      v183,
      v100,
      v163,
      v179,
      v180,
      v99);
    v101 = v175;
    v102 = &v175[4 * (unsigned int)v176];
    if ( v175 != v102 )
    {
      do
      {
        v103 = *((_QWORD *)v101 + 1);
        v104 = *v101;
        v101 += 4;
        sub_B99FD0(v100, v104, v103);
      }
      while ( v102 != v101 );
    }
    v157 = (_BYTE *)v100;
    if ( v150 > (int)v36 + 1 )
      goto LABEL_96;
LABEL_45:
    ++v36;
  }
  while ( v150 > (unsigned int)v36 );
  v35 = v157;
LABEL_47:
  sub_BD84D0(a2, (__int64)v35);
  sub_B43D60((_QWORD *)a2);
  nullsub_61();
  v184 = &unk_49DA100;
  nullsub_63();
  if ( v175 != (unsigned int *)v177 )
    _libc_free((unsigned __int64)v175);
  v52 = v160;
  v53 = v161;
  if ( v160 != v161 )
  {
    do
    {
      v54 = *v52++;
      sub_3086F90(a1, v54, a3, a4);
    }
    while ( v53 != v52 );
    v53 = v160;
  }
  if ( v53 )
    j_j___libc_free_0((unsigned __int64)v53);
}
