// Function: sub_1C3BC10
// Address: 0x1c3bc10
//
void __fastcall sub_1C3BC10(__int64 a1, _QWORD **a2)
{
  _QWORD *v3; // rbx
  _QWORD **i; // r14
  __int64 v5; // rsi
  _QWORD *j; // r14
  _BYTE *v7; // rsi
  __int64 v8; // rax
  size_t v9; // rdx
  __int64 v10; // rbx
  __int8 *v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rdi
  __m128i *v15; // rax
  __m128i v16; // xmm0
  __int64 v17; // rdi
  __m128i *v18; // rax
  __m128i v19; // xmm0
  __int64 v20; // rdi
  __int64 v21; // rax
  __int64 v22; // rdi
  _QWORD *v23; // rdx
  void *v24; // rax
  _BYTE *v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rax
  __int64 v28; // rdi
  _QWORD *v29; // rdx
  void *v30; // rax
  _BYTE *v31; // rax
  __int64 k; // rbx
  unsigned int v33; // r15d
  int v34; // r12d
  __int64 v35; // rsi
  __int64 v36; // r12
  _QWORD *v37; // rbx
  __int64 v38; // rsi
  __int16 *v39; // r13
  __int16 *v40; // rbx
  __int16 *v41; // r15
  __int64 v42; // r9
  __int64 v43; // rdi
  __int64 v44; // rax
  __int64 v45; // rdi
  __m128i *v46; // rax
  __m128i v47; // xmm0
  __int64 v48; // rdi
  __int64 v49; // rax
  unsigned __int64 v50; // rax
  __int64 v51; // rbx
  char *v52; // rsi
  __int64 v53; // rdx
  __int64 v54; // rdi
  __int64 v55; // rax
  __int64 v56; // rdi
  __m128i *v57; // rax
  __m128i v58; // xmm0
  __int64 v59; // rdi
  __int64 v60; // rax
  __int64 v61; // r15
  _QWORD *v62; // rdx
  size_t v63; // rax
  _BYTE *v64; // rdi
  size_t v65; // rbx
  _BYTE *v66; // rax
  _BYTE *v67; // rbx
  __int64 v68; // rdi
  __int64 v69; // rax
  __int64 v70; // rdi
  __m128i *v71; // rax
  __int64 v72; // rdi
  __int64 v73; // rax
  __int64 v74; // rdx
  __int64 v75; // rax
  __int64 v76; // r15
  unsigned int v77; // eax
  __int64 v78; // rax
  __int64 v79; // r9
  __m128i *v80; // rdx
  __int64 v81; // rdi
  __m128i v82; // xmm0
  _BYTE *v83; // rax
  __int64 v84; // rax
  __int64 v85; // r9
  __m128i *v86; // rdx
  __int64 v87; // rdi
  __m128i v88; // xmm0
  _BYTE *v89; // rax
  __int64 v90; // rax
  __m128i *v91; // rdx
  __int64 v92; // rdi
  _BYTE *v93; // rax
  bool v94; // al
  __int64 v95; // rax
  __int64 v96; // rax
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rax
  __int64 v101; // r9
  __m128i *v102; // rdx
  __int64 v103; // rdi
  __m128i v104; // xmm0
  _BYTE *v105; // rax
  unsigned int v106; // eax
  int v107; // eax
  __int64 v108; // rax
  __int64 v109; // rdi
  __m128i *v110; // rax
  __m128i v111; // xmm0
  __int64 v112; // rax
  unsigned __int64 v113; // rdx
  __m128i v114; // xmm0
  __int64 v115; // rax
  __int64 v116; // r15
  __int64 v117; // rax
  __int64 v118; // rdi
  __int64 v119; // rdx
  __int64 v120; // rdi
  _WORD *v121; // rdx
  __int64 v122; // rdi
  __int64 v123; // rdx
  __m128i *v124; // rdx
  __int64 v125; // rax
  int v126; // eax
  __int64 v127; // rax
  unsigned int v128; // eax
  __int64 v129; // rax
  __m128i *v130; // rdx
  __int64 v131; // rdi
  __m128i v132; // xmm0
  __int64 v133; // rax
  __m128i v134; // xmm0
  _BYTE *v135; // rdi
  __int64 v136; // rax
  __int64 v137; // rdx
  __int64 v138; // rdi
  __int64 v139; // rax
  __int64 v140; // rdi
  __m128i *v141; // rax
  __m128i v142; // xmm0
  int v143; // eax
  __int64 v144; // rax
  __int64 v145; // r9
  __int64 v146; // rdi
  __m128i *v147; // rax
  void *v148; // rax
  unsigned __int64 v149; // rdx
  __int64 v150; // rax
  __int64 v151; // r9
  __m128i *v152; // rdx
  __int64 v153; // rdi
  __m128i v154; // xmm0
  _WORD *v155; // rdx
  __int64 v156; // rax
  __int64 v157; // rax
  __int64 v158; // rax
  __int64 v159; // rax
  __int64 v160; // rax
  __int64 v161; // rax
  __int64 v162; // rdi
  __int64 v163; // rax
  __int64 v164; // rdi
  __m128i *v165; // rax
  __m128i si128; // xmm0
  __int64 v167; // rax
  unsigned __int64 v168; // rax
  __int64 v169; // rbx
  __int64 v170; // rdi
  __int64 v171; // rax
  __int64 v172; // rdi
  __m128i *v173; // rax
  __m128i v174; // xmm0
  __int64 v175; // rdi
  __int64 v176; // rax
  __int64 v177; // r15
  _QWORD *v178; // rdx
  size_t v179; // rax
  _BYTE *v180; // rdi
  size_t v181; // rbx
  _BYTE *v182; // rax
  _BYTE *v183; // rbx
  __int64 v184; // rax
  __int64 v185; // rdi
  __int64 v186; // rax
  __int64 v187; // r15
  __m128i *v188; // rax
  __m128i v189; // xmm0
  size_t v190; // rax
  _BYTE *v191; // rdi
  size_t v192; // rbx
  _BYTE *v193; // rax
  _BYTE *v194; // rbx
  __int64 v195; // rdi
  __int64 v196; // rax
  __int64 v197; // r15
  _QWORD *v198; // rdx
  char *v199; // rsi
  size_t v200; // rax
  _BYTE *v201; // rdi
  size_t v202; // rbx
  _BYTE *v203; // rax
  _BYTE *v204; // rbx
  __int64 v205; // rdx
  __int64 v206; // rdi
  __int64 v207; // rax
  _QWORD *v208; // rdx
  __int64 v209; // [rsp+10h] [rbp-260h]
  __int64 v210; // [rsp+10h] [rbp-260h]
  __int64 v211; // [rsp+10h] [rbp-260h]
  __int64 v212; // [rsp+10h] [rbp-260h]
  __int64 v213; // [rsp+10h] [rbp-260h]
  __int64 v214; // [rsp+10h] [rbp-260h]
  __int64 v215; // [rsp+10h] [rbp-260h]
  __int64 v216; // [rsp+10h] [rbp-260h]
  __int64 v217; // [rsp+10h] [rbp-260h]
  __int64 v218; // [rsp+10h] [rbp-260h]
  __int64 v219; // [rsp+10h] [rbp-260h]
  __int64 v220; // [rsp+10h] [rbp-260h]
  __int64 v221; // [rsp+10h] [rbp-260h]
  __int64 v222; // [rsp+10h] [rbp-260h]
  __int64 v223; // [rsp+10h] [rbp-260h]
  __int64 v224; // [rsp+10h] [rbp-260h]
  __int64 v225; // [rsp+10h] [rbp-260h]
  __int64 v226; // [rsp+10h] [rbp-260h]
  _QWORD **v227; // [rsp+18h] [rbp-258h]
  unsigned int v228; // [rsp+20h] [rbp-250h]
  __int64 v229; // [rsp+20h] [rbp-250h]
  __int64 v230; // [rsp+20h] [rbp-250h]
  __int64 v231; // [rsp+20h] [rbp-250h]
  __int64 v232; // [rsp+20h] [rbp-250h]
  __int64 v233; // [rsp+20h] [rbp-250h]
  __int64 v234; // [rsp+20h] [rbp-250h]
  __int64 v235; // [rsp+20h] [rbp-250h]
  __int64 v236; // [rsp+20h] [rbp-250h]
  __int64 v237; // [rsp+20h] [rbp-250h]
  __int64 v238; // [rsp+20h] [rbp-250h]
  __int64 v239; // [rsp+20h] [rbp-250h]
  __int64 v240; // [rsp+20h] [rbp-250h]
  _QWORD *v241; // [rsp+28h] [rbp-248h]
  _QWORD *src; // [rsp+30h] [rbp-240h]
  char *srca; // [rsp+30h] [rbp-240h]
  char *srcb; // [rsp+30h] [rbp-240h]
  char *srcc; // [rsp+30h] [rbp-240h]
  _QWORD *v247; // [rsp+38h] [rbp-238h]
  unsigned __int64 v248; // [rsp+40h] [rbp-230h] BYREF
  unsigned __int64 v249; // [rsp+48h] [rbp-228h] BYREF
  char *v250; // [rsp+50h] [rbp-220h] BYREF
  size_t v251; // [rsp+58h] [rbp-218h]
  _QWORD v252[2]; // [rsp+60h] [rbp-210h] BYREF
  _QWORD v253[5]; // [rsp+70h] [rbp-200h] BYREF
  char v254; // [rsp+98h] [rbp-1D8h] BYREF
  char *v255; // [rsp+A0h] [rbp-1D0h]
  __int64 v256; // [rsp+A8h] [rbp-1C8h]
  char v257; // [rsp+B0h] [rbp-1C0h] BYREF
  char *v258; // [rsp+130h] [rbp-140h]
  __int64 v259; // [rsp+138h] [rbp-138h]
  char v260; // [rsp+140h] [rbp-130h] BYREF
  char *v261; // [rsp+150h] [rbp-120h]
  __int64 v262; // [rsp+158h] [rbp-118h]
  char v263; // [rsp+160h] [rbp-110h] BYREF
  __int64 v264; // [rsp+200h] [rbp-70h]
  char *v265; // [rsp+208h] [rbp-68h]
  __int64 v266; // [rsp+210h] [rbp-60h]
  char v267; // [rsp+218h] [rbp-58h] BYREF

  v3 = a2[4];
  v227 = a2 + 3;
  for ( i = a2 + 3; v3 != i; v3 = (_QWORD *)v3[1] )
  {
    v5 = (__int64)(v3 - 7);
    if ( !v3 )
      v5 = 0;
    sub_1C34CC0((_DWORD *)a1, v5);
  }
  for ( j = a2[2]; a2 + 1 != j; j = (_QWORD *)j[1] )
  {
    v7 = j - 7;
    if ( !j )
      v7 = 0;
    sub_1C355F0((_DWORD *)a1, v7);
  }
  v8 = sub_1632FA0((__int64)a2);
  v9 = *(_QWORD *)(v8 + 200);
  v10 = v8;
  if ( !v9 )
  {
    v162 = *(_QWORD *)(a1 + 24);
    v163 = *(_QWORD *)(v162 + 24);
    if ( (unsigned __int64)(*(_QWORD *)(v162 + 16) - v163) <= 6 )
    {
      sub_16E7EE0(v162, "Error: ", 7u);
    }
    else
    {
      *(_DWORD *)v163 = 1869771333;
      *(_WORD *)(v163 + 4) = 14962;
      *(_BYTE *)(v163 + 6) = 32;
      *(_QWORD *)(v162 + 24) += 7LL;
    }
    v164 = *(_QWORD *)(a1 + 24);
    v165 = *(__m128i **)(v164 + 24);
    if ( *(_QWORD *)(v164 + 16) - (_QWORD)v165 <= 0x24u )
    {
      sub_16E7EE0(v164, "Empty target data layout, must exist\n", 0x25u);
    }
    else
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_42D0C90);
      v165[2].m128i_i32[0] = 1953720696;
      v165[2].m128i_i8[4] = 10;
      *v165 = si128;
      v165[1] = _mm_load_si128((const __m128i *)&xmmword_42D0CA0);
      *(_QWORD *)(v164 + 24) += 37LL;
    }
    sub_1C31880(a1);
    v9 = *(_QWORD *)(v10 + 200);
  }
  v11 = *(__int8 **)(v10 + 192);
  v259 = 0;
  v255 = &v257;
  v256 = 0x1000000000LL;
  v258 = &v260;
  v253[3] = &v254;
  v261 = &v263;
  v253[4] = 0x800000000LL;
  v260 = 0;
  v262 = 0x800000000LL;
  v264 = 0;
  v265 = &v267;
  v266 = 0x800000000LL;
  sub_15A9300((__int64)v253, v11, v9);
  if ( !*(_DWORD *)a1 )
  {
    sub_1C27E00(&v248, (__int64)v253, *a2, 0, 1, 1);
    if ( (v248 & 0xFFFFFFFFFFFFFFFELL) == 0 )
      goto LABEL_12;
    v72 = *(_QWORD *)(a1 + 24);
    v248 = v248 & 0xFFFFFFFFFFFFFFFELL | 1;
    v73 = *(_QWORD *)(v72 + 24);
    if ( (unsigned __int64)(*(_QWORD *)(v72 + 16) - v73) <= 6 )
    {
      sub_16E7EE0(v72, "Error: ", 7u);
    }
    else
    {
      *(_DWORD *)v73 = 1869771333;
      *(_WORD *)(v73 + 4) = 14962;
      *(_BYTE *)(v73 + 6) = 32;
      *(_QWORD *)(v72 + 24) += 7LL;
    }
    v168 = v248;
    v169 = *(_QWORD *)(a1 + 24);
    v248 = 0;
    v249 = v168 | 1;
    sub_12BF440((__int64)&v250, (__int64 *)&v249);
    v52 = v250;
    sub_16E7EE0(v169, v250, v251);
    if ( v250 != (char *)v252 )
    {
      v52 = (char *)(v252[0] + 1LL);
      j_j___libc_free_0(v250, v252[0] + 1LL);
    }
    if ( (v249 & 1) == 0 && (v249 & 0xFFFFFFFFFFFFFFFELL) == 0 )
    {
      v170 = *(_QWORD *)(a1 + 24);
      v171 = *(_QWORD *)(v170 + 24);
      if ( (unsigned __int64)(*(_QWORD *)(v170 + 16) - v171) <= 6 )
      {
        sub_16E7EE0(v170, "Error: ", 7u);
      }
      else
      {
        *(_DWORD *)v171 = 1869771333;
        *(_WORD *)(v171 + 4) = 14962;
        *(_BYTE *)(v171 + 6) = 32;
        *(_QWORD *)(v170 + 24) += 7LL;
      }
      v172 = *(_QWORD *)(a1 + 24);
      v173 = *(__m128i **)(v172 + 24);
      if ( *(_QWORD *)(v172 + 16) - (_QWORD)v173 <= 0x1Bu )
      {
        sub_16E7EE0(v172, "\nExample valid data layout:\n", 0x1Cu);
      }
      else
      {
        v174 = _mm_load_si128((const __m128i *)&xmmword_4281920);
        qmemcpy(&v173[1], "ata layout:\n", 12);
        *v173 = v174;
        *(_QWORD *)(v172 + 24) += 28LL;
      }
      v175 = *(_QWORD *)(a1 + 24);
      v176 = *(_QWORD *)(v175 + 24);
      if ( (unsigned __int64)(*(_QWORD *)(v175 + 16) - v176) <= 6 )
      {
        sub_16E7EE0(v175, "Error: ", 7u);
      }
      else
      {
        *(_DWORD *)v176 = 1869771333;
        *(_WORD *)(v176 + 4) = 14962;
        *(_BYTE *)(v176 + 6) = 32;
        *(_QWORD *)(v175 + 24) += 7LL;
      }
      v177 = *(_QWORD *)(a1 + 24);
      v178 = *(_QWORD **)(v177 + 24);
      if ( *(_QWORD *)(v177 + 16) - (_QWORD)v178 <= 7u )
      {
        v177 = sub_16E7EE0(*(_QWORD *)(a1 + 24), "32-bit: ", 8u);
      }
      else
      {
        *v178 = 0x203A7469622D3233LL;
        *(_QWORD *)(v177 + 24) += 8LL;
      }
      if ( off_4CD4938[0] )
      {
        srcb = off_4CD4938[0];
        v179 = strlen(off_4CD4938[0]);
        v180 = *(_BYTE **)(v177 + 24);
        v181 = v179;
        v182 = *(_BYTE **)(v177 + 16);
        if ( v181 <= v182 - v180 )
        {
          if ( v181 )
          {
            memcpy(v180, srcb, v181);
            v183 = (_BYTE *)(*(_QWORD *)(v177 + 24) + v181);
            v182 = *(_BYTE **)(v177 + 16);
            *(_QWORD *)(v177 + 24) = v183;
            v180 = v183;
          }
LABEL_263:
          if ( v182 == v180 )
          {
            sub_16E7EE0(v177, "\n", 1u);
          }
          else
          {
            *v180 = 10;
            ++*(_QWORD *)(v177 + 24);
          }
          v195 = *(_QWORD *)(a1 + 24);
          v196 = *(_QWORD *)(v195 + 24);
          if ( (unsigned __int64)(*(_QWORD *)(v195 + 16) - v196) <= 6 )
          {
            sub_16E7EE0(v195, "Error: ", 7u);
          }
          else
          {
            *(_DWORD *)v196 = 1869771333;
            *(_WORD *)(v196 + 4) = 14962;
            *(_BYTE *)(v196 + 6) = 32;
            *(_QWORD *)(v195 + 24) += 7LL;
          }
          v197 = *(_QWORD *)(a1 + 24);
          v198 = *(_QWORD **)(v197 + 24);
          if ( *(_QWORD *)(v197 + 16) - (_QWORD)v198 <= 7u )
          {
            v197 = sub_16E7EE0(*(_QWORD *)(a1 + 24), "64-bit: ", 8u);
          }
          else
          {
            *v198 = 0x203A7469622D3436LL;
            *(_QWORD *)(v197 + 24) += 8LL;
          }
          v199 = off_4CD4948[0];
          if ( !off_4CD4948[0] )
            goto LABEL_279;
          goto LABEL_270;
        }
        v177 = sub_16E7EE0(v177, srcb, v181);
      }
      v182 = *(_BYTE **)(v177 + 16);
      v180 = *(_BYTE **)(v177 + 24);
      goto LABEL_263;
    }
LABEL_299:
    sub_16BCAE0(&v249, (__int64)v52, v53);
  }
  v43 = *(_QWORD *)(a1 + 24);
  v44 = *(_QWORD *)(v43 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v43 + 16) - v44) <= 6 )
  {
    sub_16E7EE0(v43, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v44 = 1869771333;
    *(_WORD *)(v44 + 4) = 14962;
    *(_BYTE *)(v44 + 6) = 32;
    *(_QWORD *)(v43 + 24) += 7LL;
  }
  v45 = *(_QWORD *)(a1 + 24);
  v46 = *(__m128i **)(v45 + 24);
  if ( *(_QWORD *)(v45 + 16) - (_QWORD)v46 <= 0x18u )
  {
    sub_16E7EE0(v45, "IR Kind is UnifiedNVVMIR\n", 0x19u);
  }
  else
  {
    v47 = _mm_load_si128((const __m128i *)&xmmword_42D0CB0);
    v46[1].m128i_i8[8] = 10;
    v46[1].m128i_i64[0] = 0x52494D56564E6465LL;
    *v46 = v47;
    *(_QWORD *)(v45 + 24) += 25LL;
  }
  sub_1C27E00(&v248, (__int64)v253, *a2, 0, 0, 0);
  if ( (v248 & 0xFFFFFFFFFFFFFFFELL) == 0 )
    goto LABEL_12;
  v48 = *(_QWORD *)(a1 + 24);
  v248 = v248 & 0xFFFFFFFFFFFFFFFELL | 1;
  v49 = *(_QWORD *)(v48 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v48 + 16) - v49) <= 6 )
  {
    sub_16E7EE0(v48, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v49 = 1869771333;
    *(_WORD *)(v49 + 4) = 14962;
    *(_BYTE *)(v49 + 6) = 32;
    *(_QWORD *)(v48 + 24) += 7LL;
  }
  v50 = v248;
  v51 = *(_QWORD *)(a1 + 24);
  v248 = 0;
  v249 = v50 | 1;
  sub_12BF440((__int64)&v250, (__int64 *)&v249);
  v52 = v250;
  sub_16E7EE0(v51, v250, v251);
  if ( v250 != (char *)v252 )
  {
    v52 = (char *)(v252[0] + 1LL);
    j_j___libc_free_0(v250, v252[0] + 1LL);
  }
  if ( (v249 & 1) != 0 || (v249 & 0xFFFFFFFFFFFFFFFELL) != 0 )
    goto LABEL_299;
  v54 = *(_QWORD *)(a1 + 24);
  v55 = *(_QWORD *)(v54 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v54 + 16) - v55) <= 6 )
  {
    sub_16E7EE0(v54, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v55 = 1869771333;
    *(_WORD *)(v55 + 4) = 14962;
    *(_BYTE *)(v55 + 6) = 32;
    *(_QWORD *)(v54 + 24) += 7LL;
  }
  v56 = *(_QWORD *)(a1 + 24);
  v57 = *(__m128i **)(v56 + 24);
  if ( *(_QWORD *)(v56 + 16) - (_QWORD)v57 <= 0x1Bu )
  {
    sub_16E7EE0(v56, "\nExample valid data layout:\n", 0x1Cu);
  }
  else
  {
    v58 = _mm_load_si128((const __m128i *)&xmmword_4281920);
    qmemcpy(&v57[1], "ata layout:\n", 12);
    *v57 = v58;
    *(_QWORD *)(v56 + 24) += 28LL;
  }
  v59 = *(_QWORD *)(a1 + 24);
  v60 = *(_QWORD *)(v59 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v59 + 16) - v60) <= 6 )
  {
    sub_16E7EE0(v59, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v60 = 1869771333;
    *(_WORD *)(v60 + 4) = 14962;
    *(_BYTE *)(v60 + 6) = 32;
    *(_QWORD *)(v59 + 24) += 7LL;
  }
  v61 = *(_QWORD *)(a1 + 24);
  v62 = *(_QWORD **)(v61 + 24);
  if ( *(_QWORD *)(v61 + 16) - (_QWORD)v62 <= 7u )
  {
    v61 = sub_16E7EE0(*(_QWORD *)(a1 + 24), "32-bit: ", 8u);
  }
  else
  {
    *v62 = 0x203A7469622D3233LL;
    *(_QWORD *)(v61 + 24) += 8LL;
  }
  if ( !off_4CD4930[0] )
    goto LABEL_250;
  srca = off_4CD4930[0];
  v63 = strlen(off_4CD4930[0]);
  v64 = *(_BYTE **)(v61 + 24);
  v65 = v63;
  v66 = *(_BYTE **)(v61 + 16);
  if ( v65 > v66 - v64 )
  {
    v61 = sub_16E7EE0(v61, srca, v65);
LABEL_250:
    v66 = *(_BYTE **)(v61 + 16);
    v64 = *(_BYTE **)(v61 + 24);
    goto LABEL_251;
  }
  if ( v65 )
  {
    memcpy(v64, srca, v65);
    v67 = (_BYTE *)(*(_QWORD *)(v61 + 24) + v65);
    v66 = *(_BYTE **)(v61 + 16);
    *(_QWORD *)(v61 + 24) = v67;
    v64 = v67;
  }
LABEL_251:
  if ( v64 == v66 )
  {
    sub_16E7EE0(v61, "\n", 1u);
  }
  else
  {
    *v64 = 10;
    ++*(_QWORD *)(v61 + 24);
  }
  v185 = *(_QWORD *)(a1 + 24);
  v186 = *(_QWORD *)(v185 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v185 + 16) - v186) <= 6 )
  {
    sub_16E7EE0(v185, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v186 = 1869771333;
    *(_WORD *)(v186 + 4) = 14962;
    *(_BYTE *)(v186 + 6) = 32;
    *(_QWORD *)(v185 + 24) += 7LL;
  }
  v187 = *(_QWORD *)(a1 + 24);
  v188 = *(__m128i **)(v187 + 24);
  if ( *(_QWORD *)(v187 + 16) - (_QWORD)v188 <= 0x18u )
  {
    v187 = sub_16E7EE0(*(_QWORD *)(a1 + 24), "64-bit (mixed pointers): ", 0x19u);
  }
  else
  {
    v189 = _mm_load_si128((const __m128i *)&xmmword_42D0CC0);
    v188[1].m128i_i8[8] = 32;
    v188[1].m128i_i64[0] = 0x3A29737265746E69LL;
    *v188 = v189;
    *(_QWORD *)(v187 + 24) += 25LL;
  }
  if ( !off_4CD4920[0] )
    goto LABEL_282;
  srcc = off_4CD4920[0];
  v190 = strlen(off_4CD4920[0]);
  v191 = *(_BYTE **)(v187 + 24);
  v192 = v190;
  v193 = *(_BYTE **)(v187 + 16);
  if ( v192 > v193 - v191 )
  {
    v187 = sub_16E7EE0(v187, srcc, v192);
LABEL_282:
    v193 = *(_BYTE **)(v187 + 16);
    v191 = *(_BYTE **)(v187 + 24);
    goto LABEL_283;
  }
  if ( v192 )
  {
    memcpy(v191, srcc, v192);
    v194 = (_BYTE *)(*(_QWORD *)(v187 + 24) + v192);
    v193 = *(_BYTE **)(v187 + 16);
    *(_QWORD *)(v187 + 24) = v194;
    v191 = v194;
  }
LABEL_283:
  if ( v193 == v191 )
  {
    sub_16E7EE0(v187, "\n", 1u);
  }
  else
  {
    *v191 = 10;
    ++*(_QWORD *)(v187 + 24);
  }
  v206 = *(_QWORD *)(a1 + 24);
  v207 = *(_QWORD *)(v206 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(v206 + 16) - v207) <= 6 )
  {
    sub_16E7EE0(v206, "Error: ", 7u);
  }
  else
  {
    *(_DWORD *)v207 = 1869771333;
    *(_WORD *)(v207 + 4) = 14962;
    *(_BYTE *)(v207 + 6) = 32;
    *(_QWORD *)(v206 + 24) += 7LL;
  }
  v197 = *(_QWORD *)(a1 + 24);
  v208 = *(_QWORD **)(v197 + 24);
  if ( *(_QWORD *)(v197 + 16) - (_QWORD)v208 <= 7u )
  {
    v197 = sub_16E7EE0(*(_QWORD *)(a1 + 24), "64-bit: ", 8u);
  }
  else
  {
    *v208 = 0x203A7469622D3436LL;
    *(_QWORD *)(v197 + 24) += 8LL;
  }
  v199 = off_4CD4928[0];
  if ( !off_4CD4928[0] )
    goto LABEL_279;
LABEL_270:
  v200 = strlen(v199);
  v201 = *(_BYTE **)(v197 + 24);
  v202 = v200;
  v203 = *(_BYTE **)(v197 + 16);
  if ( v202 <= v203 - v201 )
  {
    if ( v202 )
    {
      memcpy(v201, v199, v202);
      v204 = (_BYTE *)(*(_QWORD *)(v197 + 24) + v202);
      v203 = *(_BYTE **)(v197 + 16);
      *(_QWORD *)(v197 + 24) = v204;
      v201 = v204;
    }
    goto LABEL_273;
  }
  v197 = sub_16E7EE0(v197, v199, v202);
LABEL_279:
  v203 = *(_BYTE **)(v197 + 16);
  v201 = *(_BYTE **)(v197 + 24);
LABEL_273:
  if ( v203 == v201 )
  {
    v199 = "\n";
    sub_16E7EE0(v197, "\n", 1u);
  }
  else
  {
    *v201 = 10;
    ++*(_QWORD *)(v197 + 24);
  }
  sub_1C31880(a1);
  if ( (v248 & 1) != 0 || (v248 & 0xFFFFFFFFFFFFFFFELL) != 0 )
    sub_16BCAE0(&v248, (__int64)v199, v205);
LABEL_12:
  v250 = (char *)v252;
  sub_1C318F0((__int64 *)&v250, a2[30], (__int64)a2[31] + (_QWORD)a2[30]);
  if ( v251 )
  {
    if ( *(_DWORD *)a1 != 1 )
      goto LABEL_14;
  }
  else
  {
    v68 = *(_QWORD *)(a1 + 24);
    v69 = *(_QWORD *)(v68 + 24);
    if ( (unsigned __int64)(*(_QWORD *)(v68 + 16) - v69) <= 6 )
    {
      sub_16E7EE0(v68, "Error: ", 7u);
    }
    else
    {
      *(_DWORD *)v69 = 1869771333;
      *(_WORD *)(v69 + 4) = 14962;
      *(_BYTE *)(v69 + 6) = 32;
      *(_QWORD *)(v68 + 24) += 7LL;
    }
    v70 = *(_QWORD *)(a1 + 24);
    v71 = *(__m128i **)(v70 + 24);
    if ( *(_QWORD *)(v70 + 16) - (_QWORD)v71 <= 0x1Fu )
    {
      sub_16E7EE0(v70, "Empty target triple, must exist\n", 0x20u);
    }
    else
    {
      *v71 = _mm_load_si128((const __m128i *)&xmmword_42D0CD0);
      v71[1] = _mm_load_si128((const __m128i *)&xmmword_42D0CE0);
      *(_QWORD *)(v70 + 24) += 32LL;
    }
    sub_1C31880(a1);
    if ( *(_DWORD *)a1 != 1 )
    {
LABEL_14:
      if ( sub_22416F0(&v250, "nvptx-", 0, 6) && sub_22416F0(&v250, "nvptx64-", 0, 8)
        || sub_2241820(&v250, "-cuda", -1, 5) == -1 )
      {
        v12 = *(_QWORD *)(a1 + 24);
        v13 = *(_QWORD *)(v12 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v12 + 16) - v13) <= 6 )
        {
          sub_16E7EE0(v12, "Error: ", 7u);
        }
        else
        {
          *(_DWORD *)v13 = 1869771333;
          *(_WORD *)(v13 + 4) = 14962;
          *(_BYTE *)(v13 + 6) = 32;
          *(_QWORD *)(v12 + 24) += 7LL;
        }
        v14 = *(_QWORD *)(a1 + 24);
        v15 = *(__m128i **)(v14 + 24);
        if ( *(_QWORD *)(v14 + 16) - (_QWORD)v15 <= 0x16u )
        {
          v14 = sub_16E7EE0(v14, "Invalid target triple (", 0x17u);
        }
        else
        {
          v16 = _mm_load_si128((const __m128i *)&xmmword_42D0CF0);
          v15[1].m128i_i32[0] = 1819306354;
          v15[1].m128i_i16[2] = 8293;
          v15[1].m128i_i8[6] = 40;
          *v15 = v16;
          *(_QWORD *)(v14 + 24) += 23LL;
        }
        v17 = sub_16E7EE0(v14, v250, v251);
        v18 = *(__m128i **)(v17 + 24);
        if ( *(_QWORD *)(v17 + 16) - (_QWORD)v18 <= 0x12u )
        {
          sub_16E7EE0(v17, "), must be one of:\n", 0x13u);
        }
        else
        {
          v19 = _mm_load_si128((const __m128i *)&xmmword_42D0D00);
          v18[1].m128i_i8[2] = 10;
          v18[1].m128i_i16[0] = 14950;
          *v18 = v19;
          *(_QWORD *)(v17 + 24) += 19LL;
        }
        v20 = *(_QWORD *)(a1 + 24);
        v21 = *(_QWORD *)(v20 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v20 + 16) - v21) <= 6 )
        {
          sub_16E7EE0(v20, "Error: ", 7u);
        }
        else
        {
          *(_DWORD *)v21 = 1869771333;
          *(_WORD *)(v21 + 4) = 14962;
          *(_BYTE *)(v21 + 6) = 32;
          *(_QWORD *)(v20 + 24) += 7LL;
        }
        v22 = *(_QWORD *)(a1 + 24);
        v23 = *(_QWORD **)(v22 + 24);
        if ( *(_QWORD *)(v22 + 16) - (_QWORD)v23 <= 7u )
        {
          v22 = sub_16E7EE0(v22, "32-bit: ", 8u);
          v24 = *(void **)(v22 + 24);
        }
        else
        {
          *v23 = 0x203A7469622D3233LL;
          v24 = (void *)(*(_QWORD *)(v22 + 24) + 8LL);
          *(_QWORD *)(v22 + 24) = v24;
        }
        if ( *(_QWORD *)(v22 + 16) - (_QWORD)v24 <= 0xBu )
        {
          v22 = sub_16E7EE0(v22, "nvptx-*-cuda", 0xCu);
          v25 = *(_BYTE **)(v22 + 24);
        }
        else
        {
          qmemcpy(v24, "nvptx-*-cuda", 12);
          v25 = (_BYTE *)(*(_QWORD *)(v22 + 24) + 12LL);
          *(_QWORD *)(v22 + 24) = v25;
        }
        if ( *(_BYTE **)(v22 + 16) == v25 )
        {
          sub_16E7EE0(v22, "\n", 1u);
        }
        else
        {
          *v25 = 10;
          ++*(_QWORD *)(v22 + 24);
        }
        v26 = *(_QWORD *)(a1 + 24);
        v27 = *(_QWORD *)(v26 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v26 + 16) - v27) <= 6 )
        {
          sub_16E7EE0(v26, "Error: ", 7u);
        }
        else
        {
          *(_DWORD *)v27 = 1869771333;
          *(_WORD *)(v27 + 4) = 14962;
          *(_BYTE *)(v27 + 6) = 32;
          *(_QWORD *)(v26 + 24) += 7LL;
        }
        v28 = *(_QWORD *)(a1 + 24);
        v29 = *(_QWORD **)(v28 + 24);
        if ( *(_QWORD *)(v28 + 16) - (_QWORD)v29 <= 7u )
        {
          v28 = sub_16E7EE0(v28, "64-bit: ", 8u);
          v30 = *(void **)(v28 + 24);
        }
        else
        {
          *v29 = 0x203A7469622D3436LL;
          v30 = (void *)(*(_QWORD *)(v28 + 24) + 8LL);
          *(_QWORD *)(v28 + 24) = v30;
        }
        if ( *(_QWORD *)(v28 + 16) - (_QWORD)v30 <= 0xDu )
        {
          v28 = sub_16E7EE0(v28, "nvptx64-*-cuda", 0xEu);
          v31 = *(_BYTE **)(v28 + 24);
        }
        else
        {
          qmemcpy(v30, "nvptx64-*-cuda", 14);
          v31 = (_BYTE *)(*(_QWORD *)(v28 + 24) + 14LL);
          *(_QWORD *)(v28 + 24) = v31;
        }
        if ( *(_BYTE **)(v28 + 16) == v31 )
        {
          sub_16E7EE0(v28, "\n", 1u);
        }
        else
        {
          *v31 = 10;
          ++*(_QWORD *)(v28 + 24);
        }
        sub_1C31880(a1);
      }
      goto LABEL_39;
    }
  }
  if ( (unsigned int)sub_2241AC0(&v250, "nvptx-nvidia-cuda")
    && (unsigned int)sub_2241AC0(&v250, "nvptx64-nvidia-cuda")
    && (unsigned int)sub_2241AC0(&v250, "nvptx-nvidia-nvcl")
    && (unsigned int)sub_2241AC0(&v250, "nvptx64-nvidia-nvcl")
    && (unsigned int)sub_2241AC0(&v250, "nvsass-nvidia-cuda")
    && (unsigned int)sub_2241AC0(&v250, "nvsass-nvidia-nvcl")
    && (unsigned int)sub_2241AC0(&v250, "nvsass-nvidia-directx")
    && (unsigned int)sub_2241AC0(&v250, "nvsass-nvidia-spirv") )
  {
    sub_1263B40(*(_QWORD *)(a1 + 24), "Error: ");
    sub_1263B40(*(_QWORD *)(a1 + 24), "Invalid target triple\n");
    sub_1C31880(a1);
  }
LABEL_39:
  for ( k = (__int64)a2[10]; a2 + 9 != (_QWORD **)k; k = *(_QWORD *)(k + 8) )
  {
    v33 = 0;
    v34 = sub_161F520(k);
    if ( v34 )
    {
      do
      {
        v35 = sub_161F530(k, v33);
        if ( v35 )
          sub_1C35DC0(a1, v35);
        ++v33;
      }
      while ( v34 != v33 );
    }
  }
  v36 = a1;
  v241 = a2[4];
  if ( v227 != v241 )
  {
    while ( 1 )
    {
      v37 = v241;
      v38 = (__int64)(v241 - 7);
      v241 = (_QWORD *)v241[1];
      sub_1C32740(v36, v38);
      src = v37 + 2;
      if ( v37 + 2 != (_QWORD *)v37[3] )
        break;
LABEL_119:
      if ( v227 == v241 )
        goto LABEL_120;
    }
    v247 = (_QWORD *)v37[3];
    while ( 1 )
    {
      v39 = (__int16 *)v247[3];
      v40 = (__int16 *)(v247 + 2);
      v247 = (_QWORD *)v247[1];
      while ( v40 != v39 )
      {
LABEL_50:
        v41 = v39;
        v39 = (__int16 *)*((_QWORD *)v39 + 1);
        v42 = (__int64)(v41 - 12);
        switch ( *((_BYTE *)v41 - 8) )
        {
          case 0x18:
          case 0x58:
            sub_1C32630(v36, "landingpad", (__int64)(v41 - 12));
            continue;
          case 0x19:
          case 0x1B:
          case 0x1F:
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x23:
          case 0x24:
          case 0x25:
          case 0x26:
          case 0x27:
          case 0x28:
          case 0x29:
          case 0x2A:
          case 0x2B:
          case 0x2C:
          case 0x2D:
          case 0x2E:
          case 0x2F:
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x38:
          case 0x3C:
          case 0x3D:
          case 0x3E:
          case 0x3F:
          case 0x40:
          case 0x41:
          case 0x42:
          case 0x43:
          case 0x44:
          case 0x45:
          case 0x46:
          case 0x47:
          case 0x49:
          case 0x4A:
          case 0x4B:
          case 0x4C:
          case 0x4D:
          case 0x4F:
          case 0x50:
          case 0x51:
          case 0x52:
          case 0x53:
          case 0x54:
          case 0x55:
          case 0x56:
          case 0x57:
            goto LABEL_116;
          case 0x1A:
            if ( !*((_QWORD *)v41 + 3) && *(v41 - 3) >= 0 )
            {
              sub_1C34B00(v36, (__int64)(v41 - 12));
              goto LABEL_117;
            }
            v234 = (__int64)(v41 - 12);
            v115 = sub_1625940((__int64)(v41 - 12), "pragma", 6u);
            v42 = (__int64)(v41 - 12);
            v116 = v115;
            if ( !v115 )
              goto LABEL_116;
            v117 = *(unsigned int *)(v115 + 8);
            if ( (_DWORD)v117 != 2 )
            {
              v118 = *(_QWORD *)(v36 + 24);
              v119 = *(_QWORD *)(v118 + 24);
              if ( (unsigned __int64)(*(_QWORD *)(v118 + 16) - v119) <= 6 )
              {
                sub_16E7EE0(v118, "Error: ", 7u);
                v42 = v234;
              }
              else
              {
                *(_DWORD *)v119 = 1869771333;
                *(_WORD *)(v119 + 4) = 14962;
                *(_BYTE *)(v119 + 6) = 32;
                *(_QWORD *)(v118 + 24) += 7LL;
              }
              v120 = *(_QWORD *)(v36 + 24);
              v121 = *(_WORD **)(v120 + 24);
              if ( *(_QWORD *)(v120 + 16) - (_QWORD)v121 <= 1u )
              {
                v239 = v42;
                sub_16E7EE0(v120, ": ", 2u);
                v42 = v239;
              }
              else
              {
                *v121 = 8250;
                *(_QWORD *)(v120 + 24) += 2LL;
              }
              v235 = v42;
              sub_1556280((unsigned __int8 *)v116, *(_QWORD *)(v36 + 24), 0);
              v122 = *(_QWORD *)(v36 + 24);
              v42 = v235;
              v123 = *(_QWORD *)(v122 + 24);
              if ( (unsigned __int64)(*(_QWORD *)(v122 + 16) - v123) <= 2 )
              {
                sub_16E7EE0(v122, "\n  ", 3u);
                v42 = v235;
              }
              else
              {
                *(_BYTE *)(v123 + 2) = 32;
                *(_WORD *)v123 = 8202;
                *(_QWORD *)(v122 + 24) += 3LL;
              }
              v92 = *(_QWORD *)(v36 + 24);
              v124 = *(__m128i **)(v92 + 24);
              if ( *(_QWORD *)(v92 + 16) - (_QWORD)v124 <= 0x2Fu )
              {
                v238 = v42;
                v159 = sub_16E7EE0(v92, "branch pragma metadata does not have 2 operands?", 0x30u);
                v42 = v238;
                v92 = v159;
                v93 = *(_BYTE **)(v159 + 24);
              }
              else
              {
                *v124 = _mm_load_si128((const __m128i *)&xmmword_42D0D10);
                v124[1] = _mm_load_si128((const __m128i *)&xmmword_42D0D20);
                v124[2] = _mm_load_si128((const __m128i *)&xmmword_42D0D30);
                v93 = (_BYTE *)(*(_QWORD *)(v92 + 24) + 48LL);
                *(_QWORD *)(v92 + 24) = v93;
              }
              if ( v93 == *(_BYTE **)(v92 + 16) )
              {
LABEL_159:
                v236 = v42;
                sub_16E7EE0(v92, "\n", 1u);
                v42 = v236;
              }
              else
              {
LABEL_114:
                *v93 = 10;
                ++*(_QWORD *)(v92 + 24);
              }
              goto LABEL_115;
            }
            if ( *(_BYTE *)(v116 + 1) == 1 )
            {
              v116 = *(_QWORD *)(v116 - 8);
              if ( (unsigned __int8)(*(_BYTE *)v116 - 4) > 0x1Eu )
                goto LABEL_116;
              v117 = *(unsigned int *)(v116 + 8);
            }
            v135 = *(_BYTE **)(v116 - 8 * v117);
            if ( v135 )
            {
              if ( !*v135 )
              {
                v136 = sub_161E970((__int64)v135);
                v42 = v234;
                if ( v137 == 6 && *(_DWORD *)v136 == 1869770357 && *(_WORD *)(v136 + 4) == 27756 )
                {
                  v138 = *(_QWORD *)(v36 + 24);
                  v139 = *(_QWORD *)(v138 + 24);
                  if ( (unsigned __int64)(*(_QWORD *)(v138 + 16) - v139) <= 6 )
                  {
                    sub_16E7EE0(v138, "Error: ", 7u);
                    v42 = v234;
                  }
                  else
                  {
                    *(_DWORD *)v139 = 1869771333;
                    *(_WORD *)(v139 + 4) = 14962;
                    *(_BYTE *)(v139 + 6) = 32;
                    *(_QWORD *)(v138 + 24) += 7LL;
                  }
                  v140 = *(_QWORD *)(v36 + 24);
                  v141 = *(__m128i **)(v140 + 24);
                  if ( *(_QWORD *)(v140 + 16) - (_QWORD)v141 <= 0x49u )
                  {
                    v240 = v42;
                    sub_16E7EE0(
                      v140,
                      "pragma unroll is not supported.  Please use llvm.loop.unroll.count instead",
                      0x4Au);
                    v42 = v240;
                  }
                  else
                  {
                    v142 = _mm_load_si128((const __m128i *)&xmmword_42D0D40);
                    qmemcpy(&v141[4], "nt instead", 10);
                    *v141 = v142;
                    v141[1] = _mm_load_si128((const __m128i *)&xmmword_42D0D50);
                    v141[2] = _mm_load_si128((const __m128i *)&xmmword_42D0D60);
                    v141[3] = _mm_load_si128((const __m128i *)&xmmword_42D0D70);
                    *(_QWORD *)(v140 + 24) += 74LL;
                  }
                  goto LABEL_115;
                }
              }
            }
            goto LABEL_116;
          case 0x1C:
            sub_1C32630(v36, "indirectbr", (__int64)(v41 - 12));
            continue;
          case 0x1D:
            sub_1C32630(v36, "invoke", (__int64)(v41 - 12));
            continue;
          case 0x1E:
            sub_1C32630(v36, "resume", (__int64)(v41 - 12));
            continue;
          case 0x35:
            if ( (unsigned int)(1 << *(v41 - 3)) <= 0x1000001 )
              goto LABEL_116;
            v125 = sub_1C321C0(v36, (__int64)(v41 - 12), 0);
            sub_1263B40(v125, "alloca align must be <= 2^23\n");
            sub_1C31880(v36);
            sub_1C34B00(v36, (__int64)(v41 - 12));
            goto LABEL_117;
          case 0x36:
          case 0x37:
            v231 = (__int64)(v41 - 12);
            v94 = sub_15F32D0((__int64)(v41 - 12));
            v42 = (__int64)(v41 - 12);
            if ( !v94 )
              goto LABEL_116;
            v95 = sub_1C321C0(v36, v231, 0);
            sub_1263B40(v95, "Atomic loads/stores are not supported\n");
            sub_1C31880(v36);
            sub_1C34B00(v36, v231);
            goto LABEL_117;
          case 0x39:
            if ( *(_DWORD *)v36 == 1 )
            {
              if ( (((unsigned __int16)*(v41 - 3) >> 1) & 0x7FFFBFFFu) - 6 <= 1 )
              {
LABEL_116:
                sub_1C34B00(v36, v42);
              }
              else
              {
                v96 = sub_1C321C0(v36, (__int64)(v41 - 12), 0);
                v97 = sub_1263B40(v96, "Invalid ordering for fence, only acq_rel and seq_cst are supported.");
                sub_1263B40(v97, "\n");
                sub_1C31880(v36);
                sub_1C34B00(v36, (__int64)(v41 - 12));
              }
LABEL_117:
              if ( v40 == v39 )
                goto LABEL_118;
              goto LABEL_50;
            }
            sub_1C32630(v36, "fence", (__int64)(v41 - 12));
            break;
          case 0x3A:
            sub_1C36220(v36, (__int64)(v41 - 12));
            continue;
          case 0x3B:
            v98 = *((_QWORD *)v41 - 3);
            v232 = v98;
            if ( *(_BYTE *)(v98 + 8) != 11 )
              goto LABEL_131;
            v143 = sub_1643030(v98);
            v42 = (__int64)(v41 - 12);
            if ( ((v143 - 32) & 0xFFFFFFDF) == 0 || v143 == 128 )
              goto LABEL_131;
            v144 = sub_1C321C0(v36, (__int64)(v41 - 12), 0);
            v145 = (__int64)(v41 - 12);
            v146 = v144;
            v147 = *(__m128i **)(v144 + 24);
            if ( *(_QWORD *)(v146 + 16) - (_QWORD)v147 <= 0x2Fu )
            {
              v184 = sub_16E7EE0(v146, "Atomic operations on non-i32/i64/i128 types are ", 0x30u);
              v145 = (__int64)(v41 - 12);
              v146 = v184;
              v148 = *(void **)(v184 + 24);
              if ( *(_QWORD *)(v146 + 16) - (_QWORD)v148 > 0xDu )
              {
LABEL_190:
                qmemcpy(v148, "not supported\n", 14);
                *(_QWORD *)(v146 + 24) += 14LL;
                goto LABEL_191;
              }
            }
            else
            {
              *v147 = _mm_load_si128((const __m128i *)&xmmword_42D0AF0);
              v147[1] = _mm_load_si128((const __m128i *)&xmmword_42D0B00);
              v147[2] = _mm_load_si128((const __m128i *)&xmmword_42D0B10);
              v148 = (void *)(*(_QWORD *)(v146 + 24) + 48LL);
              v149 = *(_QWORD *)(v146 + 16) - (_QWORD)v148;
              *(_QWORD *)(v146 + 24) = v148;
              if ( v149 > 0xD )
                goto LABEL_190;
            }
            v226 = v145;
            sub_16E7EE0(v146, "not supported\n", 0xEu);
            v145 = v226;
LABEL_191:
            v218 = v145;
            sub_1C31880(v36);
            v42 = v218;
LABEL_131:
            v99 = **((_QWORD **)v41 - 9);
            if ( *(_BYTE *)(v99 + 8) != 15 )
            {
              v213 = v42;
              v100 = sub_1C321C0(v36, v42, 0);
              v101 = v213;
              v102 = *(__m128i **)(v100 + 24);
              v103 = v100;
              if ( *(_QWORD *)(v100 + 16) - (_QWORD)v102 <= 0x27u )
              {
                v158 = sub_16E7EE0(v100, "atomicrmw pointer operand not a pointer?", 0x28u);
                v101 = v213;
                v103 = v158;
                v105 = *(_BYTE **)(v158 + 24);
              }
              else
              {
                v104 = _mm_load_si128((const __m128i *)&xmmword_42D0D80);
                v102[2].m128i_i64[0] = 0x3F7265746E696F70LL;
                *v102 = v104;
                v102[1] = _mm_load_si128((const __m128i *)&xmmword_42D0D90);
                v105 = (_BYTE *)(*(_QWORD *)(v100 + 24) + 40LL);
                *(_QWORD *)(v103 + 24) = v105;
              }
              if ( v105 == *(_BYTE **)(v103 + 16) )
              {
                v223 = v101;
                sub_16E7EE0(v103, "\n", 1u);
                v101 = v223;
              }
              else
              {
                *v105 = 10;
                ++*(_QWORD *)(v103 + 24);
              }
LABEL_136:
              v214 = v101;
              sub_1C31880(v36);
              v42 = v214;
              goto LABEL_137;
            }
            v128 = *(_DWORD *)(v99 + 8);
            if ( v128 > 0x1FF && v128 >> 8 != 3 )
            {
              v217 = v42;
              v129 = sub_1C321C0(v36, v42, 0);
              v101 = v217;
              v130 = *(__m128i **)(v129 + 24);
              v131 = v129;
              if ( *(_QWORD *)(v129 + 16) - (_QWORD)v130 <= 0x27u )
              {
                v167 = sub_16E7EE0(v129, "atomicrmw pointer operand must point to ", 0x28u);
                v101 = v217;
                v131 = v167;
                v133 = *(_QWORD *)(v167 + 24);
              }
              else
              {
                v132 = _mm_load_si128((const __m128i *)&xmmword_42D0D80);
                v130[2].m128i_i64[0] = 0x206F7420746E696FLL;
                *v130 = v132;
                v130[1] = _mm_load_si128((const __m128i *)&xmmword_42D0DA0);
                v133 = *(_QWORD *)(v129 + 24) + 40LL;
                *(_QWORD *)(v131 + 24) = v133;
              }
              if ( (unsigned __int64)(*(_QWORD *)(v131 + 16) - v133) <= 0x28 )
              {
                v225 = v101;
                sub_16E7EE0(v131, "generic, global, or shared address space\n", 0x29u);
                v101 = v225;
              }
              else
              {
                v134 = _mm_load_si128((const __m128i *)&xmmword_42D0DB0);
                *(_BYTE *)(v133 + 40) = 10;
                *(_QWORD *)(v133 + 32) = 0x6563617073207373LL;
                *(__m128i *)v133 = v134;
                *(__m128i *)(v133 + 16) = _mm_load_si128((const __m128i *)&xmmword_42D0DC0);
                *(_QWORD *)(v131 + 24) += 41LL;
              }
              goto LABEL_136;
            }
LABEL_137:
            v106 = ((unsigned __int16)*(v41 - 3) >> 5) & 0x7FFFBFF;
            if ( v106 <= 3 )
              goto LABEL_138;
            if ( v106 - 5 <= 5 )
            {
              v216 = v42;
              v126 = sub_1643030(v232);
              v42 = v216;
              if ( v126 == 128 )
                goto LABEL_140;
              sub_1C34B00(v36, v216);
              goto LABEL_117;
            }
            v219 = v42;
            v150 = sub_1C321C0(v36, v42, 0);
            v151 = v219;
            v152 = *(__m128i **)(v150 + 24);
            v153 = v150;
            if ( *(_QWORD *)(v150 + 16) - (_QWORD)v152 <= 0x23u )
            {
              v161 = sub_16E7EE0(v150, "atomicrmw does not support operation", 0x24u);
              v151 = v219;
              v155 = *(_WORD **)(v161 + 24);
              v153 = v161;
            }
            else
            {
              v154 = _mm_load_si128((const __m128i *)&xmmword_42D0DD0);
              v152[2].m128i_i32[0] = 1852795252;
              *v152 = v154;
              v152[1] = _mm_load_si128((const __m128i *)&xmmword_42D0DE0);
              v155 = (_WORD *)(*(_QWORD *)(v150 + 24) + 36LL);
              *(_QWORD *)(v150 + 24) = v155;
            }
            if ( *(_QWORD *)(v153 + 16) - (_QWORD)v155 <= 1u )
            {
              v224 = v151;
              sub_16E7EE0(v153, ".\n", 2u);
              v151 = v224;
            }
            else
            {
              *v155 = 2606;
              *(_QWORD *)(v153 + 24) += 2LL;
            }
            v220 = v151;
            sub_1C31880(v36);
            v42 = v220;
LABEL_138:
            v215 = v42;
            v107 = sub_1643030(v232);
            v42 = v215;
            if ( v107 == 128 && (*(v41 - 3) & 0x7FE0) != 0 )
            {
LABEL_140:
              v233 = v42;
              v108 = sub_1C321C0(v36, v42, 0);
              v42 = v233;
              v109 = v108;
              v110 = *(__m128i **)(v108 + 24);
              if ( *(_QWORD *)(v109 + 16) - (_QWORD)v110 <= 0x32u )
              {
                v127 = sub_16E7EE0(v109, "Atomic operations on i128 types are only supported ", 0x33u);
                v42 = v233;
                v109 = v127;
                v112 = *(_QWORD *)(v127 + 24);
                if ( (unsigned __int64)(*(_QWORD *)(v109 + 16) - v112) <= 0x12 )
                  goto LABEL_168;
LABEL_142:
                v114 = _mm_load_si128((const __m128i *)&xmmword_42D0E10);
                *(_BYTE *)(v112 + 18) = 10;
                *(_WORD *)(v112 + 16) = 28271;
                *(__m128i *)v112 = v114;
                *(_QWORD *)(v109 + 24) += 19LL;
              }
              else
              {
                v111 = _mm_load_si128((const __m128i *)&xmmword_42D0AF0);
                v110[3].m128i_i8[2] = 32;
                v110[3].m128i_i16[0] = 25701;
                *v110 = v111;
                v110[1] = _mm_load_si128((const __m128i *)&xmmword_42D0DF0);
                v110[2] = _mm_load_si128((const __m128i *)&xmmword_42D0E00);
                v112 = *(_QWORD *)(v109 + 24) + 51LL;
                v113 = *(_QWORD *)(v109 + 16) - v112;
                *(_QWORD *)(v109 + 24) = v112;
                if ( v113 > 0x12 )
                  goto LABEL_142;
LABEL_168:
                v237 = v42;
                sub_16E7EE0(v109, "for xchg operation\n", 0x13u);
                v42 = v237;
              }
LABEL_115:
              v230 = v42;
              sub_1C31880(v36);
              v42 = v230;
              goto LABEL_116;
            }
            goto LABEL_116;
          case 0x48:
            v74 = **((_QWORD **)v41 - 6);
            v75 = *((_QWORD *)v41 - 3);
            if ( *(_BYTE *)(v74 + 8) == 16 )
              v74 = **(_QWORD **)(v74 + 16);
            v76 = *(_DWORD *)(v74 + 8) >> 8;
            if ( *(_BYTE *)(v75 + 8) == 16 )
              v75 = **(_QWORD **)(v75 + 16);
            v77 = *(_DWORD *)(v75 + 8);
            v228 = v77 >> 8;
            if ( v77 > 0x1FF && (((unsigned int)&loc_FFFFFD + (v77 >> 8)) & 0xFFFFFF) > 2 )
            {
              v209 = v42;
              v78 = sub_1C321C0(v36, v42, 0);
              v79 = v209;
              v80 = *(__m128i **)(v78 + 24);
              v81 = v78;
              if ( *(_QWORD *)(v78 + 16) - (_QWORD)v80 <= 0x1Bu )
              {
                v156 = sub_16E7EE0(v78, "Invalid target address space", 0x1Cu);
                v79 = v209;
                v81 = v156;
                v83 = *(_BYTE **)(v156 + 24);
              }
              else
              {
                v82 = _mm_load_si128((const __m128i *)&xmmword_42D0E20);
                qmemcpy(&v80[1], "ddress space", 12);
                *v80 = v82;
                v83 = (_BYTE *)(*(_QWORD *)(v78 + 24) + 28LL);
                *(_QWORD *)(v81 + 24) = v83;
              }
              if ( *(_BYTE **)(v81 + 16) == v83 )
              {
                v221 = v79;
                sub_16E7EE0(v81, "\n", 1u);
                v79 = v221;
              }
              else
              {
                *v83 = 10;
                ++*(_QWORD *)(v81 + 24);
              }
              v210 = v79;
              sub_1C31880(v36);
              v42 = v210;
            }
            if ( (unsigned int)v76 > 1 && ((unsigned int)((unsigned int)&loc_FFFFFD + v76) & 0xFFFFFF) > 2 )
            {
              v211 = v42;
              v84 = sub_1C321C0(v36, v42, 0);
              v85 = v211;
              v86 = *(__m128i **)(v84 + 24);
              v87 = v84;
              if ( *(_QWORD *)(v84 + 16) - (_QWORD)v86 <= 0x1Bu )
              {
                v157 = sub_16E7EE0(v84, "Invalid source address space", 0x1Cu);
                v85 = v211;
                v87 = v157;
                v89 = *(_BYTE **)(v157 + 24);
              }
              else
              {
                v88 = _mm_load_si128((const __m128i *)&xmmword_42D0E30);
                qmemcpy(&v86[1], "ddress space", 12);
                *v86 = v88;
                v89 = (_BYTE *)(*(_QWORD *)(v84 + 24) + 28LL);
                *(_QWORD *)(v87 + 24) = v89;
              }
              if ( *(_BYTE **)(v87 + 16) == v89 )
              {
                v222 = v85;
                sub_16E7EE0(v87, "\n", 1u);
                v85 = v222;
              }
              else
              {
                *v89 = 10;
                ++*(_QWORD *)(v87 + 24);
              }
              v212 = v85;
              sub_1C31880(v36);
              v42 = v212;
            }
            if ( !(_DWORD)v76 || !v228 )
              goto LABEL_116;
            v229 = v42;
            v90 = sub_1C321C0(v36, v42, 0);
            v42 = v229;
            v91 = *(__m128i **)(v90 + 24);
            v92 = v90;
            if ( *(_QWORD *)(v90 + 16) - (_QWORD)v91 <= 0x3Fu )
            {
              v160 = sub_16E7EE0(v90, "Cannot cast non-generic pointer to different non-generic pointer", 0x40u);
              v42 = v229;
              v92 = v160;
              v93 = *(_BYTE **)(v160 + 24);
            }
            else
            {
              *v91 = _mm_load_si128((const __m128i *)&xmmword_42D0E40);
              v91[1] = _mm_load_si128((const __m128i *)&xmmword_42D0E50);
              v91[2] = _mm_load_si128((const __m128i *)&xmmword_42D0E60);
              v91[3] = _mm_load_si128((const __m128i *)&xmmword_42D0E70);
              v93 = (_BYTE *)(*(_QWORD *)(v90 + 24) + 64LL);
              *(_QWORD *)(v92 + 24) = v93;
            }
            if ( *(_BYTE **)(v92 + 16) != v93 )
              goto LABEL_114;
            goto LABEL_159;
          case 0x4E:
            sub_1C36530(v36, (__int64 *)v41 - 3);
            continue;
        }
      }
LABEL_118:
      if ( src == v247 )
        goto LABEL_119;
    }
  }
LABEL_120:
  if ( v250 != (char *)v252 )
    j_j___libc_free_0(v250, v252[0] + 1LL);
  sub_15A93E0(v253);
}
