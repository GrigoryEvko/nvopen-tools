// Function: sub_1E8AD40
// Address: 0x1e8ad40
//
void __fastcall sub_1E8AD40(__int64 a1)
{
  __int64 v1; // rax
  unsigned int v2; // r14d
  unsigned int v3; // ebx
  unsigned __int64 v4; // r15
  unsigned __int64 v5; // rax
  __int64 v6; // rax
  void *v7; // rdi
  __int64 v8; // rdx
  unsigned int v9; // eax
  __int64 v10; // rax
  _QWORD *v11; // rbx
  _QWORD *v12; // rax
  __int64 *v13; // rax
  __int64 *v14; // r12
  __int64 *v15; // r15
  __int64 *v16; // r14
  __int64 v17; // r10
  __int64 *v18; // r9
  __int64 v19; // r13
  __int64 v20; // rsi
  __int64 *v21; // rdi
  unsigned int v22; // r8d
  __int64 *v23; // rax
  __int64 *v24; // rcx
  __int64 v25; // rax
  __int64 *v26; // r12
  __int64 *v27; // r15
  __int64 *v28; // r10
  __int64 *v29; // r9
  __int64 v30; // rsi
  __int64 *v31; // rdi
  unsigned int v32; // r8d
  __int64 *v33; // rax
  __int64 *v34; // rcx
  __int64 v35; // rax
  int v36; // r8d
  int v37; // r9d
  _QWORD *v38; // rax
  __int64 v39; // rdx
  _DWORD *v40; // rdx
  __int64 v41; // rbx
  char *v42; // rax
  char *i; // rdx
  __int64 v44; // rbx
  __int64 v45; // rdx
  unsigned __int64 v46; // rdi
  unsigned __int64 v47; // rsi
  unsigned __int64 v48; // rbx
  __int64 v49; // rax
  unsigned __int64 v50; // rdx
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // rax
  char v53; // r8
  unsigned __int64 v54; // rax
  unsigned __int64 v55; // rdi
  __int64 v56; // rax
  unsigned __int64 v57; // rax
  char *v58; // rax
  int v59; // r13d
  unsigned __int8 v60; // r15
  __int64 v61; // r12
  __int64 v62; // rax
  char v63; // si
  unsigned __int64 v64; // rdx
  int v65; // r12d
  __int64 v66; // r15
  __int64 v67; // r9
  int v68; // eax
  char *v69; // rax
  __int64 *v70; // rbx
  char *v71; // rax
  void *v72; // rax
  __int64 v73; // rax
  __int64 v74; // rsi
  __int64 **v75; // rdi
  __int64 v76; // r12
  __int64 v77; // rdx
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 v80; // rax
  __int64 v81; // rax
  __int64 v82; // r12
  __int64 v83; // rax
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 *v87; // rbx
  char *v88; // rax
  void *v89; // rax
  __int64 v90; // rax
  __int64 v91; // r12
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // rax
  __int64 v96; // r12
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rax
  unsigned __int64 v101; // rax
  unsigned __int64 v102; // rdi
  __int64 v103; // rdx
  __int16 v104; // ax
  __int64 j; // rdi
  __int64 v106; // rax
  unsigned __int64 v107; // r12
  __int64 v108; // r13
  __int64 *v109; // rax
  char v110; // dl
  __int64 v111; // rbx
  __int64 *v112; // rax
  __int64 *v113; // rcx
  unsigned int v114; // r8d
  __int64 *v115; // rsi
  _QWORD *v116; // rsi
  unsigned int v117; // edi
  _QWORD *v118; // rcx
  void *v119; // rbx
  __int64 v120; // r12
  void *v121; // r8
  int v122; // edx
  int v123; // edx
  __int64 v124; // rdi
  __int64 v125; // rax
  int v126; // r11d
  unsigned int v127; // r10d
  void *v128; // rax
  __int64 v129; // rax
  __int64 v130; // rax
  __int64 v131; // rax
  __int64 v132; // rax
  __int64 v133; // rdi
  __int64 v134; // rsi
  unsigned __int64 v135; // rax
  __int64 v136; // rax
  __int64 v137; // rax
  signed int v138; // [rsp+14h] [rbp-21Ch]
  int v139; // [rsp+18h] [rbp-218h]
  int v140; // [rsp+1Ch] [rbp-214h]
  __int64 v141; // [rsp+20h] [rbp-210h]
  unsigned __int64 v142; // [rsp+30h] [rbp-200h]
  int v143; // [rsp+30h] [rbp-200h]
  unsigned __int8 v144; // [rsp+38h] [rbp-1F8h]
  __int64 v145; // [rsp+38h] [rbp-1F8h]
  unsigned __int64 v146; // [rsp+38h] [rbp-1F8h]
  unsigned __int64 v147; // [rsp+38h] [rbp-1F8h]
  int v148; // [rsp+40h] [rbp-1F0h]
  __int64 v149; // [rsp+40h] [rbp-1F0h]
  __int64 v150; // [rsp+40h] [rbp-1F0h]
  __int64 v151; // [rsp+48h] [rbp-1E8h]
  unsigned __int8 v152; // [rsp+48h] [rbp-1E8h]
  __int64 v153; // [rsp+48h] [rbp-1E8h]
  __int64 v154; // [rsp+48h] [rbp-1E8h]
  __int64 v155; // [rsp+50h] [rbp-1E0h]
  __int64 *v156; // [rsp+50h] [rbp-1E0h]
  __int64 *v157; // [rsp+50h] [rbp-1E0h]
  int v158; // [rsp+58h] [rbp-1D8h]
  void *v159; // [rsp+58h] [rbp-1D8h]
  __int64 v160; // [rsp+60h] [rbp-1D0h]
  _QWORD *v161; // [rsp+60h] [rbp-1D0h]
  __int64 v163; // [rsp+70h] [rbp-1C0h]
  unsigned __int64 v164; // [rsp+78h] [rbp-1B8h] BYREF
  unsigned __int64 v165; // [rsp+80h] [rbp-1B0h]
  unsigned __int64 v166; // [rsp+88h] [rbp-1A8h]
  _QWORD v167[2]; // [rsp+90h] [rbp-1A0h] BYREF
  void (__fastcall *v168)(_QWORD *, _QWORD *, __int64); // [rsp+A0h] [rbp-190h]
  void (__fastcall *v169)(_QWORD *, __int64); // [rsp+A8h] [rbp-188h]
  _QWORD v170[2]; // [rsp+B0h] [rbp-180h] BYREF
  void (__fastcall *v171)(_QWORD *, _QWORD *, __int64); // [rsp+C0h] [rbp-170h]
  void (__fastcall *v172)(_QWORD *, __int64); // [rsp+C8h] [rbp-168h]
  __int64 *v173; // [rsp+D0h] [rbp-160h] BYREF
  char *v174; // [rsp+D8h] [rbp-158h] BYREF
  void (__fastcall *v175)(__int64 **, __int64 **, __int64); // [rsp+E0h] [rbp-150h]
  void (__fastcall *v176)(__int64 **, __int64); // [rsp+E8h] [rbp-148h]
  _QWORD v177[2]; // [rsp+F0h] [rbp-140h] BYREF
  void (__fastcall *v178)(_QWORD *, _QWORD *, __int64); // [rsp+100h] [rbp-130h]
  void (__fastcall *v179)(_QWORD *, __int64); // [rsp+108h] [rbp-128h]
  char v180; // [rsp+110h] [rbp-120h]
  __int64 v181; // [rsp+120h] [rbp-110h] BYREF
  _BYTE *v182; // [rsp+128h] [rbp-108h]
  _BYTE *v183; // [rsp+130h] [rbp-100h]
  __int64 v184; // [rsp+138h] [rbp-F8h]
  int v185; // [rsp+140h] [rbp-F0h]
  _BYTE v186[72]; // [rsp+148h] [rbp-E8h] BYREF
  void *src; // [rsp+190h] [rbp-A0h] BYREF
  __int64 v188; // [rsp+198h] [rbp-98h]
  _DWORD v189[36]; // [rsp+1A0h] [rbp-90h] BYREF

  v1 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 520) = 0;
  v2 = *(_DWORD *)(v1 + 320);
  v160 = v1;
  if ( v2 )
  {
    v189[0] = *(_DWORD *)(v1 + 320);
    src = 0;
    v3 = (v2 + 63) >> 6;
    v188 = 0;
    v120 = v3;
    v121 = (void *)malloc(8LL * v3);
    if ( v121 )
    {
      v4 = (v2 + 63) >> 6;
    }
    else if ( 8LL * v3 || (v137 = malloc(1u), v121 = 0, !v137) )
    {
      v159 = v121;
      sub_16BD1C0("Allocation failed", 1u);
      v2 = v189[0];
      v121 = v159;
      v3 = (unsigned int)(v189[0] + 63) >> 6;
      v4 = v3;
    }
    else
    {
      v4 = (v2 + 63) >> 6;
      v121 = (void *)v137;
    }
    src = v121;
    v188 = v120;
    memcpy(v121, *(const void **)(v160 + 304), 8 * v120);
  }
  else
  {
    (*(void (__fastcall **)(void **, _QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 64LL))(
      &src,
      *(_QWORD *)(a1 + 40),
      *(_QWORD *)(a1 + 16));
    v2 = v189[0];
    v3 = (unsigned int)(v189[0] + 63) >> 6;
    v4 = v3;
  }
  *(_DWORD *)(a1 + 192) = v2;
  v5 = *(_QWORD *)(a1 + 184);
  if ( v2 <= v5 << 6 )
  {
    if ( v2 )
    {
      memcpy(*(void **)(a1 + 176), src, 8 * v4);
      v122 = *(_DWORD *)(a1 + 192);
      v5 = *(_QWORD *)(a1 + 184);
      v3 = (unsigned int)(v122 + 63) >> 6;
      v4 = v3;
      if ( v5 <= v3 )
      {
LABEL_174:
        v123 = v122 & 0x3F;
        if ( v123 )
          *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8LL * (v3 - 1)) &= ~(-1LL << v123);
        goto LABEL_6;
      }
    }
    else if ( v5 <= v4 )
    {
      goto LABEL_6;
    }
    v135 = v5 - v4;
    if ( v135 )
      memset((void *)(*(_QWORD *)(a1 + 176) + 8 * v4), 0, 8 * v135);
    v122 = *(_DWORD *)(a1 + 192);
    goto LABEL_174;
  }
  v119 = (void *)malloc(8 * v4);
  if ( !v119 )
  {
    if ( 8 * v4 || (v136 = malloc(1u)) == 0 )
      sub_16BD1C0("Allocation failed", 1u);
    else
      v119 = (void *)v136;
  }
  memcpy(v119, src, 8 * v4);
  _libc_free(*(_QWORD *)(a1 + 176));
  *(_QWORD *)(a1 + 176) = v119;
  *(_QWORD *)(a1 + 184) = v4;
LABEL_6:
  _libc_free((unsigned __int64)src);
  v6 = *(_QWORD *)(a1 + 16);
  if ( (*(_QWORD *)(v6 + 320) & 0xFFFFFFFFFFFFFFF8LL) != v6 + 320 )
    sub_1E85750(a1, *(_QWORD *)(v6 + 328));
  ++*(_QWORD *)(a1 + 72);
  v7 = *(void **)(a1 + 88);
  v151 = a1 + 72;
  if ( v7 != *(void **)(a1 + 80) )
  {
    v8 = *(unsigned int *)(a1 + 96);
    v9 = 4 * (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 104));
    if ( v9 < 0x20 )
      v9 = 32;
    if ( (unsigned int)v8 > v9 )
    {
      sub_16CC920(v151);
      goto LABEL_14;
    }
    memset(v7, -1, 8 * v8);
  }
  *(_QWORD *)(a1 + 100) = 0;
LABEL_14:
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD **)(v10 + 328);
  v161 = (_QWORD *)(v10 + 320);
  if ( (_QWORD *)(v10 + 320) != v11 )
  {
    while ( 1 )
    {
      v12 = *(_QWORD **)(a1 + 80);
      if ( *(_QWORD **)(a1 + 88) != v12 )
        break;
      v116 = &v12[*(unsigned int *)(a1 + 100)];
      v117 = *(_DWORD *)(a1 + 100);
      if ( v12 == v116 )
      {
LABEL_163:
        if ( v117 >= *(_DWORD *)(a1 + 96) )
          break;
        *(_DWORD *)(a1 + 100) = v117 + 1;
        *v116 = v11;
        ++*(_QWORD *)(a1 + 72);
      }
      else
      {
        v118 = 0;
        while ( (_QWORD *)*v12 != v11 )
        {
          if ( *v12 == -2 )
            v118 = v12;
          if ( v116 == ++v12 )
          {
            if ( !v118 )
              goto LABEL_163;
            *v118 = v11;
            --*(_DWORD *)(a1 + 104);
            ++*(_QWORD *)(a1 + 72);
            break;
          }
        }
      }
LABEL_17:
      src = v11;
      v13 = sub_1E855C0(a1 + 528, (__int64 *)&src);
      v14 = (__int64 *)v11[9];
      v15 = (__int64 *)v11[8];
      v16 = v13;
      if ( v15 != v14 )
      {
        v17 = v13[24];
        v18 = (__int64 *)v13[23];
        v19 = (__int64)(v13 + 22);
        while ( 1 )
        {
LABEL_21:
          v20 = *v15;
          if ( v18 != (__int64 *)v17 )
            goto LABEL_19;
          v21 = &v18[*((unsigned int *)v16 + 51)];
          v22 = *((_DWORD *)v16 + 51);
          if ( v21 != v18 )
          {
            v23 = v18;
            v24 = 0;
            while ( v20 != *v23 )
            {
              if ( *v23 == -2 )
                v24 = v23;
              if ( v21 == ++v23 )
              {
                if ( !v24 )
                  goto LABEL_151;
                ++v15;
                *v24 = v20;
                v17 = v16[24];
                --*((_DWORD *)v16 + 52);
                v18 = (__int64 *)v16[23];
                ++v16[22];
                if ( v14 != v15 )
                  goto LABEL_21;
                goto LABEL_30;
              }
            }
            goto LABEL_20;
          }
LABEL_151:
          if ( v22 < *((_DWORD *)v16 + 50) )
          {
            *((_DWORD *)v16 + 51) = v22 + 1;
            *v21 = v20;
            v18 = (__int64 *)v16[23];
            ++v16[22];
            v17 = v16[24];
          }
          else
          {
LABEL_19:
            sub_16CCBA0(v19, v20);
            v17 = v16[24];
            v18 = (__int64 *)v16[23];
          }
LABEL_20:
          if ( v14 == ++v15 )
          {
LABEL_30:
            v14 = (__int64 *)v11[9];
            v25 = v11[8];
            goto LABEL_31;
          }
        }
      }
      v25 = v11[9];
LABEL_31:
      if ( *((_DWORD *)v16 + 51) - *((_DWORD *)v16 + 52) != (unsigned int)(((__int64)v14 - v25) >> 3) )
        sub_1E869F0(a1, "MBB has duplicate entries in its predecessor list.", (__int64)v11);
      v26 = (__int64 *)v11[12];
      v27 = (__int64 *)v11[11];
      if ( v27 != v26 )
      {
        v28 = (__int64 *)v16[37];
        v29 = (__int64 *)v16[36];
        while ( 1 )
        {
LABEL_37:
          v30 = *v27;
          if ( v29 != v28 )
            goto LABEL_35;
          v31 = &v29[*((unsigned int *)v16 + 77)];
          v32 = *((_DWORD *)v16 + 77);
          if ( v31 != v29 )
          {
            v33 = v29;
            v34 = 0;
            while ( v30 != *v33 )
            {
              if ( *v33 == -2 )
                v34 = v33;
              if ( v31 == ++v33 )
              {
                if ( !v34 )
                  goto LABEL_149;
                ++v27;
                *v34 = v30;
                v28 = (__int64 *)v16[37];
                --*((_DWORD *)v16 + 78);
                v29 = (__int64 *)v16[36];
                ++v16[35];
                if ( v26 != v27 )
                  goto LABEL_37;
                goto LABEL_46;
              }
            }
            goto LABEL_36;
          }
LABEL_149:
          if ( v32 < *((_DWORD *)v16 + 76) )
          {
            *((_DWORD *)v16 + 77) = v32 + 1;
            *v31 = v30;
            v29 = (__int64 *)v16[36];
            ++v16[35];
            v28 = (__int64 *)v16[37];
          }
          else
          {
LABEL_35:
            sub_16CCBA0((__int64)(v16 + 35), v30);
            v28 = (__int64 *)v16[37];
            v29 = (__int64 *)v16[36];
          }
LABEL_36:
          if ( v26 == ++v27 )
          {
LABEL_46:
            v26 = (__int64 *)v11[12];
            v35 = v11[11];
            goto LABEL_47;
          }
        }
      }
      v35 = v11[12];
LABEL_47:
      if ( *((_DWORD *)v16 + 77) - *((_DWORD *)v16 + 78) != (unsigned int)(((__int64)v26 - v35) >> 3) )
        sub_1E869F0(a1, "MBB has duplicate entries in its successor list.", (__int64)v11);
      v11 = (_QWORD *)v11[1];
      if ( v161 == v11 )
        goto LABEL_50;
    }
    sub_16CCBA0(v151, (__int64)v11);
    goto LABEL_17;
  }
LABEL_50:
  nullsub_707();
  v38 = *(_QWORD **)(a1 + 16);
  if ( v38 + 40 == (_QWORD *)(v38[40] & 0xFFFFFFFFFFFFFFF8LL) )
    return;
  v39 = *(_QWORD *)(a1 + 32);
  v140 = *(_DWORD *)(v39 + 36);
  v139 = *(_DWORD *)(v39 + 40);
  if ( (v139 & v140) == 0xFFFFFFFF )
    return;
  src = v189;
  v40 = v189;
  v188 = 0x800000000LL;
  v41 = (__int64)(v38[13] - v38[12]) >> 3;
  if ( (_DWORD)v41 )
  {
    v42 = (char *)v189;
    if ( (unsigned int)v41 > 8uLL )
    {
      sub_16CD150((__int64)&src, v189, (unsigned int)v41, 12, v36, v37);
      v40 = src;
      v42 = (char *)src + 12 * (unsigned int)v188;
    }
    for ( i = (char *)&v40[3 * (unsigned int)v41]; i != v42; v42 += 12 )
    {
      if ( v42 )
      {
        *(_DWORD *)v42 = 0;
        *((_DWORD *)v42 + 1) = 0;
        v42[8] = 0;
        v42[9] = 0;
      }
    }
    LODWORD(v188) = v41;
    v38 = *(_QWORD **)(a1 + 16);
  }
  v44 = v38[41];
  v181 = 0;
  v182 = v186;
  v183 = v186;
  v184 = 8;
  v185 = 0;
  v173 = &v181;
  v174 = 0;
  v175 = 0;
  v176 = 0;
  sub_1E89520((__int64)v177, (__int64)&v181, v44);
  if ( v180 )
  {
    v177[0] = v44;
    LOBYTE(v178) = 0;
    sub_1E65930((unsigned __int64 *)&v174, (__int64)v177);
  }
  v46 = (unsigned __int64)v175;
  v164 = 0;
  v47 = (unsigned __int64)v174;
  v165 = 0;
  v163 = (__int64)v173;
  v166 = 0;
  v48 = (char *)v175 - (char *)v174;
  if ( (char *)v175 == v174 )
  {
    v50 = 0;
  }
  else
  {
    if ( v48 > 0x7FFFFFFFFFFFFFF8LL )
      sub_4261EA(v175, v174, v45);
    v49 = sub_22077B0((char *)v175 - (char *)v174);
    v46 = (unsigned __int64)v175;
    v47 = (unsigned __int64)v174;
    v50 = v49;
  }
  v164 = v50;
  v165 = v50;
  v166 = v50 + v48;
  if ( v47 != v46 )
  {
    v51 = v50;
    v52 = v47;
    do
    {
      if ( v51 )
      {
        *(_QWORD *)v51 = *(_QWORD *)v52;
        v53 = *(_BYTE *)(v52 + 16);
        *(_BYTE *)(v51 + 16) = v53;
        if ( v53 )
          *(_QWORD *)(v51 + 8) = *(_QWORD *)(v52 + 8);
      }
      v52 += 24LL;
      v51 += 24LL;
    }
    while ( v46 != v52 );
    v54 = v46 - 24;
    v46 = (unsigned __int64)v174;
    v50 += 8 * ((v54 - v47) >> 3) + 24;
  }
  v165 = v50;
  if ( v46 )
  {
    j_j___libc_free_0(v46, (char *)v176 - v46);
    v50 = v165;
  }
  v55 = v164;
LABEL_75:
  v56 = v50 - v55;
  if ( v50 == v55 )
    goto LABEL_141;
  do
  {
    v57 = 0xAAAAAAAAAAAAAAABLL * (v56 >> 3);
    if ( (unsigned int)v57 <= 1 )
    {
      v60 = 0;
      v59 = 0;
    }
    else
    {
      v58 = (char *)src + 12 * *(int *)(*(_QWORD *)(v55 + 24LL * (unsigned int)(v57 - 2)) + 48LL);
      v59 = *((_DWORD *)v58 + 1);
      v60 = v58[9];
    }
    v61 = *(_QWORD *)(v50 - 24);
    v62 = v61 + 24;
    v141 = v61 + 24;
    if ( *(_QWORD *)(v61 + 32) == v61 + 24 )
    {
      v158 = v59;
      v144 = v60;
    }
    else
    {
      v155 = *(_QWORD *)(v50 - 24);
      v63 = v60;
      v64 = *(_QWORD *)(v61 + 32);
      v65 = v59;
      v152 = v60;
      v66 = v62;
      v67 = a1;
      do
      {
        while ( 1 )
        {
          v68 = **(unsigned __int16 **)(v64 + 16);
          if ( v140 == v68 )
          {
            if ( v63 )
            {
              v146 = v64;
              v149 = v67;
              sub_1E86C30(v67, "FrameSetup is after another FrameSetup", v64);
              v64 = v146;
              v67 = v149;
              v68 = **(unsigned __int16 **)(v146 + 16);
            }
            v133 = *(_QWORD *)(v64 + 32);
            v134 = *(_QWORD *)(v133 + 24);
            if ( *(_DWORD *)(*(_QWORD *)(v67 + 32) + 36LL) == v68 )
              v134 += *(_QWORD *)(v133 + 64);
            v65 -= v134;
            v63 = 1;
          }
          if ( v139 == v68 )
          {
            v124 = *(_QWORD *)(v64 + 32);
            v125 = *(_QWORD *)(v124 + 24);
            if ( *(_DWORD *)(*(_QWORD *)(v67 + 32) + 36LL) == v139 )
              v125 += *(_QWORD *)(v124 + 64);
            v126 = v125;
            if ( v63 )
            {
              v127 = abs32(v65);
              if ( (_DWORD)v125 != v127 )
              {
                v148 = v125;
                v142 = v64;
                v145 = v67;
                v138 = v127;
                sub_1E86C30(v67, "FrameDestroy <n> is after FrameSetup <m>", v64);
                v128 = sub_16E8CB0();
                v129 = sub_1263B40((__int64)v128, "FrameDestroy <");
                v130 = sub_16E7AB0(v129, v148);
                v131 = sub_1263B40(v130, "> is after FrameSetup <");
                v132 = sub_16E7AB0(v131, v138);
                sub_1263B40(v132, ">.\n");
                v64 = v142;
                v67 = v145;
                v126 = v148;
              }
            }
            else
            {
              v147 = v64;
              v150 = v67;
              v143 = v125;
              sub_1E86C30(v67, "FrameDestroy is not after a FrameSetup", v64);
              v67 = v150;
              v64 = v147;
              v126 = v143;
            }
            v65 += v126;
            v63 = 0;
          }
          if ( (*(_BYTE *)v64 & 4) == 0 )
            break;
          v64 = *(_QWORD *)(v64 + 8);
          if ( v66 == v64 )
            goto LABEL_85;
        }
        while ( (*(_BYTE *)(v64 + 46) & 8) != 0 )
          v64 = *(_QWORD *)(v64 + 8);
        v64 = *(_QWORD *)(v64 + 8);
      }
      while ( v66 != v64 );
LABEL_85:
      v144 = v63;
      v60 = v152;
      v158 = v65;
      v61 = v155;
    }
    v69 = (char *)src + 12 * *(int *)(v61 + 48);
    *((_DWORD *)v69 + 1) = v158;
    *(_DWORD *)v69 = v59;
    v69[8] = v60;
    v69[9] = v144;
    v70 = *(__int64 **)(v61 + 64);
    v156 = *(__int64 **)(v61 + 72);
    if ( v70 != v156 )
    {
      v153 = v61;
      do
      {
        if ( sub_1DA1810((__int64)&v181, *v70) )
        {
          v71 = (char *)src + 12 * *(int *)(*v70 + 48);
          if ( v59 != *((_DWORD *)v71 + 1) || v71[9] != v60 )
          {
            sub_1E869F0(a1, "The exit stack state of a predecessor is inconsistent.", v153);
            v72 = sub_16E8CB0();
            v73 = sub_1263B40((__int64)v72, "Predecessor ");
            v74 = *v70;
            v75 = (__int64 **)v177;
            v76 = v73;
            sub_1DD5B60(v177, *v70);
            if ( !v178 )
              goto LABEL_212;
            v179(v177, v76);
            v78 = sub_1263B40(v76, " has exit state (");
            v79 = sub_16E7AB0(v78, *((int *)src + 3 * *(int *)(*v70 + 48) + 1));
            v80 = sub_1263B40(v79, ", ");
            v81 = sub_16E7AB0(v80, *((unsigned __int8 *)src + 12 * *(int *)(*v70 + 48) + 9));
            v74 = v153;
            v75 = &v173;
            v82 = sub_1263B40(v81, "), while ");
            sub_1DD5B60(&v173, v153);
            if ( !v175 )
LABEL_212:
              sub_4263D6(v75, v74, v77);
            v176(&v173, v82);
            v83 = sub_1263B40(v82, " has entry state (");
            v84 = sub_16E7AB0(v83, v59);
            v85 = sub_1263B40(v84, ", ");
            v86 = sub_16E7AB0(v85, v60);
            sub_1263B40(v86, ").\n");
            if ( v175 )
              v175(&v173, &v173, 3);
            if ( v178 )
              v178(v177, v177, 3);
          }
        }
        ++v70;
      }
      while ( v156 != v70 );
      v61 = v153;
    }
    v87 = *(__int64 **)(v61 + 88);
    v157 = *(__int64 **)(v61 + 96);
    if ( v87 != v157 )
    {
      v154 = v61;
      do
      {
        if ( sub_1DA1810((__int64)&v181, *v87) )
        {
          v88 = (char *)src + 12 * *(int *)(*v87 + 48);
          if ( *(_DWORD *)v88 != v158 || v88[8] != v144 )
          {
            sub_1E869F0(a1, "The entry stack state of a successor is inconsistent.", v154);
            v89 = sub_16E8CB0();
            v90 = sub_1263B40((__int64)v89, "Successor ");
            v74 = *v87;
            v75 = (__int64 **)v170;
            v91 = v90;
            sub_1DD5B60(v170, *v87);
            if ( !v171 )
              goto LABEL_212;
            v172(v170, v91);
            v92 = sub_1263B40(v91, " has entry state (");
            v93 = sub_16E7AB0(v92, *((int *)src + 3 * *(int *)(*v87 + 48)));
            v94 = sub_1263B40(v93, ", ");
            v95 = sub_16E7AB0(v94, *((unsigned __int8 *)src + 12 * *(int *)(*v87 + 48) + 8));
            v74 = v154;
            v75 = (__int64 **)v167;
            v96 = sub_1263B40(v95, "), while ");
            sub_1DD5B60(v167, v154);
            if ( !v168 )
              goto LABEL_212;
            v169(v167, v96);
            v97 = sub_1263B40(v96, " has exit state (");
            v98 = sub_16E7AB0(v97, v158);
            v99 = sub_1263B40(v98, ", ");
            v100 = sub_16E7AB0(v99, v144);
            sub_1263B40(v100, ").\n");
            if ( v168 )
              v168(v167, v167, 3);
            if ( v171 )
              v171(v170, v170, 3);
          }
        }
        ++v87;
      }
      while ( v157 != v87 );
      v61 = v154;
    }
    v101 = *(_QWORD *)(v61 + 24) & 0xFFFFFFFFFFFFFFF8LL;
    v102 = v101;
    if ( v141 != v101 )
    {
      if ( !v101 )
        BUG();
      v103 = *(_QWORD *)v101;
      v104 = *(_WORD *)(v101 + 46);
      if ( (v103 & 4) != 0 )
      {
        if ( (v104 & 4) != 0 )
          goto LABEL_197;
      }
      else if ( (v104 & 4) != 0 )
      {
        for ( j = v103; ; j = *(_QWORD *)v102 )
        {
          v102 = j & 0xFFFFFFFFFFFFFFF8LL;
          v104 = *(_WORD *)(v102 + 46);
          if ( (v104 & 4) == 0 )
            break;
        }
      }
      if ( (v104 & 8) != 0 )
      {
        LOBYTE(v106) = sub_1E15D00(v102, 8u, 1);
        goto LABEL_121;
      }
LABEL_197:
      v106 = (*(_QWORD *)(*(_QWORD *)(v102 + 16) + 8LL) >> 3) & 1LL;
LABEL_121:
      if ( (_BYTE)v106 )
      {
        if ( v144 )
          sub_1E869F0(a1, "A return block ends with a FrameSetup.", v61);
        if ( v158 )
          sub_1E869F0(a1, "A return block ends with a nonzero stack adjustment.", v61);
      }
    }
    v107 = v165;
LABEL_127:
    v108 = *(_QWORD *)(v107 - 24);
    if ( !*(_BYTE *)(v107 - 8) )
    {
      v109 = *(__int64 **)(v108 + 88);
      *(_BYTE *)(v107 - 8) = 1;
      *(_QWORD *)(v107 - 16) = v109;
      goto LABEL_131;
    }
    while ( 1 )
    {
LABEL_130:
      v109 = *(__int64 **)(v107 - 16);
LABEL_131:
      if ( v109 == *(__int64 **)(v108 + 96) )
      {
        v165 -= 24LL;
        v55 = v164;
        v107 = v165;
        if ( v165 != v164 )
          goto LABEL_127;
        v50 = v164;
        goto LABEL_75;
      }
      *(_QWORD *)(v107 - 16) = v109 + 1;
      v111 = *v109;
      v112 = *(__int64 **)(v163 + 8);
      if ( *(__int64 **)(v163 + 16) == v112 )
      {
        v113 = &v112[*(unsigned int *)(v163 + 28)];
        v114 = *(_DWORD *)(v163 + 28);
        if ( v112 != v113 )
        {
          v115 = 0;
          do
          {
            while ( 1 )
            {
              if ( v111 == *v112 )
                goto LABEL_130;
              if ( *v112 != -2 )
                break;
              v115 = v112;
              if ( v113 == v112 + 1 )
                goto LABEL_139;
              ++v112;
            }
            ++v112;
          }
          while ( v113 != v112 );
          if ( v115 )
          {
LABEL_139:
            *v115 = v111;
            --*(_DWORD *)(v163 + 32);
            ++*(_QWORD *)v163;
            goto LABEL_140;
          }
        }
        if ( v114 < *(_DWORD *)(v163 + 24) )
          break;
      }
      sub_16CCBA0(v163, v111);
      if ( v110 )
        goto LABEL_140;
    }
    *(_DWORD *)(v163 + 28) = v114 + 1;
    *v113 = v111;
    ++*(_QWORD *)v163;
LABEL_140:
    v177[0] = v111;
    LOBYTE(v178) = 0;
    sub_1E65930(&v164, (__int64)v177);
    v50 = v165;
    v55 = v164;
    v56 = v165 - v164;
  }
  while ( v165 != v164 );
LABEL_141:
  if ( v55 != v50 )
    BUG();
  if ( v55 )
    j_j___libc_free_0(v55, v166 - v55);
  if ( v183 != v182 )
    _libc_free((unsigned __int64)v183);
  if ( src != v189 )
    _libc_free((unsigned __int64)src);
}
