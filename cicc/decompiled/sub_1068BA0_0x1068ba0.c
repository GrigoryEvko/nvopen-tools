// Function: sub_1068BA0
// Address: 0x1068ba0
//
__int64 *__fastcall sub_1068BA0(__int64 *a1, __int64 *a2)
{
  _QWORD *v2; // rdi
  unsigned int v3; // ebx
  unsigned int v4; // r12d
  int v5; // r13d
  __int64 v6; // r14
  unsigned int v7; // esi
  int v8; // r10d
  _QWORD *v9; // rdx
  unsigned int v10; // edi
  _QWORD *v11; // rax
  __int64 v12; // rcx
  __int64 *v13; // rax
  __int64 v14; // rbx
  __int64 v15; // r9
  __int64 v16; // rdi
  unsigned __int8 v17; // al
  _QWORD *v18; // r8
  __int64 v19; // rsi
  _QWORD *v20; // rcx
  __int64 v21; // rdi
  __int64 v22; // rax
  unsigned __int64 v23; // rdx
  unsigned int v24; // esi
  int v25; // ecx
  __int64 v26; // rdi
  int v27; // r10d
  _QWORD *v28; // r9
  int v29; // r12d
  unsigned int v30; // esi
  __int64 v31; // rax
  unsigned int i; // r12d
  __int64 v34; // r9
  _BYTE *v35; // r14
  unsigned __int8 v36; // al
  _QWORD *v37; // rdx
  __int64 v38; // rsi
  __int64 v39; // rax
  unsigned int v40; // edx
  unsigned int v41; // ecx
  __int64 *v42; // r8
  __int64 v43; // r10
  __int64 v44; // rcx
  bool v45; // cc
  _QWORD *v46; // r8
  int v47; // r15d
  unsigned int v48; // edx
  __int64 *v49; // rdi
  __int64 v50; // rcx
  unsigned __int8 v51; // al
  _BYTE *v52; // r10
  _BYTE *v53; // rdx
  __int64 v54; // rdx
  _QWORD *v55; // rax
  int v56; // ebx
  bool v57; // al
  unsigned __int8 v58; // al
  __int64 v59; // rax
  __int64 v60; // r13
  __m128i *v61; // rdx
  __m128i si128; // xmm0
  __int64 v63; // rax
  size_t v64; // rdx
  __m128i *v65; // rdi
  unsigned __int8 *v66; // rsi
  unsigned __int64 v67; // rax
  __m128i v68; // xmm0
  const char **v69; // rax
  _WORD *v70; // rdx
  _WORD *v71; // rdx
  const char **v72; // rax
  _WORD *v73; // rdx
  _BYTE *v74; // rax
  unsigned int *v75; // r13
  unsigned int *v76; // rbx
  _BYTE *v77; // rdx
  __int64 v78; // rcx
  unsigned int v79; // eax
  __int64 v80; // r8
  unsigned int v81; // r15d
  __int64 v82; // rdx
  _BYTE *v83; // rdi
  unsigned __int8 v84; // al
  __int64 v85; // rbx
  __int64 v86; // rax
  __int64 v87; // rax
  const char *v88; // rax
  __int64 v89; // rax
  __int64 v90; // rdx
  __int64 v91; // r8
  __int64 v92; // r9
  __int64 v93; // rcx
  __int64 v94; // r8
  __int64 v95; // r9
  __int64 v96; // rcx
  __int64 v97; // r8
  __int64 v98; // r9
  __int64 v99; // rcx
  __int64 v100; // r8
  __int64 v101; // r9
  __int64 v102; // rcx
  __int64 v103; // r8
  __int64 v104; // r9
  __int64 v105; // rsi
  int v106; // r8d
  _BYTE *v107; // r15
  __int64 v108; // r13
  _BYTE *v109; // rdi
  __int64 v110; // rax
  __int64 v111; // rsi
  _QWORD *v112; // rax
  _QWORD *v113; // rdx
  __int64 v114; // rbx
  int v115; // ebx
  _QWORD *v116; // rax
  __int64 v117; // r9
  __int64 v118; // rax
  __int64 v119; // rax
  __int64 v120; // rdx
  __int64 v121; // rcx
  __int64 v122; // r8
  __int64 v123; // r9
  char v124; // al
  _BYTE *v125; // r15
  __int64 v126; // r13
  _BYTE *v127; // rdi
  __int64 v128; // rax
  __int64 v129; // rsi
  _QWORD *v130; // rax
  _QWORD *v131; // rdx
  __int64 v132; // r14
  __int64 v133; // rax
  __int64 v134; // rax
  __int64 v135; // r14
  __int64 v136; // rax
  int v137; // r13d
  __int64 *v138; // rbx
  int v139; // edx
  __int64 v140; // rbx
  __m128i *v141; // rdx
  __m128i v142; // xmm0
  __int64 v143; // rax
  size_t v144; // rdx
  __m128i *v145; // rdi
  unsigned __int8 *v146; // rsi
  size_t v147; // r15
  unsigned __int64 v148; // rax
  __m128i v149; // xmm0
  const char **v150; // rax
  _WORD *v151; // rdx
  _WORD *v152; // rdx
  const char **v153; // rax
  __int64 v154; // rdx
  __int64 v155; // rcx
  _BYTE *v156; // rbx
  __int64 v157; // r8
  __int64 v158; // r9
  __int64 v159; // rcx
  __int64 v160; // r8
  __int64 v161; // r9
  __int64 v162; // r14
  unsigned __int8 v163; // al
  __int64 *v164; // rsi
  __int64 v165; // rax
  __int64 v166; // rcx
  __int64 v167; // r8
  __int64 v168; // r9
  unsigned __int8 v169; // al
  __int64 *v170; // rsi
  __int64 v171; // rax
  bool v172; // al
  unsigned int v173; // r14d
  __int64 v174; // rdx
  unsigned int v175; // r13d
  __int64 v176; // r12
  __int64 v177; // rdx
  __int64 v178; // rcx
  _BYTE *v179; // rbx
  __int64 v180; // r8
  __int64 v181; // r9
  _WORD *v182; // r13
  _BYTE *v183; // rax
  __int64 *v184; // r14
  __int64 v185; // rdx
  __int64 v186; // r12
  unsigned int v187; // r15d
  __int64 v188; // rbx
  _QWORD *v189; // r8
  unsigned int v190; // r15d
  int v191; // r9d
  __int64 v192; // rsi
  __int64 v193; // rcx
  int v194; // r8d
  __int64 *v195; // r13
  unsigned int v196; // eax
  __int64 v197; // r8
  unsigned int v198; // ebx
  __int64 v199; // rax
  unsigned __int64 v200; // rdx
  unsigned int v201; // eax
  __int64 *v202; // rsi
  __int64 v203; // r8
  __int64 *v204; // r13
  int v205; // r8d
  __int64 v206; // rcx
  __int64 v207; // rdi
  __int64 *v208; // r15
  __int64 *v209; // r12
  __int64 *v210; // rdi
  unsigned __int8 v211; // al
  __int64 v212; // rcx
  __int64 v213; // rbx
  __int64 v214; // rax
  unsigned __int8 v215; // cl
  __int64 v216; // rax
  __int64 v217; // rsi
  unsigned __int8 v218; // al
  __int64 v219; // rcx
  int v220; // r9d
  __int64 v221; // rax
  __int64 v222; // rdx
  int v223; // r11d
  int v224; // esi
  int v225; // r10d
  size_t v226; // [rsp+0h] [rbp-440h]
  __int64 v227; // [rsp+8h] [rbp-438h]
  bool v228; // [rsp+30h] [rbp-410h]
  unsigned int v229; // [rsp+30h] [rbp-410h]
  unsigned int v230; // [rsp+30h] [rbp-410h]
  int v231; // [rsp+34h] [rbp-40Ch]
  _BYTE *v233; // [rsp+48h] [rbp-3F8h]
  __int64 v234; // [rsp+48h] [rbp-3F8h]
  __int64 v235; // [rsp+48h] [rbp-3F8h]
  __int64 v236; // [rsp+48h] [rbp-3F8h]
  __int64 v237; // [rsp+48h] [rbp-3F8h]
  __int64 *v238; // [rsp+48h] [rbp-3F8h]
  __int64 v239; // [rsp+48h] [rbp-3F8h]
  __int64 v240; // [rsp+48h] [rbp-3F8h]
  __int64 v241; // [rsp+48h] [rbp-3F8h]
  __int64 v242; // [rsp+50h] [rbp-3F0h]
  unsigned int v244; // [rsp+64h] [rbp-3DCh] BYREF
  __int64 v245; // [rsp+68h] [rbp-3D8h] BYREF
  __int64 v246; // [rsp+70h] [rbp-3D0h] BYREF
  __int64 v247; // [rsp+78h] [rbp-3C8h] BYREF
  unsigned int *v248; // [rsp+80h] [rbp-3C0h] BYREF
  __int64 v249; // [rsp+88h] [rbp-3B8h]
  __int64 v250; // [rsp+90h] [rbp-3B0h] BYREF
  __int64 v251; // [rsp+98h] [rbp-3A8h]
  __int64 v252; // [rsp+A0h] [rbp-3A0h]
  unsigned int v253; // [rsp+A8h] [rbp-398h]
  __int64 v254; // [rsp+B0h] [rbp-390h] BYREF
  __int64 v255; // [rsp+B8h] [rbp-388h]
  __int64 v256; // [rsp+C0h] [rbp-380h]
  __int64 v257; // [rsp+C8h] [rbp-378h]
  __m128i v258; // [rsp+D0h] [rbp-370h] BYREF
  __int64 v259; // [rsp+E0h] [rbp-360h]
  __int64 v260; // [rsp+E8h] [rbp-358h]
  __int16 v261; // [rsp+F0h] [rbp-350h]
  __m128i v262[2]; // [rsp+100h] [rbp-340h] BYREF
  char v263; // [rsp+120h] [rbp-320h]
  char v264; // [rsp+121h] [rbp-31Fh]
  __m128i v265[3]; // [rsp+130h] [rbp-310h] BYREF
  __m128i v266[2]; // [rsp+160h] [rbp-2E0h] BYREF
  __int16 v267; // [rsp+180h] [rbp-2C0h]
  __m128i v268[3]; // [rsp+190h] [rbp-2B0h] BYREF
  __m128i v269[2]; // [rsp+1C0h] [rbp-280h] BYREF
  char v270; // [rsp+1E0h] [rbp-260h]
  char v271; // [rsp+1E1h] [rbp-25Fh]
  __m128i v272[3]; // [rsp+1F0h] [rbp-250h] BYREF
  __m128i v273; // [rsp+220h] [rbp-220h] BYREF
  char v274; // [rsp+230h] [rbp-210h] BYREF
  __int16 v275; // [rsp+240h] [rbp-200h]
  __m128i v276; // [rsp+250h] [rbp-1F0h] BYREF
  _QWORD v277[2]; // [rsp+260h] [rbp-1E0h] BYREF
  __int16 v278; // [rsp+270h] [rbp-1D0h]
  __m128i v279; // [rsp+280h] [rbp-1C0h] BYREF
  __int64 *v280; // [rsp+290h] [rbp-1B0h]
  __int64 *v281; // [rsp+298h] [rbp-1A8h]
  unsigned int *v282; // [rsp+2A0h] [rbp-1A0h]
  __int64 *v283; // [rsp+2A8h] [rbp-198h]
  __int64 v284; // [rsp+2B0h] [rbp-190h] BYREF
  __int64 v285; // [rsp+2B8h] [rbp-188h]
  __int64 v286; // [rsp+2C0h] [rbp-180h]
  __int64 v287; // [rsp+2C8h] [rbp-178h]
  __int64 *v288; // [rsp+2D0h] [rbp-170h]
  __int64 v289; // [rsp+2D8h] [rbp-168h]
  _BYTE v290[128]; // [rsp+2E0h] [rbp-160h] BYREF
  __m128i v291; // [rsp+360h] [rbp-E0h] BYREF
  _QWORD *v292; // [rsp+370h] [rbp-D0h]
  unsigned __int64 v293; // [rsp+378h] [rbp-C8h]
  void *dest; // [rsp+380h] [rbp-C0h]
  __int64 v295; // [rsp+388h] [rbp-B8h]
  _QWORD v296[22]; // [rsp+390h] [rbp-B0h] BYREF

  v2 = (_QWORD *)a2[1];
  v242 = v2[108];
  if ( !v242 )
  {
    v291.m128i_i64[0] = 0;
    *a1 = 1;
    sub_9C66B0(v291.m128i_i64);
    return a1;
  }
  sub_A85B60(v2);
  sub_A84F90((_QWORD *)a2[1]);
  v245 = sub_BA92C0(*a2);
  v3 = sub_B91A00(v245);
  if ( !v3 )
  {
    v29 = sub_B91A00(v242);
    if ( v29 )
    {
      do
      {
        v30 = v3++;
        v31 = sub_B91A10(v242, v30);
        sub_B979A0(v245, v31);
      }
      while ( v29 != v3 );
    }
    *a1 = 1;
    return a1;
  }
  v4 = 0;
  v250 = 0;
  v288 = (__int64 *)v290;
  v289 = 0x1000000000LL;
  v251 = 0;
  v252 = 0;
  v253 = 0;
  v284 = 0;
  v285 = 0;
  v286 = 0;
  v287 = 0;
  v248 = (unsigned int *)&v250;
  v249 = 0;
  v254 = 0;
  v255 = 0;
  v256 = 0;
  v257 = 0;
  v5 = sub_B91A00(v245);
  if ( v5 )
  {
    do
    {
      while ( 1 )
      {
        v14 = sub_B91A10(v245, v4);
        v16 = v14 - 16;
        v17 = *(_BYTE *)(v14 - 16);
        if ( (v17 & 2) != 0 )
          v18 = *(_QWORD **)(v14 - 32);
        else
          v18 = (_QWORD *)(v16 - 8LL * ((v17 >> 2) & 0xF));
        v19 = *(_QWORD *)(*v18 + 136LL);
        v20 = *(_QWORD **)(v19 + 24);
        if ( *(_DWORD *)(v19 + 32) > 0x40u )
          v20 = (_QWORD *)*v20;
        if ( (v17 & 2) == 0 )
          break;
        if ( v20 != (_QWORD *)3 )
        {
          v6 = *(_QWORD *)(*(_QWORD *)(v14 - 32) + 8LL);
          if ( v20 != (_QWORD *)8 )
            goto LABEL_7;
          goto LABEL_18;
        }
LABEL_34:
        ++v4;
        v291.m128i_i64[0] = v18[2];
        sub_1067EC0((__int64)&v284, v291.m128i_i64, (v17 & 2) != 0, (__int64)v20, (__int64)v18, v15);
        if ( v4 == v5 )
          goto LABEL_35;
      }
      v21 = v16 - 8LL * ((v17 >> 2) & 0xF);
      if ( v20 == (_QWORD *)3 )
        goto LABEL_34;
      v6 = *(_QWORD *)(v21 + 8);
      if ( v20 != (_QWORD *)8 )
      {
LABEL_7:
        v7 = v253;
        if ( !v253 )
          goto LABEL_21;
        goto LABEL_8;
      }
LABEL_18:
      v22 = (unsigned int)v249;
      v23 = (unsigned int)v249 + 1LL;
      if ( v23 > HIDWORD(v249) )
      {
        sub_C8D5F0((__int64)&v248, &v250, v23, 4u, (__int64)v18, v15);
        v22 = (unsigned int)v249;
      }
      v248[v22] = v4;
      v7 = v253;
      LODWORD(v249) = v249 + 1;
      if ( !v253 )
      {
LABEL_21:
        ++v250;
        goto LABEL_22;
      }
LABEL_8:
      v8 = 1;
      v9 = 0;
      v10 = (v7 - 1) & (((unsigned int)v6 >> 9) ^ ((unsigned int)v6 >> 4));
      v11 = (_QWORD *)(v251 + 24LL * v10);
      v12 = *v11;
      if ( *v11 != v6 )
      {
        while ( v12 != -4096 )
        {
          if ( v12 == -8192 && !v9 )
            v9 = v11;
          v10 = (v7 - 1) & (v8 + v10);
          v11 = (_QWORD *)(v251 + 24LL * v10);
          v12 = *v11;
          if ( *v11 == v6 )
            goto LABEL_9;
          ++v8;
        }
        if ( !v9 )
          v9 = v11;
        ++v250;
        v25 = v252 + 1;
        if ( 4 * ((int)v252 + 1) >= 3 * v7 )
        {
LABEL_22:
          sub_1062CA0((__int64)&v250, 2 * v7);
          if ( !v253 )
            goto LABEL_305;
          v24 = (v253 - 1) & (((unsigned int)v6 >> 9) ^ ((unsigned int)v6 >> 4));
          v25 = v252 + 1;
          v9 = (_QWORD *)(v251 + 24LL * v24);
          v26 = *v9;
          if ( *v9 != v6 )
          {
            v27 = 1;
            v28 = 0;
            while ( v26 != -4096 )
            {
              if ( !v28 && v26 == -8192 )
                v28 = v9;
              v24 = (v253 - 1) & (v27 + v24);
              v9 = (_QWORD *)(v251 + 24LL * v24);
              v26 = *v9;
              if ( *v9 == v6 )
                goto LABEL_156;
              ++v27;
            }
            if ( v28 )
              v9 = v28;
          }
        }
        else if ( v7 - HIDWORD(v252) - v25 <= v7 >> 3 )
        {
          sub_1062CA0((__int64)&v250, v7);
          if ( !v253 )
          {
LABEL_305:
            LODWORD(v252) = v252 + 1;
            BUG();
          }
          v189 = 0;
          v190 = (v253 - 1) & (((unsigned int)v6 >> 9) ^ ((unsigned int)v6 >> 4));
          v191 = 1;
          v25 = v252 + 1;
          v9 = (_QWORD *)(v251 + 24LL * v190);
          v192 = *v9;
          if ( *v9 != v6 )
          {
            while ( v192 != -4096 )
            {
              if ( v192 == -8192 && !v189 )
                v189 = v9;
              v190 = (v253 - 1) & (v191 + v190);
              v9 = (_QWORD *)(v251 + 24LL * v190);
              v192 = *v9;
              if ( *v9 == v6 )
                goto LABEL_156;
              ++v191;
            }
            if ( v189 )
              v9 = v189;
          }
        }
LABEL_156:
        LODWORD(v252) = v25;
        if ( *v9 != -4096 )
          --HIDWORD(v252);
        *v9 = v6;
        v13 = v9 + 1;
        v9[1] = 0;
        *((_DWORD *)v9 + 4) = 0;
        goto LABEL_10;
      }
LABEL_9:
      v13 = v11 + 1;
LABEL_10:
      *((_DWORD *)v13 + 2) = v4++;
      *v13 = v14;
    }
    while ( v4 != v5 );
  }
LABEL_35:
  v231 = sub_B91A00(v242);
  if ( v231 )
  {
    for ( i = 0; v231 != i; ++i )
    {
      v34 = sub_B91A10(v242, i);
      v35 = (_BYTE *)(v34 - 16);
      v36 = *(_BYTE *)(v34 - 16);
      if ( (v36 & 2) != 0 )
        v37 = *(_QWORD **)(v34 - 32);
      else
        v37 = &v35[-8 * ((v36 >> 2) & 0xF)];
      v38 = *(_QWORD *)(*v37 + 136LL);
      v39 = v37[1];
      v40 = v253;
      v246 = v39;
      if ( v253 )
      {
        v41 = (v253 - 1) & (((unsigned int)v39 >> 9) ^ ((unsigned int)v39 >> 4));
        v42 = (__int64 *)(v251 + 24LL * v41);
        v43 = *v42;
        if ( v39 == *v42 )
        {
LABEL_41:
          v44 = v42[1];
          v40 = *((_DWORD *)v42 + 4);
          goto LABEL_42;
        }
        v106 = 1;
        while ( v43 != -4096 )
        {
          v223 = v106 + 1;
          v41 = (v253 - 1) & (v106 + v41);
          v42 = (__int64 *)(v251 + 24LL * v41);
          v43 = *v42;
          if ( v39 == *v42 )
            goto LABEL_41;
          v106 = v223;
        }
        v40 = 0;
      }
      v44 = 0;
LABEL_42:
      v45 = *(_DWORD *)(v38 + 32) <= 0x40u;
      v46 = *(_QWORD **)(v38 + 24);
      v247 = v44;
      v244 = v40;
      if ( !v45 )
        v46 = (_QWORD *)*v46;
      v47 = (int)v46;
      if ( (_DWORD)v257 )
      {
        v48 = (v257 - 1) & (((unsigned int)v39 >> 9) ^ ((unsigned int)v39 >> 4));
        v49 = (__int64 *)(v255 + 8LL * v48);
        v50 = *v49;
        if ( v39 == *v49 )
          goto LABEL_46;
        v137 = 1;
        v138 = 0;
        while ( v50 != -4096 )
        {
          if ( v138 || v50 != -8192 )
            v49 = v138;
          v48 = (v257 - 1) & (v137 + v48);
          v50 = *(_QWORD *)(v255 + 8LL * v48);
          if ( v39 == v50 )
            goto LABEL_46;
          ++v137;
          v138 = v49;
          v49 = (__int64 *)(v255 + 8LL * v48);
        }
        if ( !v138 )
          v138 = v49;
        ++v254;
        v139 = v256 + 1;
        if ( 4 * ((int)v256 + 1) < (unsigned int)(3 * v257) )
        {
          if ( (int)v257 - HIDWORD(v256) - v139 <= (unsigned int)v257 >> 3 )
          {
            v241 = v34;
            sub_10637C0((__int64)&v254, v257);
            if ( !(_DWORD)v257 )
            {
LABEL_306:
              LODWORD(v256) = v256 + 1;
              BUG();
            }
            v39 = v246;
            v204 = 0;
            v34 = v241;
            v205 = 1;
            LODWORD(v206) = (v257 - 1) & (((unsigned int)v246 >> 9) ^ ((unsigned int)v246 >> 4));
            v138 = (__int64 *)(v255 + 8LL * (unsigned int)v206);
            v207 = *v138;
            v139 = v256 + 1;
            if ( *v138 != v246 )
            {
              while ( v207 != -4096 )
              {
                if ( !v204 && v207 == -8192 )
                  v204 = v138;
                v206 = ((_DWORD)v257 - 1) & (unsigned int)(v206 + v205);
                v138 = (__int64 *)(v255 + 8 * v206);
                v207 = *v138;
                if ( v246 == *v138 )
                  goto LABEL_166;
                ++v205;
              }
              if ( v204 )
                v138 = v204;
            }
          }
          goto LABEL_166;
        }
      }
      else
      {
        ++v254;
      }
      v239 = v34;
      sub_10637C0((__int64)&v254, 2 * v257);
      if ( !(_DWORD)v257 )
        goto LABEL_306;
      v34 = v239;
      v139 = v256 + 1;
      LODWORD(v193) = (v257 - 1) & (((unsigned int)v246 >> 9) ^ ((unsigned int)v246 >> 4));
      v138 = (__int64 *)(v255 + 8LL * (unsigned int)v193);
      v39 = *v138;
      if ( v246 != *v138 )
      {
        v194 = 1;
        v195 = 0;
        while ( v39 != -4096 )
        {
          if ( v39 == -8192 && !v195 )
            v195 = v138;
          v193 = ((_DWORD)v257 - 1) & (unsigned int)(v193 + v194);
          v138 = (__int64 *)(v255 + 8 * v193);
          v39 = *v138;
          if ( v246 == *v138 )
            goto LABEL_166;
          ++v194;
        }
        v39 = v246;
        if ( v195 )
          v138 = v195;
      }
LABEL_166:
      LODWORD(v256) = v139;
      if ( *v138 != -4096 )
        --HIDWORD(v256);
      *v138 = v39;
LABEL_46:
      if ( v47 == 3 )
      {
        v235 = v34;
        v291.m128i_i64[0] = *((_QWORD *)sub_A17150(v35) + 2);
        v124 = sub_1067EC0((__int64)&v284, v291.m128i_i64, v120, v121, v122, v123);
        v117 = v235;
        if ( !v124 )
          continue;
        goto LABEL_124;
      }
      if ( !v247 )
      {
        if ( v47 == 8 )
        {
          v240 = v34;
          v196 = sub_B91A00(v245);
          v34 = v240;
          v198 = v196;
          v199 = (unsigned int)v249;
          v200 = (unsigned int)v249 + 1LL;
          if ( v200 > HIDWORD(v249) )
          {
            sub_C8D5F0((__int64)&v248, &v250, v200, 4u, v197, v240);
            v199 = (unsigned int)v249;
            v34 = v240;
          }
          v248[v199] = v198;
          LODWORD(v249) = v249 + 1;
          if ( (_DWORD)v257 )
          {
            v201 = (v257 - 1) & (((unsigned int)v246 >> 9) ^ ((unsigned int)v246 >> 4));
            v202 = (__int64 *)(v255 + 8LL * v201);
            v203 = *v202;
            if ( *v202 == v246 )
            {
LABEL_237:
              *v202 = -8192;
              LODWORD(v256) = v256 - 1;
              ++HIDWORD(v256);
            }
            else
            {
              v224 = 1;
              while ( v203 != -4096 )
              {
                v225 = v224 + 1;
                v201 = (v257 - 1) & (v224 + v201);
                v202 = (__int64 *)(v255 + 8LL * v201);
                v203 = *v202;
                if ( v246 == *v202 )
                  goto LABEL_237;
                v224 = v225;
              }
            }
          }
        }
        v234 = v34;
        v115 = sub_B91A00(v245);
        v116 = sub_1062EA0((__int64)&v250, &v246);
        v117 = v234;
        *((_DWORD *)v116 + 2) = v115;
        *v116 = v234;
LABEL_124:
        sub_B979A0(v245, v117);
        continue;
      }
      v51 = *(_BYTE *)(v247 - 16);
      v52 = (_BYTE *)(v247 - 16);
      if ( (v51 & 2) != 0 )
        v53 = *(_BYTE **)(v247 - 32);
      else
        v53 = &v52[-8 * ((v51 >> 2) & 0xF)];
      v54 = *(_QWORD *)(*(_QWORD *)v53 + 136LL);
      v55 = *(_QWORD **)(v54 + 24);
      if ( *(_DWORD *)(v54 + 32) > 0x40u )
        v55 = (_QWORD *)*v55;
      v56 = (int)v55;
      if ( (_DWORD)v55 == 4 )
      {
        v233 = (_BYTE *)(v247 - 16);
        if ( v47 == 4 )
        {
          v85 = *((_QWORD *)sub_A17150(v35) + 2);
          if ( v85 != *((_QWORD *)sub_A17150(v233) + 2) )
          {
            v279.m128i_i64[0] = (__int64)"'";
            v86 = *a2;
            LOWORD(v282) = 259;
            v273.m128i_i64[0] = v86 + 168;
            v269[0].m128i_i64[0] = (__int64)"' and '";
            v87 = a2[1];
            v275 = 260;
            v271 = 1;
            v270 = 3;
            v267 = 260;
            v264 = 1;
            v266[0].m128i_i64[0] = v87 + 168;
            v88 = "': IDs have conflicting override values in '";
LABEL_99:
            v262[0].m128i_i64[0] = (__int64)v88;
            v263 = 3;
            v89 = sub_B91420(v246);
            v260 = v90;
            v261 = 1283;
            v259 = v89;
            v258.m128i_i64[0] = (__int64)"linking module flags '";
            sub_9C6370(v265, &v258, v262, 1283, v91, v92);
            sub_9C6370(v268, v265, v266, v93, v94, v95);
            sub_9C6370(v272, v268, v269, v96, v97, v98);
            sub_9C6370(&v276, v272, &v273, v99, v100, v101);
            goto LABEL_100;
          }
        }
        continue;
      }
      if ( v47 == 4 )
      {
        v237 = v34;
        sub_B970B0(v245, v244, v34);
        *sub_1062EA0((__int64)&v250, &v246) = v237;
        continue;
      }
      v228 = (_DWORD)v55 == 8;
      v57 = (_DWORD)v55 == 2;
      if ( v47 != v56 )
      {
        if ( (!v57 || v47 != 8) && (v47 != 2 || !v228) && (v47 != 7 || !v57) && (v56 != 7 || v47 != 2) )
        {
          v279.m128i_i64[0] = (__int64)"'";
          v118 = *a2;
          LOWORD(v282) = 259;
          v275 = 260;
          v273.m128i_i64[0] = v118 + 168;
          v269[0].m128i_i64[0] = (__int64)"' and '";
          v119 = a2[1];
          v271 = 1;
          v270 = 3;
          v266[0].m128i_i64[0] = v119 + 168;
          v88 = "': IDs have conflicting behaviors in '";
          v267 = 260;
          v264 = 1;
          goto LABEL_99;
        }
        v279.m128i_i64[0] = (__int64)a2;
        v279.m128i_i64[1] = (__int64)&v247;
        v280 = &v246;
        v281 = &v245;
        v282 = &v244;
        v283 = &v250;
LABEL_58:
        v58 = *(_BYTE *)(v34 - 16);
        if ( (v58 & 2) != 0 )
          v59 = *(_QWORD *)(v34 - 32);
        else
          v59 = v34 - 8LL * ((v58 >> 2) & 0xF) - 16;
        v60 = *(_QWORD *)(v59 + 16);
        if ( *((_QWORD *)sub_A17150(v52) + 2) != v60 )
        {
          v276.m128i_i64[0] = (__int64)v277;
          v295 = 0x100000000LL;
          v296[0] = &v276;
          v291.m128i_i64[0] = (__int64)&unk_49DD210;
          v276.m128i_i64[1] = 0;
          LOBYTE(v277[0]) = 0;
          v291.m128i_i64[1] = 0;
          v292 = 0;
          v293 = 0;
          dest = 0;
          sub_CB5980((__int64)&v291, 0, 0, 0);
          v61 = (__m128i *)dest;
          if ( v293 - (unsigned __int64)dest <= 0x15 )
          {
            sub_CB6200((__int64)&v291, "linking module flags '", 0x16u);
          }
          else
          {
            si128 = _mm_load_si128((const __m128i *)&xmmword_3F8EEE0);
            *((_DWORD *)dest + 4) = 1936154988;
            v61[1].m128i_i16[2] = 10016;
            *v61 = si128;
            dest = (char *)dest + 22;
          }
          v63 = sub_B91420(v246);
          v65 = (__m128i *)dest;
          v66 = (unsigned __int8 *)v63;
          v67 = v293 - (_QWORD)dest;
          if ( v293 - (unsigned __int64)dest < v64 )
          {
            sub_CB6200((__int64)&v291, v66, v64);
            v65 = (__m128i *)dest;
            v67 = v293 - (_QWORD)dest;
          }
          else if ( v64 )
          {
            v226 = v64;
            memcpy(dest, v66, v64);
            v65 = (__m128i *)((char *)dest + v226);
            dest = v65;
            v67 = v293 - (_QWORD)v65;
          }
          if ( v67 <= 0x20 )
          {
            sub_CB6200((__int64)&v291, "': IDs have conflicting values ('", 0x21u);
          }
          else
          {
            v68 = _mm_load_si128((const __m128i *)&xmmword_3F8EEF0);
            v65[2].m128i_i8[0] = 39;
            *v65 = v68;
            v65[1] = _mm_load_si128((const __m128i *)&xmmword_3F8EF00);
            dest = (char *)dest + 33;
          }
          v69 = (const char **)sub_A17150(v35);
          sub_A61DE0(v69[2], (__int64)&v291, 0);
          v70 = dest;
          if ( v293 - (unsigned __int64)dest <= 6 )
          {
            sub_CB6200((__int64)&v291, "' from ", 7u);
          }
          else
          {
            *(_DWORD *)dest = 1919295527;
            v70[2] = 28015;
            *((_BYTE *)v70 + 6) = 32;
            dest = (char *)dest + 7;
          }
          sub_CB6200((__int64)&v291, *(unsigned __int8 **)(a2[1] + 168), *(_QWORD *)(a2[1] + 176));
          v71 = dest;
          if ( v293 - (unsigned __int64)dest <= 6 )
          {
            sub_CB6200((__int64)&v291, " with '", 7u);
          }
          else
          {
            *(_DWORD *)dest = 1953068832;
            v71[2] = 8296;
            *((_BYTE *)v71 + 6) = 39;
            dest = (char *)dest + 7;
          }
          v72 = (const char **)sub_A17150((_BYTE *)(v247 - 16));
          sub_A61DE0(v72[2], (__int64)&v291, 0);
          v73 = dest;
          if ( v293 - (unsigned __int64)dest <= 6 )
          {
            sub_CB6200((__int64)&v291, "' from ", 7u);
          }
          else
          {
            *(_DWORD *)dest = 1919295527;
            v73[2] = 28015;
            *((_BYTE *)v73 + 6) = 32;
            dest = (char *)dest + 7;
          }
          sub_CB6200((__int64)&v291, *(unsigned __int8 **)(*a2 + 168), *(_QWORD *)(*a2 + 176));
          v74 = dest;
          if ( (unsigned __int64)dest >= v293 )
          {
            sub_CB5D20((__int64)&v291, 41);
          }
          else
          {
            dest = (char *)dest + 1;
            *v74 = 41;
          }
          v291.m128i_i64[0] = (__int64)&unk_49DD210;
          sub_CB5840((__int64)&v291);
          v291.m128i_i64[0] = (__int64)&v276;
          LOWORD(dest) = 260;
          v227 = *(_QWORD *)a2[1];
          sub_1061A30((__int64)&v273, 1, (__int64)&v291);
          sub_B6EB20(v227, (__int64)&v273);
          if ( (_QWORD *)v276.m128i_i64[0] != v277 )
            j_j___libc_free_0(v276.m128i_i64[0], v277[0] + 1LL);
        }
        if ( v228 )
        {
LABEL_113:
          v107 = (_BYTE *)(v247 - 16);
          v108 = *(_QWORD *)(*((_QWORD *)sub_A17150((_BYTE *)(v247 - 16)) + 2) + 136LL);
          v109 = v107;
          v110 = *((_QWORD *)sub_A17150(v35) + 2);
          if ( v56 != 8 )
            v109 = v35;
          v111 = *(_QWORD *)(v110 + 136);
          v291.m128i_i64[0] = *(_QWORD *)sub_A17150(v109);
          v291.m128i_i64[1] = v246;
          v112 = *(_QWORD **)(v111 + 24);
          if ( *(_DWORD *)(v111 + 32) > 0x40u )
            v112 = (_QWORD *)*v112;
          v113 = *(_QWORD **)(v108 + 24);
          if ( *(_DWORD *)(v108 + 32) > 0x40u )
            v113 = (_QWORD *)*v113;
          if ( v113 <= v112 )
            v35 = v107;
          goto LABEL_121;
        }
        goto LABEL_79;
      }
      v279.m128i_i64[1] = (__int64)&v247;
      v280 = &v246;
      v281 = &v245;
      v279.m128i_i64[0] = (__int64)a2;
      v282 = &v244;
      v283 = &v250;
      if ( v47 == 2 || v57 )
        goto LABEL_58;
      if ( v228 )
        goto LABEL_113;
LABEL_79:
      if ( v47 == 8 )
        goto LABEL_113;
      if ( v56 == 7 || v47 == 7 )
      {
        v125 = (_BYTE *)(v247 - 16);
        v126 = *(_QWORD *)(*((_QWORD *)sub_A17150((_BYTE *)(v247 - 16)) + 2) + 136LL);
        v127 = v125;
        v128 = *((_QWORD *)sub_A17150(v35) + 2);
        if ( v56 != 7 )
          v127 = v35;
        v129 = *(_QWORD *)(v128 + 136);
        v291.m128i_i64[0] = *(_QWORD *)sub_A17150(v127);
        v291.m128i_i64[1] = v246;
        v130 = *(_QWORD **)(v129 + 24);
        if ( *(_DWORD *)(v129 + 32) > 0x40u )
          v130 = (_QWORD *)*v130;
        v131 = *(_QWORD **)(v126 + 24);
        if ( *(_DWORD *)(v126 + 32) > 0x40u )
          v131 = (_QWORD *)*v131;
        if ( v131 >= v130 )
          v35 = v125;
LABEL_121:
        v292 = (_QWORD *)*((_QWORD *)sub_A17150(v35) + 2);
        v114 = sub_B9C770(*(__int64 **)*a2, v291.m128i_i64, (__int64 *)3, 0, 1);
        sub_B970B0(v245, v244, v114);
        *sub_1062EA0((__int64)&v250, &v246) = v114;
        continue;
      }
      switch ( v47 )
      {
        case 5:
          v179 = (_BYTE *)*((_QWORD *)sub_A17150((_BYTE *)(v247 - 16)) + 2);
          if ( (v179[1] & 0x7F) == 1 )
          {
            if ( *v179 != 5 )
              v179 = 0;
          }
          else
          {
            v179 = (_BYTE *)sub_1063100((__int64)&v279, (__int64)v179, v177, v178, v180, v181);
          }
          v182 = v179 - 16;
          v183 = sub_A17150(v35);
          v184 = (__int64 *)sub_A17150((_BYTE *)(*((_QWORD *)v183 + 2) - 16LL));
          v238 = &v184[v185];
          if ( v184 != v238 )
          {
            v230 = i;
            v186 = (__int64)v179;
            do
            {
              v188 = *v184;
              if ( (*(_BYTE *)(v186 - 16) & 2) != 0 )
                v187 = *(_DWORD *)(v186 - 24);
              else
                v187 = (*(_WORD *)(v186 - 16) >> 6) & 0xF;
              ++v184;
              sub_B98740(v182, v187 + 1LL);
              sub_B97110(v186, v187, v188);
            }
            while ( v238 != v184 );
            i = v230;
          }
          break;
        case 6:
          v291 = 0u;
          dest = v296;
          v295 = 0x1000000000LL;
          v292 = 0;
          v293 = 0;
          v156 = (_BYTE *)*((_QWORD *)sub_A17150((_BYTE *)(v247 - 16)) + 2);
          if ( (v156[1] & 0x7F) == 1 )
          {
            if ( *v156 != 5 )
              BUG();
          }
          else
          {
            v156 = (_BYTE *)sub_1063100((__int64)&v279, (__int64)v156, v154, v155, v157, v158);
          }
          v162 = *((_QWORD *)sub_A17150(v35) + 2);
          v163 = *(v156 - 16);
          if ( (v163 & 2) != 0 )
          {
            v164 = (__int64 *)*((_QWORD *)v156 - 4);
            v165 = *((unsigned int *)v156 - 6);
          }
          else
          {
            v164 = (__int64 *)&v156[-8 * ((v163 >> 2) & 0xF) - 16];
            v165 = (*((_WORD *)v156 - 8) >> 6) & 0xF;
          }
          sub_1068530((__int64)&v291, v164, &v164[v165], v159, v160, v161);
          v169 = *(_BYTE *)(v162 - 16);
          if ( (v169 & 2) != 0 )
          {
            v170 = *(__int64 **)(v162 - 32);
            v171 = *(unsigned int *)(v162 - 24);
          }
          else
          {
            v170 = (__int64 *)(v162 - 8LL * ((v169 >> 2) & 0xF) - 16);
            v171 = (*(_WORD *)(v162 - 16) >> 6) & 0xF;
          }
          sub_1068530((__int64)&v291, v170, &v170[v171], v166, v167, v168);
          v172 = (*(v156 - 16) & 2) != 0;
          if ( (*(v156 - 16) & 2) != 0 )
            v173 = *((_DWORD *)v156 - 6);
          else
            v173 = (*((_WORD *)v156 - 8) >> 6) & 0xF;
          v174 = v173;
          if ( (unsigned int)v295 > v173 )
          {
            v229 = i;
            while ( 1 )
            {
              v176 = *((_QWORD *)dest + v174);
              v175 = v172 ? *((_DWORD *)v156 - 6) : (*((_WORD *)v156 - 8) >> 6) & 0xF;
              sub_B98740((_WORD *)v156 - 8, v175 + 1LL);
              v170 = (__int64 *)v175;
              sub_B97110((__int64)v156, v175, v176);
              v174 = v173 + 1;
              v173 = v174;
              if ( (unsigned int)v174 >= (unsigned int)v295 )
                break;
              v172 = (*(v156 - 16) & 2) != 0;
            }
            i = v229;
          }
          if ( dest != v296 )
            _libc_free(dest, v170);
          sub_C7D6A0(v291.m128i_i64[1], 8LL * (unsigned int)v293, 8);
          break;
        case 1:
          v140 = *((_QWORD *)sub_A17150(v35) + 2);
          if ( *((_QWORD *)sub_A17150((_BYTE *)(v247 - 16)) + 2) != v140 )
          {
            v273.m128i_i64[1] = 0;
            v273.m128i_i64[0] = (__int64)&v274;
            v295 = 0x100000000LL;
            v291.m128i_i64[0] = (__int64)&unk_49DD210;
            v274 = 0;
            v291.m128i_i64[1] = 0;
            v292 = 0;
            v293 = 0;
            dest = 0;
            v296[0] = &v273;
            sub_CB5980((__int64)&v291, 0, 0, 0);
            v141 = (__m128i *)dest;
            if ( v293 - (unsigned __int64)dest <= 0x15 )
            {
              sub_CB6200((__int64)&v291, "linking module flags '", 0x16u);
            }
            else
            {
              v142 = _mm_load_si128((const __m128i *)&xmmword_3F8EEE0);
              *((_DWORD *)dest + 4) = 1936154988;
              v141[1].m128i_i16[2] = 10016;
              *v141 = v142;
              dest = (char *)dest + 22;
            }
            v143 = sub_B91420(v246);
            v145 = (__m128i *)dest;
            v146 = (unsigned __int8 *)v143;
            v147 = v144;
            v148 = v293 - (_QWORD)dest;
            if ( v144 > v293 - (unsigned __int64)dest )
            {
              sub_CB6200((__int64)&v291, v146, v144);
              v145 = (__m128i *)dest;
              v148 = v293 - (_QWORD)dest;
            }
            else if ( v144 )
            {
              memcpy(dest, v146, v144);
              v145 = (__m128i *)((char *)dest + v147);
              dest = v145;
              v148 = v293 - (_QWORD)v145;
            }
            if ( v148 <= 0x20 )
            {
              sub_CB6200((__int64)&v291, "': IDs have conflicting values: '", 0x21u);
            }
            else
            {
              v149 = _mm_load_si128((const __m128i *)&xmmword_3F8EEF0);
              v145[2].m128i_i8[0] = 39;
              *v145 = v149;
              v145[1] = _mm_load_si128((const __m128i *)&xmmword_3F8EF10);
              dest = (char *)dest + 33;
            }
            v150 = (const char **)sub_A17150(v35);
            sub_A61DE0(v150[2], (__int64)&v291, 0);
            v151 = dest;
            if ( v293 - (unsigned __int64)dest <= 6 )
            {
              sub_CB6200((__int64)&v291, "' from ", 7u);
            }
            else
            {
              *(_DWORD *)dest = 1919295527;
              v151[2] = 28015;
              *((_BYTE *)v151 + 6) = 32;
              dest = (char *)dest + 7;
            }
            sub_CB6200((__int64)&v291, *(unsigned __int8 **)(a2[1] + 168), *(_QWORD *)(a2[1] + 176));
            v152 = dest;
            if ( v293 - (unsigned __int64)dest <= 6 )
            {
              sub_CB6200((__int64)&v291, ", and '", 7u);
            }
            else
            {
              *(_DWORD *)dest = 1851858988;
              v152[2] = 8292;
              *((_BYTE *)v152 + 6) = 39;
              dest = (char *)dest + 7;
            }
            v153 = (const char **)sub_A17150((_BYTE *)(v247 - 16));
            sub_A61DE0(v153[2], (__int64)&v291, 0);
            sub_8FD6D0((__int64)&v276, "' from ", (_QWORD *)(*a2 + 168));
            sub_CB6200((__int64)&v291, (unsigned __int8 *)v276.m128i_i64[0], v276.m128i_u64[1]);
            sub_2240A30(&v276);
            v291.m128i_i64[0] = (__int64)&unk_49DD210;
            sub_CB5840((__int64)&v291);
            v291.m128i_i64[0] = (__int64)&v273;
            LOWORD(dest) = 260;
            sub_1061590(a1, (__int64)&v291);
            sub_2240A30(&v273);
            goto LABEL_101;
          }
          break;
      }
    }
  }
  v75 = v248;
  v76 = &v248[(unsigned int)v249];
  if ( v76 != v248 )
  {
    while ( 1 )
    {
      v81 = *v75;
      v82 = sub_B91A10(v245, *v75);
      v83 = (_BYTE *)(v82 - 16);
      v84 = *(_BYTE *)(v82 - 16);
      if ( (v84 & 2) != 0 )
        v77 = *(_BYTE **)(v82 - 32);
      else
        v77 = &v83[-8 * ((v84 >> 2) & 0xF)];
      v78 = *((_QWORD *)v77 + 1);
      if ( !(_DWORD)v257 )
        goto LABEL_159;
      v79 = (v257 - 1) & (((unsigned int)v78 >> 9) ^ ((unsigned int)v78 >> 4));
      v80 = *(_QWORD *)(v255 + 8LL * v79);
      if ( v78 != v80 )
        break;
LABEL_91:
      if ( v76 == ++v75 )
        goto LABEL_244;
    }
    v220 = 1;
    while ( v80 != -4096 )
    {
      v79 = (v257 - 1) & (v220 + v79);
      v80 = *(_QWORD *)(v255 + 8LL * v79);
      if ( v78 == v80 )
        goto LABEL_91;
      ++v220;
    }
LABEL_159:
    v236 = *((_QWORD *)v77 + 1);
    v132 = *(_QWORD *)(*((_QWORD *)sub_A17150(v83) + 2) + 136LL);
    v133 = *(_QWORD *)sub_A17150(v83);
    v291.m128i_i64[1] = v236;
    v291.m128i_i64[0] = v133;
    v134 = sub_AD64C0(*(_QWORD *)(v132 + 8), 0, 0);
    v292 = sub_B98A20(v134, 0);
    v135 = v245;
    v136 = sub_B9C770(*(__int64 **)*a2, v291.m128i_i64, (__int64 *)3, 0, 1);
    sub_B970B0(v135, v81, v136);
    goto LABEL_91;
  }
LABEL_244:
  if ( &v288[(unsigned int)v289] == v288 )
  {
LABEL_272:
    v291.m128i_i64[0] = 0;
    *a1 = 1;
    sub_9C66B0(v291.m128i_i64);
  }
  else
  {
    v208 = &v288[(unsigned int)v289];
    v209 = v288;
    while ( 1 )
    {
      v217 = *v209;
      v218 = *(_BYTE *)(*v209 - 16);
      v219 = *v209 - 16;
      v210 = (v218 & 2) != 0 ? *(__int64 **)(v217 - 32) : (__int64 *)(v219 - 8LL * ((v218 >> 2) & 0xF));
      v273.m128i_i64[0] = *v210;
      v211 = *(_BYTE *)(v217 - 16);
      v212 = (v211 & 2) != 0 ? *(_QWORD *)(v217 - 32) : v219 - 8LL * ((v211 >> 2) & 0xF);
      v213 = *(_QWORD *)(v212 + 8);
      v214 = *sub_1062EA0((__int64)&v250, v273.m128i_i64);
      if ( !v214 )
        break;
      v215 = *(_BYTE *)(v214 - 16);
      v216 = (v215 & 2) != 0 ? *(_QWORD *)(v214 - 32) : -16 - 8LL * ((v215 >> 2) & 0xF) + v214;
      if ( v213 != *(_QWORD *)(v216 + 16) )
        break;
      if ( v208 == ++v209 )
        goto LABEL_272;
    }
    v279.m128i_i64[0] = (__int64)"': does not have the required value";
    LOWORD(v282) = 259;
    v221 = sub_B91420(v273.m128i_i64[0]);
    v102 = 1283;
    v276.m128i_i64[0] = (__int64)"linking module flags '";
    v277[1] = v222;
    v278 = 1283;
    v277[0] = v221;
LABEL_100:
    sub_9C6370(&v291, &v276, &v279, v102, v103, v104);
    sub_1061590(a1, (__int64)&v291);
  }
LABEL_101:
  v105 = 8LL * (unsigned int)v257;
  sub_C7D6A0(v255, v105, 8);
  if ( v248 != (unsigned int *)&v250 )
    _libc_free(v248, v105);
  if ( v288 != (__int64 *)v290 )
    _libc_free(v288, v105);
  sub_C7D6A0(v285, 8LL * (unsigned int)v287, 8);
  sub_C7D6A0(v251, 24LL * v253, 8);
  return a1;
}
