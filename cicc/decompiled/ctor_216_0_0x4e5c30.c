// Function: ctor_216_0
// Address: 0x4e5c30
//
int ctor_216_0()
{
  int v0; // eax
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // r11d
  int v10; // ecx
  int v11; // r11d
  int v12; // r9d
  int v13; // r11d
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v19; // [rsp+50h] [rbp-50h] BYREF
  int v20; // [rsp+54h] [rbp-4Ch] BYREF
  int *v21; // [rsp+58h] [rbp-48h] BYREF
  const char *v22; // [rsp+60h] [rbp-40h] BYREF
  __int64 v23; // [rsp+68h] [rbp-38h]

  qword_4FB34C0 = (__int64)&unk_49EED30;
  v0 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  word_4FB34CC &= 0xF000u;
  qword_4FB34D0 = 0;
  qword_4FB3508 = (__int64)qword_4FA01C0;
  qword_4FB34D8 = 0;
  qword_4FB34E0 = 0;
  qword_4FB34E8 = 0;
  dword_4FB34C8 = v0;
  qword_4FB3518 = (__int64)&unk_4FB3538;
  qword_4FB3520 = (__int64)&unk_4FB3538;
  qword_4FB34F0 = 0;
  qword_4FB34F8 = 0;
  qword_4FB3568 = (__int64)&unk_49E74A8;
  qword_4FB3500 = 0;
  qword_4FB34C0 = (__int64)&unk_49EEAF0;
  qword_4FB3510 = 0;
  byte_4FB3558 = 0;
  qword_4FB3578 = (__int64)&unk_49EEE10;
  qword_4FB3528 = 4;
  dword_4FB3530 = 0;
  dword_4FB3560 = 0;
  byte_4FB3574 = 1;
  dword_4FB3570 = 0;
  sub_16B8280(&qword_4FB34C0, "runtime-unroll-threshold", 24);
  dword_4FB3560 = 95;
  byte_4FB3574 = 1;
  dword_4FB3570 = 95;
  qword_4FB34F0 = 49;
  qword_4FB34E8 = (__int64)"The cut-off point for automatic runtime unrolling";
  LOBYTE(word_4FB34CC) = word_4FB34CC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB34C0);
  __cxa_atexit(sub_12EDE60, &qword_4FB34C0, &qword_4A427C0);
  v23 = 69;
  v21 = &v19;
  v22 = "The maximum iteration count below which runtime unrolling is disabled";
  v20 = 1;
  v19 = 20;
  sub_19B75E0(&unk_4FB33E0, "runtime-unroll-iter-threshold", &v21, &v20);
  __cxa_atexit(sub_12EDE60, &unk_4FB33E0, &qword_4A427C0);
  qword_4FB3300 = (__int64)&unk_49EED30;
  v1 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB3398 = 0;
  word_4FB330C &= 0xF000u;
  qword_4FB3310 = 0;
  qword_4FB3318 = 0;
  qword_4FB33B8 = (__int64)&unk_49EEE10;
  qword_4FB3320 = 0;
  dword_4FB3308 = v1;
  qword_4FB3358 = (__int64)&unk_4FB3378;
  qword_4FB3360 = (__int64)&unk_4FB3378;
  qword_4FB3348 = (__int64)qword_4FA01C0;
  qword_4FB33A8 = (__int64)&unk_49E74A8;
  qword_4FB3300 = (__int64)&unk_49EEAF0;
  qword_4FB3328 = 0;
  qword_4FB3330 = 0;
  qword_4FB3338 = 0;
  qword_4FB3340 = 0;
  qword_4FB3350 = 0;
  qword_4FB3368 = 4;
  dword_4FB3370 = 0;
  dword_4FB33A0 = 0;
  byte_4FB33B4 = 1;
  dword_4FB33B0 = 0;
  sub_16B8280(&qword_4FB3300, "unroll-assumed-size", 19);
  qword_4FB3328 = (__int64)"Assumed size for unknown types of local array";
  dword_4FB33A0 = 4;
  byte_4FB33B4 = 1;
  dword_4FB33B0 = 4;
  LOBYTE(word_4FB330C) = word_4FB330C & 0x9F | 0x20;
  qword_4FB3330 = 45;
  sub_16B88A0(&qword_4FB3300);
  __cxa_atexit(sub_12EDE60, &qword_4FB3300, &qword_4A427C0);
  v22 = "The cost threshold for loop unrolling";
  v23 = 37;
  LODWORD(v21) = 1;
  sub_19B7760(&unk_4FB3220, "unroll-threshold", &v21, &v22);
  __cxa_atexit(sub_12EDE60, &unk_4FB3220, &qword_4A427C0);
  qword_4FB3140 = (__int64)&unk_49EED30;
  v2 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB31D8 = 0;
  word_4FB314C &= 0xF000u;
  qword_4FB3150 = 0;
  qword_4FB3158 = 0;
  qword_4FB31F8 = (__int64)&unk_49EEE10;
  qword_4FB3160 = 0;
  dword_4FB3148 = v2;
  qword_4FB3198 = (__int64)&unk_4FB31B8;
  qword_4FB31A0 = (__int64)&unk_4FB31B8;
  qword_4FB3188 = (__int64)qword_4FA01C0;
  qword_4FB31E8 = (__int64)&unk_49E74A8;
  qword_4FB3140 = (__int64)&unk_49EEAF0;
  qword_4FB3168 = 0;
  qword_4FB3170 = 0;
  qword_4FB3178 = 0;
  qword_4FB3180 = 0;
  qword_4FB3190 = 0;
  qword_4FB31A8 = 4;
  dword_4FB31B0 = 0;
  dword_4FB31E0 = 0;
  byte_4FB31F4 = 1;
  dword_4FB31F0 = 0;
  sub_16B8280(&qword_4FB3140, "unroll-partial-threshold", 24);
  qword_4FB3168 = (__int64)"The cost threshold for partial loop unrolling";
  qword_4FB3170 = 45;
  LOBYTE(word_4FB314C) = word_4FB314C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB3140);
  __cxa_atexit(sub_12EDE60, &qword_4FB3140, &qword_4A427C0);
  qword_4FB3060 = (__int64)&unk_49EED30;
  v3 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB30F8 = 0;
  word_4FB306C &= 0xF000u;
  qword_4FB3070 = 0;
  qword_4FB3078 = 0;
  qword_4FB3118 = (__int64)&unk_49EEE10;
  qword_4FB3080 = 0;
  dword_4FB3068 = v3;
  qword_4FB30B8 = (__int64)&unk_4FB30D8;
  qword_4FB30C0 = (__int64)&unk_4FB30D8;
  qword_4FB30A8 = (__int64)qword_4FA01C0;
  qword_4FB3108 = (__int64)&unk_49E74A8;
  qword_4FB3060 = (__int64)&unk_49EEAF0;
  qword_4FB3088 = 0;
  qword_4FB3090 = 0;
  qword_4FB3098 = 0;
  qword_4FB30A0 = 0;
  qword_4FB30B0 = 0;
  qword_4FB30C8 = 4;
  dword_4FB30D0 = 0;
  dword_4FB3100 = 0;
  byte_4FB3114 = 1;
  dword_4FB3110 = 0;
  sub_16B8280(&qword_4FB3060, "unroll-max-percent-threshold-boost", 34);
  dword_4FB3100 = 400;
  byte_4FB3114 = 1;
  dword_4FB3110 = 400;
  qword_4FB3090 = 359;
  qword_4FB3088 = (__int64)"The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggres"
                           "sively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will "
                           "reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*"
                           "std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.";
  LOBYTE(word_4FB306C) = word_4FB306C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB3060);
  __cxa_atexit(sub_12EDE60, &qword_4FB3060, &qword_4A427C0);
  qword_4FB2F80 = (__int64)&unk_49EED30;
  v4 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB3018 = 0;
  word_4FB2F8C &= 0xF000u;
  qword_4FB2F90 = 0;
  qword_4FB2F98 = 0;
  qword_4FB3038 = (__int64)&unk_49EEE10;
  qword_4FB2FA0 = 0;
  dword_4FB2F88 = v4;
  qword_4FB2FD8 = (__int64)&unk_4FB2FF8;
  qword_4FB2FE0 = (__int64)&unk_4FB2FF8;
  qword_4FB2FC8 = (__int64)qword_4FA01C0;
  qword_4FB3028 = (__int64)&unk_49E74A8;
  qword_4FB2F80 = (__int64)&unk_49EEAF0;
  qword_4FB2FA8 = 0;
  qword_4FB2FB0 = 0;
  qword_4FB2FB8 = 0;
  qword_4FB2FC0 = 0;
  qword_4FB2FD0 = 0;
  qword_4FB2FE8 = 4;
  dword_4FB2FF0 = 0;
  dword_4FB3020 = 0;
  byte_4FB3034 = 1;
  dword_4FB3030 = 0;
  sub_16B8280(&qword_4FB2F80, "unroll-max-iteration-count-to-analyze", 37);
  qword_4FB2FA8 = (__int64)"Don't allow loop unrolling to simulate more than this number ofiterations when checking full "
                           "unroll profitability";
  dword_4FB3020 = 10;
  byte_4FB3034 = 1;
  dword_4FB3030 = 10;
  LOBYTE(word_4FB2F8C) = word_4FB2F8C & 0x9F | 0x20;
  qword_4FB2FB0 = 113;
  sub_16B88A0(&qword_4FB2F80);
  __cxa_atexit(sub_12EDE60, &qword_4FB2F80, &qword_4A427C0);
  qword_4FB2EA0 = (__int64)&unk_49EED30;
  v5 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2F38 = 0;
  word_4FB2EAC &= 0xF000u;
  qword_4FB2EB0 = 0;
  qword_4FB2EB8 = 0;
  qword_4FB2F58 = (__int64)&unk_49EEE10;
  qword_4FB2EC0 = 0;
  dword_4FB2EA8 = v5;
  qword_4FB2EF8 = (__int64)&unk_4FB2F18;
  qword_4FB2F00 = (__int64)&unk_4FB2F18;
  qword_4FB2EE8 = (__int64)qword_4FA01C0;
  qword_4FB2F48 = (__int64)&unk_49E74A8;
  qword_4FB2EA0 = (__int64)&unk_49EEAF0;
  qword_4FB2EC8 = 0;
  qword_4FB2ED0 = 0;
  qword_4FB2ED8 = 0;
  qword_4FB2EE0 = 0;
  qword_4FB2EF0 = 0;
  qword_4FB2F08 = 4;
  dword_4FB2F10 = 0;
  dword_4FB2F40 = 0;
  byte_4FB2F54 = 1;
  dword_4FB2F50 = 0;
  sub_16B8280(&qword_4FB2EA0, "unroll-count", 12);
  qword_4FB2ED0 = 105;
  qword_4FB2EC8 = (__int64)"Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes";
  LOBYTE(word_4FB2EAC) = word_4FB2EAC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2EA0);
  __cxa_atexit(sub_12EDE60, &qword_4FB2EA0, &qword_4A427C0);
  v22 = "Set the max unroll count for partial and runtime unrolling, fortesting purposes";
  v23 = 79;
  LODWORD(v21) = 1;
  sub_19B7760(&unk_4FB2DC0, "unroll-max-count", &v21, &v22);
  __cxa_atexit(sub_12EDE60, &unk_4FB2DC0, &qword_4A427C0);
  qword_4FB2CE0 = (__int64)&unk_49EED30;
  v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2D78 = 0;
  word_4FB2CEC &= 0xF000u;
  qword_4FB2CF0 = 0;
  qword_4FB2CF8 = 0;
  qword_4FB2D98 = (__int64)&unk_49EEE10;
  qword_4FB2D00 = 0;
  dword_4FB2CE8 = v6;
  qword_4FB2D38 = (__int64)&unk_4FB2D58;
  qword_4FB2D40 = (__int64)&unk_4FB2D58;
  qword_4FB2D28 = (__int64)qword_4FA01C0;
  qword_4FB2D88 = (__int64)&unk_49E74A8;
  qword_4FB2CE0 = (__int64)&unk_49EEAF0;
  qword_4FB2D08 = 0;
  qword_4FB2D10 = 0;
  qword_4FB2D18 = 0;
  qword_4FB2D20 = 0;
  qword_4FB2D30 = 0;
  qword_4FB2D48 = 4;
  dword_4FB2D50 = 0;
  dword_4FB2D80 = 0;
  byte_4FB2D94 = 1;
  dword_4FB2D90 = 0;
  sub_16B8280(&qword_4FB2CE0, "unroll-full-max-count", 21);
  qword_4FB2D10 = 65;
  qword_4FB2D08 = (__int64)"Set the max unroll count for full unrolling, for testing purposes";
  LOBYTE(word_4FB2CEC) = word_4FB2CEC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2CE0);
  __cxa_atexit(sub_12EDE60, &qword_4FB2CE0, &qword_4A427C0);
  qword_4FB2C00 = (__int64)&unk_49EED30;
  v7 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2C98 = 0;
  word_4FB2C0C &= 0xF000u;
  qword_4FB2C10 = 0;
  qword_4FB2C18 = 0;
  qword_4FB2CB8 = (__int64)&unk_49EEE10;
  qword_4FB2C20 = 0;
  dword_4FB2C08 = v7;
  qword_4FB2C58 = (__int64)&unk_4FB2C78;
  qword_4FB2C60 = (__int64)&unk_4FB2C78;
  qword_4FB2C48 = (__int64)qword_4FA01C0;
  qword_4FB2CA8 = (__int64)&unk_49E74A8;
  qword_4FB2C00 = (__int64)&unk_49EEAF0;
  qword_4FB2C28 = 0;
  qword_4FB2C30 = 0;
  qword_4FB2C38 = 0;
  qword_4FB2C40 = 0;
  qword_4FB2C50 = 0;
  qword_4FB2C68 = 4;
  dword_4FB2C70 = 0;
  dword_4FB2CA0 = 0;
  byte_4FB2CB4 = 1;
  dword_4FB2CB0 = 0;
  sub_16B8280(&qword_4FB2C00, "unroll-peel-count", 17);
  qword_4FB2C28 = (__int64)"Set the unroll peeling count, for testing purposes";
  qword_4FB2C30 = 50;
  LOBYTE(word_4FB2C0C) = word_4FB2C0C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2C00);
  __cxa_atexit(sub_12EDE60, &qword_4FB2C00, &qword_4A427C0);
  qword_4FB2B20 = (__int64)&unk_49EED30;
  v8 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2BB8 = 0;
  word_4FB2B2C &= 0xF000u;
  qword_4FB2B30 = 0;
  qword_4FB2B38 = 0;
  qword_4FB2B40 = 0;
  qword_4FB2B48 = 0;
  dword_4FB2B28 = v8;
  qword_4FB2B78 = (__int64)&unk_4FB2B98;
  qword_4FB2B80 = (__int64)&unk_4FB2B98;
  qword_4FB2B68 = (__int64)qword_4FA01C0;
  qword_4FB2B50 = 0;
  word_4FB2BD0 = 256;
  qword_4FB2BC8 = (__int64)&unk_49E74E8;
  qword_4FB2B20 = (__int64)&unk_49EEC70;
  qword_4FB2BD8 = (__int64)&unk_49EEDB0;
  qword_4FB2B58 = 0;
  qword_4FB2B60 = 0;
  qword_4FB2B70 = 0;
  qword_4FB2B88 = 4;
  dword_4FB2B90 = 0;
  byte_4FB2BC0 = 0;
  sub_16B8280(&qword_4FB2B20, "unroll-allow-partial", 20);
  qword_4FB2B50 = 83;
  qword_4FB2B48 = (__int64)"Allows loops to be partially unrolled until -unroll-threshold loop size is reached.";
  LOBYTE(word_4FB2B2C) = word_4FB2B2C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2B20);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2B20, &qword_4A427C0);
  qword_4FB2A40 = (__int64)&unk_49EED30;
  v9 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2AD8 = 0;
  word_4FB2AF0 = 256;
  qword_4FB2A50 = 0;
  word_4FB2A4C &= 0xF000u;
  qword_4FB2AE8 = (__int64)&unk_49E74E8;
  qword_4FB2A40 = (__int64)&unk_49EEC70;
  dword_4FB2A48 = v9;
  qword_4FB2AF8 = (__int64)&unk_49EEDB0;
  qword_4FB2A88 = (__int64)qword_4FA01C0;
  qword_4FB2A98 = (__int64)&unk_4FB2AB8;
  qword_4FB2AA0 = (__int64)&unk_4FB2AB8;
  qword_4FB2A58 = 0;
  qword_4FB2A60 = 0;
  qword_4FB2A68 = 0;
  qword_4FB2A70 = 0;
  qword_4FB2A78 = 0;
  qword_4FB2A80 = 0;
  qword_4FB2A90 = 0;
  qword_4FB2AA8 = 4;
  dword_4FB2AB0 = 0;
  byte_4FB2AE0 = 0;
  sub_16B8280(&qword_4FB2A40, "unroll-allow-remainder", 22);
  qword_4FB2A70 = 78;
  qword_4FB2A68 = (__int64)"Allow generation of a loop remainder (extra iterations) when unrolling a loop.";
  LOBYTE(word_4FB2A4C) = word_4FB2A4C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2A40);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2A40, &qword_4A427C0);
  qword_4FB2960 = (__int64)&unk_49EED30;
  v10 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB29F8 = 0;
  word_4FB296C &= 0xF000u;
  qword_4FB2970 = 0;
  qword_4FB2978 = 0;
  qword_4FB2A08 = (__int64)&unk_49E74E8;
  word_4FB2A10 = 256;
  dword_4FB2968 = v10;
  qword_4FB2960 = (__int64)&unk_49EEC70;
  qword_4FB2A18 = (__int64)&unk_49EEDB0;
  qword_4FB29A8 = (__int64)qword_4FA01C0;
  qword_4FB29B8 = (__int64)&unk_4FB29D8;
  qword_4FB29C0 = (__int64)&unk_4FB29D8;
  qword_4FB2980 = 0;
  qword_4FB2988 = 0;
  qword_4FB2990 = 0;
  qword_4FB2998 = 0;
  qword_4FB29A0 = 0;
  qword_4FB29B0 = 0;
  qword_4FB29C8 = 4;
  dword_4FB29D0 = 0;
  byte_4FB2A00 = 0;
  sub_16B8280(&qword_4FB2960, "unroll-runtime", 14);
  qword_4FB2990 = 38;
  qword_4FB2988 = (__int64)"Unroll loops with run-time trip counts";
  LOBYTE(word_4FB296C) = word_4FB296C & 0x98 | 0x21;
  sub_16B88A0(&qword_4FB2960);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2960, &qword_4A427C0);
  qword_4FB2880 = (__int64)&unk_49EED30;
  v11 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2918 = 0;
  word_4FB288C &= 0xF000u;
  qword_4FB2890 = 0;
  qword_4FB2898 = 0;
  qword_4FB2938 = (__int64)&unk_49EEE10;
  qword_4FB28A0 = 0;
  dword_4FB2888 = v11;
  qword_4FB28D8 = (__int64)&unk_4FB28F8;
  qword_4FB28E0 = (__int64)&unk_4FB28F8;
  qword_4FB28C8 = (__int64)qword_4FA01C0;
  qword_4FB2928 = (__int64)&unk_49E74A8;
  qword_4FB2880 = (__int64)&unk_49EEAF0;
  qword_4FB28A8 = 0;
  qword_4FB28B0 = 0;
  qword_4FB28B8 = 0;
  qword_4FB28C0 = 0;
  qword_4FB28D0 = 0;
  qword_4FB28E8 = 4;
  dword_4FB28F0 = 0;
  dword_4FB2920 = 0;
  byte_4FB2934 = 1;
  dword_4FB2930 = 0;
  sub_16B8280(&qword_4FB2880, "unroll-max-upperbound", 21);
  dword_4FB2920 = 8;
  byte_4FB2934 = 1;
  dword_4FB2930 = 8;
  qword_4FB28B0 = 65;
  qword_4FB28A8 = (__int64)"The max of trip count upper bound that is considered in unrolling";
  LOBYTE(word_4FB288C) = word_4FB288C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB2880);
  __cxa_atexit(sub_12EDE60, &qword_4FB2880, &qword_4A427C0);
  qword_4FB27A0 = (__int64)&unk_49EED30;
  v12 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2838 = 0;
  word_4FB27AC &= 0xF000u;
  qword_4FB27B0 = 0;
  qword_4FB27B8 = 0;
  qword_4FB2858 = (__int64)&unk_49EEE10;
  qword_4FB27C0 = 0;
  dword_4FB27A8 = v12;
  qword_4FB27F8 = (__int64)&unk_4FB2818;
  qword_4FB2800 = (__int64)&unk_4FB2818;
  qword_4FB27E8 = (__int64)qword_4FA01C0;
  qword_4FB2848 = (__int64)&unk_49E74A8;
  qword_4FB27A0 = (__int64)&unk_49EEAF0;
  qword_4FB27C8 = 0;
  qword_4FB27D0 = 0;
  qword_4FB27D8 = 0;
  qword_4FB27E0 = 0;
  qword_4FB27F0 = 0;
  qword_4FB2808 = 4;
  dword_4FB2810 = 0;
  dword_4FB2840 = 0;
  byte_4FB2854 = 1;
  dword_4FB2850 = 0;
  sub_16B8280(&qword_4FB27A0, "max-pragma-upperbound-unroll", 28);
  dword_4FB2840 = 64;
  byte_4FB2854 = 1;
  dword_4FB2850 = 64;
  qword_4FB27D0 = 77;
  qword_4FB27C8 = (__int64)"The max of trip count upper bound that is considered in unrolling with pragma";
  LOBYTE(word_4FB27AC) = word_4FB27AC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB27A0);
  __cxa_atexit(sub_12EDE60, &qword_4FB27A0, &qword_4A427C0);
  qword_4FB26C0 = (__int64)&unk_49EED30;
  v13 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  byte_4FB2758 = 0;
  word_4FB26CC &= 0xF000u;
  qword_4FB26D0 = 0;
  qword_4FB26D8 = 0;
  qword_4FB2778 = (__int64)&unk_49EEE10;
  qword_4FB26E0 = 0;
  dword_4FB26C8 = v13;
  qword_4FB2718 = (__int64)&unk_4FB2738;
  qword_4FB2720 = (__int64)&unk_4FB2738;
  qword_4FB2708 = (__int64)qword_4FA01C0;
  qword_4FB2768 = (__int64)&unk_49E74A8;
  qword_4FB26C0 = (__int64)&unk_49EEAF0;
  qword_4FB26E8 = 0;
  qword_4FB26F0 = 0;
  qword_4FB26F8 = 0;
  qword_4FB2700 = 0;
  qword_4FB2710 = 0;
  qword_4FB2728 = 4;
  dword_4FB2730 = 0;
  dword_4FB2760 = 0;
  byte_4FB2774 = 1;
  dword_4FB2770 = 0;
  sub_16B8280(&qword_4FB26C0, "pragma-unroll-threshold", 23);
  dword_4FB2760 = 0x8000;
  byte_4FB2774 = 1;
  dword_4FB2770 = 0x8000;
  qword_4FB26F0 = 74;
  LOBYTE(word_4FB26CC) = word_4FB26CC & 0x9F | 0x20;
  qword_4FB26E8 = (__int64)"Unrolled size limit for loops with an unroll(full) or unroll_count pragma.";
  sub_16B88A0(&qword_4FB26C0);
  __cxa_atexit(sub_12EDE60, &qword_4FB26C0, &qword_4A427C0);
  v22 = "If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be le"
        "ss aggressively unrolled.";
  v23 = 137;
  v21 = &v19;
  v20 = 1;
  v19 = 5;
  sub_19B75E0(&unk_4FB25E0, "flat-loop-tripcount-threshold", &v21, &v20);
  __cxa_atexit(sub_12EDE60, &unk_4FB25E0, &qword_4A427C0);
  qword_4FB2500 = (__int64)&unk_49EED30;
  v14 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  word_4FB25B0 = 256;
  qword_4FB2510 = 0;
  word_4FB250C &= 0xF000u;
  qword_4FB2500 = (__int64)&unk_49EEC70;
  qword_4FB25B8 = (__int64)&unk_49EEDB0;
  dword_4FB2508 = v14;
  qword_4FB2548 = (__int64)qword_4FA01C0;
  qword_4FB2558 = (__int64)&unk_4FB2578;
  qword_4FB2560 = (__int64)&unk_4FB2578;
  qword_4FB25A8 = (__int64)&unk_49E74E8;
  qword_4FB2518 = 0;
  qword_4FB2520 = 0;
  qword_4FB2528 = 0;
  qword_4FB2530 = 0;
  qword_4FB2538 = 0;
  qword_4FB2540 = 0;
  qword_4FB2550 = 0;
  qword_4FB2568 = 4;
  dword_4FB2570 = 0;
  byte_4FB2598 = 0;
  byte_4FB25A0 = 0;
  sub_16B8280(&qword_4FB2500, "unroll-allow-peeling", 20);
  word_4FB25B0 = 257;
  byte_4FB25A0 = 1;
  qword_4FB2530 = 73;
  LOBYTE(word_4FB250C) = word_4FB250C & 0x9F | 0x20;
  qword_4FB2528 = (__int64)"Allows loops to be peeled when the dynamic trip count is known to be low.";
  sub_16B88A0(&qword_4FB2500);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2500, &qword_4A427C0);
  qword_4FB2420 = (__int64)&unk_49EED30;
  v15 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  word_4FB24D0 = 256;
  qword_4FB2430 = 0;
  word_4FB242C &= 0xF000u;
  qword_4FB2420 = (__int64)&unk_49EEC70;
  qword_4FB24D8 = (__int64)&unk_49EEDB0;
  dword_4FB2428 = v15;
  qword_4FB2468 = (__int64)qword_4FA01C0;
  qword_4FB2478 = (__int64)&unk_4FB2498;
  qword_4FB2480 = (__int64)&unk_4FB2498;
  qword_4FB24C8 = (__int64)&unk_49E74E8;
  qword_4FB2438 = 0;
  qword_4FB2440 = 0;
  qword_4FB2448 = 0;
  qword_4FB2450 = 0;
  qword_4FB2458 = 0;
  qword_4FB2460 = 0;
  qword_4FB2470 = 0;
  qword_4FB2488 = 4;
  dword_4FB2490 = 0;
  byte_4FB24B8 = 0;
  byte_4FB24C0 = 0;
  sub_16B8280(&qword_4FB2420, "unroll-count-extern-indirect-call-as-inline", 43);
  word_4FB24D0 = 256;
  byte_4FB24C0 = 0;
  qword_4FB2450 = 135;
  LOBYTE(word_4FB242C) = word_4FB242C & 0x9F | 0x20;
  qword_4FB2448 = (__int64)"During unroll loop analysis, consider calls to extern functions or indirect calls as potentia"
                           "lly inlinable (e.g. during LTO generation)";
  sub_16B88A0(&qword_4FB2420);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2420, &qword_4A427C0);
  qword_4FB2340 = (__int64)&unk_49EED30;
  v16 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  word_4FB23F0 = 256;
  qword_4FB2350 = 0;
  word_4FB234C &= 0xF000u;
  qword_4FB2340 = (__int64)&unk_49EEC70;
  qword_4FB23F8 = (__int64)&unk_49EEDB0;
  dword_4FB2348 = v16;
  qword_4FB2388 = (__int64)qword_4FA01C0;
  qword_4FB2398 = (__int64)&unk_4FB23B8;
  qword_4FB23A0 = (__int64)&unk_4FB23B8;
  qword_4FB23E8 = (__int64)&unk_49E74E8;
  qword_4FB2358 = 0;
  qword_4FB2360 = 0;
  qword_4FB2368 = 0;
  qword_4FB2370 = 0;
  qword_4FB2378 = 0;
  qword_4FB2380 = 0;
  qword_4FB2390 = 0;
  qword_4FB23A8 = 4;
  dword_4FB23B0 = 0;
  byte_4FB23D8 = 0;
  byte_4FB23E0 = 0;
  sub_16B8280(&qword_4FB2340, "unroll-remainder", 16);
  qword_4FB2370 = 40;
  LOBYTE(word_4FB234C) = word_4FB234C & 0x9F | 0x20;
  qword_4FB2368 = (__int64)"Allow the loop remainder to be unrolled.";
  sub_16B88A0(&qword_4FB2340);
  __cxa_atexit(sub_12EDEC0, &qword_4FB2340, &qword_4A427C0);
  qword_4FB2260 = (__int64)&unk_49EED30;
  v17 = _InterlockedExchangeAdd64((volatile signed __int64 *)&unk_4FA0230, 1u);
  word_4FB2310 = 256;
  qword_4FB2270 = 0;
  word_4FB226C &= 0xF000u;
  qword_4FB2260 = (__int64)&unk_49EEC70;
  qword_4FB2318 = (__int64)&unk_49EEDB0;
  dword_4FB2268 = v17;
  qword_4FB22A8 = (__int64)qword_4FA01C0;
  qword_4FB22B8 = (__int64)&unk_4FB22D8;
  qword_4FB22C0 = (__int64)&unk_4FB22D8;
  qword_4FB2308 = (__int64)&unk_49E74E8;
  qword_4FB2278 = 0;
  qword_4FB2280 = 0;
  qword_4FB2288 = 0;
  qword_4FB2290 = 0;
  qword_4FB2298 = 0;
  qword_4FB22A0 = 0;
  qword_4FB22B0 = 0;
  qword_4FB22C8 = 4;
  dword_4FB22D0 = 0;
  byte_4FB22F8 = 0;
  byte_4FB2300 = 0;
  sub_16B8280(&qword_4FB2260, "unroll-revisit-child-loops", 26);
  qword_4FB2290 = 154;
  LOBYTE(word_4FB226C) = word_4FB226C & 0x9F | 0x20;
  qword_4FB2288 = (__int64)"Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be "
                           "needed as child loops (or their clones) were already visited.";
  sub_16B88A0(&qword_4FB2260);
  return __cxa_atexit(sub_12EDEC0, &qword_4FB2260, &qword_4A427C0);
}
