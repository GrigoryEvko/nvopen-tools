// Function: ctor_247_0
// Address: 0x4ee490
//
int ctor_247_0()
{
  int v1; // [rsp+40h] [rbp-50h] BYREF
  int v2; // [rsp+44h] [rbp-4Ch] BYREF
  int *v3; // [rsp+48h] [rbp-48h] BYREF
  const char *v4; // [rsp+50h] [rbp-40h] BYREF
  __int64 v5; // [rsp+58h] [rbp-38h]

  v4 = "Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overh"
       "eads are incurred.";
  v3 = &v1;
  v5 = 131;
  v2 = 1;
  v1 = 16;
  sub_1B957F0(&unk_4FB8DA0, "vectorizer-min-trip-count", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8DA0, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB8CC0, 0, 0);
  byte_4FB8D60 = 0;
  word_4FB8D70 = 256;
  qword_4FB8D68 = (__int64)&unk_49E74E8;
  qword_4FB8CC0 = (__int64)&unk_49EEC70;
  qword_4FB8D78 = (__int64)&unk_49EEDB0;
  sub_16B8280(&qword_4FB8CC0, "vectorizer-maximize-bandwidth", 29);
  byte_4FB8D60 = 0;
  word_4FB8D70 = 256;
  qword_4FB8CF0 = 109;
  qword_4FB8CE8 = (__int64)"Maximize bandwidth when selecting vectorization factor which will be determined by the smalle"
                           "st type in loop.";
  byte_4FB8CCC = byte_4FB8CCC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB8CC0);
  __cxa_atexit(sub_12EDEC0, &qword_4FB8CC0, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB8BE0, 0, 0);
  byte_4FB8C80 = 0;
  qword_4FB8C88 = (__int64)&unk_49E74E8;
  qword_4FB8BE0 = (__int64)&unk_49EEC70;
  qword_4FB8C98 = (__int64)&unk_49EEDB0;
  word_4FB8C90 = 256;
  sub_16B8280(&qword_4FB8BE0, "enable-interleaved-mem-accesses", 31);
  word_4FB8C90 = 256;
  byte_4FB8C80 = 0;
  qword_4FB8C10 = 61;
  qword_4FB8C08 = (__int64)"Enable vectorization on interleaved memory accesses in a loop";
  byte_4FB8BEC = byte_4FB8BEC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB8BE0);
  __cxa_atexit(sub_12EDEC0, &qword_4FB8BE0, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB8B00, 0, 0);
  dword_4FB8BA0 = 0;
  byte_4FB8BB4 = 1;
  qword_4FB8BA8 = (__int64)&unk_49E74A8;
  qword_4FB8B00 = (__int64)&unk_49EEAF0;
  qword_4FB8BB8 = (__int64)&unk_49EEE10;
  dword_4FB8BB0 = 0;
  sub_16B8280(&qword_4FB8B00, "max-interleave-group-factor", 27);
  qword_4FB8B30 = 60;
  dword_4FB8BA0 = 8;
  byte_4FB8BB4 = 1;
  dword_4FB8BB0 = 8;
  qword_4FB8B28 = (__int64)"Maximum factor for an interleaved access group (default = 8)";
  byte_4FB8B0C = byte_4FB8B0C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB8B00);
  __cxa_atexit(sub_12EDE60, &qword_4FB8B00, &qword_4A427C0);
  v5 = 62;
  v4 = "A flag that overrides the target's number of scalar registers.";
  v3 = &v1;
  v2 = 1;
  v1 = 0;
  sub_1B95970(&unk_4FB8A20, "force-target-num-scalar-regs", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8A20, &qword_4A427C0);
  v5 = 62;
  v4 = "A flag that overrides the target's number of vector registers.";
  v3 = &v1;
  v2 = 1;
  v1 = 0;
  sub_1B95970(&unk_4FB8940, "force-target-num-vector-regs", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8940, &qword_4A427C0);
  v5 = 74;
  v4 = "A flag that overrides the target's max interleave factor for scalar loops.";
  v3 = &v1;
  v2 = 1;
  v1 = 0;
  sub_1B95AF0(&unk_4FB8860, "force-target-max-scalar-interleave", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8860, &qword_4A427C0);
  v5 = 78;
  v4 = "A flag that overrides the target's max interleave factor for vectorized loops.";
  v3 = &v1;
  v2 = 1;
  v1 = 0;
  sub_1B95AF0(&unk_4FB8780, "force-target-max-vector-interleave", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8780, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB86A0, 0, 0);
  dword_4FB8740 = 0;
  qword_4FB8748 = (__int64)&unk_49E74A8;
  qword_4FB86A0 = (__int64)&unk_49EEAF0;
  qword_4FB8758 = (__int64)&unk_49EEE10;
  byte_4FB8754 = 1;
  dword_4FB8750 = 0;
  sub_16B8280(&qword_4FB86A0, "force-target-instruction-cost", 29);
  dword_4FB8740 = 0;
  byte_4FB8754 = 1;
  dword_4FB8750 = 0;
  qword_4FB86D0 = 141;
  qword_4FB86C8 = (__int64)"A flag that overrides the target's expected cost for an instruction to a single constant valu"
                           "e. Mostly useful for getting consistent testing.";
  byte_4FB86AC = byte_4FB86AC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB86A0);
  __cxa_atexit(sub_12EDE60, &qword_4FB86A0, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB85C0, 0, 0);
  dword_4FB8660 = 0;
  qword_4FB8668 = (__int64)&unk_49E74A8;
  qword_4FB85C0 = (__int64)&unk_49EEAF0;
  qword_4FB8678 = (__int64)&unk_49EEE10;
  byte_4FB8674 = 1;
  dword_4FB8670 = 0;
  sub_16B8280(&qword_4FB85C0, "small-loop-cost", 15);
  dword_4FB8660 = 20;
  qword_4FB85E8 = (__int64)"The cost of a loop that is considered 'small' by the interleaver.";
  byte_4FB8674 = 1;
  dword_4FB8670 = 20;
  qword_4FB85F0 = 65;
  byte_4FB85CC = byte_4FB85CC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB85C0);
  __cxa_atexit(sub_12EDE60, &qword_4FB85C0, &qword_4A427C0);
  v5 = 152;
  v4 = "Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions an"
       "d being more aggressive in hot regions.";
  v3 = &v1;
  v2 = 1;
  LOBYTE(v1) = 1;
  sub_1B95C70(&unk_4FB84E0, "loop-vectorize-with-block-frequency", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDEC0, &unk_4FB84E0, &qword_4A427C0);
  v5 = 64;
  v4 = "Enable runtime interleaving until load/store ports are saturated";
  v3 = &v1;
  v2 = 1;
  LOBYTE(v1) = 1;
  sub_1B95C70(&unk_4FB8400, "enable-loadstore-runtime-interleave", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDEC0, &unk_4FB8400, &qword_4A427C0);
  v5 = 51;
  v4 = "Max number of stores to be predicated behind an if.";
  v3 = &v1;
  v2 = 1;
  v1 = 1;
  sub_1B957F0(&unk_4FB8320, "vectorize-num-stores-pred", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDE60, &unk_4FB8320, &qword_4A427C0);
  v5 = 56;
  v4 = "Count the induction variable only once when interleaving";
  v3 = &v1;
  v2 = 1;
  LOBYTE(v1) = 1;
  sub_1B95DF0(&unk_4FB8240, "enable-ind-var-reg-heur", &v3, &v2, &v4);
  __cxa_atexit(sub_12EDEC0, &unk_4FB8240, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB8160, 0, 0);
  byte_4FB8200 = 0;
  word_4FB8210 = 256;
  qword_4FB8160 = (__int64)&unk_49EEC70;
  qword_4FB8218 = (__int64)&unk_49EEDB0;
  qword_4FB8208 = (__int64)&unk_49E74E8;
  sub_16B8280(&qword_4FB8160, "enable-cond-stores-vec", 22);
  byte_4FB8200 = 1;
  word_4FB8210 = 257;
  qword_4FB8190 = 53;
  qword_4FB8188 = (__int64)"Enable if predication of stores during vectorization.";
  byte_4FB816C = byte_4FB816C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB8160);
  __cxa_atexit(sub_12EDEC0, &qword_4FB8160, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB8080, 0, 0);
  dword_4FB8120 = 0;
  qword_4FB8128 = (__int64)&unk_49E74A8;
  qword_4FB8138 = (__int64)&unk_49EEE10;
  qword_4FB8080 = (__int64)&unk_49EEAF0;
  byte_4FB8134 = 1;
  dword_4FB8130 = 0;
  sub_16B8280(&qword_4FB8080, "max-nested-scalar-reduction-interleave", 38);
  dword_4FB8120 = 2;
  byte_4FB8134 = 1;
  dword_4FB8130 = 2;
  qword_4FB80B0 = 90;
  qword_4FB80A8 = (__int64)"The maximum interleave count to use when interleaving a scalar reduction in a nested loop.";
  byte_4FB808C = byte_4FB808C & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB8080);
  __cxa_atexit(sub_12EDE60, &qword_4FB8080, &qword_4A427C0);
  sub_12F0CE0(&qword_4FB7FA0, 0, 0);
  byte_4FB8040 = 0;
  qword_4FB7FA0 = (__int64)&unk_49EEC70;
  qword_4FB8058 = (__int64)&unk_49EEDB0;
  word_4FB8050 = 256;
  qword_4FB8048 = (__int64)&unk_49E74E8;
  sub_16B8280(&qword_4FB7FA0, "enable-vplan-native-path", 24);
  word_4FB8050 = 256;
  byte_4FB8040 = 0;
  qword_4FB7FD0 = 81;
  qword_4FB7FC8 = (__int64)"Enable VPlan-native vectorization path with support for outer loop vectorization.";
  byte_4FB7FAC = byte_4FB7FAC & 0x9F | 0x20;
  sub_16B88A0(&qword_4FB7FA0);
  __cxa_atexit(sub_12EDEC0, &qword_4FB7FA0, &qword_4A427C0);
  v5 = 175;
  v4 = "Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPl"
       "an H-CFG construction in the VPlan-native vectorization path).";
  v2 = 1;
  LOBYTE(v1) = 0;
  v3 = &v1;
  sub_1B95DF0(&unk_4FB7EC0, "vplan-build-stress-test", &v3, &v2, &v4);
  return __cxa_atexit(sub_12EDEC0, &unk_4FB7EC0, &qword_4A427C0);
}
