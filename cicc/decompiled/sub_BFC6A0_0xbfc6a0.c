// Function: sub_BFC6A0
// Address: 0xbfc6a0
//
void __fastcall sub_BFC6A0(__int64 *a1, __int64 a2)
{
  unsigned __int8 *v3; // r14
  __int64 v4; // rbx
  __int64 v5; // r13
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // r12
  int v9; // r12d
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r13
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r12
  int v17; // r12d
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  int v21; // eax
  __int64 v22; // rdx
  __int64 v23; // rdi
  __int64 v24; // rdx
  unsigned int v25; // eax
  __int64 v26; // rcx
  __int64 v27; // r13
  __int64 v28; // r12
  int v29; // edx
  __int64 v30; // r13
  __int64 v31; // rax
  __int64 v32; // rdx
  __int64 v33; // r12
  int v34; // r12d
  __int64 v35; // rax
  __int64 v36; // rdx
  __int64 v37; // rax
  __int64 v38; // r12
  unsigned __int8 *v39; // rax
  bool v40; // zf
  char *v41; // rax
  char v42; // dl
  int v43; // edx
  __int64 v44; // r12
  const char *v45; // rax
  __int64 v46; // r8
  _BYTE *v47; // rax
  const char *v48; // rax
  __int64 v49; // r12
  int v50; // edx
  unsigned int v51; // eax
  __int64 v52; // r8
  __int64 v53; // r9
  int v54; // eax
  __int64 v55; // r13
  __int64 v56; // rbx
  __int64 v57; // r12
  unsigned int v58; // eax
  __int64 v59; // r8
  __int64 v60; // r9
  __int64 v61; // r14
  int v62; // edx
  __int64 v63; // rax
  __int64 v64; // rdx
  __int64 v65; // rax
  __int64 v66; // rdx
  __int64 v67; // rbx
  __int64 v68; // r15
  unsigned __int8 *v69; // rax
  int v70; // r13d
  unsigned int v71; // r14d
  char v72; // r15
  char v73; // bl
  char v74; // al
  char v75; // al
  unsigned int v76; // eax
  unsigned int i; // ebx
  __int64 v78; // r13
  char v79; // al
  __int64 v80; // rax
  __int64 v81; // r13
  bool v82; // r12
  bool v83; // sf
  __int64 v84; // rax
  __int64 v85; // rdx
  __int64 v86; // r12
  __int64 v87; // r12
  __int64 v88; // r13
  __int64 v89; // rax
  int v90; // r15d
  __int64 v91; // r12
  __int64 v92; // r14
  __int64 v93; // rbx
  __int64 v94; // rax
  bool v95; // al
  int v96; // r14d
  __int64 v97; // r14
  const char *v98; // rax
  __int64 *v99; // r15
  const char *v100; // rax
  unsigned __int8 *v101; // rsi
  __int64 v102; // rcx
  __int64 v103; // r9
  int v104; // eax
  unsigned __int8 *v105; // rax
  unsigned __int8 *v106; // r12
  const char *v107; // rax
  __int64 v108; // rdx
  __int64 v109; // rax
  __int64 v110; // rcx
  char v111; // dl
  __int64 v112; // rdi
  char v113; // al
  unsigned int v114; // eax
  __int64 v115; // r12
  bool v116; // bl
  __int64 v117; // rax
  unsigned int *v118; // rax
  int v119; // esi
  __int64 v120; // rdi
  __int64 v121; // rdx
  __int64 *v122; // rcx
  __int64 v123; // rbx
  char v124; // al
  char v125; // al
  const char *v126; // rax
  __int64 v127; // rbx
  unsigned int v128; // r12d
  unsigned int v129; // r12d
  int v130; // eax
  const char *v131; // rax
  __int64 v132; // rbx
  __int64 v133; // rsi
  __int64 v134; // rdx
  int v135; // ecx
  int v136; // eax
  __int64 v137; // rdx
  unsigned int v138; // eax
  bool v139; // al
  __int64 v140; // rax
  __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // r12
  __int64 v144; // rdi
  __int64 v145; // rdi
  __int64 v146; // rdi
  int v147; // eax
  __int64 v148; // rdx
  const char *v149; // rdi
  __int64 v150; // rbx
  _BYTE *v151; // rax
  __int64 v152; // rdi
  _BYTE *v153; // rax
  __int64 v154; // rbx
  __int64 v155; // rax
  __int64 v156; // r12
  int v157; // r12d
  __int64 v158; // rax
  __int64 v159; // rax
  _BYTE *v160; // rbx
  __int64 v161; // rax
  unsigned __int8 *v162; // r13
  __int64 v163; // r12
  __int64 v164; // rax
  __int64 *v165; // rax
  _BYTE *v166; // r14
  __int64 *v167; // r13
  __int64 *k; // rbx
  __int64 v169; // rax
  __int64 *v170; // rdx
  __int64 v171; // r12
  __int64 v172; // rax
  __int64 v173; // rbx
  __int64 v174; // rax
  __int64 v175; // rax
  __int64 v176; // r12
  __int64 v177; // rax
  int v178; // eax
  __int64 v179; // rax
  __int64 v180; // rcx
  int v181; // r8d
  unsigned int jj; // edx
  _QWORD *v183; // r10
  unsigned __int64 v184; // rax
  __int64 *v185; // rdx
  __int64 v186; // r8
  __int64 *v187; // r14
  bool v188; // r13
  __int64 *kk; // r12
  __int64 v190; // rbx
  __int64 v191; // rax
  __int64 *v192; // rbx
  bool v193; // r15
  bool v194; // r12
  int v195; // r13d
  __int64 v196; // rax
  bool v197; // cl
  bool v198; // r12
  unsigned int v199; // edx
  __int64 v200; // rsi
  unsigned int v201; // eax
  __int64 v202; // r12
  _QWORD *ii; // r13
  __int64 v204; // rax
  _QWORD *v205; // rax
  _QWORD *v206; // rbx
  __int64 v207; // rax
  _BYTE *v208; // rdi
  __int64 v209; // rdx
  _QWORD *v210; // rax
  __int64 v211; // rdx
  _QWORD *v212; // rax
  __int64 v213; // rdx
  __int64 v214; // rsi
  __int64 v215; // rcx
  __int64 v216; // rdi
  unsigned __int64 v217; // rbx
  __int64 v218; // rax
  unsigned __int64 v219; // r12
  __int64 v220; // rdx
  __int64 v221; // r8
  __int64 v222; // r8
  __int64 v223; // rdi
  unsigned int v224; // eax
  int v225; // edx
  int v226; // edx
  _BYTE *v227; // rdi
  __int64 v228; // rax
  __int64 v229; // rcx
  _QWORD *v230; // rdx
  __int64 v231; // rcx
  _QWORD *v232; // rdx
  __int64 v233; // rcx
  _QWORD *v234; // rdx
  __int64 v235; // rdx
  _QWORD *v236; // rax
  __int16 v237; // ax
  _BYTE *v238; // rax
  __int64 v239; // rax
  int v240; // eax
  __int64 v241; // rax
  __int64 v242; // rax
  __int64 v243; // rdx
  __int64 v244; // rcx
  __int64 v245; // r8
  __int64 v246; // rdi
  unsigned __int8 v247; // al
  __int64 v248; // r8
  _QWORD *v249; // rcx
  _QWORD *v250; // rax
  _QWORD *v251; // rax
  __int64 v252; // r9
  __int64 v253; // r11
  __int64 v254; // r9
  __int64 v255; // r8
  _QWORD *v256; // rdx
  _QWORD *v257; // rcx
  _QWORD *v258; // rdx
  __int64 v259; // rax
  __int64 v260; // rbx
  __int64 v261; // r12
  __int64 v262; // rax
  __int64 v263; // r12
  __int64 v264; // rbx
  __int64 v265; // rcx
  __int64 v266; // r12
  __int64 v267; // r12
  unsigned __int8 *v268; // rax
  __int64 v269; // r12
  _QWORD *v270; // rbx
  unsigned __int64 v271; // rax
  unsigned __int64 v272; // rdx
  __int64 v273; // r12
  unsigned __int8 *v274; // rax
  unsigned __int8 **v275; // rdx
  unsigned __int8 **nn; // rbx
  unsigned __int8 *v277; // rdi
  __int64 v278; // r12
  __int64 v279; // rdi
  int v280; // ebx
  __int64 v281; // rax
  __int64 v282; // rax
  char v283; // r8
  int v284; // ebx
  int v285; // eax
  unsigned __int64 v286; // rax
  __int64 v287; // rdx
  _QWORD *v288; // rax
  __int64 v289; // r12
  unsigned int v290; // ebx
  bool v291; // al
  __int64 v293; // rdx
  __int64 v294; // rax
  __int64 v295; // rbx
  __int64 v296; // r8
  int v297; // eax
  unsigned __int8 v298; // dl
  __int64 v299; // r12
  _BYTE *v300; // rax
  __int64 v301; // r12
  __int64 v302; // rdx
  _QWORD *v303; // rax
  int v304; // eax
  unsigned int v305; // eax
  __int64 v306; // rax
  const char *v307; // rbx
  __int64 v308; // rax
  __int64 v309; // rdx
  unsigned __int16 v310; // ax
  unsigned __int8 *v311; // rdx
  __int64 v312; // rcx
  int v313; // eax
  __int64 v314; // rdx
  unsigned int v315; // ebx
  unsigned __int8 v316; // al
  __int64 v317; // rcx
  __int64 v318; // rdi
  int v319; // eax
  __int64 v320; // rdx
  __int64 v321; // r12
  int v322; // eax
  unsigned __int8 v323; // dl
  int v324; // ebx
  __int64 v325; // rdx
  __int64 v326; // rdi
  __int64 v327; // rcx
  __int64 v328; // rax
  __int64 v329; // r12
  unsigned int v330; // eax
  __int64 v331; // rbx
  __int64 v332; // r12
  int v333; // ecx
  __int64 v334; // rdx
  __int64 v335; // rcx
  _QWORD *v336; // rax
  __int64 v337; // rcx
  _QWORD *v338; // rax
  __int64 v339; // rdx
  _QWORD *v340; // rax
  __int64 v341; // rbx
  unsigned __int16 v342; // ax
  char v343; // cl
  _QWORD *v344; // r8
  unsigned __int64 v345; // rdx
  __int64 v346; // rax
  int v347; // eax
  unsigned __int16 v348; // ax
  char v349; // cl
  unsigned __int64 v350; // rdx
  __int64 v351; // rdx
  __int64 v352; // rax
  _QWORD *v353; // rcx
  __int64 v354; // rdi
  __int64 v355; // r8
  unsigned int v356; // eax
  __int64 v357; // rbx
  __int64 v358; // rcx
  int v359; // eax
  __int64 v360; // rbx
  _BYTE *v361; // rax
  __int64 v362; // rdx
  __int64 v363; // rax
  _QWORD *v364; // rcx
  __int64 v365; // rdi
  __int64 v366; // r8
  unsigned int v367; // eax
  unsigned int v368; // ebx
  __int64 v369; // rcx
  __int64 v370; // rcx
  __int64 v371; // rcx
  int v372; // eax
  __int64 v373; // rdx
  unsigned int v374; // ebx
  unsigned int v375; // ebx
  __int64 v376; // rax
  __int64 v377; // rsi
  __int64 v378; // rbx
  __int64 v379; // rax
  unsigned __int8 v380; // cl
  int v381; // edi
  __int64 v382; // rdx
  __int64 v383; // rax
  unsigned __int8 v384; // cl
  __int64 v385; // rax
  __int64 v386; // r12
  _BYTE *v387; // rax
  __int64 v388; // rdx
  __int64 *v389; // rax
  unsigned int v390; // edx
  __int64 v391; // rax
  __int64 v392; // rax
  __int64 v393; // rbx
  int v394; // eax
  __int64 v395; // rsi
  __int64 v396; // rcx
  _QWORD *v397; // rdx
  int v398; // r12d
  int v399; // edx
  __int64 v400; // rsi
  unsigned __int64 v401; // rcx
  __int64 v402; // r12
  __int64 v403; // rbx
  int v404; // r13d
  __int64 v405; // rdx
  _QWORD *v406; // rax
  __int64 v407; // rdx
  _QWORD *v408; // rax
  __int64 v409; // r13
  __int64 v410; // rbx
  __int64 v411; // r12
  __int64 v412; // r15
  char v413; // r14
  __int64 v414; // rax
  __int64 v415; // rax
  __int64 v416; // rax
  int v417; // eax
  unsigned __int8 *v418; // r12
  int v419; // edx
  unsigned __int8 v420; // dl
  __int64 v421; // rbx
  __int64 v422; // rax
  unsigned __int8 *v423; // rbx
  __int64 v424; // rdx
  __int64 v425; // rcx
  __int64 v426; // rax
  _QWORD *v427; // r12
  _QWORD *v428; // rbx
  __int64 v429; // rbx
  __int64 v430; // rdx
  __int64 v431; // rsi
  unsigned int v432; // edx
  unsigned int v433; // eax
  __int64 v434; // rdx
  unsigned __int64 v435; // rdi
  __int64 v436; // rax
  _QWORD *v437; // rax
  __int64 v438; // rbx
  __int64 v439; // rdx
  unsigned __int8 v440; // cl
  __int64 v441; // rax
  __int64 v442; // r12
  __int64 v443; // rdi
  __int64 v444; // rax
  __int64 v445; // rdx
  __int64 v446; // rbx
  size_t *v447; // r13
  size_t v448; // r15
  unsigned int v449; // r12d
  int v450; // eax
  int v451; // edi
  __int64 v452; // rdx
  char v453; // al
  __int64 v454; // rdx
  __int64 v455; // rcx
  __int64 v456; // rcx
  __int64 v457; // rcx
  const char *v458; // rax
  _BYTE *v459; // rax
  __int64 v460; // rbx
  _BYTE *v461; // r12
  unsigned __int8 v462; // al
  unsigned __int8 **v463; // rdx
  unsigned __int8 v464; // al
  unsigned __int8 **v465; // rdx
  unsigned __int8 *v466; // rax
  unsigned __int8 *v467; // rcx
  _BYTE *v468; // r8
  unsigned __int8 **v469; // rax
  unsigned __int8 **v470; // rax
  unsigned __int8 *v471; // rax
  __int64 v472; // r12
  _BYTE *v473; // rax
  __int64 v474; // rbx
  __int64 v475; // rdx
  unsigned __int8 *v476; // rax
  __int64 v477; // rbx
  char v478; // r12
  __int64 v479; // r13
  __int64 v480; // rdx
  unsigned __int8 v481; // cl
  __int64 v482; // rax
  unsigned __int8 v483; // cl
  __int64 v484; // rax
  __int64 v485; // r12
  unsigned int m; // r15d
  unsigned int v487; // r15d
  __int64 v488; // rax
  int v489; // eax
  __int64 v490; // rax
  int v491; // ebx
  __int64 v492; // rax
  int v493; // ebx
  __int64 v494; // rax
  int v495; // r12d
  int v496; // eax
  int v497; // edx
  unsigned int v498; // eax
  const char *v499; // rax
  __int64 v500; // rax
  __int64 v501; // rdx
  int v502; // ebx
  __int64 v503; // rax
  __int64 v504; // rdx
  __int64 v505; // rcx
  __int64 v506; // rax
  char *v507; // rdx
  char v508; // bl
  __int64 v509; // rdx
  int v510; // eax
  int v511; // edx
  __int64 v512; // rcx
  unsigned int v513; // r12d
  __int64 v514; // r12
  __int64 v515; // rcx
  int v516; // edx
  int v517; // edi
  int v518; // eax
  bool v519; // di
  __int64 v520; // rdi
  unsigned int v521; // eax
  __int64 v522; // r12
  __int64 v523; // rbx
  int v524; // ecx
  unsigned int v525; // r12d
  unsigned int v526; // eax
  __int64 v527; // r12
  _BYTE *v528; // rax
  __int64 v529; // rdi
  _BYTE *v530; // rax
  _BYTE *v531; // rax
  __int64 v532; // r14
  __int64 v533; // r12
  unsigned int v534; // eax
  __int64 v535; // rbx
  __int64 v536; // r9
  __int64 v537; // rax
  __int64 v538; // r12
  char *v539; // rdx
  char *v540; // rbx
  __int64 n; // rax
  signed __int64 v542; // rax
  __int64 v543; // rax
  __int64 v544; // rax
  unsigned __int8 *v545; // rbx
  __int64 v546; // [rsp+8h] [rbp-258h]
  unsigned __int8 *v547; // [rsp+8h] [rbp-258h]
  __int64 *v548; // [rsp+10h] [rbp-250h]
  unsigned int v549; // [rsp+10h] [rbp-250h]
  __int64 v550; // [rsp+18h] [rbp-248h]
  unsigned __int8 *v551; // [rsp+18h] [rbp-248h]
  const void *v552; // [rsp+18h] [rbp-248h]
  unsigned __int8 *v553; // [rsp+18h] [rbp-248h]
  __int64 v554; // [rsp+18h] [rbp-248h]
  __int64 v555; // [rsp+20h] [rbp-240h]
  bool v556; // [rsp+20h] [rbp-240h]
  int v557; // [rsp+28h] [rbp-238h]
  char v558; // [rsp+28h] [rbp-238h]
  __int64 *v559; // [rsp+30h] [rbp-230h]
  unsigned __int8 *v560; // [rsp+30h] [rbp-230h]
  __int64 v561; // [rsp+30h] [rbp-230h]
  char v562; // [rsp+30h] [rbp-230h]
  __int64 v563; // [rsp+30h] [rbp-230h]
  int v564; // [rsp+30h] [rbp-230h]
  int v565; // [rsp+30h] [rbp-230h]
  __int64 mm; // [rsp+30h] [rbp-230h]
  __int64 v567; // [rsp+30h] [rbp-230h]
  char *v568; // [rsp+30h] [rbp-230h]
  const char *v569; // [rsp+30h] [rbp-230h]
  __int64 v570; // [rsp+30h] [rbp-230h]
  int v571; // [rsp+30h] [rbp-230h]
  char v572; // [rsp+38h] [rbp-228h]
  char v573; // [rsp+38h] [rbp-228h]
  __int64 v574; // [rsp+38h] [rbp-228h]
  int v575; // [rsp+40h] [rbp-220h]
  __int64 *v576; // [rsp+40h] [rbp-220h]
  char v577; // [rsp+40h] [rbp-220h]
  __int64 v578; // [rsp+48h] [rbp-218h]
  int v579; // [rsp+48h] [rbp-218h]
  char v580; // [rsp+48h] [rbp-218h]
  char v581; // [rsp+48h] [rbp-218h]
  unsigned __int8 *j; // [rsp+48h] [rbp-218h]
  __int64 v583; // [rsp+48h] [rbp-218h]
  __int64 v584; // [rsp+48h] [rbp-218h]
  char v585; // [rsp+48h] [rbp-218h]
  unsigned int v586; // [rsp+48h] [rbp-218h]
  unsigned __int8 v587; // [rsp+48h] [rbp-218h]
  char v588; // [rsp+48h] [rbp-218h]
  int v589; // [rsp+48h] [rbp-218h]
  __int64 v590; // [rsp+48h] [rbp-218h]
  const char *v591; // [rsp+48h] [rbp-218h]
  __int64 v592; // [rsp+48h] [rbp-218h]
  __int64 v593; // [rsp+48h] [rbp-218h]
  int v594; // [rsp+48h] [rbp-218h]
  __int64 v595; // [rsp+48h] [rbp-218h]
  unsigned __int8 *v596; // [rsp+50h] [rbp-210h]
  char v597; // [rsp+50h] [rbp-210h]
  bool v598; // [rsp+50h] [rbp-210h]
  __int64 v599; // [rsp+50h] [rbp-210h]
  __int64 v600; // [rsp+50h] [rbp-210h]
  __int64 v601; // [rsp+50h] [rbp-210h]
  char v602; // [rsp+50h] [rbp-210h]
  __int64 v603; // [rsp+50h] [rbp-210h]
  unsigned __int8 **v604; // [rsp+50h] [rbp-210h]
  int v605; // [rsp+50h] [rbp-210h]
  __int64 v606; // [rsp+50h] [rbp-210h]
  __int64 v607; // [rsp+50h] [rbp-210h]
  char v608; // [rsp+50h] [rbp-210h]
  __int64 v609; // [rsp+50h] [rbp-210h]
  __int64 v610; // [rsp+50h] [rbp-210h]
  __int64 v611; // [rsp+50h] [rbp-210h]
  __int64 *v612; // [rsp+50h] [rbp-210h]
  __int64 v613; // [rsp+50h] [rbp-210h]
  __int64 *v614; // [rsp+50h] [rbp-210h]
  const char *v615; // [rsp+50h] [rbp-210h]
  __int64 *v616; // [rsp+50h] [rbp-210h]
  unsigned __int8 v617; // [rsp+50h] [rbp-210h]
  unsigned int v618; // [rsp+50h] [rbp-210h]
  char *v619; // [rsp+50h] [rbp-210h]
  __int64 v620; // [rsp+58h] [rbp-208h]
  char v621; // [rsp+58h] [rbp-208h]
  unsigned __int8 *v622; // [rsp+58h] [rbp-208h]
  bool v623; // [rsp+58h] [rbp-208h]
  unsigned __int8 *v624; // [rsp+58h] [rbp-208h]
  unsigned int v625; // [rsp+58h] [rbp-208h]
  bool v626; // [rsp+58h] [rbp-208h]
  __int64 v627; // [rsp+68h] [rbp-1F8h] BYREF
  _BYTE *v628; // [rsp+70h] [rbp-1F0h] BYREF
  _BYTE *v629; // [rsp+78h] [rbp-1E8h] BYREF
  _BYTE *v630; // [rsp+80h] [rbp-1E0h] BYREF
  _BYTE *v631; // [rsp+88h] [rbp-1D8h] BYREF
  int *v632; // [rsp+90h] [rbp-1D0h] BYREF
  __int64 v633; // [rsp+98h] [rbp-1C8h]
  __m128i v634[2]; // [rsp+A0h] [rbp-1C0h] BYREF
  char v635; // [rsp+C0h] [rbp-1A0h]
  char v636; // [rsp+C1h] [rbp-19Fh]
  __m128i v637; // [rsp+D0h] [rbp-190h] BYREF
  const char *v638; // [rsp+E0h] [rbp-180h] BYREF
  char v639; // [rsp+E8h] [rbp-178h]
  __int16 v640; // [rsp+F0h] [rbp-170h]
  __m128i v641; // [rsp+100h] [rbp-160h] BYREF
  _BYTE v642[32]; // [rsp+110h] [rbp-150h] BYREF
  __m128i v643; // [rsp+130h] [rbp-130h] BYREF
  _BYTE v644[96]; // [rsp+140h] [rbp-120h] BYREF
  __m128i v645; // [rsp+1A0h] [rbp-C0h] BYREF
  __m128i v646; // [rsp+1B0h] [rbp-B0h] BYREF
  __int16 v647; // [rsp+1C0h] [rbp-A0h]

  v3 = (unsigned __int8 *)a2;
  if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 - 32) + 8LL) + 8LL) != 14 )
  {
    HIBYTE(v647) = 1;
    v45 = "Called function must be a pointer!";
    goto LABEL_60;
  }
  v4 = *(_QWORD *)(a2 + 80);
  if ( !(*(_DWORD *)(v4 + 8) >> 8) )
  {
    if ( *(_BYTE *)a2 == 40 )
    {
      v13 = 32LL * (unsigned int)sub_B491D0(a2);
    }
    else
    {
      v13 = 0;
      if ( *(_BYTE *)a2 != 85 )
      {
        v13 = 64;
        if ( *(_BYTE *)a2 != 34 )
LABEL_1450:
          BUG();
      }
    }
    if ( *(char *)(a2 + 7) < 0 )
    {
      v14 = sub_BD2BC0(a2);
      v16 = v14 + v15;
      if ( *(char *)(a2 + 7) >= 0 )
      {
        if ( (unsigned int)(v16 >> 4) )
          goto LABEL_1465;
      }
      else if ( (unsigned int)((v16 - sub_BD2BC0(a2)) >> 4) )
      {
        if ( *(char *)(a2 + 7) < 0 )
        {
          v17 = *(_DWORD *)(sub_BD2BC0(a2) + 8);
          if ( *(char *)(a2 + 7) >= 0 )
            BUG();
          v18 = sub_BD2BC0(a2);
          v20 = 32LL * (unsigned int)(*(_DWORD *)(v18 + v19 - 4) - v17);
LABEL_25:
          v21 = *(_DWORD *)(a2 + 4);
          a2 = *(unsigned int *)(v4 + 12);
          v22 = (32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF) - 32 - v13 - v20) >> 5;
          v23 = (unsigned int)v22;
          if ( (_DWORD)a2 - 1 != (_DWORD)v22 )
          {
            HIBYTE(v647) = 1;
            v45 = "Incorrect number of arguments passed to called function!";
            goto LABEL_60;
          }
          goto LABEL_26;
        }
LABEL_1465:
        BUG();
      }
    }
    v20 = 0;
    goto LABEL_25;
  }
  if ( *(_BYTE *)a2 == 40 )
  {
    v5 = 32LL * (unsigned int)sub_B491D0(a2);
  }
  else
  {
    v5 = 0;
    if ( *(_BYTE *)a2 != 85 )
    {
      v5 = 64;
      if ( *(_BYTE *)a2 != 34 )
        goto LABEL_1450;
    }
  }
  if ( *(char *)(a2 + 7) >= 0 )
    goto LABEL_56;
  v6 = sub_BD2BC0(a2);
  v8 = v6 + v7;
  if ( *(char *)(a2 + 7) >= 0 )
  {
    if ( (unsigned int)(v8 >> 4) )
LABEL_1463:
      BUG();
LABEL_56:
    v12 = 0;
    goto LABEL_57;
  }
  if ( !(unsigned int)((v8 - sub_BD2BC0(a2)) >> 4) )
    goto LABEL_56;
  if ( *(char *)(a2 + 7) >= 0 )
    goto LABEL_1463;
  v9 = *(_DWORD *)(sub_BD2BC0(a2) + 8);
  if ( *(char *)(a2 + 7) >= 0 )
    BUG();
  v10 = sub_BD2BC0(a2);
  v12 = 32LL * (unsigned int)(*(_DWORD *)(v10 + v11 - 4) - v9);
LABEL_57:
  v23 = (unsigned int)(*(_DWORD *)(v4 + 12) - 1);
  v21 = *(_DWORD *)(a2 + 4);
  if ( (unsigned int)v23 > (unsigned int)((32LL * (v21 & 0x7FFFFFF) - 32 - v5 - v12) >> 5) )
  {
    HIBYTE(v647) = 1;
    v45 = "Called function requires more parameters than were provided!";
LABEL_60:
    v645.m128i_i64[0] = (__int64)v45;
    LOBYTE(v647) = 3;
    sub_BED490(a1, (__int64)&v645, v3);
    return;
  }
LABEL_26:
  v24 = 0;
  v25 = v21 & 0x7FFFFFF;
  while ( v23 != v24 )
  {
    v26 = v24++;
    a2 = (unsigned int)v24;
    v27 = *(_QWORD *)&v3[32 * (v26 - v25)];
    v28 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8LL * (unsigned int)v24);
    if ( *(_QWORD *)(v27 + 8) != v28 )
    {
      v645.m128i_i64[0] = (__int64)"Call parameter type does not match function signature!";
      v647 = 259;
      sub_BDBF70(a1, (__int64)&v645);
      if ( !*a1 )
        return;
      sub_BDBD80((__int64)a1, (_BYTE *)v27);
      if ( v28 )
      {
        v46 = *a1;
        v47 = *(_BYTE **)(*a1 + 32);
        if ( (unsigned __int64)v47 >= *(_QWORD *)(*a1 + 24) )
        {
          v46 = sub_CB5D20(*a1, 32);
        }
        else
        {
          *(_QWORD *)(v46 + 32) = v47 + 1;
          *v47 = 32;
        }
        sub_A587F0(v28, v46, 0, 0);
      }
      goto LABEL_67;
    }
  }
  v29 = *v3;
  v627 = *((_QWORD *)v3 + 9);
  if ( v29 == 40 )
  {
    v30 = 32LL * (unsigned int)sub_B491D0((__int64)v3);
  }
  else
  {
    v30 = 0;
    if ( v29 != 85 )
    {
      v30 = 64;
      if ( v29 != 34 )
        goto LABEL_1450;
    }
  }
  if ( (v3[7] & 0x80u) == 0 )
    goto LABEL_69;
  v31 = sub_BD2BC0((__int64)v3);
  v33 = v31 + v32;
  if ( (v3[7] & 0x80u) == 0 )
  {
    if ( (unsigned int)(v33 >> 4) )
LABEL_1461:
      BUG();
LABEL_69:
    v37 = 0;
    goto LABEL_37;
  }
  if ( !(unsigned int)((v33 - sub_BD2BC0((__int64)v3)) >> 4) )
    goto LABEL_69;
  if ( (v3[7] & 0x80u) == 0 )
    goto LABEL_1461;
  v34 = *(_DWORD *)(sub_BD2BC0((__int64)v3) + 8);
  if ( (v3[7] & 0x80u) == 0 )
    BUG();
  v35 = sub_BD2BC0((__int64)v3);
  v37 = 32LL * (unsigned int)(*(_DWORD *)(v35 + v36 - 4) - v34);
LABEL_37:
  v38 = 32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF) - 32 - v30;
  v645.m128i_i64[0] = v627;
  if ( (unsigned int)((v38 - v37) >> 5) + 2 < (unsigned int)sub_A74480((__int64)&v645) )
  {
    HIBYTE(v647) = 1;
    v48 = "Attribute after last parameter!";
    goto LABEL_75;
  }
  v39 = sub_BD3990(*((unsigned __int8 **)v3 - 4), a2);
  v620 = (__int64)v39;
  if ( *v39 )
  {
    v620 = 0;
    if ( ((*((_WORD *)v3 + 1) >> 2) & 0x3FFu) - 104 <= 1 )
      goto LABEL_162;
  }
  else
  {
    if ( (v39[33] & 0x20) != 0 )
    {
      if ( *((_QWORD *)v39 + 3) != v4 )
      {
        HIBYTE(v647) = 1;
        v48 = "Intrinsic called with incompatible signature";
        goto LABEL_75;
      }
      if ( ((*((_WORD *)v3 + 1) >> 2) & 0x3FFu) - 104 > 1 )
      {
        v572 = sub_A73ED0(&v627, 67);
        if ( v572 )
        {
LABEL_43:
          if ( (unsigned __int8)sub_B2D610(v620, 67) )
            goto LABEL_44;
LABEL_99:
          HIBYTE(v647) = 1;
          v48 = "speculatable attribute may not apply to call sites";
          goto LABEL_75;
        }
        v572 = 1;
        goto LABEL_44;
      }
LABEL_162:
      HIBYTE(v647) = 1;
      v48 = "Direct calls to amdgpu_cs_chain/amdgpu_cs_chain_preserve functions not allowed. Please use the @llvm.amdgpu."
            "cs.chain intrinsic instead.";
      goto LABEL_75;
    }
    if ( ((*((_WORD *)v3 + 1) >> 2) & 0x3FFu) - 104 <= 1 )
      goto LABEL_162;
  }
  v637.m128i_i64[0] = (__int64)"return type";
  v640 = 259;
  v49 = **(_QWORD **)(v4 + 16);
  v50 = *(unsigned __int8 *)(v49 + 8);
  if ( (_BYTE)v50 == 12
    || (unsigned __int8)v50 <= 3u
    || (_BYTE)v50 == 5
    || (v50 & 0xFB) == 0xA
    || (v50 & 0xFD) == 4
    || ((unsigned __int8)(*(_BYTE *)(v49 + 8) - 15) <= 3u || v50 == 20)
    && (unsigned __int8)sub_BCEBA0(**(_QWORD **)(v4 + 16), 0) )
  {
    v51 = sub_AE5020(a1[17], v49);
    if ( (unsigned __int64)(1LL << v51) > 0x100000000LL )
    {
      v644[17] = 1;
      v643.m128i_i64[0] = (__int64)" to called function!";
      v644[16] = 3;
      v646 = v637;
      v645.m128i_i64[0] = (__int64)"Incorrect alignment of ";
      LOBYTE(v647) = 3;
      HIBYTE(v647) = v640;
      sub_9C6370(&v641, &v645, &v643, v51, v52, v53);
      sub_BED490(a1, (__int64)&v641, v3);
    }
  }
  v54 = *(_DWORD *)(v4 + 12);
  if ( v54 != 1 )
  {
    v55 = v4;
    v56 = 8;
    v596 = v3;
    v57 = 8LL * (unsigned int)(v54 - 2) + 16;
    do
    {
      v61 = *(_QWORD *)(*(_QWORD *)(v55 + 16) + v56);
      v636 = 1;
      v634[0].m128i_i64[0] = (__int64)"argument passed";
      v635 = 3;
      v62 = *(unsigned __int8 *)(v61 + 8);
      if ( (_BYTE)v62 == 12
        || (unsigned __int8)v62 <= 3u
        || (_BYTE)v62 == 5
        || (v62 & 0xFB) == 0xA
        || (v62 & 0xFD) == 4
        || ((unsigned __int8)(*(_BYTE *)(v61 + 8) - 15) <= 3u || v62 == 20) && (unsigned __int8)sub_BCEBA0(v61, 0) )
      {
        v58 = sub_AE5020(a1[17], v61);
        if ( (unsigned __int64)(1LL << v58) > 0x100000000LL )
        {
          v642[17] = 1;
          v641.m128i_i64[0] = (__int64)" to called function!";
          v645.m128i_i64[0] = (__int64)"Incorrect alignment of ";
          v642[16] = 3;
          v647 = 259;
          sub_9C6370(&v643, &v645, v634, v58, v59, v60);
          sub_9C6370(&v637, &v643, &v641, v102, (__int64)&v637, v103);
          sub_BED490(a1, (__int64)&v637, v596);
        }
      }
      v56 += 8;
    }
    while ( v57 != v56 );
    v4 = v55;
    v3 = v596;
  }
  v572 = sub_A73ED0(&v627, 67);
  if ( v572 )
  {
    v572 = 0;
    if ( !v620 )
      goto LABEL_99;
    goto LABEL_43;
  }
LABEL_44:
  v40 = (unsigned __int8)sub_A73ED0(&v627, 84) == 0;
  v41 = (char *)*((_QWORD *)v3 - 4);
  if ( v40 )
  {
    v42 = *v41;
  }
  else
  {
    if ( !v41 || (v42 = *v41) != 0 || *((_QWORD *)v3 + 10) != *((_QWORD *)v41 + 3) )
      BUG();
    if ( *((_DWORD *)v41 + 9) != 16 )
    {
      HIBYTE(v647) = 1;
      v107 = "preallocated as a call site attribute can only be on llvm.call.preallocated.arg";
LABEL_182:
      v645.m128i_i64[0] = (__int64)v107;
      LOBYTE(v647) = 3;
      sub_BDBF70(a1, (__int64)&v645);
      return;
    }
  }
  sub_BEB370((__int64)a1, v4, v627, v3, v572, v42 == 25);
  v43 = *v3;
  if ( v43 == 40 )
  {
    v44 = -32 - 32LL * (unsigned int)sub_B491D0((__int64)v3);
  }
  else
  {
    v44 = -32;
    if ( v43 != 85 )
    {
      v44 = -96;
      if ( v43 != 34 )
        goto LABEL_1450;
    }
  }
  if ( (v3[7] & 0x80u) == 0 )
    goto LABEL_107;
  v63 = sub_BD2BC0((__int64)v3);
  v578 = v64 + v63;
  if ( (v3[7] & 0x80u) == 0 )
  {
    if ( (unsigned int)(v578 >> 4) )
      goto LABEL_1452;
  }
  else if ( (unsigned int)((v578 - sub_BD2BC0((__int64)v3)) >> 4) )
  {
    if ( (v3[7] & 0x80u) != 0 )
    {
      v579 = *(_DWORD *)(sub_BD2BC0((__int64)v3) + 8);
      if ( (v3[7] & 0x80u) == 0 )
        BUG();
      v65 = sub_BD2BC0((__int64)v3);
      v44 -= 32LL * (unsigned int)(*(_DWORD *)(v65 + v66 - 4) - v579);
      goto LABEL_107;
    }
LABEL_1452:
    BUG();
  }
LABEL_107:
  if ( 32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF) + v44 )
  {
    v104 = sub_A17190(v3);
    if ( (unsigned __int8)sub_B49B80((__int64)v3, v104 - 1, 83) )
    {
      v105 = sub_BD4CB0(
               *(unsigned __int8 **)&v3[32
                                      * ((unsigned int)(*(_DWORD *)(v4 + 12) - 2)
                                       - (unsigned __int64)(*((_DWORD *)v3 + 1) & 0x7FFFFFF))],
               (void (__fastcall *)(__int64, unsigned __int8 *))nullsub_96,
               (__int64)&v645);
      v106 = v105;
      if ( *v105 == 60 && (v105[2] & 0x40) == 0 )
      {
        v645.m128i_i64[0] = (__int64)"inalloca argument for call has mismatched alloca";
        v647 = 259;
        sub_BDBF70(a1, (__int64)&v645);
        if ( !*a1 )
          return;
        v101 = v106;
        goto LABEL_166;
      }
    }
  }
  v575 = *(_DWORD *)(v4 + 12) - 1;
  if ( *(_DWORD *)(v4 + 12) == 1 )
  {
    if ( *(_DWORD *)(v4 + 8) >> 8 )
      goto LABEL_234;
    goto LABEL_190;
  }
  v555 = v4;
  v67 = 0;
  v559 = a1;
  v68 = (__int64)v3;
  do
  {
    if ( !(unsigned __int8)sub_B49B80(v68, v67, 74) )
      goto LABEL_142;
    v643.m128i_i64[0] = *(_QWORD *)(v68 + 32 * (v67 - (*(_DWORD *)(v68 + 4) & 0x7FFFFFF)));
    v69 = sub_BD4CB0(
            (unsigned __int8 *)v643.m128i_i64[0],
            (void (__fastcall *)(__int64, unsigned __int8 *))nullsub_96,
            (__int64)&v645);
    if ( *v69 != 60 )
    {
      v81 = v643.m128i_i64[0];
      if ( *(_BYTE *)v643.m128i_i64[0] != 22 )
      {
        v97 = v68;
        HIBYTE(v647) = 1;
        v99 = v559;
        v98 = "swifterror argument should come from an alloca or parameter";
        goto LABEL_159;
      }
      if ( !(unsigned __int8)sub_B2D650(v643.m128i_i64[0]) )
      {
        v3 = (unsigned __int8 *)v68;
        HIBYTE(v647) = 1;
        a1 = v559;
        v622 = (unsigned __int8 *)v81;
        v100 = "swifterror argument for call has mismatched parameter";
LABEL_164:
        v645.m128i_i64[0] = (__int64)v100;
        LOBYTE(v647) = 3;
        sub_BDBF70(a1, (__int64)&v645);
        if ( !*a1 )
          return;
        v101 = v622;
LABEL_166:
        sub_BDBD80((__int64)a1, v101);
LABEL_67:
        sub_BDBD80((__int64)a1, v3);
        return;
      }
LABEL_142:
      v70 = v67 + 1;
      if ( (unsigned __int8)sub_A74710(&v627, (int)v67 + 1, 14)
        && (!v620 || !(unsigned __int8)sub_B2D640(v620, v67, 14)) )
      {
        v97 = v68;
        HIBYTE(v647) = 1;
        v99 = v559;
        v643.m128i_i64[0] = *(_QWORD *)(v97 + 32 * (v67 - (*(_DWORD *)(v97 + 4) & 0x7FFFFFF)));
        v98 = "immarg may not apply only to call sites";
        goto LABEL_159;
      }
      if ( (unsigned __int8)sub_B49B80(v68, v67, 14) )
      {
        v643.m128i_i64[0] = *(_QWORD *)(v68 + 32 * (v67 - (*(_DWORD *)(v68 + 4) & 0x7FFFFFF)));
        if ( (unsigned __int8)(*(_BYTE *)v643.m128i_i64[0] - 17) > 1u )
        {
          v97 = v68;
          HIBYTE(v647) = 1;
          v99 = v559;
          v98 = "immarg operand has non-immediate parameter";
          goto LABEL_159;
        }
      }
      if ( (unsigned __int8)sub_B49B80(v68, v67, 84) )
      {
        v82 = 0;
        v83 = *(char *)(v68 + 7) < 0;
        v643.m128i_i64[0] = *(_QWORD *)(v68 + 32 * (v67 - (*(_DWORD *)(v68 + 4) & 0x7FFFFFF)));
        if ( v83 )
        {
          v84 = sub_BD2BC0(v68);
          v86 = v84 + v85;
          if ( *(char *)(v68 + 7) < 0 )
            v86 -= sub_BD2BC0(v68);
          v87 = v86 >> 4;
          if ( (_DWORD)v87 )
          {
            v557 = v67 + 1;
            v88 = v68;
            v89 = (unsigned int)v87;
            v90 = 0;
            v91 = 0;
            v92 = v67;
            v93 = 16 * v89;
            do
            {
              v94 = 0;
              if ( *(char *)(v88 + 7) < 0 )
                v94 = sub_BD2BC0(v88);
              v95 = *(_DWORD *)(*(_QWORD *)(v94 + v91) + 8LL) == 4;
              v91 += 16;
              v90 += v95;
            }
            while ( v91 != v93 );
            v67 = v92;
            v96 = v90;
            v68 = v88;
            v70 = v557;
            v82 = v96 != 0;
          }
          else
          {
            v82 = 0;
          }
        }
        if ( sub_B49200(v68) == v82 )
        {
          HIBYTE(v647) = 1;
          v97 = v68;
          v98 = "preallocated operand either requires a preallocated bundle or the call to be musttail (but not both)";
          v99 = v559;
LABEL_159:
          v645.m128i_i64[0] = (__int64)v98;
          LOBYTE(v647) = 3;
          sub_BEE860(v99, (__int64)&v645, &v643, (_BYTE *)v97);
          return;
        }
      }
      goto LABEL_114;
    }
    if ( (v69[2] & 0x80u) == 0 )
    {
      HIBYTE(v647) = 1;
      v3 = (unsigned __int8 *)v68;
      a1 = v559;
      v622 = v69;
      v100 = "swifterror argument for call has mismatched alloca";
      goto LABEL_164;
    }
    v70 = v67 + 1;
LABEL_114:
    ++v67;
  }
  while ( v575 != v70 );
  v4 = v555;
  v3 = (unsigned __int8 *)v68;
  a1 = v559;
  if ( *(_DWORD *)(v555 + 8) >> 8 )
  {
    if ( *(_DWORD *)(v555 + 12) != 1 )
    {
      v560 = v3;
      v71 = 0;
      v576 = a1;
      v72 = 0;
      v73 = 0;
      do
      {
        v74 = sub_A74710(&v627, ++v71, 21);
        if ( v74 )
          v72 = v74;
        v75 = sub_A74710(&v627, v71, 52);
        if ( v75 )
          v73 = v75;
        v76 = *(_DWORD *)(v555 + 12) - 1;
      }
      while ( v76 > v71 );
      v621 = v72;
      v3 = v560;
      v580 = v73;
      a1 = v576;
      v4 = v555;
      goto LABEL_124;
    }
LABEL_234:
    v580 = 0;
    v76 = 0;
    v621 = 0;
LABEL_124:
    v561 = v4;
    for ( i = v76; (unsigned int)sub_A17190(v3) > i; ++i )
    {
      v78 = *(_QWORD *)(*(_QWORD *)&v3[32 * (i - (unsigned __int64)(*((_DWORD *)v3 + 1) & 0x7FFFFFF))] + 8LL);
      v643.m128i_i64[0] = sub_A744E0(&v627, i);
      sub_BEA6A0(a1, v643.m128i_i64[0], v78, v3);
      v79 = sub_A73170(&v643, 21);
      if ( v79 )
      {
        if ( v621 )
        {
          HIBYTE(v647) = 1;
          v48 = "More than one parameter has attribute nest!";
          goto LABEL_75;
        }
        v621 = v79;
      }
      if ( (unsigned __int8)sub_A73170(&v643, 52) )
      {
        if ( v580 )
        {
          HIBYTE(v647) = 1;
          v48 = "More than one parameter has attribute returned!";
          goto LABEL_75;
        }
        v580 = sub_BCAF30(v78, **(_QWORD **)(v561 + 16));
        if ( !v580 )
        {
          HIBYTE(v647) = 1;
          v48 = "Incompatible argument and return types for 'returned' attribute";
          goto LABEL_75;
        }
      }
      v80 = *((_QWORD *)v3 - 4);
      if ( (!v80 || *(_BYTE *)v80 || *(_QWORD *)(v80 + 24) != *((_QWORD *)v3 + 10) || *(_DWORD *)(v80 + 36) != 151)
        && (unsigned __int8)sub_A73170(&v643, 85) )
      {
        HIBYTE(v647) = 1;
        v48 = "Attribute 'sret' cannot be used for vararg call arguments!";
        goto LABEL_75;
      }
      if ( (unsigned __int8)sub_A73170(&v643, 83) && (unsigned int)sub_A17190(v3) - 1 != i )
      {
        HIBYTE(v647) = 1;
        v48 = "inalloca isn't on the last argument!";
        goto LABEL_75;
      }
    }
    v4 = v561;
  }
LABEL_190:
  if ( !v572 )
  {
    v108 = *(_QWORD *)(v4 + 16);
    v109 = v108 + 8;
    v110 = v108 + 8LL * *(unsigned int *)(v4 + 12);
    if ( v110 != v108 + 8 )
    {
      do
      {
        v111 = *(_BYTE *)(*(_QWORD *)v109 + 8LL);
        if ( v111 == 9 )
        {
          HIBYTE(v647) = 1;
          v48 = "Function has metadata parameter but isn't an intrinsic";
          goto LABEL_75;
        }
        if ( v111 == 11 )
        {
          HIBYTE(v647) = 1;
          v48 = "Function has token parameter but isn't an intrinsic";
          goto LABEL_75;
        }
        v109 += 8;
      }
      while ( v110 != v109 );
    }
  }
  v112 = *((_QWORD *)v3 - 4);
  if ( v112 && !*(_BYTE *)v112 && *(_QWORD *)(v112 + 24) == *((_QWORD *)v3 + 10) )
    goto LABEL_258;
  v113 = *(_BYTE *)(**(_QWORD **)(v4 + 16) + 8LL);
  if ( v113 == 11 )
  {
    HIBYTE(v647) = 1;
    v107 = "Return type cannot be token for indirect call!";
    goto LABEL_182;
  }
  if ( v113 == 10 )
  {
    HIBYTE(v647) = 1;
    v107 = "Return type cannot be x86_amx for indirect call!";
    goto LABEL_182;
  }
  if ( !v112 || *(_BYTE *)v112 || *(_QWORD *)(v112 + 24) != *((_QWORD *)v3 + 10) )
    goto LABEL_205;
LABEL_258:
  v625 = *(_DWORD *)(v112 + 36);
  if ( !v625 )
    goto LABEL_205;
  v628 = (_BYTE *)*((_QWORD *)v3 - 4);
  if ( !sub_B2FC80(v112) )
  {
    v645.m128i_i64[0] = (__int64)"Intrinsic functions should never be defined!";
    v647 = 259;
    sub_BED850(a1, (__int64)&v645, &v628);
    goto LABEL_205;
  }
  v127 = *((_QWORD *)v628 + 3);
  v128 = *(_DWORD *)(v127 + 8);
  v643.m128i_i64[0] = (__int64)v644;
  v643.m128i_i64[1] = 0x800000000LL;
  v129 = v128 >> 8;
  sub_B6DAB0(v625, (__int64)&v643);
  v632 = (int *)v643.m128i_i64[0];
  v633 = v643.m128i_u32[2];
  v641.m128i_i64[0] = (__int64)v642;
  v641.m128i_i64[1] = 0x400000000LL;
  v130 = sub_B6B020(v127, &v632, (__int64)&v641);
  if ( v130 == 1 )
  {
    HIBYTE(v647) = 1;
    v458 = "Intrinsic has incorrect return type!";
    goto LABEL_1161;
  }
  if ( v130 == 2 )
  {
    HIBYTE(v647) = 1;
    v458 = "Intrinsic has incorrect argument type!";
    goto LABEL_1161;
  }
  if ( !v129 )
  {
    if ( (unsigned __int8)sub_B6B160(0, (__int64 *)&v632) )
    {
      HIBYTE(v647) = 1;
      v458 = "Callsite was not defined with variable arguments!";
      goto LABEL_1161;
    }
LABEL_264:
    v574 = v633;
    if ( v633 )
    {
      HIBYTE(v647) = 1;
      v458 = "Intrinsic has too few arguments!";
      goto LABEL_1161;
    }
    sub_B6E0E0(v634, v625, v641.m128i_i64[0], v641.m128i_u32[2], *((__int64 **)v628 + 5), v127);
    v131 = sub_BD5D20((__int64)v628);
    v132 = v634[0].m128i_i64[1];
    v133 = v634[0].m128i_i64[1];
    v598 = sub_9691B0((const void *)v634[0].m128i_i64[0], v634[0].m128i_u64[1], v131, v134);
    if ( !v598 )
    {
      v637.m128i_i64[1] = 0;
      LOBYTE(v638) = 0;
      v637.m128i_i64[0] = (__int64)&v638;
      sub_2240E30(&v637, v132 + 68);
      if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - v637.m128i_i64[1]) <= 0x43 )
        sub_4262D8((__int64)"basic_string::append");
      sub_2241490(&v637, "Intrinsic name not mangled correctly for type arguments! Should be: ", 68, v456);
      sub_2241490(&v637, v634[0].m128i_i64[0], v634[0].m128i_i64[1], v457);
      v133 = (__int64)&v645;
      v647 = 260;
      v645.m128i_i64[0] = (__int64)&v637;
      sub_BED850(a1, (__int64)&v645, &v628);
      sub_2240A30(&v637);
      goto LABEL_364;
    }
    v136 = *v3;
    v137 = (unsigned int)(v136 - 29);
    if ( v136 == 40 )
    {
      v138 = sub_B491D0((__int64)v3);
    }
    else
    {
      v138 = 0;
      if ( (_DWORD)v137 != 56 )
      {
        v138 = 2;
        if ( (_DWORD)v137 != 5 )
          goto LABEL_1450;
      }
    }
    v154 = -32 - 32LL * v138;
    if ( (v3[7] & 0x80u) != 0 )
    {
      v155 = sub_BD2BC0((__int64)v3);
      v156 = v155 + v137;
      if ( (v3[7] & 0x80u) == 0 )
      {
        if ( (unsigned int)(v156 >> 4) )
          goto LABEL_1459;
      }
      else if ( (unsigned int)((v156 - sub_BD2BC0((__int64)v3)) >> 4) )
      {
        if ( (v3[7] & 0x80u) != 0 )
        {
          v157 = *(_DWORD *)(sub_BD2BC0((__int64)v3) + 8);
          if ( (v3[7] & 0x80u) == 0 )
            BUG();
          v158 = sub_BD2BC0((__int64)v3);
          v159 = (unsigned int)(*(_DWORD *)(v158 + v137 - 4) - v157);
LABEL_341:
          v551 = &v3[v154 - 32 * v159];
          for ( j = &v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)]; v551 != j; j += 32 )
          {
            v160 = *(_BYTE **)j;
            if ( **(_BYTE **)j == 24 )
            {
              v161 = sub_B491C0((__int64)v3);
              v162 = (unsigned __int8 *)*((_QWORD *)v160 + 3);
              v163 = v161;
              if ( (unsigned __int8)(*v162 - 5) <= 0x1Fu )
              {
                v133 = *((_QWORD *)v160 + 3);
                sub_BE3890((__int64)a1, v133, 0);
              }
              else
              {
                if ( !*((_BYTE *)a1 + 476) )
                  goto LABEL_1404;
                v137 = a1[57];
                v164 = *((unsigned int *)a1 + 117);
                v133 = v137 + 8 * v164;
                while ( v133 != v137 )
                {
                  if ( v162 == *(unsigned __int8 **)v137 )
                    goto LABEL_343;
                  v137 += 8;
                }
                if ( (unsigned int)v164 < *((_DWORD *)a1 + 116) )
                {
                  *((_DWORD *)a1 + 117) = v164 + 1;
                  *(_QWORD *)v133 = v162;
                  ++a1[56];
                }
                else
                {
LABEL_1404:
                  v133 = *((_QWORD *)v160 + 3);
                  sub_C8CC70(a1 + 56, v133);
                  if ( !(_BYTE)v137 )
                    goto LABEL_343;
                }
                if ( (unsigned int)*v162 - 1 <= 1 )
                {
                  v133 = (__int64)v162;
                  sub_BDC5E0((__int64)a1, (__int64)v162, v163);
                }
                if ( *v162 == 4 )
                {
                  v165 = (__int64 *)*((_QWORD *)v162 + 17);
                  v137 = *((unsigned int *)v162 + 36);
                  v547 = v3;
                  v166 = v160;
                  v167 = &v165[v137];
                  for ( k = v165; v167 != k; ++k )
                  {
                    v133 = *k;
                    sub_BDC5E0((__int64)a1, v133, v163);
                  }
                  v160 = v166;
                  v3 = v547;
                }
              }
            }
LABEL_343:
            if ( *v160 <= 0x15u && *(_BYTE *)(*((_QWORD *)v160 + 1) + 8LL) == 10 )
            {
              v645.m128i_i64[0] = (__int64)"const x86_amx is not allowed in argument!";
              v133 = (__int64)&v645;
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            }
          }
          if ( v625 > 0x236 )
          {
            if ( v625 == 3164 )
            {
              v239 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v239 + 8) - 17 <= 1 )
                v239 = **(_QWORD **)(v239 + 16);
              v240 = *(_DWORD *)(v239 + 8) >> 8;
              if ( ((v240 + 16777214) & 0xFFFFFFu) <= 7 && v240 != 4 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.amdgcn.s.prefetch.data only supports global or constant memory";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              goto LABEL_383;
            }
            if ( v625 <= 0xC5C )
            {
              if ( v625 == 2088 )
              {
                v237 = (*(_WORD *)(sub_B491C0((__int64)v3) + 2) >> 4) & 0x3FF;
                if ( v237 != 90 && (unsigned __int16)(v237 - 104) > 1u )
                {
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"Intrinsic can only be used from functions with the amdgpu_cs, amdgpu_cs_c"
                                               "hain or amdgpu_cs_chain_preserve calling conventions";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                }
                if ( !(unsigned __int8)sub_B49B80((__int64)v3, 2, 15) )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"SGPR arguments must have the `inreg` attribute";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                if ( (unsigned __int8)sub_B49B80((__int64)v3, 3, 15) )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"VGPR arguments must not have the `inreg` attribute";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                v133 = (__int64)v3;
                v238 = (_BYTE *)sub_BF02C0(*((_QWORD *)v3 + 5) + 48LL, (__int64)v3);
                if ( !v238 || *v238 != 36 )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"llvm.amdgcn.cs.chain must be followed by unreachable";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                goto LABEL_383;
              }
              if ( v625 > 0x828 )
              {
                if ( v625 == 2986 )
                {
                  v227 = *(_BYTE **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
                  if ( *v227 != 22 || !(unsigned __int8)sub_B2D740((__int64)v227) )
                  {
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"only inreg arguments to the parent function are valid as inputs to this intrinsic";
                    v647 = 259;
                    sub_BEFC60(a1, (__int64)&v645, &v637);
                    goto LABEL_364;
                  }
                }
                else if ( v625 - 3060 <= 1 )
                {
                  v213 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
                  v214 = *(_QWORD *)&v3[-32 * v213];
                  v629 = (_BYTE *)v214;
                  v215 = *(_QWORD *)&v3[32 * (1 - v213)];
                  v630 = (_BYTE *)v215;
                  v216 = *(_QWORD *)&v3[32 * (3 - v213)];
                  v217 = *(_QWORD *)(v216 + 24);
                  if ( *(_DWORD *)(v216 + 32) > 0x40u )
                    v217 = *(_QWORD *)v217;
                  v218 = *(_QWORD *)&v3[32 * (4 - v213)];
                  v219 = *(_QWORD *)(v218 + 24);
                  if ( *(_DWORD *)(v218 + 32) > 0x40u )
                    v219 = *(_QWORD *)v219;
                  if ( v217 > 4 )
                  {
                    v637.m128i_i64[0] = *(_QWORD *)&v3[32 * (3 - v213)];
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"invalid value for cbsz format";
                    v647 = 259;
                    sub_BEFA80(a1, (__int64)&v645, v3, &v637);
                    goto LABEL_364;
                  }
                  if ( v219 > 4 )
                  {
                    v637.m128i_i64[0] = *(_QWORD *)&v3[32 * (4 - v213)];
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"invalid value for blgp format";
                    v647 = 259;
                    sub_BEFA80(a1, (__int64)&v645, v3, &v637);
                    goto LABEL_364;
                  }
                  v220 = *(_QWORD *)(v214 + 8);
                  if ( *(_BYTE *)(v220 + 8) != 17 )
                    goto LABEL_493;
                  v221 = *(_QWORD *)(v215 + 8);
                  if ( *(_BYTE *)(v221 + 8) != 17 )
                    v221 = 0;
                  v583 = v221;
                  v600 = *(_QWORD *)(v214 + 8);
                  if ( !sub_BCAC40(*(_QWORD *)(v220 + 24), 32)
                    || (v222 = v583, (*(_DWORD *)(v600 + 32) & 0xFFFFFFFD) != 4) && *(_DWORD *)(v600 + 32) != 8 )
                  {
LABEL_493:
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"operand 0 must be 4, 6 or 8 element i32 vector";
                    v647 = 259;
                    sub_BEFD60(a1, (__int64)&v645, &v637, &v629);
                    goto LABEL_364;
                  }
                  if ( !v583
                    || (v223 = *(_QWORD *)(v583 + 24), v133 = 32, v584 = v600, v601 = v222, !sub_BCAC40(v223, 32))
                    || (v224 = *(_DWORD *)(v601 + 32), (v224 & 0xFFFFFFFD) != 4) && v224 != 8 )
                  {
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"operand 1 must be 4, 6 or 8 element i32 vector";
                    v647 = 259;
                    sub_BEFD60(a1, (__int64)&v645, &v637, &v630);
                    goto LABEL_364;
                  }
                  if ( *(_DWORD *)(v584 + 32) < *(_DWORD *)&asc_3F64000[4 * (unsigned int)v217] )
                  {
                    v226 = *((_DWORD *)v3 + 1);
                    v133 = (__int64)&v645;
                    v631 = v3;
                    v647 = 259;
                    v637.m128i_i64[0] = *(_QWORD *)&v3[32 * (3LL - (v226 & 0x7FFFFFF))];
                    v645.m128i_i64[0] = (__int64)"invalid vector type for format";
                    sub_BEFED0(a1, (__int64)&v645, &v631, &v629, &v637);
                    goto LABEL_364;
                  }
                  if ( *(_DWORD *)&asc_3F64000[4 * (unsigned int)v219] > v224 )
                  {
                    v225 = *((_DWORD *)v3 + 1);
                    v133 = (__int64)&v645;
                    v631 = v3;
                    v647 = 259;
                    v637.m128i_i64[0] = *(_QWORD *)&v3[32 * (5LL - (v225 & 0x7FFFFFF))];
                    v645.m128i_i64[0] = (__int64)"invalid vector type for format";
                    sub_BEFED0(a1, (__int64)&v645, &v631, &v630, &v637);
                    goto LABEL_364;
                  }
                }
                goto LABEL_383;
              }
              if ( v625 == 776 )
              {
                v228 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
                v229 = *(_QWORD *)&v3[32 * (1 - v228)];
                v230 = *(_QWORD **)(v229 + 24);
                if ( *(_DWORD *)(v229 + 32) > 0x40u )
                  v230 = (_QWORD *)*v230;
                if ( (unsigned __int64)v230 > 1 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"write argument to llvm.aarch64.prefetch must be 0 or 1";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
                v231 = *(_QWORD *)&v3[32 * (2 - v228)];
                v232 = *(_QWORD **)(v231 + 24);
                if ( *(_DWORD *)(v231 + 32) > 0x40u )
                  v232 = (_QWORD *)*v232;
                if ( (unsigned __int64)v232 > 3 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"target argument to llvm.aarch64.prefetch must be 0-3";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
                v233 = *(_QWORD *)&v3[32 * (3 - v228)];
                v234 = *(_QWORD **)(v233 + 24);
                if ( *(_DWORD *)(v233 + 32) > 0x40u )
                  v234 = (_QWORD *)*v234;
                if ( (unsigned __int64)v234 > 1 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"stream argument to llvm.aarch64.prefetch must be 0 or 1";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
                v235 = *(_QWORD *)&v3[32 * (4 - v228)];
                v236 = *(_QWORD **)(v235 + 24);
                if ( *(_DWORD *)(v235 + 32) > 0x40u )
                  v236 = (_QWORD *)*v236;
                if ( (unsigned __int64)v236 > 1 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"isdata argument to llvm.aarch64.prefetch must be 0 or 1";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
                goto LABEL_383;
              }
              if ( v625 <= 0x307 || (v625 & 0xFFFFFFFD) != 0x479 )
                goto LABEL_383;
            }
            else
            {
              if ( v625 > 0x21A3 )
              {
                if ( v625 - 9431 <= 1 )
                {
                  v211 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
                  v212 = *(_QWORD **)(v211 + 24);
                  if ( *(_DWORD *)(v211 + 32) > 0x40u )
                    v212 = (_QWORD *)*v212;
                  if ( ((unsigned __int8)v212 & 7) != 0 )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"reg_count argument to nvvm.setmaxnreg must be in multiples of 8";
                    v647 = 259;
                    sub_BDBF70(a1, (__int64)&v645);
                    goto LABEL_364;
                  }
                  if ( (unsigned int)((_DWORD)v212 - 24) > 0xE8 )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"reg_count argument to nvvm.setmaxnreg must be within [24, 256]";
                    v647 = 259;
                    sub_BDBF70(a1, (__int64)&v645);
                    goto LABEL_364;
                  }
                }
                goto LABEL_383;
              }
              if ( v625 > 0x219F )
              {
                v209 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
                v210 = *(_QWORD **)(v209 + 24);
                if ( *(_DWORD *)(v209 + 32) > 0x40u )
                  v210 = (_QWORD *)*v210;
                if ( (_DWORD)v210 != 128 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)" The only supported value for size operand is 128";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                  goto LABEL_364;
                }
                goto LABEL_383;
              }
              if ( v625 == 3196 )
              {
                if ( ((*(_WORD *)(sub_B491C0((__int64)v3) + 2) >> 4) & 0x3FFu) - 104 > 1 )
                {
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"Intrinsic can only be used from functions with the amdgpu_cs_chain or amd"
                                               "gpu_cs_chain_preserve calling conventions";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                }
                v133 = 1;
                if ( (unsigned __int8)sub_B49B80((__int64)v3, 1, 15) )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"Value for inactive lanes must not have the `inreg` attribute";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                v208 = *(_BYTE **)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
                if ( *v208 != 22 )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"Value for inactive lanes must be a function argument";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                if ( (unsigned __int8)sub_B2D740((__int64)v208) )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = (__int64)v3;
                  v645.m128i_i64[0] = (__int64)"Value for inactive lanes must be a VGPR function argument";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                goto LABEL_383;
              }
              if ( v625 <= 0xC7B )
                goto LABEL_383;
              if ( v625 != 3788 )
              {
                if ( v625 <= 0xECC )
                {
                  if ( v625 == 3382 || v625 == 3388 )
                  {
LABEL_453:
                    v133 = 0;
                    if ( !sub_A74920((_QWORD *)v3 + 9, 0) )
                    {
                      v133 = (__int64)&v645;
                      v637.m128i_i64[0] = (__int64)v3;
                      v645.m128i_i64[0] = (__int64)"Intrinsic requires elementtype attribute on first argument.";
                      v647 = 259;
                      sub_BEFC60(a1, (__int64)&v645, &v637);
                      goto LABEL_364;
                    }
                  }
                  goto LABEL_383;
                }
                if ( v625 != 3790 )
                  goto LABEL_383;
              }
            }
            v133 = 1;
            v645.m128i_i64[0] = *((_QWORD *)v3 + 9);
            if ( !sub_A74920(&v645, 1) )
            {
              v133 = (__int64)&v645;
              v637.m128i_i64[0] = (__int64)v3;
              v645.m128i_i64[0] = (__int64)"Intrinsic requires elementtype attribute on second argument.";
              v647 = 259;
              sub_BEFC60(a1, (__int64)&v645, &v637);
              goto LABEL_364;
            }
            goto LABEL_383;
          }
          if ( v625 <= 0xA )
            goto LABEL_383;
          switch ( v625 )
          {
            case 0xBu:
              if ( (v3[7] & 0x80u) == 0 )
              {
                v567 = 0;
                v446 = 0;
              }
              else
              {
                v444 = sub_BD2BC0((__int64)v3);
                v567 = v445 + v444;
                if ( (v3[7] & 0x80u) == 0 )
                  v446 = 0;
                else
                  v446 = sub_BD2BC0((__int64)v3);
              }
              v614 = a1;
              while ( 2 )
              {
                if ( v446 == v567 )
                {
                  a1 = v614;
                  goto LABEL_383;
                }
                v447 = *(size_t **)v446;
                v448 = **(_QWORD **)v446;
                v549 = *(_DWORD *)(v446 + 8);
                v449 = *(_DWORD *)(v446 + 12) - v549;
                v552 = (const void *)(*(_QWORD *)v446 + 16LL);
                v133 = v448;
                if ( sub_9691B0(v552, v448, "separate_storage", 16) )
                {
                  a1 = v614;
                  if ( v449 == 2 )
                  {
                    v452 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
                    if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v3[32 * (v549 - v452)] + 8LL) + 8LL) != 14
                      || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v3[32 * (v549 + 1 - v452)] + 8LL) + 8LL) != 14 )
                    {
                      v133 = (__int64)&v645;
                      v645.m128i_i64[0] = (__int64)"arguments to separate_storage assumptions should be pointers";
                      v647 = 259;
                      sub_BED490(v614, (__int64)&v645, v3);
                    }
                  }
                  else
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"separate_storage assumptions should have 2 arguments";
                    v647 = 259;
                    sub_BED490(v614, (__int64)&v645, v3);
                  }
                }
                else
                {
                  if ( sub_9691B0(v552, v448, "ignore", 6) )
                    goto LABEL_1126;
                  if ( sub_A70200((__int64)v552, v448) )
                  {
                    v447 = *(size_t **)v446;
LABEL_1126:
                    v133 = *v447;
                    v450 = sub_A6E860((__int64)(v447 + 2), *v447);
                    v451 = v450;
                    if ( v450 == 86 )
                    {
                      a1 = v614;
                      if ( v449 - 2 > 1 )
                      {
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"alignment assumptions should have 2 or 3 arguments";
                        v647 = 259;
                        sub_BED490(v614, (__int64)&v645, v3);
                      }
                      else
                      {
                        v454 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
                        v455 = *(unsigned int *)(v446 + 8);
                        if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v3[32 * (v455 - v454)] + 8LL) + 8LL) == 14 )
                        {
                          if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v3[32 * ((unsigned int)(v455 + 1) - v454)] + 8LL) + 8LL) == 12 )
                          {
                            if ( v449 == 3
                              && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&v3[32 * ((unsigned int)(v455 + 2) - v454)] + 8LL)
                                          + 8LL) != 12 )
                            {
                              v133 = (__int64)&v645;
                              v645.m128i_i64[0] = (__int64)"third argument should be an integer if present";
                              v647 = 259;
                              sub_BED490(v614, (__int64)&v645, v3);
                            }
                          }
                          else
                          {
                            v133 = (__int64)&v645;
                            v645.m128i_i64[0] = (__int64)"second argument should be an integer";
                            v647 = 259;
                            sub_BED490(v614, (__int64)&v645, v3);
                          }
                        }
                        else
                        {
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"first argument should be a pointer";
                          v647 = 259;
                          sub_BED490(v614, (__int64)&v645, v3);
                        }
                      }
                    }
                    else if ( v449 > 2 )
                    {
                      a1 = v614;
                      v133 = (__int64)&v645;
                      v645.m128i_i64[0] = (__int64)"too many arguments";
                      v647 = 259;
                      sub_BED490(v614, (__int64)&v645, v3);
                    }
                    else
                    {
                      if ( !v450 )
                      {
                        a1 = v614;
                        goto LABEL_383;
                      }
                      if ( (unsigned int)(v450 - 86) <= 0xA )
                      {
                        if ( v449 == 2 )
                        {
                          if ( **(_BYTE **)&v3[32
                                             * ((unsigned int)(*(_DWORD *)(v446 + 8) + 1)
                                              - (unsigned __int64)(*((_DWORD *)v3 + 1) & 0x7FFFFFF))] == 17 )
                            goto LABEL_1120;
                          a1 = v614;
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"the second argument should be a constant integral value";
                          v647 = 259;
                          sub_BED490(v614, (__int64)&v645, v3);
                        }
                        else
                        {
                          a1 = v614;
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"this attribute should have 2 arguments";
                          v647 = 259;
                          sub_BED490(v614, (__int64)&v645, v3);
                        }
                      }
                      else
                      {
                        if ( sub_A71A10(v450) )
                        {
                          if ( v449 != 1 )
                          {
                            a1 = v614;
                            v133 = (__int64)&v645;
                            v645.m128i_i64[0] = (__int64)"this attribute should have one argument";
                            v647 = 259;
                            sub_BED490(v614, (__int64)&v645, v3);
                            goto LABEL_364;
                          }
LABEL_1120:
                          v446 += 16;
                          continue;
                        }
                        v453 = sub_A719F0(v451);
                        if ( !v449 || !v453 )
                          goto LABEL_1120;
                        a1 = v614;
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"this attribute has no argument";
                        v647 = 259;
                        sub_BED490(v614, (__int64)&v645, v3);
                      }
                    }
                  }
                  else
                  {
                    a1 = v614;
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"tags must be valid attribute names";
                    v647 = 259;
                    sub_BED490(v614, (__int64)&v645, v3);
                  }
                }
                goto LABEL_364;
              }
            case 0xFu:
              if ( (sub_BCB060(*((_QWORD *)v3 + 1)) & 0xF) == 0 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v637.m128i_i64[0] = (__int64)v3;
              v645.m128i_i64[0] = (__int64)"bswap must be an even number of bytes";
              v647 = 259;
              sub_BEFC60(a1, (__int64)&v645, &v637);
              goto LABEL_364;
            case 0x10u:
              v480 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *(_BYTE *)v480 <= 0x1Cu )
                goto LABEL_1238;
              v481 = *(_BYTE *)v480 - 34;
              if ( v481 > 0x33u || ((0x8000000000041uLL >> v481) & 1) == 0 )
                goto LABEL_1238;
              v482 = *(_QWORD *)(v480 - 32);
              if ( !v482 || *(_BYTE *)v482 || *(_QWORD *)(v482 + 24) != *(_QWORD *)(v480 + 80) )
                BUG();
              if ( *(_DWORD *)(v482 + 36) != 17 )
              {
LABEL_1238:
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.arg token argument must be a llvm.call.preallocated.setup";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              v133 = 84;
              if ( (unsigned __int8)sub_A73ED0((_QWORD *)v3 + 9, 84) )
                goto LABEL_383;
              v133 = 84;
              if ( (unsigned __int8)sub_B49560((__int64)v3, 84) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.arg must be called with a \"preallocated\" call site attribute";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x11u:
              v477 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *(_BYTE *)v477 != 17 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.setup argument must be a constant";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              v616 = a1;
              v478 = 0;
              v570 = *((_QWORD *)v3 + 2);
              while ( 2 )
              {
                if ( !v570 )
                {
                  a1 = v616;
                  goto LABEL_383;
                }
                v479 = *(_QWORD *)(v570 + 24);
                if ( *(_BYTE *)v479 <= 0x1Cu
                  || (v483 = *(_BYTE *)v479 - 34, v483 > 0x33u)
                  || ((0x8000000000041uLL >> v483) & 1) == 0 )
                {
                  a1 = v616;
                  v645.m128i_i64[0] = (__int64)"Uses of llvm.call.preallocated.setup must be calls";
                  v133 = (__int64)&v645;
                  v647 = 259;
                  sub_BDBF70(v616, (__int64)&v645);
                  break;
                }
                v484 = *(_QWORD *)(v479 - 32);
                if ( !v484 )
                  goto LABEL_1246;
                if ( *(_BYTE *)v484 )
                  goto LABEL_1246;
                v133 = *(_QWORD *)(v479 + 80);
                if ( *(_QWORD *)(v484 + 24) != v133 )
                  goto LABEL_1246;
                v489 = *(_DWORD *)(v484 + 36);
                if ( v489 == 16 )
                {
                  v490 = *(_QWORD *)(v479 + 32 * (1LL - (*(_DWORD *)(v479 + 4) & 0x7FFFFFF)));
                  if ( *(_BYTE *)v490 == 17 )
                  {
                    v637.m128i_i32[2] = *(_DWORD *)(v490 + 32);
                    if ( v637.m128i_i32[2] > 0x40u )
                      sub_C43780(&v637, v490 + 24);
                    else
                      v637.m128i_i64[0] = *(_QWORD *)(v490 + 24);
                    if ( !sub_986F30((__int64)&v637, 0) )
                    {
                      v133 = v477 + 24;
                      if ( (int)sub_C4C880(&v637, v477 + 24) < 0 )
                      {
                        sub_969240(v637.m128i_i64);
                        goto LABEL_1260;
                      }
                    }
                    a1 = v616;
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.alloc arg index must be between 0 and correspond"
                                                 "ing llvm.call.preallocated.setup's argument count";
                    v647 = 259;
                    sub_BDBF70(v616, (__int64)&v645);
                    sub_969240(v637.m128i_i64);
                  }
                  else
                  {
                    a1 = v616;
                    v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.alloc arg index must be a constant";
                    v133 = (__int64)&v645;
                    v647 = 259;
                    sub_BDBF70(v616, (__int64)&v645);
                  }
                }
                else
                {
                  if ( v489 == 18 )
                  {
LABEL_1260:
                    v570 = *(_QWORD *)(v570 + 8);
                    continue;
                  }
LABEL_1246:
                  if ( v478 )
                  {
                    a1 = v616;
                    v645.m128i_i64[0] = (__int64)"Can have at most one call corresponding to a llvm.call.preallocated.setup";
                    v133 = (__int64)&v645;
                    v647 = 259;
                    sub_BDBF70(v616, (__int64)&v645);
                    break;
                  }
                  v485 = 0;
                  for ( m = 0; (unsigned int)sub_A17190((unsigned __int8 *)v479) > m; ++m )
                    v485 -= ((unsigned __int8)sub_B49B80(v479, m, 84) == 0) - 1LL;
                  if ( !v485 )
                  {
                    a1 = v616;
                    v645.m128i_i64[0] = (__int64)"cannot use preallocated intrinsics on a call without preallocated arguments";
                    v133 = (__int64)&v645;
                    v647 = 259;
                    sub_BDBF70(v616, (__int64)&v645);
                    break;
                  }
                  v487 = *(_DWORD *)(v477 + 32);
                  if ( v487 > 0x40 )
                  {
                    if ( v487 - (unsigned int)sub_C444A0(v477 + 24) > 0x40 )
                      goto LABEL_1254;
                    v488 = **(_QWORD **)(v477 + 24);
                  }
                  else
                  {
                    v488 = *(_QWORD *)(v477 + 24);
                  }
                  if ( v485 != v488 )
                  {
LABEL_1254:
                    a1 = v616;
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.setup arg size must be equal to number of preall"
                                                 "ocated arguments at call site";
                    v647 = 259;
                    sub_BEF920(v616, (__int64)&v645, v3, (_BYTE *)v479);
                    break;
                  }
                  v133 = 4;
                  if ( (unsigned int)sub_BDBB60(v479, 4) > 1 )
                  {
                    a1 = v616;
                  }
                  else
                  {
                    v133 = v479;
                    sub_BDBBF0((__int64)&v637, v479, 4);
                    v478 = v639;
                    if ( v639 )
                    {
                      if ( v3 == *(unsigned __int8 **)v637.m128i_i64[0] )
                        goto LABEL_1260;
                      a1 = v616;
                      v645.m128i_i64[0] = (__int64)"preallocated bundle must have token from corresponding llvm.call.preallocated.setup";
                      v133 = (__int64)&v645;
                      v647 = 259;
                      sub_BDBF70(v616, (__int64)&v645);
                    }
                    else
                    {
                      a1 = v616;
                      v645.m128i_i64[0] = (__int64)"Use of llvm.call.preallocated.setup outside intrinsics must be in \"p"
                                                   "reallocated\" operand bundle";
                      v133 = (__int64)&v645;
                      v647 = 259;
                      sub_BDBF70(v616, (__int64)&v645);
                    }
                  }
                }
                break;
              }
LABEL_364:
              sub_2240A30(v634);
              goto LABEL_365;
            case 0x12u:
              v439 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *(_BYTE *)v439 > 0x1Cu )
              {
                v440 = *(_BYTE *)v439 - 34;
                if ( v440 <= 0x33u && ((0x8000000000041uLL >> v440) & 1) != 0 )
                {
                  v441 = *(_QWORD *)(v439 - 32);
                  if ( !v441 || *(_BYTE *)v441 || *(_QWORD *)(v441 + 24) != *(_QWORD *)(v439 + 80) )
                    BUG();
                  if ( *(_DWORD *)(v441 + 36) == 17 )
                    goto LABEL_383;
                }
              }
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"llvm.call.preallocated.teardown token argument must be a llvm.call.preallocated.setup";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x13u:
              v438 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *(_BYTE *)v438 != 40 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"intrinstic requires callbr operand";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v442 = *((_QWORD *)v3 + 5);
              v443 = sub_AA5510(v442);
              if ( !v443 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Intrinsic in block must have 1 unique predecessor";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_383;
              }
              if ( *(_BYTE *)sub_986580(v443) != 40 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Intrinsic must have corresponding callbr in predecessor";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_383;
              }
              v133 = (__int64)&v646;
              v595 = (__int64)v3;
              v645.m128i_i64[0] = (__int64)&v646;
              v532 = v442;
              v533 = v438;
              v645.m128i_i64[1] = 0x1000000000LL;
              v534 = *(_DWORD *)(v438 + 88);
              v535 = 0;
              v618 = v534;
              while ( 1 )
              {
                v543 = v645.m128i_u32[2];
                if ( v618 <= (unsigned int)v535 )
                  break;
                v536 = *(_QWORD *)(v533 + 32 * (v535 - *(unsigned int *)(v533 + 88)) - 32);
                if ( (unsigned __int64)v645.m128i_u32[2] + 1 > v645.m128i_u32[3] )
                {
                  v554 = *(_QWORD *)(v533 + 32 * (v535 - *(unsigned int *)(v533 + 88)) - 32);
                  sub_C8D5F0(&v645, &v646, v645.m128i_u32[2] + 1LL, 8);
                  v543 = v645.m128i_u32[2];
                  v536 = v554;
                }
                ++v535;
                *(_QWORD *)(v645.m128i_i64[0] + 8 * v543) = v536;
                ++v645.m128i_i32[2];
              }
              v537 = 8LL * v645.m128i_u32[2];
              v538 = v532;
              v3 = (unsigned __int8 *)v595;
              v539 = (char *)(v645.m128i_i64[0] + v537);
              v540 = (char *)v645.m128i_i64[0];
              for ( n = v537 >> 5; n; --n )
              {
                if ( v538 == *(_QWORD *)v540 )
                  goto LABEL_1407;
                if ( v538 == *((_QWORD *)v540 + 1) )
                {
                  v540 += 8;
                  goto LABEL_1407;
                }
                if ( v538 == *((_QWORD *)v540 + 2) )
                {
                  v540 += 16;
                  goto LABEL_1407;
                }
                if ( v538 == *((_QWORD *)v540 + 3) )
                {
                  v540 += 24;
                  goto LABEL_1407;
                }
                v540 += 32;
              }
              v542 = v539 - v540;
              if ( v539 - v540 == 16 )
                goto LABEL_1417;
              if ( v542 == 24 )
              {
                if ( v538 == *(_QWORD *)v540 )
                  goto LABEL_1407;
                v540 += 8;
LABEL_1417:
                if ( v538 == *(_QWORD *)v540 )
                  goto LABEL_1407;
                v540 += 8;
              }
              else if ( v542 != 8 )
              {
                goto LABEL_1400;
              }
              if ( v538 != *(_QWORD *)v540 )
              {
LABEL_1400:
                v540 = v539;
                if ( (__m128i *)v645.m128i_i64[0] == &v646 )
                {
LABEL_1401:
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = v595;
                  v645.m128i_i64[0] = (__int64)"Intrinsic's corresponding callbr must have intrinsic's parent basic block"
                                               " in indirect destination list";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                goto LABEL_1408;
              }
LABEL_1407:
              if ( (__m128i *)v645.m128i_i64[0] == &v646 )
              {
LABEL_1409:
                if ( v539 == v540 )
                  goto LABEL_1401;
                v544 = *(_QWORD *)(v538 + 56);
                if ( !v544 || v595 != v544 - 24 )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = v595;
                  v645.m128i_i64[0] = (__int64)"No other instructions may proceed intrinsic";
                  v647 = 259;
                  sub_BEFC60(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                goto LABEL_383;
              }
LABEL_1408:
              v619 = v539;
              _libc_free(v645.m128i_i64[0], &v646);
              v539 = v619;
              goto LABEL_1409;
            case 0x30u:
              v545 = sub_BD3990(*(unsigned __int8 **)&v3[32 * (3LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))], v133);
              if ( *v545 == 20 )
                goto LABEL_383;
              if ( *v545 != 3
                || (v545[80] & 1) == 0
                || sub_B2FC80((__int64)v545)
                || (unsigned __int8)sub_B2F6B0((__int64)v545)
                || (v545[80] & 2) != 0 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"info argument of llvm.coro.id must refer to an initialized constant";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( (unsigned __int8)(**((_BYTE **)v545 - 4) - 9) <= 1u )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"info argument of llvm.coro.id must refer to either a struct or an array";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x44u:
              v133 = (__int64)"assign";
              sub_BDFB60((__int64)a1, (__int64)"assign", 6, (__int64)v3);
              goto LABEL_383;
            case 0x45u:
              if ( **(_BYTE **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] != 24 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"invalid llvm.dbg.declare intrinsic call 1";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v133 = (__int64)"declare";
              sub_BDFB60((__int64)a1, (__int64)"declare", 7, (__int64)v3);
              goto LABEL_383;
            case 0x46u:
              v615 = *(const char **)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 24LL);
              if ( *v615 == 27 )
              {
                v459 = (_BYTE *)*((_QWORD *)v3 + 6);
                if ( !v459 || *v459 == 6 )
                {
                  v460 = *((_QWORD *)v3 + 5);
                  if ( v460 )
                    v461 = *(_BYTE **)(v460 + 72);
                  else
                    v461 = 0;
                  v591 = (const char *)sub_B10CD0((__int64)(v3 + 48));
                  if ( v591 )
                  {
                    v568 = (char *)(v615 - 16);
                    v462 = *(v615 - 16);
                    if ( (v462 & 2) != 0 )
                      v463 = (unsigned __int8 **)*((_QWORD *)v615 - 4);
                    else
                      v463 = (unsigned __int8 **)&v568[-8 * ((v462 >> 2) & 0xF)];
                    sub_BDA280(*v463);
                    v133 = (__int64)v591;
                    v464 = *(v591 - 16);
                    if ( (v464 & 2) != 0 )
                      v465 = (unsigned __int8 **)*((_QWORD *)v591 - 4);
                    else
                      v465 = (unsigned __int8 **)&v591[-8 * ((v464 >> 2) & 0xF) - 16];
                    v466 = sub_BDA280(*v465);
                    LOBYTE(v133) = v466 == 0 || v467 == 0;
                    if ( !(_BYTE)v133 && v467 != v466 )
                    {
                      v469 = (unsigned __int8 **)sub_A17150(v468);
                      v553 = sub_AF34D0(*v469);
                      v470 = (unsigned __int8 **)sub_A17150(v568);
                      v471 = sub_AF34D0(*v470);
                      v133 = (__int64)&v637;
                      v647 = 1283;
                      v569 = (const char *)v471;
                      v645.m128i_i64[0] = (__int64)"mismatched subprogram between llvm.dbg.";
                      v646.m128i_i64[0] = (__int64)"label";
                      v646.m128i_i64[1] = 5;
                      v637.m128i_i64[0] = (__int64)&v645;
                      v638 = " label and !dbg attachment";
                      v640 = 770;
                      sub_BDD6D0(a1, (__int64)&v637);
                      if ( *a1 )
                      {
                        sub_BDBD80((__int64)a1, v3);
                        if ( v460 )
                          sub_BDBD80((__int64)a1, (_BYTE *)v460);
                        if ( v461 )
                          sub_BDBD80((__int64)a1, v461);
                        sub_BD9900(a1, v615);
                        if ( v569 )
                          sub_BD9900(a1, v569);
                        sub_BD9900(a1, v591);
                        v133 = (__int64)v553;
                        if ( v553 )
                          sub_BD9900(a1, (const char *)v553);
                      }
                    }
                  }
                  else
                  {
                    v133 = (__int64)&v637;
                    v647 = 1283;
                    v645.m128i_i64[0] = (__int64)"llvm.dbg.";
                    v646.m128i_i64[0] = (__int64)"label";
                    v646.m128i_i64[1] = 5;
                    v637.m128i_i64[0] = (__int64)&v645;
                    v638 = " intrinsic requires a !dbg attachment";
                    v640 = 770;
                    sub_BDBF70(a1, (__int64)&v637);
                    if ( *a1 )
                    {
                      v133 = (__int64)v3;
                      sub_BDBD80((__int64)a1, v3);
                      if ( v460 )
                      {
                        v133 = v460;
                        sub_BDBD80((__int64)a1, (_BYTE *)v460);
                      }
                      if ( v461 )
                      {
                        v133 = (__int64)v461;
                        sub_BDBD80((__int64)a1, v461);
                      }
                    }
                  }
                }
              }
              else
              {
                v472 = *a1;
                v647 = 1283;
                v645.m128i_i64[0] = (__int64)"invalid llvm.dbg.";
                v646.m128i_i64[0] = (__int64)"label";
                v646.m128i_i64[1] = 5;
                v637.m128i_i64[0] = (__int64)&v645;
                v638 = " intrinsic variable";
                v640 = 770;
                if ( v472 )
                {
                  v133 = v472;
                  sub_CA0E80(&v637, v472);
                  v473 = *(_BYTE **)(v472 + 32);
                  if ( (unsigned __int64)v473 >= *(_QWORD *)(v472 + 24) )
                  {
                    v133 = 10;
                    sub_CB5D20(v472, 10);
                  }
                  else
                  {
                    *(_QWORD *)(v472 + 32) = v473 + 1;
                    *v473 = 10;
                  }
                }
                *((_BYTE *)a1 + 152) |= *((_BYTE *)a1 + 154);
                v40 = *a1 == 0;
                *((_BYTE *)a1 + 153) = 1;
                if ( !v40 )
                {
                  sub_BDBD80((__int64)a1, v3);
                  v133 = (__int64)v615;
                  sub_BD9900(a1, v615);
                }
              }
              goto LABEL_383;
            case 0x47u:
              v133 = (__int64)"value";
              sub_BDFB60((__int64)a1, (__int64)"value", 5, (__int64)v3);
              goto LABEL_383;
            case 0x4Bu:
            case 0x4Cu:
              if ( **(_BYTE **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] == 81 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"eh.exceptionpointer argument must be a catchpad";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0x5Du:
            case 0x5Eu:
            case 0x5Fu:
            case 0x60u:
            case 0x61u:
            case 0x62u:
            case 0x63u:
            case 0x64u:
            case 0x65u:
            case 0x66u:
            case 0x67u:
            case 0x68u:
            case 0x69u:
            case 0x6Au:
            case 0x6Bu:
            case 0x6Cu:
            case 0x6Du:
            case 0x6Eu:
            case 0x6Fu:
            case 0x70u:
            case 0x71u:
            case 0x72u:
            case 0x73u:
            case 0x74u:
            case 0x75u:
            case 0x76u:
            case 0x77u:
            case 0x78u:
            case 0x79u:
            case 0x7Au:
            case 0x7Bu:
            case 0x7Cu:
            case 0x7Du:
            case 0x7Eu:
            case 0x7Fu:
            case 0x80u:
            case 0x81u:
            case 0x82u:
            case 0x83u:
            case 0x84u:
            case 0x85u:
            case 0x86u:
            case 0x87u:
            case 0x88u:
            case 0x89u:
            case 0x8Au:
            case 0x8Bu:
            case 0x8Cu:
            case 0x8Du:
              v491 = sub_B5A050(v3);
              v492 = *((_QWORD *)v3 - 4);
              if ( !v492 || *(_BYTE *)v492 || *(_QWORD *)(v492 + 24) != *((_QWORD *)v3 + 10) )
                BUG();
              v617 = sub_B6B000(*(_DWORD *)(v492 + 36));
              v493 = v617 + v491;
              v494 = *((_QWORD *)v3 - 4);
              v495 = v493 + 1;
              if ( !v494 || *(_BYTE *)v494 || (v133 = *((_QWORD *)v3 + 10), *(_QWORD *)(v494 + 24) != v133) )
                BUG();
              if ( (unsigned int)(*(_DWORD *)(v494 + 36) - 103) <= 1 )
                v495 = v493 + 2;
              v496 = *v3;
              v497 = v496 - 29;
              if ( v496 == 40 )
              {
                v498 = sub_B491D0((__int64)v3);
              }
              else
              {
                v498 = 0;
                if ( v497 != 56 )
                {
                  v498 = 2;
                  if ( v497 != 5 )
                    goto LABEL_1450;
                }
              }
              v592 = 32LL * v498;
              if ( (v3[7] & 0x80u) == 0 )
                goto LABEL_1379;
              v500 = sub_BD2BC0((__int64)v3);
              if ( (v3[7] & 0x80u) == 0 )
              {
                if ( (unsigned int)((v500 + v501) >> 4) )
                  goto LABEL_1468;
              }
              else if ( (unsigned int)((v500 + v501 - sub_BD2BC0((__int64)v3)) >> 4) )
              {
                if ( (v3[7] & 0x80u) != 0 )
                {
                  v502 = *(_DWORD *)(sub_BD2BC0((__int64)v3) + 8);
                  if ( (v3[7] & 0x80u) == 0 )
                    BUG();
                  v503 = sub_BD2BC0((__int64)v3);
                  v505 = (unsigned int)(*(_DWORD *)(v503 + v504 - 4) - v502);
                  goto LABEL_1302;
                }
LABEL_1468:
                BUG();
              }
LABEL_1379:
              v505 = 0;
LABEL_1302:
              v506 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              if ( v495 == (unsigned int)((32 * v506 - 32 - v592 - 32 * v505) >> 5) )
              {
                v507 = (char *)*((_QWORD *)v3 - 4);
                if ( !v507 || (v508 = *v507) != 0 || (v133 = *((_QWORD *)v3 + 10), *((_QWORD *)v507 + 3) != v133) )
                  BUG();
                switch ( *((_DWORD *)v507 + 9) )
                {
                  case 0x67:
                  case 0x68:
                    sub_B5A030((__int64)v3, v133);
                    if ( v521 <= 0xF )
                      goto LABEL_1320;
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"invalid predicate for constrained FP comparison intrinsic";
                    v647 = 259;
                    sub_BF01C0(a1, (__int64)&v645, &v637);
                    goto LABEL_383;
                  case 0x6E:
                  case 0x71:
                    v522 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v506] + 8LL);
                    if ( (unsigned __int8)sub_BDB700(v522) )
                    {
                      v523 = *((_QWORD *)v3 + 1);
                      if ( (unsigned __int8)sub_BDB700(v523) )
                      {
                        v133 = *(unsigned __int8 *)(v523 + 8);
                        v524 = *(unsigned __int8 *)(v522 + 8);
                        if ( (unsigned int)(v133 - 17) <= 1 != (unsigned int)(v524 - 17) <= 1 )
                          goto LABEL_1330;
                        if ( (unsigned int)(v524 - 17) <= 1
                          && (((_BYTE)v133 == 18) != ((_BYTE)v524 == 18)
                           || *(_DWORD *)(v523 + 32) != *(_DWORD *)(v522 + 32)) )
                        {
                          goto LABEL_1352;
                        }
                        v594 = sub_987FE0((__int64)v3);
                        v525 = sub_BCB060(v522);
                        v526 = sub_BCB060(v523);
                        if ( v594 == 113 )
                        {
                          if ( v525 > v526 )
                            goto LABEL_1320;
                          v133 = (__int64)&v645;
                          v637.m128i_i64[0] = (__int64)v3;
                          v645.m128i_i64[0] = (__int64)"Intrinsic first argument's type must be larger than result type";
                          v647 = 259;
                          sub_BF01C0(a1, (__int64)&v645, &v637);
                        }
                        else
                        {
                          if ( v525 < v526 )
                            goto LABEL_1320;
                          v133 = (__int64)&v645;
                          v637.m128i_i64[0] = (__int64)v3;
                          v645.m128i_i64[0] = (__int64)"Intrinsic first argument's type must be smaller than result type";
                          v647 = 259;
                          sub_BF01C0(a1, (__int64)&v645, &v637);
                        }
                      }
                      else
                      {
                        v133 = (__int64)&v645;
                        v637.m128i_i64[0] = (__int64)v3;
                        v645.m128i_i64[0] = (__int64)"Intrinsic result must be FP or FP vector";
                        v647 = 259;
                        sub_BF01C0(a1, (__int64)&v645, &v637);
                      }
                    }
                    else
                    {
                      v133 = (__int64)&v645;
                      v637.m128i_i64[0] = (__int64)v3;
                      v645.m128i_i64[0] = (__int64)"Intrinsic first argument must be FP or FP vector";
                      v647 = 259;
                      sub_BF01C0(a1, (__int64)&v645, &v637);
                    }
                    goto LABEL_383;
                  case 0x6F:
                  case 0x70:
                    v514 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v506] + 8LL);
                    if ( !(unsigned __int8)sub_BDB700(v514) )
                    {
                      v133 = (__int64)&v645;
                      v637.m128i_i64[0] = (__int64)v3;
                      v645.m128i_i64[0] = (__int64)"Intrinsic first argument must be floating point";
                      v647 = 259;
                      sub_BF01C0(a1, (__int64)&v645, &v637);
                      goto LABEL_383;
                    }
                    v515 = *((_QWORD *)v3 + 1);
                    v516 = *(unsigned __int8 *)(v515 + 8);
                    v517 = *(unsigned __int8 *)(v514 + 8);
                    v133 = *(unsigned __int8 *)(v515 + 8);
                    if ( (unsigned int)(v517 - 17) > 1 )
                    {
                      if ( v516 == 18 )
                        goto LABEL_1330;
                      v519 = 0;
                      v518 = 0;
                    }
                    else
                    {
                      v518 = *(_DWORD *)(v514 + 32);
                      v508 = (_BYTE)v517 == 18;
                      if ( v516 == 18 )
                      {
                        if ( !v518 )
                          goto LABEL_1330;
                        goto LABEL_1365;
                      }
                      v519 = v518 != 0;
                    }
                    if ( v519 != (v516 == 17) )
                      goto LABEL_1330;
                    v520 = *((_QWORD *)v3 + 1);
                    if ( v516 != 17 )
                    {
LABEL_1340:
                      if ( *(_BYTE *)(v520 + 8) == 12 )
                      {
                        if ( (unsigned int)(v516 - 17) <= 1
                          && (v518 != *(_DWORD *)(v515 + 32) || ((_BYTE)v133 == 18) != v508) )
                        {
                          goto LABEL_1352;
                        }
                        goto LABEL_1320;
                      }
                      v133 = (__int64)&v645;
                      v637.m128i_i64[0] = (__int64)v3;
                      v645.m128i_i64[0] = (__int64)"Intrinsic result must be an integer";
                      v647 = 259;
                      sub_BF01C0(a1, (__int64)&v645, &v637);
                      goto LABEL_383;
                    }
LABEL_1365:
                    v520 = **(_QWORD **)(v515 + 16);
                    goto LABEL_1340;
                  case 0x75:
                  case 0x7A:
                    if ( (unsigned int)*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)&v3[-32 * v506] + 8LL) + 8LL) - 17 <= 1
                      || (unsigned int)*(unsigned __int8 *)(*((_QWORD *)v3 + 1) + 8LL) - 17 <= 1 )
                    {
                      goto LABEL_1316;
                    }
                    goto LABEL_1320;
                  case 0x76:
                  case 0x7B:
                    if ( (unsigned int)*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)&v3[-32 * v506] + 8LL) + 8LL) - 17 > 1
                      && (unsigned int)*(unsigned __int8 *)(*((_QWORD *)v3 + 1) + 8LL) - 17 > 1 )
                    {
                      goto LABEL_1320;
                    }
LABEL_1316:
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"Intrinsic does not support vectors";
                    v647 = 259;
                    sub_BF01C0(a1, (__int64)&v645, &v637);
                    goto LABEL_383;
                  case 0x88:
                  case 0x8D:
                    v509 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v506] + 8LL);
                    v510 = *(unsigned __int8 *)(v509 + 8);
                    if ( (unsigned int)(v510 - 17) > 1 )
                    {
                      if ( (_BYTE)v510 == 12 )
                      {
                        v511 = 0;
LABEL_1310:
                        v512 = *((_QWORD *)v3 + 1);
                        v513 = *(unsigned __int8 *)(v512 + 8) - 17;
                        if ( (v511 != 0) == v513 <= 1 )
                        {
                          v571 = v511;
                          v593 = *((_QWORD *)v3 + 1);
                          v133 = *(unsigned __int8 *)(v512 + 8);
                          if ( (unsigned __int8)sub_BDB700(v593) )
                          {
                            if ( v513 > 1 || v571 == *(_DWORD *)(v593 + 32) && ((_BYTE)v133 == 18) == v508 )
                            {
LABEL_1320:
                              if ( (unsigned __int16)sub_B59EF0(v3, v133) >> 8 )
                              {
                                if ( v617 && !((unsigned __int16)sub_B59DB0(v3, v133) >> 8) )
                                {
                                  v133 = (__int64)&v645;
                                  v637.m128i_i64[0] = (__int64)v3;
                                  v645.m128i_i64[0] = (__int64)"invalid rounding mode argument";
                                  v647 = 259;
                                  sub_BF01C0(a1, (__int64)&v645, &v637);
                                }
                              }
                              else
                              {
                                v133 = (__int64)&v645;
                                v637.m128i_i64[0] = (__int64)v3;
                                v645.m128i_i64[0] = (__int64)"invalid exception behavior argument";
                                v647 = 259;
                                sub_BF01C0(a1, (__int64)&v645, &v637);
                              }
                            }
                            else
                            {
LABEL_1352:
                              v133 = (__int64)&v645;
                              v637.m128i_i64[0] = (__int64)v3;
                              v645.m128i_i64[0] = (__int64)"Intrinsic first argument and result vector lengths must be equal";
                              v647 = 259;
                              sub_BF01C0(a1, (__int64)&v645, &v637);
                            }
                          }
                          else
                          {
                            v133 = (__int64)&v645;
                            v637.m128i_i64[0] = (__int64)v3;
                            v645.m128i_i64[0] = (__int64)"Intrinsic result must be a floating point";
                            v647 = 259;
                            sub_BF01C0(a1, (__int64)&v645, &v637);
                          }
                        }
                        else
                        {
LABEL_1330:
                          v133 = (__int64)&v645;
                          v637.m128i_i64[0] = (__int64)v3;
                          v645.m128i_i64[0] = (__int64)"Intrinsic first argument and result disagree on vector use";
                          v647 = 259;
                          sub_BF01C0(a1, (__int64)&v645, &v637);
                        }
                        goto LABEL_383;
                      }
                    }
                    else if ( *(_BYTE *)(**(_QWORD **)(v509 + 16) + 8LL) == 12 )
                    {
                      v511 = *(_DWORD *)(v509 + 32);
                      v508 = (_BYTE)v510 == 18;
                      goto LABEL_1310;
                    }
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"Intrinsic first argument must be integer";
                    v647 = 259;
                    sub_BF01C0(a1, (__int64)&v645, &v637);
                    goto LABEL_383;
                  default:
                    goto LABEL_1320;
                }
              }
              v527 = *a1;
              v645.m128i_i64[0] = (__int64)"invalid arguments for constrained FP intrinsic";
              v647 = 259;
              if ( v527 )
              {
                v133 = v527;
                sub_CA0E80(&v645, v527);
                v528 = *(_BYTE **)(v527 + 32);
                if ( (unsigned __int64)v528 >= *(_QWORD *)(v527 + 24) )
                {
                  v133 = 10;
                  sub_CB5D20(v527, 10);
                }
                else
                {
                  *(_QWORD *)(v527 + 32) = v528 + 1;
                  *v528 = 10;
                }
                v527 = *a1;
              }
              *((_BYTE *)a1 + 152) = 1;
              if ( v527 )
              {
                if ( *v3 <= 0x1Cu )
                {
                  v133 = v527;
                  sub_A5C020(v3, v527, 1, (__int64)(a1 + 2));
                  v529 = *a1;
                  v531 = *(_BYTE **)(*a1 + 32);
                  if ( (unsigned __int64)v531 < *(_QWORD *)(*a1 + 24) )
                  {
                    *(_QWORD *)(v529 + 32) = v531 + 1;
                    *v531 = 10;
                    goto LABEL_383;
                  }
                }
                else
                {
                  v133 = v527;
                  sub_A693B0((__int64)v3, (_BYTE *)v527, (__int64)(a1 + 2), 0);
                  v529 = *a1;
                  v530 = *(_BYTE **)(*a1 + 32);
                  if ( (unsigned __int64)v530 < *(_QWORD *)(*a1 + 24) )
                  {
                    *(_QWORD *)(v529 + 32) = v530 + 1;
                    *v530 = 10;
                    goto LABEL_383;
                  }
                }
                v133 = 10;
                sub_CB5D20(v529, 10);
              }
LABEL_383:
              v626 = sub_B58D90(v625);
              if ( v626 )
              {
                v175 = *((_QWORD *)v3 + 5);
                v176 = *(_QWORD *)(v175 + 72);
                if ( (*(_BYTE *)(v176 + 2) & 8) != 0 )
                {
                  v177 = sub_B2E500(*(_QWORD *)(v175 + 72));
                  v178 = sub_B2A630(v177);
                  if ( v178 > 10 )
                  {
                    if ( v178 != 12 )
                      goto LABEL_364;
                  }
                  else if ( v178 <= 6 )
                  {
                    goto LABEL_364;
                  }
                  if ( !*((_DWORD *)a1 + 232) )
                  {
                    v200 = v176;
                    sub_B2AF20((__int64)&v645, v176);
                    v201 = *((_DWORD *)a1 + 234);
                    if ( v201 )
                    {
                      v202 = a1[115] + 16LL * v201;
                      for ( ii = (_QWORD *)a1[115]; (_QWORD *)v202 != ii; ii += 2 )
                      {
                        if ( *ii != -8192 && *ii != -4096 )
                        {
                          v204 = ii[1];
                          if ( v204 )
                          {
                            if ( (v204 & 4) != 0 )
                            {
                              v205 = (_QWORD *)(v204 & 0xFFFFFFFFFFFFFFF8LL);
                              v206 = v205;
                              if ( v205 )
                              {
                                if ( (_QWORD *)*v205 != v205 + 2 )
                                  _libc_free(*v205, v200);
                                v200 = 48;
                                j_j___libc_free_0(v206, 48);
                              }
                            }
                          }
                        }
                      }
                    }
                    sub_C7D6A0(a1[115], 16LL * *((unsigned int *)a1 + 234), 8);
                    v207 = v645.m128i_i64[1];
                    ++a1[114];
                    a1[115] = v207;
                    ++v645.m128i_i64[0];
                    a1[116] = v646.m128i_i64[0];
                    v645.m128i_i64[1] = 0;
                    *((_DWORD *)a1 + 234) = v646.m128i_i32[2];
                    v646.m128i_i64[0] = 0;
                    v646.m128i_i32[2] = 0;
                    sub_C7D6A0(0, 0, 8);
                  }
                  v179 = *((unsigned int *)a1 + 234);
                  v133 = *((_QWORD *)v3 + 5);
                  v180 = a1[115];
                  if ( (_DWORD)v179 )
                  {
                    v181 = 1;
                    for ( jj = (v179 - 1) & (((unsigned int)v133 >> 9) ^ ((unsigned int)v133 >> 4));
                          ;
                          jj = (v179 - 1) & v199 )
                    {
                      v183 = (_QWORD *)(v180 + 16LL * jj);
                      if ( v133 == *v183 )
                        break;
                      if ( *v183 == -4096 )
                        goto LABEL_413;
                      v199 = v181 + jj;
                      ++v181;
                    }
                  }
                  else
                  {
LABEL_413:
                    v183 = (_QWORD *)(v180 + 16 * v179);
                  }
                  v184 = v183[1] & 0xFFFFFFFFFFFFFFF8LL;
                  if ( (v183[1] & 4) != 0 )
                  {
                    v185 = *(__int64 **)v184;
                    v186 = *(_QWORD *)v184 + 8LL * *(unsigned int *)(v184 + 8);
                  }
                  else
                  {
                    v185 = v183 + 1;
                    if ( v184 )
                      v184 = 8;
                    v186 = (__int64)v185 + v184;
                  }
                  v599 = (__int64)v3;
                  v187 = (__int64 *)v186;
                  v188 = 0;
                  for ( kk = v185; kk != v187; ++kk )
                  {
                    v190 = *kk;
                    v191 = sub_BDB910(*kk);
                    if ( v191 != v190 + 48 && v191 != 0 && (unsigned int)*(unsigned __int8 *)(v191 - 24) - 80 <= 1 )
                      v188 = v191 != v190 + 48 && v191 != 0;
                  }
                  v3 = (unsigned __int8 *)v599;
                  v192 = a1;
                  v193 = v188;
                  v194 = 0;
                  v195 = sub_A172A0(v599);
                  while ( v195 != (_DWORD)v574 )
                  {
                    v196 = 0;
                    if ( *(char *)(v599 + 7) < 0 )
                      v196 = sub_BD2BC0(v599);
                    if ( *(_DWORD *)(*(_QWORD *)(v196 + 16 * v574) + 8LL) == 1 )
                      v194 = v626;
                    v133 = ++v574;
                  }
                  v197 = v194;
                  v198 = v193;
                  a1 = v192;
                  if ( v198 && !v197 )
                  {
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = v599;
                    v645.m128i_i64[0] = (__int64)"Missing funclet token on intrinsic call";
                    v647 = 259;
                    sub_BEFC60(v192, (__int64)&v645, &v637);
                  }
                }
              }
              goto LABEL_364;
            case 0x92u:
              if ( *v3 != 85 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"experimental_deoptimize cannot be invoked";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v133 = 0;
              if ( (unsigned int)sub_BDBB60((__int64)v3, 0) != 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"experimental_deoptimize must have exactly one \"deopt\" operand bundle";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              v474 = *((_QWORD *)v3 + 1);
              if ( v474 != **(_QWORD **)(*(_QWORD *)(sub_B43CB0((__int64)v3) + 24) + 16LL) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"experimental_deoptimize return type must match caller return type";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( *v3 != 85 )
                goto LABEL_383;
              v133 = (__int64)v3;
              v475 = sub_BF02C0(*((_QWORD *)v3 + 5) + 48LL, (__int64)v3);
              if ( *(_BYTE *)v475 != 30 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"calls to experimental_deoptimize must be followed by a return";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( *(_BYTE *)(*((_QWORD *)v3 + 1) + 8LL) != 7 )
              {
                if ( (*(_DWORD *)(v475 + 4) & 0x7FFFFFF) == 0
                  || (v476 = *(unsigned __int8 **)(v475 - 32LL * (*(_DWORD *)(v475 + 4) & 0x7FFFFFF)), v3 != v476)
                  || !v476 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"calls to experimental_deoptimize must be followed by a return of the valu"
                                               "e computed by experimental_deoptimize";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                  goto LABEL_364;
                }
              }
              goto LABEL_383;
            case 0x95u:
              if ( (unsigned int)sub_A17190(v3) != 3 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"wrong number of arguments";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v422 = *((_QWORD *)v3 + 1);
              if ( (unsigned int)*(unsigned __int8 *)(v422 + 8) - 17 <= 1 )
                v422 = **(_QWORD **)(v422 + 16);
              if ( *(_BYTE *)(v422 + 8) != 14 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate must return a pointer or a vector of pointers";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v423 = *(unsigned __int8 **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *v423 == 95 )
              {
                v631 = (_BYTE *)sub_AA5510(*((_QWORD *)v423 + 5));
                if ( !v631 )
                {
                  v133 = (__int64)&v645;
                  v637.m128i_i64[0] = *((_QWORD *)v423 + 5);
                  v645.m128i_i64[0] = (__int64)"safepoints should have unique landingpads";
                  v647 = 259;
                  sub_BEE760(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
                v435 = sub_986580((__int64)v631);
                if ( !v435 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"safepoint block should be well formed";
                  v647 = 259;
                  sub_BEE1B0(a1, (__int64)&v645, &v631);
                  goto LABEL_364;
                }
                if ( !sub_BDBD20(v435) )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc relocate should be linked to a statepoint";
                  v647 = 259;
                  sub_BEE1B0(a1, (__int64)&v645, &v631);
                  goto LABEL_364;
                }
              }
              else
              {
                v637.m128i_i64[0] = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
                if ( !sub_BDBD20(v637.m128i_i64[0]) && (unsigned int)*v423 - 12 > 1 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc relocate is incorrectly tied to the statepoint";
                  v647 = 259;
                  sub_BEFA80(a1, (__int64)&v645, v3, &v637);
                  goto LABEL_364;
                }
              }
              v133 = sub_B5B6B0((__int64)v3);
              v424 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v425 = *(_QWORD *)&v3[32 * (1 - v424)];
              if ( *(_BYTE *)v425 != 17 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate operand #2 must be integer offset";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v426 = *(_QWORD *)&v3[32 * (2 - v424)];
              if ( *(_BYTE *)v426 != 17 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate operand #3 must be integer offset";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v427 = *(_QWORD **)(v425 + 24);
              if ( *(_DWORD *)(v425 + 32) > 0x40u )
                v427 = (_QWORD *)*v427;
              v428 = *(_QWORD **)(v426 + 24);
              if ( *(_DWORD *)(v426 + 32) > 0x40u )
                v428 = (_QWORD *)*v428;
              if ( (unsigned int)*(unsigned __int8 *)v133 - 12 <= 1 )
                goto LABEL_383;
              sub_BDBBF0((__int64)&v637, v133, 5);
              if ( v639 )
              {
                if ( v637.m128i_i64[1] <= (unsigned __int64)v427 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.relocate: statepoint base index out of bounds";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
                if ( v637.m128i_i64[1] <= (unsigned __int64)v428 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.relocate: statepoint derived index out of bounds";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_364;
                }
              }
              v590 = *((_QWORD *)v3 + 1);
              v613 = *(_QWORD *)(sub_B5B890((__int64)v3) + 8);
              v429 = *(_QWORD *)(sub_B5B740((__int64)v3) + 8);
              v430 = v429;
              if ( (unsigned int)*(unsigned __int8 *)(v429 + 8) - 17 <= 1 )
                v430 = **(_QWORD **)(v429 + 16);
              if ( *(_BYTE *)(v430 + 8) != 14 )
                goto LABEL_1083;
              v431 = v613;
              v432 = *(unsigned __int8 *)(v613 + 8) - 17;
              if ( v432 <= 1 )
                v431 = **(_QWORD **)(v613 + 16);
              if ( *(_BYTE *)(v431 + 8) != 14 )
              {
LABEL_1083:
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate: relocated value must be a pointer";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v433 = *(unsigned __int8 *)(v590 + 8) - 17;
              if ( v433 <= 1 != v432 <= 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate: vector relocates to vector and pointer to pointer";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v434 = v590;
              if ( v433 <= 1 )
                v434 = **(_QWORD **)(v590 + 16);
              if ( *(_DWORD *)(v434 + 8) >> 8 != *(_DWORD *)(v431 + 8) >> 8 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.relocate: relocating a pointer shouldn't change its address space";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v436 = sub_B43CB0((__int64)v3);
              v437 = (_QWORD *)sub_B2DBE0(v436);
              sub_E3FC80(&v631, *v437, v437[1]);
              if ( v631 )
              {
                if ( (unsigned __int8)sub_BD9120((__int64 *)&v631, v590) )
                {
                  if ( (unsigned __int8)sub_BD9120((__int64 *)&v631, v429) )
                  {
                    v133 = v613;
                    if ( (unsigned __int8)sub_BD9120((__int64 *)&v631, v613) )
                    {
                      sub_BEFBE0(&v631);
                      goto LABEL_383;
                    }
                  }
                  HIBYTE(v647) = 1;
                  v499 = "gc.relocate: relocated value must be a gc pointer";
                }
                else
                {
                  HIBYTE(v647) = 1;
                  v499 = "gc.relocate: must return gc pointer";
                }
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)v499;
                LOBYTE(v647) = 3;
                sub_BED490(a1, (__int64)&v645, v3);
              }
              else
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = sub_B43CB0((__int64)v3);
                v645.m128i_i64[0] = (__int64)"gc.relocate: calling function must have GCStrategy";
                v647 = 259;
                sub_BED850(a1, (__int64)&v645, &v637);
              }
              sub_BEFBE0(&v631);
              goto LABEL_364;
            case 0x96u:
              if ( (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 72LL) + 3LL) & 0x40) == 0 )
                goto LABEL_670;
              v417 = *((_DWORD *)v3 + 1);
              v418 = *(unsigned __int8 **)&v3[-32 * (v417 & 0x7FFFFFF)];
              v419 = *v418;
              if ( (unsigned int)(v419 - 12) <= 1 )
                goto LABEL_383;
              if ( (unsigned __int8)v419 <= 0x1Cu )
                goto LABEL_1033;
              v420 = v419 - 34;
              if ( v420 > 0x33u )
                goto LABEL_1033;
              if ( ((0x8000000000041uLL >> v420) & 1) == 0 )
                goto LABEL_1033;
              v421 = *((_QWORD *)v418 - 4);
              if ( !v421 || *(_BYTE *)v421 || *(_QWORD *)(v421 + 24) != *((_QWORD *)v418 + 10) )
                goto LABEL_1033;
              if ( sub_B2FC80(*((_QWORD *)v418 - 4)) && *(_DWORD *)(v421 + 36) == 151 )
              {
                v133 = 2;
                if ( *((_QWORD *)v3 + 1) == **(_QWORD **)(sub_A74920((_QWORD *)v418 + 9, 2) + 16) )
                  goto LABEL_383;
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.result result type does not match wrapped callee";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
              }
              else
              {
                v417 = *((_DWORD *)v3 + 1);
LABEL_1033:
                v133 = (__int64)&v645;
                v647 = 259;
                v637.m128i_i64[0] = *(_QWORD *)&v3[-32 * (v417 & 0x7FFFFFF)];
                v645.m128i_i64[0] = (__int64)"gc.result operand #1 must be from a statepoint";
                sub_BEFA80(a1, (__int64)&v645, v3, &v637);
              }
              goto LABEL_364;
            case 0x97u:
              if ( *v3 == 85 )
              {
                v387 = (_BYTE *)*((_QWORD *)v3 - 4);
                v637.m128i_i64[0] = (__int64)v3;
                if ( *v387 == 25 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.statepoint support for inline assembly unimplemented";
                  v647 = 259;
                  sub_BEEAD0(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
              }
              if ( (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 72LL) + 3LL) & 0x40) == 0 )
                goto LABEL_670;
              if ( sub_B49E00((__int64)v3) || (unsigned __int8)sub_B49E20((__int64)v3) || sub_B49E80((__int64)v3) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint must read and write all memory to preserve reordering restric"
                                             "tions required by safepoint semantics";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v388 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              v389 = *(__int64 **)(v388 + 24);
              v390 = *(_DWORD *)(v388 + 32);
              if ( v390 > 0x40 )
              {
                v391 = *v389;
              }
              else
              {
                if ( !v390 )
                  goto LABEL_946;
                v391 = (__int64)((_QWORD)v389 << (64 - (unsigned __int8)v390)) >> (64 - (unsigned __int8)v390);
              }
              if ( v391 < 0 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint number of patchable bytes must be positive";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
LABEL_946:
              v392 = sub_A74920((_QWORD *)v3 + 9, 2);
              v393 = v392;
              if ( !v392 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint callee argument must have elementtype attribute";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              if ( *(_BYTE *)(v392 + 8) != 13 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint callee elementtype must be function type";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v394 = *((_DWORD *)v3 + 1);
              v395 = v394 & 0x7FFFFFF;
              v396 = *(_QWORD *)&v3[32 * (3 - v395)];
              v397 = *(_QWORD **)(v396 + 24);
              if ( *(_DWORD *)(v396 + 32) > 0x40u )
                v397 = (_QWORD *)*v397;
              v398 = (int)v397;
              if ( (int)v397 < 0 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint number of arguments to underlying call must be positive";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v399 = *(_DWORD *)(v393 + 12) - 1;
              if ( *(_DWORD *)(v393 + 8) >> 8 )
              {
                if ( v398 < v399 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.statepoint mismatch in number of vararg call args";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_383;
                }
                if ( *(_BYTE *)(**(_QWORD **)(v393 + 16) + 8LL) != 7 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.statepoint doesn't support wrapping non-void vararg functions yet";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_383;
                }
              }
              else if ( v398 != v399 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint mismatch in number of call args";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v400 = *(_QWORD *)&v3[32 * (4 - v395)];
              v401 = *(_QWORD *)(v400 + 24);
              if ( *(_DWORD *)(v400 + 32) > 0x40u )
                v401 = *(_QWORD *)v401;
              if ( (v401 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"unknown flag used in gc.statepoint flags argument";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v565 = v398;
              v402 = v393;
              v612 = a1;
              v403 = 5;
              v630 = (_BYTE *)*((_QWORD *)v3 + 9);
              v404 = v399;
              while ( 1 )
              {
                v133 = v394 & 0x7FFFFFF;
                if ( (int)v403 - 5 >= v404 )
                  break;
                if ( *(_QWORD *)(*(_QWORD *)(v402 + 16) + 8 * v403 - 32) != *(_QWORD *)(*(_QWORD *)&v3[32 * (v403 - v133)]
                                                                                      + 8LL) )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.statepoint call argument does not match wrapped function type";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                  goto LABEL_383;
                }
                if ( *(_DWORD *)(v402 + 8) >> 8 )
                {
                  v637.m128i_i64[0] = sub_A744E0(&v630, v403);
                  if ( (unsigned __int8)sub_A73170(&v637, 85) )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"Attribute 'sret' cannot be used for vararg call arguments!";
                    v647 = 259;
                    sub_BED490(a1, (__int64)&v645, v3);
                    goto LABEL_383;
                  }
                  v394 = *((_DWORD *)v3 + 1);
                }
                ++v403;
              }
              v405 = *(_QWORD *)&v3[32 * (v565 + 5 - v133)];
              if ( *(_BYTE *)v405 != 17 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint number of transition arguments must be constant integer";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v406 = *(_QWORD **)(v405 + 24);
              if ( *(_DWORD *)(v405 + 32) > 0x40u )
                v406 = (_QWORD *)*v406;
              if ( (_DWORD)v406 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint w/inline transition bundle is deprecated";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v407 = *(_QWORD *)&v3[32 * (v565 + 6 - v133)];
              if ( *(_BYTE *)v407 != 17 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint number of deoptimization arguments must be constant integer";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v408 = *(_QWORD **)(v407 + 24);
              if ( *(_DWORD *)(v407 + 32) > 0x40u )
                v408 = (_QWORD *)*v408;
              if ( (_DWORD)v408 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint w/inline deopt operands is deprecated";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              if ( (unsigned int)sub_A17190(v3) != v565 + 7 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"gc.statepoint too many arguments";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_383;
              }
              v409 = (__int64)v3;
              for ( mm = *((_QWORD *)v3 + 2); ; mm = *(_QWORD *)(mm + 8) )
              {
                if ( !mm )
                {
                  v3 = (unsigned __int8 *)v409;
                  a1 = v612;
                  goto LABEL_383;
                }
                v410 = *(_QWORD *)(mm + 24);
                v631 = (_BYTE *)v410;
                if ( *(_BYTE *)v410 != 85 )
                {
                  v3 = (unsigned __int8 *)v409;
                  a1 = v612;
                  v637.m128i_i64[0] = 0;
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"illegal use of statepoint token";
                  v647 = 259;
                  sub_BED590(v612, (__int64)&v645, (_BYTE *)v409, &v631);
                  goto LABEL_383;
                }
                v637.m128i_i64[0] = v410;
                if ( *(_BYTE *)v410 != 85
                  || (v411 = *(_QWORD *)(v410 - 32)) == 0
                  || (*(_BYTE *)v411
                   || (v412 = *(_QWORD *)(v411 + 24), v412 != *(_QWORD *)(v410 + 80))
                   || (v413 = *(_BYTE *)(v411 + 33), (v413 & 0x20) == 0)
                   || (unsigned int)sub_987FE0(v410) != 149)
                  && (*(_BYTE *)v411
                   || (v412 = *(_QWORD *)(v411 + 24), v412 != *(_QWORD *)(v410 + 80))
                   || (v413 = *(_BYTE *)(v411 + 33), (v413 & 0x20) == 0)
                   || (unsigned int)sub_987FE0(v410) != 150) )
                {
                  v3 = (unsigned __int8 *)v409;
                  a1 = v612;
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"gc.result or gc.relocate are the only value uses of a gc.statepoint";
                  v647 = 259;
                  sub_BED590(v612, (__int64)&v645, (_BYTE *)v409, &v631);
                  goto LABEL_383;
                }
                if ( !*(_BYTE *)v411
                  && v412 == *(_QWORD *)(v410 + 80)
                  && (v413 & 0x20) != 0
                  && (unsigned int)sub_987FE0(v410) == 150 )
                {
                  v414 = *(_QWORD *)(v410 - 32LL * (*(_DWORD *)(v410 + 4) & 0x7FFFFFF));
                  if ( !v414 || v409 != v414 )
                  {
                    v3 = (unsigned __int8 *)v409;
                    a1 = v612;
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"gc.result connected to wrong gc.statepoint";
                    v647 = 259;
                    sub_BED6F0(v612, (__int64)&v645, (_BYTE *)v409, &v637);
                    goto LABEL_383;
                  }
                }
                else if ( *(_BYTE *)v409 == 85 )
                {
                  v415 = *(_QWORD *)(v409 - 32);
                  if ( v415 )
                  {
                    if ( !*(_BYTE *)v415 )
                    {
                      v133 = *(_QWORD *)(v409 + 80);
                      if ( *(_QWORD *)(v415 + 24) == v133
                        && (*(_BYTE *)(v415 + 33) & 0x20) != 0
                        && (unsigned int)sub_987FE0(v409) == 149 )
                      {
                        v416 = *(_QWORD *)(v410 - 32LL * (*(_DWORD *)(v410 + 4) & 0x7FFFFFF));
                        if ( v409 != v416 || !v416 )
                        {
                          v3 = (unsigned __int8 *)v409;
                          a1 = v612;
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"gc.relocate connected to wrong gc.statepoint";
                          v647 = 259;
                          sub_BED6F0(v612, (__int64)&v645, (_BYTE *)v409, &v637);
                          goto LABEL_383;
                        }
                      }
                    }
                  }
                }
              }
            case 0x98u:
              v385 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              v386 = v385 + 24;
              v133 = (unsigned int)(*(_DWORD *)(v385 + 32) - 1);
              if ( !sub_986C60((__int64 *)(v385 + 24), v133) && !sub_9867B0(v386) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"get_vector_length: VF must be positive";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0x99u:
              if ( *v3 != 85 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"experimental_guard cannot be invoked";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v133 = 0;
              if ( (unsigned int)sub_BDBB60((__int64)v3, 0) == 1 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"experimental_guard must have exactly one \"deopt\" operand bundle";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x9Bu:
              v383 = *((unsigned int *)a1 + 570);
              if ( v383 + 1 > (unsigned __int64)*((unsigned int *)a1 + 571) )
              {
                v133 = (__int64)(a1 + 286);
                sub_C8D5F0(a1 + 284, a1 + 286, v383 + 1, 8);
                v383 = *((unsigned int *)a1 + 570);
              }
              *(_QWORD *)(a1[284] + 8 * v383) = v3;
              ++*((_DWORD *)a1 + 570);
              goto LABEL_383;
            case 0x9Cu:
              if ( ((*((_WORD *)v3 + 1) >> 2) & 0x3FF) != 0xD )
                goto LABEL_383;
              v384 = *(_BYTE *)(*((_QWORD *)v3 + 1) + 8LL);
              if ( v384 <= 3u || v384 == 5 || v384 <= 0x14u && ((0x165450uLL >> v384) & 1) != 0 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"patchpoint: invalid return type used with anyregcc";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xA2u:
              v376 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v377 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1 - v376)] + 8LL);
              v378 = *(_QWORD *)(*(_QWORD *)&v3[32 * (2 - v376)] + 8LL);
              v379 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v376] + 8LL);
              v380 = *(_BYTE *)(v378 + 8);
              if ( (unsigned int)*(unsigned __int8 *)(v379 + 8) - 17 >= 2 )
                v379 = 0;
              v381 = *(unsigned __int8 *)(v377 + 8);
              if ( (unsigned int)(v381 - 17) > 1 || (unsigned int)v380 - 17 > 1 || !v379 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Operands must be vectors.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              if ( (_BYTE)v381 != 17 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Second operand must be a fixed length vector.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v382 = *(_QWORD *)(v379 + 24);
              if ( *(_BYTE *)(v382 + 8) != 12 )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"First operand must be a vector of integers.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              if ( v382 != *(_QWORD *)(v377 + 24) )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"First two operands must have the same element type.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              if ( (*(_BYTE *)(v379 + 8) == 18) != (v380 == 18) || *(_DWORD *)(v378 + 32) != *(_DWORD *)(v379 + 32) )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"First operand and mask must have the same number of elements.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v133 = 1;
              if ( sub_BCAC40(*(_QWORD *)(v378 + 24), 1) )
              {
                if ( *((_QWORD *)v3 + 1) == v378 )
                  goto LABEL_383;
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Return type must match the mask type.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
              }
              else
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"Mask must be a vector of i1's.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
              }
              goto LABEL_364;
            case 0xA3u:
              if ( !(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))] + 8LL) + 32LL)
                   % *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL) + 32LL)) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"Invalid vector widths for partial reduction. The width of the input vector mu"
                                           "st be a positive integer multiple of the width of the accumulator vector.";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0xA4u:
            case 0xA5u:
            case 0xA6u:
            case 0xA7u:
            case 0xA8u:
            case 0x194u:
            case 0x195u:
            case 0x196u:
            case 0x197u:
            case 0x198u:
            case 0x199u:
            case 0x19Au:
            case 0x19Bu:
            case 0x19Cu:
            case 0x19Du:
            case 0x19Eu:
            case 0x19Fu:
            case 0x1A0u:
            case 0x1A1u:
            case 0x1A2u:
            case 0x1A3u:
            case 0x1A4u:
            case 0x1A5u:
            case 0x1A6u:
            case 0x1A7u:
            case 0x1A8u:
            case 0x1A9u:
            case 0x1AAu:
            case 0x1ABu:
            case 0x1ACu:
            case 0x1ADu:
            case 0x1AEu:
            case 0x1AFu:
            case 0x1B0u:
            case 0x1B1u:
            case 0x1B2u:
            case 0x1B3u:
            case 0x1B4u:
            case 0x1B5u:
            case 0x1B6u:
            case 0x1B7u:
            case 0x1B8u:
            case 0x1B9u:
            case 0x1BAu:
            case 0x1BBu:
            case 0x1BCu:
            case 0x1BDu:
            case 0x1BEu:
            case 0x1BFu:
            case 0x1C0u:
            case 0x1C1u:
            case 0x1C2u:
            case 0x1C3u:
            case 0x1C4u:
            case 0x1C5u:
            case 0x1C6u:
            case 0x1C7u:
            case 0x1C8u:
            case 0x1C9u:
            case 0x1CAu:
            case 0x1CBu:
            case 0x1CCu:
            case 0x1CDu:
            case 0x1CEu:
            case 0x1CFu:
            case 0x1D0u:
            case 0x1D1u:
            case 0x1D2u:
            case 0x1D3u:
            case 0x1D4u:
            case 0x1D5u:
            case 0x1D6u:
            case 0x1D7u:
            case 0x1D8u:
            case 0x1D9u:
            case 0x1DAu:
            case 0x1DBu:
            case 0x1DCu:
            case 0x1DDu:
            case 0x1DEu:
            case 0x1DFu:
            case 0x1E0u:
            case 0x1E1u:
            case 0x1E2u:
            case 0x1E3u:
            case 0x1E4u:
            case 0x1E5u:
            case 0x1E6u:
            case 0x1E7u:
            case 0x1E8u:
            case 0x1E9u:
            case 0x1EAu:
            case 0x1EBu:
            case 0x1ECu:
              v294 = *((_QWORD *)v3 - 4);
              if ( !v294 || *(_BYTE *)v294 || *(_QWORD *)(v294 + 24) != *((_QWORD *)v3 + 10) )
                BUG();
              if ( sub_B5B010(*(_DWORD *)(v294 + 36), v133, v137, v135) )
              {
                v295 = *((_QWORD *)v3 + 1);
                v296 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                v297 = *(unsigned __int8 *)(v295 + 8);
                v298 = *(_BYTE *)(v296 + 8);
                LOBYTE(v133) = v298 == 18;
                if ( (v298 == 18) == ((_BYTE)v297 == 18) )
                {
                  v133 = *(unsigned int *)(v295 + 32);
                  if ( *(_DWORD *)(v296 + 32) == (_DWORD)v133 )
                  {
                    v301 = *((_QWORD *)v3 - 4);
                    if ( !v301 || *(_BYTE *)v301 || *(_QWORD *)(v301 + 24) != *((_QWORD *)v3 + 10) )
                      BUG();
                    v133 = *(unsigned int *)(v301 + 36);
                    switch ( (int)v133 )
                    {
                      case 425:
                        v611 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( !(unsigned __int8)sub_BDB700(*((_QWORD *)v3 + 1)) || !(unsigned __int8)sub_BDB700(v611) )
                        {
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"llvm.vp.fpext intrinsic first argument and result element type mu"
                                                       "st be floating-point";
                          v647 = 259;
                          sub_BF00C0(a1, (__int64)&v645, v3);
                          goto LABEL_383;
                        }
                        v375 = sub_BCB060(v295);
                        if ( v375 > (unsigned int)sub_BCB060(v611) )
                          goto LABEL_683;
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.fpext intrinsic the bit size of first argument must be smal"
                                                     "ler than the bit size of the return type";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 426:
                      case 427:
                      case 437:
                      case 439:
                        if ( (unsigned int)(v297 - 17) <= 1 )
                          v295 = **(_QWORD **)(v295 + 16);
                        if ( *(_BYTE *)(v295 + 8) == 12
                          && (unsigned __int8)sub_BDB700(*(_QWORD *)(*(_QWORD *)&v3[-32
                                                                                  * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)]
                                                                   + 8LL)) )
                        {
                          goto LABEL_683;
                        }
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.fptoui, llvm.vp.fptosi, llvm.vp.lrint or llvm.vp.llrintintr"
                                                     "insic first argument element type must be floating-point and result"
                                                     " element type must be integer";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 428:
                        v609 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( !(unsigned __int8)sub_BDB700(*((_QWORD *)v3 + 1)) || !(unsigned __int8)sub_BDB700(v609) )
                        {
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"llvm.vp.fptrunc intrinsic first argument and result element type "
                                                       "must be floating-point";
                          v647 = 259;
                          sub_BF00C0(a1, (__int64)&v645, v3);
                          goto LABEL_383;
                        }
                        v368 = sub_BCB060(v295);
                        if ( v368 < (unsigned int)sub_BCB060(v609) )
                          goto LABEL_683;
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.fptrunc intrinsic the bit size of first argument must be la"
                                                     "rger than the bit size of the return type";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 435:
                        if ( (unsigned int)(v297 - 17) <= 1 )
                          v295 = **(_QWORD **)(v295 + 16);
                        if ( *(_BYTE *)(v295 + 8) == 14 )
                        {
                          v370 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                          if ( (unsigned int)v298 - 17 <= 1 )
                            v370 = **(_QWORD **)(v296 + 16);
                          if ( *(_BYTE *)(v370 + 8) == 12 )
                            goto LABEL_683;
                        }
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.inttoptr intrinsic first argument element type must be inte"
                                                     "ger and result element type must be pointer";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 449:
                        if ( (unsigned int)(v297 - 17) <= 1 )
                          v295 = **(_QWORD **)(v295 + 16);
                        if ( *(_BYTE *)(v295 + 8) == 12 )
                        {
                          v369 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                          if ( (unsigned int)v298 - 17 <= 1 )
                            v369 = **(_QWORD **)(v296 + 16);
                          if ( *(_BYTE *)(v369 + 8) == 14 )
                            goto LABEL_683;
                        }
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.ptrtoint intrinsic first argument element type must be poin"
                                                     "ter and result element type must be integer";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 473:
                      case 492:
                        v371 = *((_QWORD *)v3 + 1);
                        if ( (unsigned int)(v297 - 17) <= 1 )
                          v371 = **(_QWORD **)(v295 + 16);
                        if ( *(_BYTE *)(v371 + 8) != 12 )
                          goto LABEL_892;
                        v372 = v298;
                        v373 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( (unsigned int)(v372 - 17) <= 1 )
                          v373 = **(_QWORD **)(v296 + 16);
                        v610 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( *(_BYTE *)(v373 + 8) != 12 )
                        {
LABEL_892:
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"llvm.vp.zext or llvm.vp.sext intrinsic first argument and result "
                                                       "element type must be integer";
                          v647 = 259;
                          sub_BF00C0(a1, (__int64)&v645, v3);
                          goto LABEL_383;
                        }
                        v374 = sub_BCB060(v295);
                        if ( v374 > (unsigned int)sub_BCB060(v610) )
                          goto LABEL_683;
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.zext or llvm.vp.sext intrinsic the bit size of first argume"
                                                     "nt must be smaller than the bit size of the return type";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 475:
                      case 486:
                        v587 = *(_BYTE *)(v296 + 8);
                        v607 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( (unsigned __int8)sub_BDB700(*((_QWORD *)v3 + 1)) )
                        {
                          v317 = v607;
                          if ( (unsigned int)v587 - 17 <= 1 )
                            v317 = **(_QWORD **)(v607 + 16);
                          if ( *(_BYTE *)(v317 + 8) == 12 )
                            goto LABEL_683;
                        }
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.uitofp or llvm.vp.sitofp intrinsic first argument element t"
                                                     "ype must be integer and result element type must be floating-point";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        goto LABEL_383;
                      case 483:
                        v312 = *((_QWORD *)v3 + 1);
                        if ( (unsigned int)(v297 - 17) <= 1 )
                          v312 = **(_QWORD **)(v295 + 16);
                        if ( *(_BYTE *)(v312 + 8) != 12 )
                          goto LABEL_736;
                        v313 = v298;
                        v314 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( (unsigned int)(v313 - 17) <= 1 )
                          v314 = **(_QWORD **)(v296 + 16);
                        v606 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
                        if ( *(_BYTE *)(v314 + 8) != 12 )
                        {
LABEL_736:
                          v133 = (__int64)&v645;
                          v645.m128i_i64[0] = (__int64)"llvm.vp.trunc intrinsic first argument and result element type must be integer";
                          v647 = 259;
                          sub_BF00C0(a1, (__int64)&v645, v3);
                          goto LABEL_383;
                        }
                        v315 = sub_BCB060(v295);
                        if ( v315 < (unsigned int)sub_BCB060(v606) )
                          goto LABEL_683;
                        v133 = (__int64)&v645;
                        v645.m128i_i64[0] = (__int64)"llvm.vp.trunc intrinsic the bit size of first argument must be larg"
                                                     "er than the bit size of the return type";
                        v647 = 259;
                        sub_BF00C0(a1, (__int64)&v645, v3);
                        break;
                      default:
                        goto LABEL_1450;
                    }
                    goto LABEL_383;
                  }
                }
                v299 = *a1;
                v645.m128i_i64[0] = (__int64)"VP cast intrinsic first argument and result vector lengths must be equal";
                v647 = 259;
                if ( v299 )
                {
                  v133 = v299;
                  sub_CA0E80(&v645, v299);
                  v300 = *(_BYTE **)(v299 + 32);
                  if ( (unsigned __int64)v300 >= *(_QWORD *)(v299 + 24) )
                  {
                    v133 = 10;
                    sub_CB5D20(v299, 10);
                  }
                  else
                  {
                    *(_QWORD *)(v299 + 32) = v300 + 1;
                    *v300 = 10;
                  }
                }
                v40 = *a1 == 0;
                *((_BYTE *)a1 + 152) = 1;
                if ( v40 )
                  goto LABEL_383;
LABEL_706:
                v133 = (__int64)v3;
                sub_BDBD80((__int64)a1, v3);
                goto LABEL_383;
              }
              v301 = *((_QWORD *)v3 - 4);
              if ( !v301 )
                BUG();
LABEL_683:
              if ( *(_BYTE *)v301 || *(_QWORD *)(v301 + 24) != *((_QWORD *)v3 + 10) )
                BUG();
              if ( *(_DWORD *)(v301 + 36) == 418 )
              {
                sub_B5B080((__int64)v3);
                if ( v305 > 0xF )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"invalid predicate for VP FP comparison intrinsic";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                  if ( !*a1 )
                    goto LABEL_383;
                  goto LABEL_706;
                }
                v301 = *((_QWORD *)v3 - 4);
                if ( !v301 )
                  BUG();
                if ( *(_BYTE *)v301 )
                  goto LABEL_1456;
              }
              if ( *(_QWORD *)(v301 + 24) != *((_QWORD *)v3 + 10) )
LABEL_1456:
                BUG();
              if ( *(_DWORD *)(v301 + 36) != 434 )
                goto LABEL_689;
              sub_B5B080((__int64)v3);
              if ( (unsigned int)(v304 - 32) > 9 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"invalid predicate for VP integer comparison intrinsic";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                if ( !*a1 )
                  goto LABEL_383;
                goto LABEL_706;
              }
              v301 = *((_QWORD *)v3 - 4);
              if ( v301 )
              {
LABEL_689:
                if ( !*(_BYTE *)v301 && *(_QWORD *)(v301 + 24) == *((_QWORD *)v3 + 10) )
                {
                  if ( *(_DWORD *)(v301 + 36) == 436 )
                  {
                    v302 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
                    v303 = *(_QWORD **)(v302 + 24);
                    if ( *(_DWORD *)(v302 + 32) > 0x40u )
                      v303 = (_QWORD *)*v303;
                    if ( ((unsigned int)v303 & 0xFFFFFC00) != 0 )
                    {
                      v133 = (__int64)&v645;
                      v645.m128i_i64[0] = (__int64)"unsupported bits for llvm.vp.is.fpclass test mask";
                      v647 = 259;
                      sub_BDBF70(a1, (__int64)&v645);
                    }
                  }
                  goto LABEL_383;
                }
              }
              BUG();
            case 0xB1u:
              v306 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              if ( *(_BYTE *)v306 != 24 || (v307 = *(const char **)(v306 + 24)) == 0 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"missing rounding mode argument";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              if ( *v307 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"invalid value for llvm.fptrunc.round metadata operand (the operand should be a string)";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                if ( *a1 )
                {
                  v133 = (__int64)v307;
                  sub_BD9900(a1, v307);
                }
                goto LABEL_364;
              }
              v308 = sub_B91420(*(_QWORD *)(v306 + 24));
              v133 = v309;
              v310 = sub_E3F580(v308, v309);
              if ( !HIBYTE(v310) || (_BYTE)v310 == 7 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"unsupported rounding mode argument";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              goto LABEL_383;
            case 0xB6u:
            case 0xB7u:
            case 0xB8u:
              if ( v625 != 183 )
                goto LABEL_669;
              v311 = sub_BD3990(*(unsigned __int8 **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)], v133);
              if ( *v311 == 60 )
              {
                v316 = **(_BYTE **)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
                if ( v316 > 0x15u )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"llvm.gcroot parameter #2 must be a constant.";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                }
                else if ( *(_BYTE *)(*((_QWORD *)v311 + 9) + 8LL) == 14 || v316 != 20 )
                {
LABEL_669:
                  if ( (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 72LL) + 3LL) & 0x40) != 0 )
                    goto LABEL_383;
LABEL_670:
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"Enclosing function does not use GC.";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                }
                else
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 "
                                               "must be a non-null constant.";
                  v647 = 259;
                  sub_BED490(a1, (__int64)&v645, v3);
                }
              }
              else
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.gcroot parameter #1 must be an alloca.";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
              }
              goto LABEL_364;
            case 0xB9u:
              v293 = *((_QWORD *)v3 + 1);
              if ( (unsigned __int8)(*(_BYTE *)(v293 + 8) - 17) > 1u )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"get_active_lane_mask: must return a vector";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v133 = 1;
              if ( sub_BCAC40(**(_QWORD **)(v293 + 16), 1) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"get_active_lane_mask: element type is not i1";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xC3u:
              if ( !*sub_BD3990(*(unsigned __int8 **)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))], v133) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"llvm.init_trampoline parameter #2 must resolve to a function.";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xCDu:
              v289 = *(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *(_BYTE *)v289 == 17 )
              {
                v290 = *(_DWORD *)(v289 + 32);
                v133 = v290 - 1;
                v291 = sub_986C60((__int64 *)(v289 + 24), v133);
                if ( !v290 || !v291 )
                  goto LABEL_383;
                if ( v290 <= 0x40
                   ? 0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v290) == *(_QWORD *)(v289 + 24)
                   : v290 == (unsigned int)sub_C445E0(v289 + 24) )
                {
                  goto LABEL_383;
                }
              }
              v133 = (__int64)&v645;
              v637.m128i_i64[0] = (__int64)v3;
              v645.m128i_i64[0] = (__int64)"invariant_start parameter must be -1, 0 or a positive number";
              v647 = 259;
              sub_BEFC60(a1, (__int64)&v645, &v637);
              goto LABEL_364;
            case 0xCFu:
              v287 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              v288 = *(_QWORD **)(v287 + 24);
              if ( *(_DWORD *)(v287 + 32) > 0x40u )
                v288 = (_QWORD *)*v288;
              if ( ((unsigned int)v288 & 0xFFFFFC00) == 0 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"unsupported bits for llvm.is.fpclass test mask";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0xD4u:
            case 0xD5u:
            case 0xDFu:
            case 0xE0u:
              v278 = *((_QWORD *)v3 + 1);
              v279 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              v280 = *(unsigned __int8 *)(v278 + 8);
              v586 = *(unsigned __int8 *)(v279 + 8) - 17;
              v281 = 0;
              if ( v586 <= 1 )
                v281 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              v133 = v281;
              if ( (unsigned int)(v280 - 17) > 1 )
              {
                v283 = sub_BDB700(v279);
                v282 = 0;
                if ( !v283 )
                  goto LABEL_638;
              }
              else
              {
                if ( !(unsigned __int8)sub_BDB700(v279) )
                  goto LABEL_638;
                v282 = v278;
                v278 = **(_QWORD **)(v278 + 16);
              }
              if ( *(_BYTE *)(v278 + 8) == 12 )
              {
                if ( v586 > 1 )
                {
                  if ( v280 == 18 )
                    goto LABEL_642;
                  v598 = 0;
                }
                else if ( v280 == 18 )
                {
LABEL_631:
                  if ( v133
                    && ((*(_BYTE *)(v282 + 8) == 18) != (*(_BYTE *)(v133 + 8) == 18)
                     || *(_DWORD *)(v282 + 32) != *(_DWORD *)(v133 + 32)) )
                  {
                    v631 = v3;
                    sub_2241BD0(&v637, v634);
                    sub_2241520(&v637, ": argument must be same length as result");
                    v133 = (__int64)&v645;
                    v647 = 260;
                    v645.m128i_i64[0] = (__int64)&v637;
                    sub_BEFC60(a1, (__int64)&v645, &v631);
                    sub_2240A30(&v637);
                    goto LABEL_364;
                  }
                  goto LABEL_383;
                }
                if ( (v280 == 17) == v598 )
                  goto LABEL_631;
LABEL_642:
                v631 = v3;
                sub_2241BD0(&v637, v634);
                sub_2241520(&v637, ": argument and result disagree on vector use");
                v133 = (__int64)&v645;
                v647 = 260;
                v645.m128i_i64[0] = (__int64)&v637;
                sub_BEFC60(a1, (__int64)&v645, &v631);
                sub_2240A30(&v637);
                goto LABEL_364;
              }
LABEL_638:
              v631 = v3;
              sub_2241BD0(&v637, v634);
              sub_2241520(
                &v637,
                ": argument must be floating-point or vector of floating-points, and result must be integer or vector of integers");
              v133 = (__int64)&v645;
              v647 = 260;
              v645.m128i_i64[0] = (__int64)&v637;
              sub_BEFC60(a1, (__int64)&v645, &v631);
              sub_2240A30(&v637);
              goto LABEL_364;
            case 0xD8u:
              v273 = *((_QWORD *)v3 + 5);
              if ( !sub_AA5B70(v273) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.localescape used outside of entry block";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              if ( *((_BYTE *)a1 + 824) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"multiple calls to llvm.localescape in one function";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v274 = sub_A7E990(v3);
              v604 = v275;
              for ( nn = (unsigned __int8 **)v274; v604 != nn; nn += 4 )
              {
                if ( **nn != 20 )
                {
                  v277 = sub_BD3990(*nn, v133);
                  if ( *v277 != 60 || !sub_B4D040((__int64)v277) )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"llvm.localescape only accepts static allocas";
                    v647 = 259;
                    sub_BED490(a1, (__int64)&v645, v3);
                    goto LABEL_364;
                  }
                }
              }
              v133 = (__int64)&v645;
              v284 = sub_A17190(v3);
              v645.m128i_i64[0] = *(_QWORD *)(v273 + 72);
              *(_DWORD *)sub_BF27C0((__int64)(a1 + 104), v645.m128i_i64) = v284;
              *((_BYTE *)a1 + 824) = 1;
              goto LABEL_383;
            case 0xD9u:
              v268 = sub_BD3990(*(unsigned __int8 **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)], v133);
              if ( *v268 )
              {
                v637.m128i_i64[0] = 0;
              }
              else
              {
                v637.m128i_i64[0] = (__int64)v268;
                if ( !sub_B2FC80((__int64)v268) )
                {
                  v133 = (__int64)&v637;
                  v269 = *(_QWORD *)&v3[32 * (2LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
                  v270 = sub_BF2570((__int64)(a1 + 104), v637.m128i_i64);
                  if ( *(_DWORD *)(v269 + 32) > 0x40u )
                  {
                    v605 = *(_DWORD *)(v269 + 32);
                    v285 = sub_C444A0(v269 + 24);
                    LODWORD(v272) = 0;
                    if ( (unsigned int)(v605 - v285) > 0x40 )
                      goto LABEL_614;
                    v271 = **(_QWORD **)(v269 + 24);
                    if ( v271 > 0xFFFFFFFF )
                      goto LABEL_614;
                  }
                  else
                  {
                    v271 = *(_QWORD *)(v269 + 24);
                    LODWORD(v272) = 0;
                    if ( v271 > 0xFFFFFFFF )
                    {
LABEL_614:
                      *((_DWORD *)v270 + 1) = v272;
                      goto LABEL_383;
                    }
                  }
                  v272 = *((unsigned int *)v270 + 1);
                  v286 = v271 + 1;
                  if ( v286 >= v272 )
                    LODWORD(v272) = v286;
                  goto LABEL_614;
                }
              }
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"llvm.localrecover first argument must be function defined in this module";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xE3u:
              v267 = *(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))] + 24LL;
              if ( sub_9867B0(v267) || sub_986BA0(v267) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"masked_gather: alignment must be 0 or a power of 2";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xE4u:
              v264 = *((_QWORD *)v3 + 1);
              if ( (unsigned int)*(unsigned __int8 *)(v264 + 8) - 17 > 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_load: must return a vector";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v265 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v266 = *(_QWORD *)(*(_QWORD *)&v3[32 * (2 - v265)] + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v266 + 8) - 17 > 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_load: mask must be vector";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v585 = *(_BYTE *)(v264 + 8);
              v603 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v133 = *(unsigned __int8 *)(v266 + 8);
              if ( !sub_986BA0(*(_QWORD *)&v3[32 * (1 - v265)] + 24LL) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_load: alignment must be a power of 2";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              if ( v264 != *(_QWORD *)(*(_QWORD *)&v3[32 * (3 - v603)] + 8LL) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_load: pass through and return type must match";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              if ( (v585 == 18) != ((_BYTE)v133 == 18) || *(_DWORD *)(v264 + 32) != *(_DWORD *)(v266 + 32) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_load: vector mask must be same length as return";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              goto LABEL_383;
            case 0xE5u:
              v263 = *(_QWORD *)&v3[32 * (2LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))] + 24LL;
              if ( sub_9867B0(v263) || sub_986BA0(v263) )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"masked_scatter: alignment must be 0 or a power of 2";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0xE6u:
              v260 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v261 = *(_QWORD *)(*(_QWORD *)&v3[32 * (3 - v260)] + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v261 + 8) - 17 > 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_store: mask must be vector";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v602 = *(_BYTE *)(v261 + 8);
              if ( !sub_986BA0(*(_QWORD *)&v3[32 * (2 - v260)] + 24LL) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_store: alignment must be a power of 2";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v262 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v260] + 8LL);
              if ( (*(_BYTE *)(v262 + 8) == 18) != (v602 == 18) || *(_DWORD *)(v262 + 32) != *(_DWORD *)(v261 + 32) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"masked_store: vector mask must be same length as value";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              goto LABEL_383;
            case 0xE7u:
            case 0xE8u:
            case 0xE9u:
            case 0xEAu:
              v241 = *((_QWORD *)v3 - 4);
              if ( v241 )
              {
                if ( *(_BYTE *)v241 )
                {
                  v241 = 0;
                }
                else if ( *(_QWORD *)(v241 + 24) != *((_QWORD *)v3 + 10) )
                {
                  v241 = 0;
                }
              }
              v637.m128i_i64[0] = v241;
              v242 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              switch ( v625 )
              {
                case 0xE9u:
                  v133 = *(_QWORD *)&v3[32 * (2 - v242)];
                  v254 = *(_QWORD *)&v3[32 * (3 - v242)];
                  v255 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v242] + 8LL);
                  v256 = *(_QWORD **)(v133 + 24);
                  if ( *(_DWORD *)(v133 + 32) > 0x40u )
                    v256 = (_QWORD *)*v256;
                  v257 = *(_QWORD **)(v254 + 24);
                  if ( *(_DWORD *)(v254 + 32) > 0x40u )
                    v257 = (_QWORD *)*v257;
                  if ( *(_DWORD *)(v255 + 32) != (_QWORD)v257 * (_QWORD)v256 )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"First argument of a matrix operation does not match specified shape!";
                    v647 = 259;
                    sub_BDBF70(a1, (__int64)&v645);
                    goto LABEL_364;
                  }
                  v246 = *(_QWORD *)&v3[32 * (4 - v242)];
                  v258 = *(_QWORD **)(v246 + 24);
                  v259 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1 - v242)] + 8LL);
                  if ( *(_DWORD *)(v246 + 32) > 0x40u )
                    v258 = (_QWORD *)*v258;
                  if ( *(_DWORD *)(v259 + 32) != (_QWORD)v258 * (_QWORD)v257 )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"Second argument of a matrix operation does not match specified shape!";
                    v647 = 259;
                    sub_BDBF70(a1, (__int64)&v645);
                    goto LABEL_364;
                  }
                  v244 = *((_QWORD *)v3 + 1);
                  v253 = *(_QWORD *)(v255 + 24);
                  v243 = 0;
                  v252 = *(_QWORD *)(v259 + 24);
                  break;
                case 0xEAu:
                  v244 = *((_QWORD *)v3 + 1);
                  v252 = 0;
                  v133 = *(_QWORD *)&v3[32 * (1 - v242)];
                  v246 = *(_QWORD *)&v3[32 * (2 - v242)];
                  v243 = 0;
                  v253 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)&v3[-32 * v242] + 8LL) + 24LL);
                  break;
                case 0xE8u:
                  v243 = *(_QWORD *)&v3[32 * (2 - v242)];
                  if ( *(_BYTE *)v243 != 17 )
                    v243 = 0;
                  v252 = 0;
                  v133 = *(_QWORD *)&v3[32 * (4 - v242)];
                  v246 = *(_QWORD *)&v3[32 * (5 - v242)];
                  v244 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v242] + 8LL);
                  v253 = *(_QWORD *)(v244 + 24);
                  break;
                default:
                  v243 = *(_QWORD *)&v3[32 * (1 - v242)];
                  if ( *(_BYTE *)v243 != 17 )
                    v243 = 0;
                  v133 = *(_QWORD *)&v3[32 * (3 - v242)];
                  v244 = *((_QWORD *)v3 + 1);
                  v245 = *(_QWORD *)(v244 + 24);
                  v246 = *(_QWORD *)&v3[32 * (4 - v242)];
                  v247 = *(_BYTE *)(v245 + 8);
                  if ( v247 == 12 || v247 <= 3u )
                    goto LABEL_547;
                  v252 = 0;
                  v253 = 0;
                  goto LABEL_567;
              }
              v245 = *(_QWORD *)(v244 + 24);
              v247 = *(_BYTE *)(v245 + 8);
              if ( v247 == 12 || v247 <= 3u )
                goto LABEL_563;
LABEL_567:
              if ( v247 != 5 && (v247 & 0xFD) != 4 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"Result type must be an integer or floating-point type!";
                v647 = 259;
                sub_BED850(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
LABEL_563:
              if ( v245 != v253 && v253 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"Vector element type mismatch of the result and first operand vector!";
                v647 = 259;
                sub_BED850(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              if ( v245 != v252 && v252 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"Vector element type mismatch of the result and second operand vector!";
                v647 = 259;
                sub_BED850(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
LABEL_547:
              v248 = *(unsigned int *)(v244 + 32);
              v249 = *(_QWORD **)(v133 + 24);
              if ( *(_DWORD *)(v133 + 32) > 0x40u )
                v249 = (_QWORD *)*v249;
              v250 = *(_QWORD **)(v246 + 24);
              if ( *(_DWORD *)(v246 + 32) > 0x40u )
                v250 = (_QWORD *)*v250;
              if ( v248 != (_QWORD)v249 * (_QWORD)v250 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"Result of a matrix operation does not fit in the returned vector!";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( v243 )
              {
                v251 = *(_QWORD **)(v243 + 24);
                if ( *(_DWORD *)(v243 + 32) > 0x40u )
                  v251 = (_QWORD *)*v251;
                if ( v249 > v251 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"Stride must be greater or equal than the number of rows!";
                  v647 = 259;
                  sub_BED850(a1, (__int64)&v645, &v637);
                  goto LABEL_364;
                }
              }
              goto LABEL_383;
            case 0xEFu:
            case 0xF2u:
            case 0xF4u:
              v341 = *(_QWORD *)&v3[32 * (3LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              if ( !sub_986BA0(v341 + 24) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"element size of the element-wise atomic memory intrinsic must be a power of 2";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v342 = sub_A74840((_QWORD *)v3 + 9, 0);
              v343 = v342;
              if ( !HIBYTE(v342) )
                goto LABEL_800;
              v344 = v3 + 72;
              if ( *(_DWORD *)(v341 + 32) > 0x40u )
              {
                v588 = v342;
                v564 = *(_DWORD *)(v341 + 32);
                if ( v564 - (unsigned int)sub_C444A0(v341 + 24) > 0x40 )
                  goto LABEL_800;
                v344 = v3 + 72;
                v343 = v588;
                v345 = **(_QWORD **)(v341 + 24);
              }
              else
              {
                v345 = *(_QWORD *)(v341 + 24);
              }
              if ( 1LL << v343 >= v345 )
              {
                v346 = *((_QWORD *)v3 - 4);
                if ( !v346 || *(_BYTE *)v346 || (v133 = *((_QWORD *)v3 + 10), *(_QWORD *)(v346 + 24) != v133) )
                  BUG();
                v347 = *(_DWORD *)(v346 + 36);
                if ( v347 != 239 && v347 != 242 )
                  goto LABEL_383;
                v133 = 1;
                v348 = sub_A74840(v344, 1);
                v349 = v348;
                if ( HIBYTE(v348) )
                {
                  if ( *(_DWORD *)(v341 + 32) > 0x40u )
                  {
                    v608 = v348;
                    v589 = *(_DWORD *)(v341 + 32);
                    if ( v589 - (unsigned int)sub_C444A0(v341 + 24) > 0x40 )
                      goto LABEL_815;
                    v349 = v608;
                    v350 = **(_QWORD **)(v341 + 24);
                  }
                  else
                  {
                    v350 = *(_QWORD *)(v341 + 24);
                  }
                  if ( 1LL << v349 >= v350 )
                    goto LABEL_383;
                }
LABEL_815:
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"incorrect alignment of the source argument";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
LABEL_800:
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"incorrect alignment of the destination argument";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0x11Eu:
              v334 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v335 = *(_QWORD *)&v3[32 * (1 - v334)];
              v336 = *(_QWORD **)(v335 + 24);
              if ( *(_DWORD *)(v335 + 32) > 0x40u )
                v336 = (_QWORD *)*v336;
              if ( (unsigned __int64)v336 > 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"rw argument to llvm.prefetch must be 0-1";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v337 = *(_QWORD *)&v3[32 * (2 - v334)];
              v338 = *(_QWORD **)(v337 + 24);
              if ( *(_DWORD *)(v337 + 32) > 0x40u )
                v338 = (_QWORD *)*v338;
              if ( (unsigned __int64)v338 > 3 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"locality argument to llvm.prefetch must be 0-3";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v339 = *(_QWORD *)&v3[32 * (3 - v334)];
              v340 = *(_QWORD **)(v339 + 24);
              if ( *(_DWORD *)(v339 + 32) > 0x40u )
                v340 = (_QWORD *)*v340;
              if ( (unsigned __int64)v340 > 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"cache type argument to llvm.prefetch must be 0-1";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              goto LABEL_383;
            case 0x11Fu:
            case 0x121u:
            case 0x233u:
            case 0x236u:
              goto LABEL_453;
            case 0x12Bu:
              v320 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v133 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v320] + 8LL);
              v321 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1 - v320)] + 8LL);
              v322 = *(unsigned __int8 *)(v133 + 8);
              if ( (unsigned int)(v322 - 17) > 1 )
              {
                if ( (_BYTE)v322 == 14 )
                {
                  if ( (unsigned int)*(unsigned __int8 *)(v321 + 8) - 17 > 1 )
                    goto LABEL_764;
                  goto LABEL_760;
                }
              }
              else if ( *(_BYTE *)(**(_QWORD **)(v133 + 16) + 8LL) == 14 )
              {
                v323 = *(_BYTE *)(v321 + 8);
                if ( (unsigned int)v323 - 17 <= 1 )
                {
                  if ( (v323 == 18) != (*(_BYTE *)(v133 + 8) == 18) || *(_DWORD *)(v321 + 32) != *(_DWORD *)(v133 + 32) )
                  {
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"llvm.ptrmask intrinsic arguments must have the same number of elements";
                    v647 = 259;
                    sub_BEFC60(a1, (__int64)&v645, &v637);
                    goto LABEL_364;
                  }
LABEL_764:
                  v324 = sub_AE43F0(a1[17], v133);
                  if ( v324 != (unsigned int)sub_BCB060(v321) )
                  {
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"llvm.ptrmask intrinsic second argument bitwidth must match pointer inde"
                                                 "x type size of first argument";
                    v647 = 259;
                    sub_BEFC60(a1, (__int64)&v645, &v637);
                    goto LABEL_364;
                  }
                  goto LABEL_383;
                }
LABEL_760:
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"llvm.ptrmask intrinsic arguments must be both scalars or both vectors";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v133 = (__int64)&v645;
              v637.m128i_i64[0] = (__int64)v3;
              v645.m128i_i64[0] = (__int64)"llvm.ptrmask intrinsic first argument must be pointer or vector of pointers";
              v647 = 259;
              sub_BEFC60(a1, (__int64)&v645, &v637);
              goto LABEL_364;
            case 0x139u:
            case 0x16Au:
              v331 = *((_QWORD *)v3 + 1);
              v332 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              if ( (unsigned int)sub_BCB060(v331) <= 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"result type must be at least 2 bits wide";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              v333 = *(unsigned __int8 *)(v331 + 8);
              v133 = *(unsigned __int8 *)(v332 + 8);
              if ( (unsigned int)(v333 - 17) <= 1 != (unsigned int)(v133 - 17) <= 1 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"ucmp/scmp argument and result types must both be either vector or scalar types";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              if ( (unsigned int)(v333 - 17) <= 1
                && (*(_DWORD *)(v332 + 32) != *(_DWORD *)(v331 + 32) || ((_BYTE)v133 == 18) != ((_BYTE)v333 == 18)) )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"return type and arguments must have the same number of elements";
                v647 = 259;
                sub_BED490(a1, (__int64)&v645, v3);
                goto LABEL_364;
              }
              goto LABEL_383;
            case 0x13Au:
            case 0x13Bu:
            case 0x14Bu:
            case 0x14Cu:
            case 0x16Bu:
            case 0x16Cu:
            case 0x16Fu:
            case 0x170u:
              v325 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v326 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v325] + 8LL);
              v327 = v326;
              if ( (unsigned int)*(unsigned __int8 *)(v326 + 8) - 17 <= 1 )
                v327 = **(_QWORD **)(v326 + 16);
              if ( *(_BYTE *)(v327 + 8) != 12 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"first operand of [us][mul|div]_fix[_sat] must be an int type or vector of ints";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              v328 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1 - v325)] + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v328 + 8) - 17 <= 1 )
                v328 = **(_QWORD **)(v328 + 16);
              if ( *(_BYTE *)(v328 + 8) == 12 )
              {
                v329 = *(_QWORD *)&v3[32 * (2 - v325)];
                if ( *(_BYTE *)(*(_QWORD *)(v329 + 8) + 8LL) == 12 )
                {
                  if ( *(_DWORD *)(v329 + 32) > 0x20u )
                  {
                    v133 = (__int64)&v645;
                    v645.m128i_i64[0] = (__int64)"third operand of [us][mul|div]_fix[_sat] must fit within 32 bits";
                    v647 = 259;
                    sub_BDBF70(a1, (__int64)&v645);
                  }
                  else
                  {
                    v133 = v625;
                    v330 = sub_BCB060(v326);
                    if ( v625 - 314 <= 1 || v625 - 331 <= 1 )
                    {
                      if ( *(_QWORD *)(v329 + 24) < (unsigned __int64)v330 )
                        goto LABEL_383;
                      v133 = (__int64)&v645;
                      v645.m128i_i64[0] = (__int64)"the scale of s[mul|div]_fix[_sat] must be less than the width of the operands";
                      v647 = 259;
                      sub_BDBF70(a1, (__int64)&v645);
                    }
                    else
                    {
                      if ( *(_QWORD *)(v329 + 24) <= (unsigned __int64)v330 )
                        goto LABEL_383;
                      v133 = (__int64)&v645;
                      v645.m128i_i64[0] = (__int64)"the scale of u[mul|div]_fix[_sat] must be less than or equal to the w"
                                                   "idth of the operands";
                      v647 = 259;
                      sub_BDBF70(a1, (__int64)&v645);
                    }
                  }
                }
                else
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"third operand of [us][mul|div]_fix[_sat] must be an int type";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                }
              }
              else
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"second operand of [us][mul|div]_fix[_sat] must be an int type or vector of ints";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
              }
              goto LABEL_364;
            case 0x155u:
              if ( *sub_BD3990(*(unsigned __int8 **)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))], v133) == 60 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"llvm.stackprotector parameter #2 must resolve to an alloca.";
              v647 = 259;
              sub_BED490(a1, (__int64)&v645, v3);
              goto LABEL_364;
            case 0x159u:
              v318 = *((_QWORD *)v3 + 1);
              v319 = *(unsigned __int8 *)(v318 + 8);
              if ( (v319 == 17 || v319 == 18)
                && *(_BYTE *)(**(_QWORD **)(v318 + 16) + 8LL) == 12
                && (unsigned int)sub_BCB060(v318) > 7 )
              {
                goto LABEL_383;
              }
              v133 = (__int64)&v645;
              v637.m128i_i64[0] = (__int64)v3;
              v645.m128i_i64[0] = (__int64)"stepvector only supported for vectors of integers with a bitwidth of at least 8.";
              v647 = 259;
              sub_BEFC60(a1, (__int64)&v645, &v637);
              goto LABEL_364;
            case 0x161u:
              v361 = *(_BYTE **)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
              if ( *v361 > 3u )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.threadlocal.address first argument must be a GlobalValue";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
              }
              else
              {
                if ( (v361[33] & 0x1C) != 0 )
                  goto LABEL_383;
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"llvm.threadlocal.address operand isThreadLocal() must be true";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
              }
              goto LABEL_364;
            case 0x177u:
              if ( *(_DWORD *)(*(_QWORD *)(sub_B43CB0((__int64)v3) + 24) + 8LL) >> 8 )
                goto LABEL_383;
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"va_start called in a non-varargs function";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x17Du:
              v362 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v363 = *(_QWORD *)&v3[32 * (1 - v362)];
              v364 = *(_QWORD **)(v363 + 24);
              if ( *(_DWORD *)(v363 + 32) > 0x40u )
                v364 = (_QWORD *)*v364;
              v365 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v362] + 8LL);
              v366 = *((_QWORD *)v3 + 1);
              if ( *(_QWORD *)(v366 + 24) != *(_QWORD *)(v365 + 24) )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"vector_extract result must have the same element type as the input vector.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v133 = *(unsigned int *)(v366 + 32);
              if ( (unsigned int)v364 % (unsigned int)v133 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"vector_extract index must be a constant multiple of the result type's known"
                                             " minimum vector length.";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( (*(_BYTE *)(v365 + 8) == 18) == (*(_BYTE *)(v366 + 8) == 18) )
              {
                v367 = *(_DWORD *)(v365 + 32);
                if ( (unsigned int)v364 >= v367 || v367 < (int)v133 + (int)v364 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"vector_extract would overrun.";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                  goto LABEL_364;
                }
              }
              goto LABEL_383;
            case 0x17Eu:
              v351 = *((_DWORD *)v3 + 1) & 0x7FFFFFF;
              v352 = *(_QWORD *)&v3[32 * (2 - v351)];
              v353 = *(_QWORD **)(v352 + 24);
              if ( *(_DWORD *)(v352 + 32) > 0x40u )
                v353 = (_QWORD *)*v353;
              v354 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1 - v351)] + 8LL);
              v355 = *(_QWORD *)(*(_QWORD *)&v3[-32 * v351] + 8LL);
              if ( *(_QWORD *)(v355 + 24) != *(_QWORD *)(v354 + 24) )
              {
                v133 = (__int64)&v645;
                v637.m128i_i64[0] = (__int64)v3;
                v645.m128i_i64[0] = (__int64)"vector_insert parameters must have the same element type.";
                v647 = 259;
                sub_BEFC60(a1, (__int64)&v645, &v637);
                goto LABEL_364;
              }
              v133 = *(unsigned int *)(v354 + 32);
              if ( (unsigned int)v353 % (unsigned int)v133 )
              {
                v133 = (__int64)&v645;
                v645.m128i_i64[0] = (__int64)"vector_insert index must be a constant multiple of the subvector's known mi"
                                             "nimum vector length.";
                v647 = 259;
                sub_BDBF70(a1, (__int64)&v645);
                goto LABEL_364;
              }
              if ( (*(_BYTE *)(v355 + 8) == 18) == (*(_BYTE *)(v354 + 8) == 18) )
              {
                v356 = *(_DWORD *)(v355 + 32);
                if ( (unsigned int)v353 >= v356 || v356 < (int)v133 + (int)v353 )
                {
                  v133 = (__int64)&v645;
                  v645.m128i_i64[0] = (__int64)"subvector operand of vector_insert would overrun the vector being inserted into.";
                  v647 = 259;
                  sub_BDBF70(a1, (__int64)&v645);
                  goto LABEL_364;
                }
              }
              goto LABEL_383;
            case 0x183u:
            case 0x184u:
            case 0x18Bu:
            case 0x18Cu:
            case 0x18Du:
            case 0x18Eu:
            case 0x18Fu:
            case 0x190u:
            case 0x191u:
              v358 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              v359 = *(unsigned __int8 *)(v358 + 8);
              if ( (unsigned int)(v359 - 17) > 1
                || *(_BYTE *)(**(_QWORD **)(v358 + 16) + 8LL) != 12
                || (unsigned __int8)(v359 - 17) > 1u )
              {
                goto LABEL_835;
              }
              goto LABEL_383;
            case 0x185u:
            case 0x18Au:
              v357 = *(_QWORD *)(*(_QWORD *)&v3[32 * (1LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))] + 8LL);
              if ( !(unsigned __int8)sub_BDB700(v357) || (unsigned int)*(unsigned __int8 *)(v357 + 8) - 17 > 1 )
                goto LABEL_835;
              goto LABEL_383;
            case 0x186u:
            case 0x188u:
              v360 = *(_QWORD *)(*(_QWORD *)&v3[-32 * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)] + 8LL);
              if ( (unsigned __int8)sub_BDB700(v360) && (unsigned int)*(unsigned __int8 *)(v360 + 8) - 17 <= 1 )
                goto LABEL_383;
LABEL_835:
              v133 = (__int64)&v645;
              v645.m128i_i64[0] = (__int64)"Intrinsic has incorrect argument type!";
              v647 = 259;
              sub_BDBF70(a1, (__int64)&v645);
              goto LABEL_364;
            case 0x193u:
              v169 = *(_QWORD *)&v3[32 * (2LL - (*((_DWORD *)v3 + 1) & 0x7FFFFFF))];
              v170 = *(__int64 **)(v169 + 24);
              v133 = *(unsigned int *)(v169 + 32);
              v171 = *(unsigned int *)(*((_QWORD *)v3 + 1) + 32LL);
              v172 = *((_QWORD *)v3 + 5);
              if ( (unsigned int)v133 > 0x40 )
              {
                v173 = *v170;
              }
              else
              {
                if ( !(_DWORD)v133 )
                {
                  v173 = 0;
                  if ( !v172 )
                    goto LABEL_382;
                  v174 = *(_QWORD *)(v172 + 72);
                  v173 = 0;
                  if ( !v174 )
                    goto LABEL_382;
LABEL_379:
                  v133 = 96;
                  v637.m128i_i64[0] = *(_QWORD *)(v174 + 120);
                  if ( (unsigned __int8)sub_A73ED0(&v637, 96) )
                  {
                    v645.m128i_i64[0] = sub_A74680(&v637);
                    v171 *= (unsigned int)sub_A73930(v645.m128i_i64);
                  }
LABEL_381:
                  if ( v173 < 0 )
                  {
                    if ( -v173 <= v171 )
                      goto LABEL_383;
LABEL_431:
                    v133 = (__int64)&v645;
                    v637.m128i_i64[0] = (__int64)v3;
                    v645.m128i_i64[0] = (__int64)"The splice index exceeds the range [-VL, VL-1] where VL is the known mi"
                                                 "nimum number of elements in the vector. For scalable vectors the minimu"
                                                 "m number of elements is determined from vscale_range.";
                    v647 = 259;
                    sub_BEFC60(a1, (__int64)&v645, &v637);
                    goto LABEL_364;
                  }
LABEL_382:
                  if ( v173 < (unsigned __int64)v171 )
                    goto LABEL_383;
                  goto LABEL_431;
                }
                v173 = (__int64)((_QWORD)v170 << (64 - (unsigned __int8)v133)) >> (64 - (unsigned __int8)v133);
              }
              if ( !v172 )
                goto LABEL_381;
              v174 = *(_QWORD *)(v172 + 72);
              if ( !v174 )
                goto LABEL_381;
              goto LABEL_379;
            default:
              goto LABEL_383;
          }
        }
LABEL_1459:
        BUG();
      }
    }
    v159 = 0;
    goto LABEL_341;
  }
  if ( !(unsigned __int8)sub_B6B160(1u, (__int64 *)&v632) )
    goto LABEL_264;
  HIBYTE(v647) = 1;
  v458 = "Intrinsic was not defined with variable arguments!";
LABEL_1161:
  v133 = (__int64)&v645;
  v645.m128i_i64[0] = (__int64)v458;
  LOBYTE(v647) = 3;
  sub_BED850(a1, (__int64)&v645, &v628);
LABEL_365:
  if ( (_BYTE *)v641.m128i_i64[0] != v642 )
    _libc_free(v641.m128i_i64[0], v133);
  if ( (_BYTE *)v643.m128i_i64[0] != v644 )
    _libc_free(v643.m128i_i64[0], v133);
LABEL_205:
  v114 = sub_A172A0((__int64)v3);
  if ( !v114 )
  {
    v623 = 0;
LABEL_278:
    v140 = *((_QWORD *)v3 - 4);
    if ( v140 && !*(_BYTE *)v140 && *(_QWORD *)(v140 + 24) == *((_QWORD *)v3 + 10) && v623 )
    {
      HIBYTE(v647) = 1;
      v48 = "Direct call cannot have a ptrauth bundle";
      goto LABEL_75;
    }
    v141 = sub_B43CB0((__int64)v3);
    v142 = sub_B92180(v141);
    v143 = *((_QWORD *)v3 - 4);
    if ( v142 && !*(_BYTE *)v143 )
    {
      if ( *(_QWORD *)(v143 + 24) != *((_QWORD *)v3 + 10) )
      {
LABEL_285:
        sub_E352E0(a1 + 259, v3);
        sub_BF6FE0((__int64)a1, (__int64)v3);
        return;
      }
      if ( !(unsigned __int8)sub_B2F6B0(*((_QWORD *)v3 - 4)) )
      {
        v144 = *((_QWORD *)v3 - 4);
        if ( v144 )
        {
          if ( *(_BYTE *)v144 )
          {
            v144 = 0;
          }
          else if ( *(_QWORD *)(v144 + 24) != *((_QWORD *)v3 + 10) )
          {
            v144 = 0;
          }
        }
        if ( !sub_B2FC80(v144) )
        {
          v145 = *((_QWORD *)v3 - 4);
          if ( v145 )
          {
            if ( *(_BYTE *)v145 )
            {
              v145 = 0;
            }
            else if ( *(_QWORD *)(v145 + 24) != *((_QWORD *)v3 + 10) )
            {
              v145 = 0;
            }
          }
          if ( sub_B92180(v145) && !*((_QWORD *)v3 + 6) )
          {
            v645.m128i_i64[0] = (__int64)"inlinable function call in a function with debug info must have a !dbg location";
            v647 = 259;
            sub_BEE9C0(a1, (__int64)&v645, v3);
            return;
          }
        }
      }
      v143 = *((_QWORD *)v3 - 4);
    }
    if ( *(_BYTE *)v143 == 25 )
      sub_BDD0F0(a1, (__int64)v3);
    goto LABEL_285;
  }
  v556 = 0;
  v115 = 0;
  v116 = 0;
  v623 = 0;
  v550 = 16LL * v114;
  v558 = 0;
  v562 = 0;
  v573 = 0;
  v577 = 0;
  v581 = 0;
  v597 = 0;
  while ( 1 )
  {
    v117 = 0;
    if ( (v3[7] & 0x80u) != 0 )
      v117 = sub_BD2BC0((__int64)v3);
    v118 = (unsigned int *)(v115 + v117);
    v119 = *(_DWORD *)(*(_QWORD *)v118 + 8LL);
    if ( !v119 )
    {
      if ( v597 )
      {
        HIBYTE(v647) = 1;
        v48 = "Multiple deopt operand bundles";
        goto LABEL_75;
      }
      v597 = 1;
      goto LABEL_209;
    }
    if ( v119 == 2 )
    {
      if ( v577 )
      {
        HIBYTE(v647) = 1;
        v48 = "Multiple gc-transition operand bundles";
        goto LABEL_75;
      }
      v577 = 1;
      goto LABEL_209;
    }
    v120 = 32LL * v118[2];
    v121 = (32LL * v118[3] - v120) >> 5;
    v122 = (__int64 *)&v3[v120 - 32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
    switch ( v119 )
    {
      case 1:
        if ( v581 )
        {
          HIBYTE(v647) = 1;
          v48 = "Multiple funclet operand bundles";
          goto LABEL_75;
        }
        if ( v121 != 1 )
        {
          HIBYTE(v647) = 1;
          v48 = "Expected exactly one funclet bundle operand";
          goto LABEL_75;
        }
        if ( (unsigned __int8)(*(_BYTE *)*v122 - 80) > 1u )
        {
          HIBYTE(v647) = 1;
          v48 = "Funclet bundle operands should correspond to a FuncletPadInst";
          goto LABEL_75;
        }
        v581 = 1;
        goto LABEL_209;
      case 3:
        if ( v573 )
        {
          HIBYTE(v647) = 1;
          v48 = "Multiple CFGuardTarget operand bundles";
          goto LABEL_75;
        }
        if ( v121 != 1 )
        {
          HIBYTE(v647) = 1;
          v48 = "Expected exactly one cfguardtarget bundle operand";
          goto LABEL_75;
        }
        v573 = 1;
        goto LABEL_209;
      case 7:
        if ( v623 )
        {
          HIBYTE(v647) = 1;
          v48 = "Multiple ptrauth operand bundles";
          goto LABEL_75;
        }
        if ( v121 != 2 )
        {
          HIBYTE(v647) = 1;
          v48 = "Expected exactly two ptrauth bundle operands";
          goto LABEL_75;
        }
        v624 = &v3[v120 - 32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
        if ( *(_BYTE *)*v122 != 17 || !sub_BCAC40(*(_QWORD *)(*v122 + 8), 32) )
        {
          HIBYTE(v647) = 1;
          v48 = "Ptrauth bundle key operand must be an i32 constant";
          goto LABEL_75;
        }
        v623 = sub_BCAC40(*(_QWORD *)(*((_QWORD *)v624 + 4) + 8LL), 64);
        if ( !v623 )
        {
          HIBYTE(v647) = 1;
          v48 = "Ptrauth bundle discriminator operand must be an i64";
          goto LABEL_75;
        }
        goto LABEL_209;
      case 8:
        if ( v556 )
        {
          HIBYTE(v647) = 1;
          v48 = "Multiple kcfi operand bundles";
          goto LABEL_75;
        }
        if ( v121 != 1 )
        {
          HIBYTE(v647) = 1;
          v48 = "Expected exactly one kcfi bundle operand";
          goto LABEL_75;
        }
        if ( *(_BYTE *)*v122 != 17 || !(v556 = sub_BCAC40(*(_QWORD *)(*v122 + 8), 32)) )
        {
          HIBYTE(v647) = 1;
          v48 = "Kcfi bundle operand must be an i32 constant";
          goto LABEL_75;
        }
        goto LABEL_209;
    }
    if ( v119 == 4 )
      break;
    if ( v119 == 5 )
    {
      if ( v558 )
      {
        HIBYTE(v647) = 1;
        v48 = "Multiple gc-live operand bundles";
        goto LABEL_75;
      }
      v558 = 1;
    }
    else if ( v119 == 6 )
    {
      if ( v116 )
      {
        HIBYTE(v647) = 1;
        v48 = "Multiple \"clang.arc.attachedcall\" operand bundles";
        goto LABEL_75;
      }
      v123 = *((_QWORD *)v3 + 10);
      if ( *(_BYTE *)(**(_QWORD **)(v123 + 16) + 8LL) == 14 )
        goto LABEL_1473;
      v546 = (32LL * v118[3] - v120) >> 5;
      v548 = (__int64 *)&v3[v120 - 32LL * (*((_DWORD *)v3 + 1) & 0x7FFFFFF)];
      v124 = sub_A73ED0((_QWORD *)v3 + 9, 36);
      v122 = v548;
      v121 = v546;
      if ( !v124 )
      {
        v125 = sub_B49560((__int64)v3, 36);
        v122 = v548;
        v121 = v546;
        if ( !v125 )
          goto LABEL_225;
      }
      if ( *(_BYTE *)(**(_QWORD **)(v123 + 16) + 8LL) == 7 )
      {
LABEL_1473:
        if ( v121 != 1 || (v146 = *v122, *(_BYTE *)*v122) )
        {
          v150 = *a1;
          v645.m128i_i64[0] = (__int64)"operand bundle \"clang.arc.attachedcall\" requires one function as an argument";
          v647 = 259;
          if ( v150 )
          {
            sub_CA0E80(&v645, v150);
            v151 = *(_BYTE **)(v150 + 32);
            if ( (unsigned __int64)v151 >= *(_QWORD *)(v150 + 24) )
            {
              sub_CB5D20(v150, 10);
            }
            else
            {
              *(_QWORD *)(v150 + 32) = v151 + 1;
              *v151 = 10;
            }
            v150 = *a1;
          }
          *((_BYTE *)a1 + 152) = 1;
          if ( v150 )
          {
            if ( *v3 <= 0x1Cu )
            {
              sub_A5C020(v3, v150, 1, (__int64)(a1 + 2));
              v152 = *a1;
              v153 = *(_BYTE **)(*a1 + 32);
              if ( (unsigned __int64)v153 >= *(_QWORD *)(*a1 + 24) )
                goto LABEL_332;
LABEL_326:
              *(_QWORD *)(v152 + 32) = v153 + 1;
              *v153 = 10;
            }
            else
            {
              sub_A693B0((__int64)v3, (_BYTE *)v150, (__int64)(a1 + 2), 0);
              v152 = *a1;
              v153 = *(_BYTE **)(*a1 + 32);
              if ( (unsigned __int64)v153 < *(_QWORD *)(*a1 + 24) )
                goto LABEL_326;
LABEL_332:
              sub_CB5D20(v152, 10);
            }
          }
LABEL_313:
          v116 = 1;
          goto LABEL_209;
        }
        v147 = *(_DWORD *)(v146 + 36);
        if ( v147 )
        {
          v116 = v147 != 281 && v147 != 272;
          if ( v116 )
          {
            v645.m128i_i64[0] = (__int64)"invalid function argument";
            v647 = 259;
            sub_BED490(a1, (__int64)&v645, v3);
            goto LABEL_209;
          }
          goto LABEL_313;
        }
        v149 = sub_BD5D20(v146);
        if ( v148 == 34 )
        {
          if ( !memcmp(v149, "objc_retainAutoreleasedReturnValue", 0x22u) )
            goto LABEL_313;
        }
        else if ( v148 == 39 && !memcmp(v149, "objc_unsafeClaimAutoreleasedReturnValue", 0x27u) )
        {
          goto LABEL_313;
        }
        HIBYTE(v647) = 1;
        v126 = "invalid function argument";
      }
      else
      {
LABEL_225:
        HIBYTE(v647) = 1;
        v126 = "a call with operand bundle \"clang.arc.attachedcall\" must call a function returning a pointer or a non-r"
               "eturning function that has a void return type";
      }
      v645.m128i_i64[0] = (__int64)v126;
      LOBYTE(v647) = 3;
      v116 = 1;
      sub_BED490(a1, (__int64)&v645, v3);
    }
LABEL_209:
    v115 += 16;
    if ( v115 == v550 )
      goto LABEL_278;
  }
  if ( !v562 )
  {
    if ( v121 != 1 )
    {
      HIBYTE(v647) = 1;
      v48 = "Expected exactly one preallocated bundle operand";
      goto LABEL_75;
    }
    v563 = *v122;
    v139 = sub_988010(*v122);
    if ( !v563 || !v139 || (unsigned int)sub_987FE0(v563) != 17 )
    {
      HIBYTE(v647) = 1;
      v48 = "\"preallocated\" argument must be a token from llvm.call.preallocated.setup";
      goto LABEL_75;
    }
    v562 = 1;
    goto LABEL_209;
  }
  HIBYTE(v647) = 1;
  v48 = "Multiple preallocated operand bundles";
LABEL_75:
  v645.m128i_i64[0] = (__int64)v48;
  LOBYTE(v647) = 3;
  sub_BED490(a1, (__int64)&v645, v3);
}
