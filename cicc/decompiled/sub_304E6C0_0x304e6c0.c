// Function: sub_304E6C0
// Address: 0x304e6c0
//
__int64 __fastcall sub_304E6C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v8; // r14
  __int64 *v9; // rax
  __int64 v10; // rsi
  __int64 v11; // r12
  __int64 v12; // r13
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rsi
  bool v16; // cc
  _QWORD *v17; // rdx
  int v18; // eax
  __int64 v19; // r12
  __int64 v21; // rdx
  unsigned int v22; // eax
  __int64 v23; // rdx
  __int64 v24; // r9
  __int64 v25; // rax
  _QWORD *v26; // r13
  __int64 v27; // r8
  __int64 v28; // rax
  __int64 v29; // r12
  bool v30; // r13
  __int64 v31; // rax
  __int16 v32; // dx
  __int64 v33; // rax
  bool v34; // al
  char v35; // cl
  int v36; // r12d
  __int64 v37; // rax
  unsigned __int64 v38; // rdx
  __m128i *v39; // rax
  __int64 *v40; // rax
  __int64 v41; // r12
  unsigned __int64 v42; // r13
  __int64 v43; // rax
  unsigned __int16 v44; // cx
  __int64 v45; // rax
  __int64 v46; // rdx
  __int64 v47; // rcx
  __int64 v48; // rax
  int v49; // edx
  unsigned int v50; // eax
  __int64 v51; // r14
  __m128i *v52; // rax
  __int128 v53; // rax
  int v54; // r9d
  __int64 v55; // rax
  __int64 v56; // rdx
  __int64 v57; // r9
  unsigned __int64 v58; // rdx
  unsigned int v59; // edx
  __int64 v60; // r8
  int v61; // edx
  __int64 v62; // rax
  unsigned __int64 v63; // rdx
  __m128i *v64; // rax
  __int64 *v65; // rax
  __int64 v66; // rsi
  __int64 v67; // r12
  unsigned __int64 v68; // r13
  __int64 v69; // rax
  unsigned __int16 v70; // cx
  __int64 v71; // rax
  __int64 v72; // rdx
  __int64 v73; // rcx
  __int64 v74; // rax
  int v75; // edx
  unsigned int v76; // eax
  __int64 v77; // r14
  __m128i *v78; // rax
  __int128 v79; // rax
  int v80; // r9d
  __int64 v81; // rax
  __int64 v82; // rdx
  unsigned __int64 v83; // rdx
  __int64 v84; // rdx
  __int64 v85; // r8
  __m128i v86; // xmm4
  __int64 v87; // rax
  __int64 v88; // rdx
  __int64 v89; // r13
  __int64 v90; // r12
  __int128 v91; // rax
  int v92; // r9d
  __m128i v93; // rax
  __int128 v94; // rax
  int v95; // r9d
  __int64 v96; // rax
  __int64 v97; // r8
  __int64 v98; // r9
  __m128i *v99; // r10
  __int64 v100; // r12
  __int64 v101; // rax
  __int64 v102; // rdx
  __int64 v103; // r13
  unsigned __int64 v104; // rdx
  __int64 v105; // rax
  __m128i *v106; // rax
  __int64 v107; // rsi
  __int64 v108; // rdi
  __int64 v109; // r9
  int v110; // r8d
  int v111; // ecx
  __int64 v112; // rax
  __int64 v113; // r10
  __int64 v114; // rbx
  int v115; // r12d
  __m128i v116; // xmm0
  __m128i v117; // xmm0
  __m128i *v118; // rdx
  unsigned int v119; // ebx
  __int64 v120; // rax
  __int64 v121; // rax
  __int16 v122; // dx
  __int64 v123; // rax
  bool v124; // al
  __m128i *v125; // r10
  unsigned int v126; // eax
  int v127; // r13d
  __int64 v128; // rbx
  int v129; // eax
  int v130; // edx
  __int64 v131; // r8
  __int64 v132; // rax
  __int64 v133; // rdx
  __int64 v134; // r9
  unsigned __int64 v135; // rdx
  __m128i *v136; // rax
  __int64 v137; // rax
  __int64 v138; // rdx
  __int64 v139; // rcx
  __int64 v140; // r9
  __int64 v141; // r8
  _BYTE *v142; // rax
  int v143; // r9d
  __int64 v144; // rax
  __int64 *v145; // r11
  __int64 v146; // rsi
  __int64 v147; // r13
  int v148; // r12d
  __int64 v149; // rbx
  __int64 v150; // rax
  __int64 v151; // rax
  unsigned int v152; // edx
  _BYTE *v153; // rax
  int v154; // eax
  int v155; // edx
  int v156; // r9d
  __int64 v157; // rax
  __int64 v158; // rax
  __int64 v159; // rdx
  __int64 v160; // rdx
  __m128i *v161; // rdi
  __int64 v162; // rsi
  __int64 v163; // rdi
  __int64 v164; // rax
  __m128i v165; // xmm0
  unsigned __int64 v166; // rdx
  __int64 v167; // r13
  __int64 v168; // r12
  int v169; // eax
  int v170; // edx
  unsigned int v171; // eax
  __int128 v172; // [rsp-30h] [rbp-330h]
  __int128 v173; // [rsp-20h] [rbp-320h]
  __int128 v174; // [rsp-20h] [rbp-320h]
  __int128 v175; // [rsp-20h] [rbp-320h]
  __int128 v176; // [rsp-10h] [rbp-310h]
  __int128 v177; // [rsp-10h] [rbp-310h]
  __int128 v178; // [rsp-10h] [rbp-310h]
  __int64 v179; // [rsp+0h] [rbp-300h]
  __int64 v180; // [rsp+0h] [rbp-300h]
  __int64 v181; // [rsp+8h] [rbp-2F8h]
  __int64 v182; // [rsp+8h] [rbp-2F8h]
  __int64 v183; // [rsp+18h] [rbp-2E8h]
  __int64 v184; // [rsp+20h] [rbp-2E0h]
  __int64 v185; // [rsp+20h] [rbp-2E0h]
  __int64 v186; // [rsp+28h] [rbp-2D8h]
  int v187; // [rsp+28h] [rbp-2D8h]
  __int64 v188; // [rsp+30h] [rbp-2D0h]
  int v189; // [rsp+30h] [rbp-2D0h]
  __int64 v190; // [rsp+38h] [rbp-2C8h]
  __int64 v191; // [rsp+38h] [rbp-2C8h]
  __int64 v192; // [rsp+38h] [rbp-2C8h]
  __int16 v193; // [rsp+3Ah] [rbp-2C6h]
  __int64 v195; // [rsp+40h] [rbp-2C0h]
  __int64 v196; // [rsp+40h] [rbp-2C0h]
  __int64 v197; // [rsp+40h] [rbp-2C0h]
  __int64 v198; // [rsp+40h] [rbp-2C0h]
  __int64 v199; // [rsp+40h] [rbp-2C0h]
  __int64 v200; // [rsp+48h] [rbp-2B8h]
  __int64 v201; // [rsp+48h] [rbp-2B8h]
  __m128i v202; // [rsp+50h] [rbp-2B0h] BYREF
  __int64 v203; // [rsp+60h] [rbp-2A0h]
  __int64 v204; // [rsp+68h] [rbp-298h]
  __int64 v205; // [rsp+70h] [rbp-290h] BYREF
  int v206; // [rsp+78h] [rbp-288h]
  __int64 v207; // [rsp+80h] [rbp-280h] BYREF
  int v208; // [rsp+88h] [rbp-278h]
  __m128i v209; // [rsp+90h] [rbp-270h] BYREF
  __m128i v210; // [rsp+A0h] [rbp-260h]
  __m128i v211; // [rsp+B0h] [rbp-250h]
  __m128i *v212; // [rsp+C0h] [rbp-240h] BYREF
  __int64 v213; // [rsp+C8h] [rbp-238h]
  __m128i v214; // [rsp+D0h] [rbp-230h] BYREF
  __m128i v215; // [rsp+E0h] [rbp-220h]
  __m128i v216; // [rsp+F0h] [rbp-210h]

  v6 = a3;
  v8 = a2;
  v9 = *(__int64 **)(a2 + 40);
  v10 = *(_QWORD *)(a2 + 80);
  v11 = *v9;
  v12 = v9[1];
  v205 = v10;
  v13 = v9[5];
  if ( v10 )
  {
    v202.m128i_i64[0] = v9[5];
    sub_B96E90((__int64)&v205, v10, 1);
    v6 = a3;
    v13 = v202.m128i_i64[0];
  }
  v14 = *(_QWORD *)(v13 + 96);
  v15 = *(unsigned int *)(v8 + 72);
  v16 = *(_DWORD *)(v14 + 32) <= 0x40u;
  v17 = *(_QWORD **)(v14 + 24);
  v206 = *(_DWORD *)(v8 + 72);
  if ( !v16 )
    v17 = (_QWORD *)*v17;
  v18 = (int)v17;
  if ( (unsigned int)v17 > 0x24A6 )
  {
    if ( (_DWORD)v17 == 9556 )
    {
      v142 = sub_C94E20((__int64)qword_4F86410);
      if ( v142 )
        LOBYTE(v142) = *v142;
      else
        v142 = (_BYTE *)LOBYTE(qword_4F86410[2]);
      if ( !(_BYTE)v142 )
        goto LABEL_11;
      v144 = *(_QWORD *)(v8 + 40);
      v145 = &v205;
      v146 = *(_QWORD *)(v144 + 80);
      v147 = *(_QWORD *)v144;
      v148 = *(_DWORD *)(v144 + 8);
      v149 = *(_QWORD *)(v144 + 88);
      v150 = *(unsigned int *)(v144 + 88);
      if ( *(_WORD *)(*(_QWORD *)(v146 + 48) + 16 * v150) == 8 )
      {
        v202.m128i_i64[0] = (__int64)&v205;
        v151 = sub_33FB310(a4, v146, v149, &v205, 7, 0);
        LODWORD(v145) = (unsigned int)&v205;
        v146 = v151;
        v150 = v152;
      }
      v214.m128i_i64[0] = v146;
      *((_QWORD *)&v177 + 1) = 2;
      *(_QWORD *)&v177 = &v212;
      v212 = (__m128i *)v147;
      LODWORD(v213) = v148;
      v214.m128i_i64[1] = v150 | v149 & 0xFFFFFFFF00000000LL;
      v19 = sub_33FC220(a4, 542, (_DWORD)v145, 1, 0, v143, v177);
      goto LABEL_12;
    }
    if ( (unsigned int)v17 <= 0x2554 )
    {
      if ( (unsigned int)v17 > 0x2528 )
      {
        if ( (((_DWORD)v17 - 9549) & 0xFFFFFFFB) != 0 )
          goto LABEL_11;
LABEL_36:
        v19 = sub_304D410(a1, v8, a4);
        goto LABEL_12;
      }
      if ( (unsigned int)v17 <= 0x2507 )
        goto LABEL_11;
      v23 = 0x100000401LL;
      if ( !_bittest64(&v23, (unsigned int)(v18 - 9480)) )
        goto LABEL_11;
      v19 = sub_30478C0(a1, v8, v6, a4);
      goto LABEL_12;
    }
    if ( (_DWORD)v17 == 9557 )
    {
      v153 = sub_C94E20((__int64)qword_4F86410);
      if ( v153 )
        LOBYTE(v153) = *v153;
      else
        v153 = (_BYTE *)LOBYTE(qword_4F86410[2]);
      if ( !(_BYTE)v153 )
        goto LABEL_11;
      v154 = sub_33E5110(a4, 7, 0, 1, 0);
      *((_QWORD *)&v178 + 1) = v12;
      *(_QWORD *)&v178 = v11;
      v157 = sub_3411EF0(a4, 543, (unsigned int)&v205, v154, v155, v156, v178);
      v19 = v157;
      if ( **(_WORD **)(v8 + 48) == 8 )
      {
        v158 = sub_33FB310(a4, v157, 0, &v205, 8, 0);
        v213 = v159;
        v214.m128i_i64[0] = v19;
        v212 = (__m128i *)v158;
        v214.m128i_i32[2] = 1;
        v203 = sub_3411660(a4, &v212, 2, &v205);
        v19 = v203;
        v204 = v160;
      }
      goto LABEL_12;
    }
    if ( (unsigned int)((_DWORD)v17 - 10299) > 9 )
      goto LABEL_11;
    v21 = *(_QWORD *)(*(_QWORD *)(a4 + 40) + 16LL);
    v22 = *(_DWORD *)(v21 + 340);
    if ( v22 > 0x408 )
    {
      if ( v22 - 1101 > 1 )
        goto LABEL_30;
    }
    else if ( v22 <= 0x3E8 || ((1LL << ((unsigned __int8)v22 + 23)) & 0xC0000C03) == 0 )
    {
      goto LABEL_30;
    }
    v59 = *(_DWORD *)(v21 + 336);
    if ( (__ROR4__(-858993459 * v22 + 1717986918, 1) > 0x19999999u || v59 <= 0x57) && v59 <= 0x55 )
LABEL_30:
      sub_C64ED0(
        "tcgen05.mma supported only on arch-conditional or family-conditional variants from SM100 onwards.",
        1u);
    v60 = *(_QWORD *)(v8 + 80);
    v207 = v60;
    if ( v60 )
    {
      sub_B96E90((__int64)&v207, v60, 1);
      LODWORD(v15) = *(_DWORD *)(v8 + 72);
    }
    v61 = *(_DWORD *)(v8 + 64);
    v208 = v15;
    v212 = &v214;
    v213 = 0x2000000000LL;
    if ( !v61 )
    {
      v161 = &v214;
      v162 = 0;
      goto LABEL_140;
    }
    v202.m128i_i64[0] = 0;
    v183 = v8;
    while ( 1 )
    {
      v65 = (__int64 *)(*(_QWORD *)(v183 + 40) + 40 * v202.m128i_i64[0]);
      v66 = *v65;
      v67 = *v65;
      v68 = v65[1];
      v196 = *v65;
      v191 = *((unsigned int *)v65 + 2);
      v69 = *(_QWORD *)(*v65 + 48) + 16 * v191;
      v70 = *(_WORD *)v69;
      v71 = *(_QWORD *)(v69 + 8);
      v209.m128i_i16[0] = v70;
      v209.m128i_i64[1] = v71;
      if ( v70 )
        break;
      if ( !sub_30070B0((__int64)&v209) )
      {
LABEL_80:
        v62 = (unsigned int)v213;
        v63 = (unsigned int)v213 + 1LL;
        if ( v63 > HIDWORD(v213) )
        {
          sub_C8D5F0((__int64)&v212, &v214, v63, 0x10u, v60, a6);
          v62 = (unsigned int)v213;
        }
        v64 = &v212[v62];
        v64->m128i_i64[0] = v67;
        v64->m128i_i64[1] = v68;
        LODWORD(v213) = v213 + 1;
        goto LABEL_83;
      }
      v74 = sub_3009970((__int64)&v209, v66, v72, v73, v60);
      v70 = v209.m128i_i16[0];
      v188 = v74;
      v187 = v75;
      if ( v209.m128i_i16[0] )
        goto LABEL_146;
      if ( !sub_3007100((__int64)&v209) )
        goto LABEL_88;
LABEL_153:
      sub_CA17B0(
        "Possible incorrect use of EVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use EVT"
        "::getVectorElementCount() instead");
      if ( !v209.m128i_i16[0] )
      {
LABEL_88:
        v76 = sub_3007130((__int64)&v209, v66);
        goto LABEL_89;
      }
      if ( (unsigned __int16)(v209.m128i_i16[0] - 176) <= 0x34u )
        sub_CA17B0(
          "Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use M"
          "VT::getVectorElementCount() instead");
LABEL_147:
      v76 = word_4456340[v209.m128i_u16[0] - 1];
LABEL_89:
      v77 = 0;
      v185 = v76;
      if ( v76 )
      {
        do
        {
          *(_QWORD *)&v79 = sub_3400D50(a4, v77, &v207, 0);
          v68 = v191 | v68 & 0xFFFFFFFF00000000LL;
          *((_QWORD *)&v174 + 1) = v68;
          *(_QWORD *)&v174 = v196;
          v60 = sub_3406EB0(a4, 158, (unsigned int)&v207, v188, v187, v80, v174, v79);
          v81 = (unsigned int)v213;
          a6 = v82;
          v83 = (unsigned int)v213 + 1LL;
          if ( v83 > HIDWORD(v213) )
          {
            v180 = v60;
            v182 = a6;
            sub_C8D5F0((__int64)&v212, &v214, v83, 0x10u, v60, a6);
            v81 = (unsigned int)v213;
            v60 = v180;
            a6 = v182;
          }
          v78 = &v212[v81];
          ++v77;
          v78->m128i_i64[0] = v60;
          v78->m128i_i64[1] = a6;
          LODWORD(v213) = v213 + 1;
        }
        while ( v185 != v77 );
      }
LABEL_83:
      if ( (unsigned __int64)*(unsigned int *)(v183 + 64) <= ++v202.m128i_i64[0] )
      {
LABEL_139:
        v8 = v183;
        v161 = v212;
        v162 = (unsigned int)v213;
        goto LABEL_140;
      }
    }
    if ( (unsigned __int16)(v70 - 17) > 0xD3u )
      goto LABEL_80;
    v163 = v188;
    v187 = 0;
    LOWORD(v163) = word_4456580[v70 - 1];
    v188 = v163;
LABEL_146:
    if ( (unsigned __int16)(v70 - 176) > 0x34u )
      goto LABEL_147;
    goto LABEL_153;
  }
  if ( (unsigned int)v17 > 0x24A4 )
  {
    v24 = *(_QWORD *)(v8 + 40);
    v25 = *(_QWORD *)(*(_QWORD *)(v24 + 40) + 96LL);
    v26 = *(_QWORD **)(v25 + 24);
    if ( *(_DWORD *)(v25 + 32) > 0x40u )
      v26 = (_QWORD *)*v26;
    v27 = *(_QWORD *)(v8 + 80);
    v207 = v27;
    if ( v27 )
    {
      sub_B96E90((__int64)&v207, v27, 1);
      v15 = *(unsigned int *)(v8 + 72);
      v24 = *(_QWORD *)(v8 + 40);
    }
    v208 = v15;
    v212 = &v214;
    v213 = 0x2000000000LL;
    v28 = *(_QWORD *)(*(_QWORD *)(v24 + 80) + 96LL);
    if ( *(_DWORD *)(v28 + 32) <= 0x40u )
      v29 = *(_QWORD *)(v28 + 24);
    else
      v29 = **(_QWORD **)(v28 + 24);
    v30 = (_DWORD)v26 == 9382;
    v31 = *(_QWORD *)(*(_QWORD *)(v24 + 160) + 48LL) + 16LL * *(unsigned int *)(v24 + 168);
    v32 = *(_WORD *)v31;
    v33 = *(_QWORD *)(v31 + 8);
    v209.m128i_i16[0] = v32;
    v209.m128i_i64[1] = v33;
    if ( v32 )
    {
      v34 = (unsigned __int16)(v32 - 17) <= 0xD3u;
    }
    else
    {
      v202.m128i_i64[0] = v24;
      v34 = sub_30070B0((__int64)&v209);
      v24 = v202.m128i_i64[0];
    }
    if ( (v29 & 0x60000) != 0x40000 )
    {
      if ( (v29 & 0x4000) != 0 )
        sub_C64ED0("noftz not support for other types for nvvm.red", 1u);
      goto LABEL_50;
    }
    v35 = BYTE1(v29) & 0x3C;
    if ( v34 )
    {
      if ( (BYTE1(v29) & 0x2C) == 0xC || v35 == 24 )
        goto LABEL_49;
    }
    else if ( v35 == 12 )
    {
LABEL_49:
      LOWORD(v29) = v29 | 0x4000;
LABEL_50:
      v36 = v29 & 0x300;
      if ( v34 && v36 )
        sub_C64ED0("Invalid address space for pointer operand in nvvm.red", 1u);
      if ( v30 && v36 )
        sub_C64ED0("Cache hint can be applied only to global or generic addrspace in nvvm.red", 1u);
      if ( *(_DWORD *)(v8 + 64) )
      {
        v183 = v8;
        v202.m128i_i64[0] = 0;
        while ( 1 )
        {
          v40 = (__int64 *)(v24 + 40 * v202.m128i_i64[0]);
          v41 = *v40;
          v42 = v40[1];
          v195 = *v40;
          v190 = *((unsigned int *)v40 + 2);
          v43 = *(_QWORD *)(*v40 + 48) + 16 * v190;
          v44 = *(_WORD *)v43;
          v45 = *(_QWORD *)(v43 + 8);
          v209.m128i_i16[0] = v44;
          v209.m128i_i64[1] = v45;
          if ( v44 )
          {
            if ( (unsigned __int16)(v44 - 17) <= 0xD3u )
            {
              v15 = v186;
              v189 = 0;
              LOWORD(v15) = word_4456580[v44 - 1];
              v186 = v15;
              goto LABEL_149;
            }
          }
          else if ( sub_30070B0((__int64)&v209) )
          {
            v48 = sub_3009970((__int64)&v209, v15, v46, v47, v27);
            v44 = v209.m128i_i16[0];
            v186 = v48;
            v189 = v49;
            if ( !v209.m128i_i16[0] )
            {
              if ( !sub_3007100((__int64)&v209) )
                goto LABEL_66;
LABEL_151:
              sub_CA17B0(
                "Possible incorrect use of EVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped,"
                " use EVT::getVectorElementCount() instead");
              if ( !v209.m128i_i16[0] )
              {
LABEL_66:
                v50 = sub_3007130((__int64)&v209, v15);
                goto LABEL_67;
              }
              if ( (unsigned __int16)(v209.m128i_i16[0] - 176) <= 0x34u )
                sub_CA17B0(
                  "Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be droppe"
                  "d, use MVT::getVectorElementCount() instead");
LABEL_150:
              v50 = word_4456340[v209.m128i_u16[0] - 1];
LABEL_67:
              v51 = 0;
              v184 = v50;
              if ( v50 )
              {
                do
                {
                  *(_QWORD *)&v53 = sub_3400D50(a4, v51, &v207, 0);
                  v15 = 158;
                  v42 = v190 | v42 & 0xFFFFFFFF00000000LL;
                  *((_QWORD *)&v173 + 1) = v42;
                  *(_QWORD *)&v173 = v195;
                  v27 = sub_3406EB0(a4, 158, (unsigned int)&v207, v186, v189, v54, v173, v53);
                  v55 = (unsigned int)v213;
                  v57 = v56;
                  v58 = (unsigned int)v213 + 1LL;
                  if ( v58 > HIDWORD(v213) )
                  {
                    v15 = (__int64)&v214;
                    v179 = v27;
                    v181 = v57;
                    sub_C8D5F0((__int64)&v212, &v214, v58, 0x10u, v27, v57);
                    v55 = (unsigned int)v213;
                    v27 = v179;
                    v57 = v181;
                  }
                  v52 = &v212[v55];
                  ++v51;
                  v52->m128i_i64[0] = v27;
                  v52->m128i_i64[1] = v57;
                  LODWORD(v213) = v213 + 1;
                }
                while ( v184 != v51 );
              }
              goto LABEL_60;
            }
LABEL_149:
            if ( (unsigned __int16)(v44 - 176) <= 0x34u )
              goto LABEL_151;
            goto LABEL_150;
          }
          v37 = (unsigned int)v213;
          v38 = (unsigned int)v213 + 1LL;
          if ( v38 > HIDWORD(v213) )
          {
            v15 = (__int64)&v214;
            sub_C8D5F0((__int64)&v212, &v214, v38, 0x10u, v27, v24);
            v37 = (unsigned int)v213;
          }
          v39 = &v212[v37];
          v39->m128i_i64[0] = v41;
          v39->m128i_i64[1] = v42;
          LODWORD(v213) = v213 + 1;
LABEL_60:
          if ( (unsigned __int64)*(unsigned int *)(v183 + 64) <= ++v202.m128i_i64[0] )
            goto LABEL_139;
          v24 = *(_QWORD *)(v183 + 40);
        }
      }
      v161 = &v214;
      v162 = 0;
LABEL_140:
      v19 = sub_33EA9D0(
              a4,
              48,
              (unsigned int)&v207,
              *(_QWORD *)(v8 + 48),
              *(_DWORD *)(v8 + 68),
              *(_QWORD *)(v8 + 112),
              (__int64)v161,
              v162,
              *(unsigned __int16 *)(v8 + 96),
              *(_QWORD *)(v8 + 104));
      if ( v212 != &v214 )
        _libc_free((unsigned __int64)v212);
      if ( v207 )
        sub_B91220((__int64)&v207, v207);
      goto LABEL_12;
    }
    sub_C64ED0("Invalid op and type combination for nvvm.red", 1u);
  }
  if ( (_DWORD)v17 == 8920 )
  {
LABEL_17:
    v19 = sub_304D180(a1, v8, a4);
    goto LABEL_12;
  }
  if ( (unsigned int)v17 > 0x22D8 )
  {
    if ( (_DWORD)v17 != 9145 )
    {
      if ( (unsigned int)v17 > 0x23B9 )
      {
LABEL_11:
        v19 = 0;
        goto LABEL_12;
      }
      if ( (_DWORD)v17 != 8924 )
      {
        if ( (unsigned int)((_DWORD)v17 - 8937) > 1 )
          goto LABEL_11;
        goto LABEL_17;
      }
      goto LABEL_36;
    }
    v114 = *(_QWORD *)(v8 + 40);
    v115 = *(_DWORD *)(v8 + 64);
    v209 = _mm_loadu_si128((const __m128i *)v114);
    v210 = _mm_loadu_si128((const __m128i *)(v114 + 40));
    v116 = _mm_loadu_si128((const __m128i *)(v114 + 80));
    v212 = &v214;
    v213 = 0x800000003LL;
    v211 = v116;
    v214 = v209;
    v215 = v210;
    v216 = v116;
    if ( v115 != 4 )
    {
      v117 = _mm_loadu_si128((const __m128i *)(v114 + 160));
      v118 = &v214;
      v119 = 4;
      v120 = 3;
      while ( 1 )
      {
        ++v119;
        v118[v120] = v117;
        v120 = (unsigned int)(v213 + 1);
        LODWORD(v213) = v213 + 1;
        if ( v119 == v115 )
          break;
        v117 = _mm_loadu_si128((const __m128i *)(*(_QWORD *)(v8 + 40) + 40LL * v119));
        if ( v120 + 1 > (unsigned __int64)HIDWORD(v213) )
        {
          v15 = (__int64)&v214;
          v202 = v117;
          sub_C8D5F0((__int64)&v212, &v214, v120 + 1, 0x10u, v6, a6);
          v120 = (unsigned int)v213;
          v117 = _mm_load_si128(&v202);
        }
        v118 = v212;
      }
      v114 = *(_QWORD *)(v8 + 40);
    }
    v121 = *(_QWORD *)(*(_QWORD *)(v114 + 120) + 48LL) + 16LL * *(unsigned int *)(v114 + 128);
    v122 = *(_WORD *)v121;
    v123 = *(_QWORD *)(v121 + 8);
    v209.m128i_i16[0] = v122;
    v209.m128i_i64[1] = v123;
    if ( v122 )
    {
      if ( (unsigned __int16)(v122 - 17) <= 0xD3u )
      {
        if ( (unsigned __int16)(v122 - 176) > 0x34u )
          goto LABEL_137;
        goto LABEL_174;
      }
    }
    else
    {
      v202.m128i_i64[0] = (__int64)&v209;
      if ( sub_30070B0((__int64)&v209) )
      {
        v124 = sub_3007100(v202.m128i_i64[0]);
        v125 = (__m128i *)v202.m128i_i64[0];
        if ( !v124 )
        {
LABEL_115:
          v126 = sub_3007130((__int64)v125, v15);
          goto LABEL_116;
        }
LABEL_174:
        sub_CA17B0(
          "Possible incorrect use of EVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use E"
          "VT::getVectorElementCount() instead");
        if ( !v209.m128i_i16[0] )
        {
          v125 = &v209;
          goto LABEL_115;
        }
        if ( (unsigned __int16)(v209.m128i_i16[0] - 176) <= 0x34u )
          sub_CA17B0(
            "Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use"
            " MVT::getVectorElementCount() instead");
LABEL_137:
        v126 = word_4456340[v209.m128i_u16[0] - 1];
LABEL_116:
        HIWORD(v127) = v193;
        v202.m128i_i64[0] = v126;
        v128 = 0;
        if ( v126 )
        {
          do
          {
            v137 = sub_3400D50(a4, v128, &v205, 0);
            v139 = *(_QWORD *)(v8 + 40);
            v140 = v138;
            v141 = v137;
            if ( v209.m128i_i16[0] )
            {
              LOWORD(v129) = word_4456580[v209.m128i_u16[0] - 1];
              v130 = 0;
            }
            else
            {
              v192 = *(_QWORD *)(v8 + 40);
              v197 = v137;
              v200 = v138;
              v129 = sub_3009970((__int64)&v209, v128, 0, v139, v137);
              v139 = v192;
              v141 = v197;
              v140 = v200;
              HIWORD(v127) = HIWORD(v129);
            }
            *((_QWORD *)&v176 + 1) = v140;
            LOWORD(v127) = v129;
            *(_QWORD *)&v176 = v141;
            v131 = sub_3406EB0(a4, 158, (unsigned int)&v205, v127, v130, v140, *(_OWORD *)(v139 + 120), v176);
            v132 = (unsigned int)v213;
            v134 = v133;
            v135 = (unsigned int)v213 + 1LL;
            if ( v135 > HIDWORD(v213) )
            {
              v199 = v131;
              v201 = v134;
              sub_C8D5F0((__int64)&v212, &v214, v135, 0x10u, v131, v134);
              v132 = (unsigned int)v213;
              v131 = v199;
              v134 = v201;
            }
            v136 = &v212[v132];
            ++v128;
            v136->m128i_i64[0] = v131;
            v136->m128i_i64[1] = v134;
            v171 = v213 + 1;
            LODWORD(v213) = v213 + 1;
          }
          while ( v202.m128i_i64[0] != v128 );
        }
        else
        {
          v171 = v213;
        }
LABEL_158:
        v167 = *(_QWORD *)(v8 + 104);
        v168 = *(unsigned __int16 *)(v8 + 96);
        v198 = *(_QWORD *)(v8 + 112);
        v202.m128i_i64[0] = (__int64)v212;
        v202.m128i_i64[1] = v171;
        v169 = sub_33ED250(a4, 1, 0, v212);
        v19 = sub_33EA9D0(
                a4,
                48,
                (unsigned int)&v205,
                v169,
                v170,
                v198,
                v202.m128i_i64[0],
                v202.m128i_i64[1],
                v168,
                v167);
        if ( v212 != &v214 )
          _libc_free((unsigned __int64)v212);
        goto LABEL_12;
      }
    }
    v164 = (unsigned int)v213;
    v165 = _mm_loadu_si128((const __m128i *)(v114 + 120));
    v166 = (unsigned int)v213 + 1LL;
    if ( v166 > HIDWORD(v213) )
    {
      v202 = v165;
      sub_C8D5F0((__int64)&v212, &v214, v166, 0x10u, v6, a6);
      v164 = (unsigned int)v213;
      v165 = _mm_load_si128(&v202);
    }
    v212[v164] = v165;
    v171 = v213 + 1;
    LODWORD(v213) = v213 + 1;
    goto LABEL_158;
  }
  if ( (unsigned int)v17 > 0x2069 )
    goto LABEL_11;
  if ( (unsigned int)v17 > 0x2065 )
  {
    v84 = *(_QWORD *)(v8 + 40);
    if ( *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v84 + 80) + 48LL) + 16LL * *(unsigned int *)(v84 + 88)) != 9 )
      goto LABEL_11;
    v85 = *(_QWORD *)(v8 + 80);
    v209.m128i_i64[0] = v85;
    if ( v85 )
    {
      v202.m128i_i64[0] = (__int64)&v209;
      sub_B96E90((__int64)&v209, v85, 1);
      v84 = *(_QWORD *)(v8 + 40);
      LODWORD(v15) = *(_DWORD *)(v8 + 72);
    }
    v212 = &v214;
    v209.m128i_i32[2] = v15;
    v213 = 0x800000000LL;
    v202.m128i_i64[0] = (__int64)&v209;
    v214 = _mm_loadu_si128((const __m128i *)v84);
    v86 = _mm_loadu_si128((const __m128i *)(v84 + 40));
    LODWORD(v213) = 2;
    v215 = v86;
    v87 = sub_33FAF80(a4, 234, (unsigned int)&v209, 116, 0, a6, *(_OWORD *)(v84 + 80));
    v89 = v88;
    v90 = v87;
    *(_QWORD *)&v91 = sub_3400D50(a4, 0, &v209, 0);
    *((_QWORD *)&v172 + 1) = v89;
    *(_QWORD *)&v172 = v90;
    v93.m128i_i64[0] = sub_3406EB0(a4, 158, (unsigned int)&v209, 8, 0, v92, v172, v91);
    v202 = v93;
    *(_QWORD *)&v94 = sub_3400D50(a4, 1, &v209, 0);
    *((_QWORD *)&v175 + 1) = v89;
    *(_QWORD *)&v175 = v90;
    v96 = sub_3406EB0(a4, 158, (unsigned int)&v209, 8, 0, v95, v175, v94);
    v99 = &v209;
    v100 = v96;
    v101 = (unsigned int)v213;
    v103 = v102;
    v104 = (unsigned int)v213 + 1LL;
    if ( v104 > HIDWORD(v213) )
    {
      sub_C8D5F0((__int64)&v212, &v214, v104, 0x10u, v97, v98);
      v101 = (unsigned int)v213;
      v99 = &v209;
    }
    v212[v101] = _mm_load_si128(&v202);
    LODWORD(v213) = v213 + 1;
    v105 = (unsigned int)v213;
    if ( (unsigned __int64)(unsigned int)v213 + 1 > HIDWORD(v213) )
    {
      v202.m128i_i64[0] = (__int64)&v209;
      sub_C8D5F0((__int64)&v212, &v214, (unsigned int)v213 + 1LL, 0x10u, v97, v98);
      v105 = (unsigned int)v213;
      v99 = (__m128i *)v202.m128i_i64[0];
    }
    v106 = &v212[v105];
    v106->m128i_i64[0] = v100;
    v106->m128i_i64[1] = v103;
    v107 = *(unsigned __int16 *)(v8 + 96);
    v108 = *(_QWORD *)(v8 + 104);
    v202.m128i_i64[0] = (__int64)v99;
    v109 = *(_QWORD *)(v8 + 112);
    v110 = *(_DWORD *)(v8 + 68);
    v111 = *(_QWORD *)(v8 + 48);
    LODWORD(v213) = v213 + 1;
    v112 = sub_33EA9D0(a4, 47, (_DWORD)v99, v111, v110, v109, (__int64)v212, (unsigned int)v213, v107, v108);
    v113 = v202.m128i_i64[0];
    v19 = v112;
    if ( v212 != &v214 )
    {
      _libc_free((unsigned __int64)v212);
      v113 = v202.m128i_i64[0];
    }
    if ( v209.m128i_i64[0] )
      sub_B91220(v113, v209.m128i_i64[0]);
  }
  else
  {
    if ( (_DWORD)v17 != 8238 && (_DWORD)v17 != 8243 )
      goto LABEL_11;
    v19 = sub_304E1A0(a1, v8, v6, a4);
  }
LABEL_12:
  if ( v205 )
    sub_B91220((__int64)&v205, v205);
  return v19;
}
