// Function: sub_214F370
// Address: 0x214f370
//
_BYTE *__fastcall sub_214F370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rdx
  __int64 v9; // rdx
  __m128i si128; // xmm0
  __m128i *v11; // rdx
  __m128i v12; // xmm0
  __int64 v13; // rdi
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rax
  void *v18; // rdx
  __int64 v19; // rdi
  void *v20; // rdx
  _BYTE *v21; // rax
  __int64 v22; // rdx
  _BYTE *v23; // rax
  __int64 v24; // rdx
  unsigned int v25; // ebx
  __int64 v26; // rdi
  __int64 v27; // rax
  unsigned int v28; // ecx
  __int64 v29; // rdi
  _BYTE *v30; // rax
  __int64 v31; // rdi
  _BYTE *v32; // rax
  _QWORD *v33; // rdx
  _BYTE *v34; // rsi
  __int64 v35; // rdx
  __int64 v36; // r15
  char *v37; // r13
  int v38; // eax
  int v39; // r13d
  __int64 v40; // rax
  _BYTE *v41; // rax
  void *v42; // rdx
  _BYTE *v43; // rax
  _BYTE *result; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  char *v47; // [rsp+10h] [rbp-60h] BYREF
  int v48; // [rsp+18h] [rbp-58h]
  char *v49; // [rsp+20h] [rbp-50h] BYREF
  size_t v50; // [rsp+28h] [rbp-48h]
  _QWORD v51[8]; // [rsp+30h] [rbp-40h] BYREF

  v8 = *(_QWORD *)(a3 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) - v8) <= 2 )
  {
    sub_16E7EE0(a3, "//\n", 3u);
    v9 = *(_QWORD *)(a3 + 24);
  }
  else
  {
    *(_BYTE *)(v8 + 2) = 10;
    *(_WORD *)v8 = 12079;
    v9 = *(_QWORD *)(a3 + 24) + 3LL;
    *(_QWORD *)(a3 + 24) = v9;
  }
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) - v9) <= 0x24 )
  {
    sub_16E7EE0(a3, "// Generated by NVIDIA NVVM Compiler\n", 0x25u);
  }
  else
  {
    si128 = _mm_load_si128((const __m128i *)&xmmword_4327120);
    *(_DWORD *)(v9 + 32) = 1919249513;
    *(_BYTE *)(v9 + 36) = 10;
    *(__m128i *)v9 = si128;
    *(__m128i *)(v9 + 16) = _mm_load_si128((const __m128i *)&xmmword_4327130);
    *(_QWORD *)(a3 + 24) += 37LL;
  }
  sub_1263B40(a3, "//\n");
  v11 = *(__m128i **)(a3 + 24);
  if ( *(_QWORD *)(a3 + 16) - (_QWORD)v11 <= 0x15u )
  {
    v13 = sub_16E7EE0(a3, "// Compiler Build ID: ", 0x16u);
  }
  else
  {
    v12 = _mm_load_si128((const __m128i *)&xmmword_4327140);
    v11[1].m128i_i32[0] = 1145643108;
    v13 = a3;
    v11[1].m128i_i16[2] = 8250;
    *v11 = v12;
    *(_QWORD *)(a3 + 24) += 22LL;
  }
  v14 = sub_1263B40(v13, (const char *)off_4CD49A8);
  sub_1263B40(v14, "\n");
  v15 = *(_QWORD *)(a3 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) - v15) <= 2 )
  {
    v16 = sub_16E7EE0(a3, "// ", 3u);
  }
  else
  {
    *(_BYTE *)(v15 + 2) = 32;
    *(_WORD *)v15 = 12079;
    v16 = a3;
    *(_QWORD *)(a3 + 24) += 3LL;
  }
  v17 = sub_1263B40(v16, (const char *)off_4CD49A0);
  sub_1263B40(v17, "\n");
  v18 = *(void **)(a3 + 24);
  if ( *(_QWORD *)(a3 + 16) - (_QWORD)v18 <= 0xBu )
  {
    v46 = sub_16E7EE0(a3, "// Based on ", 0xCu);
    v20 = *(void **)(v46 + 24);
    v19 = v46;
  }
  else
  {
    v19 = a3;
    qmemcpy(v18, "// Based on ", 12);
    v20 = (void *)(*(_QWORD *)(a3 + 24) + 12LL);
    *(_QWORD *)(a3 + 24) = v20;
  }
  if ( *(_QWORD *)(v19 + 16) - (_QWORD)v20 <= 9u )
  {
    v19 = sub_16E7EE0(v19, "NVVM 7.0.1", 0xAu);
    v21 = *(_BYTE **)(v19 + 24);
  }
  else
  {
    qmemcpy(v20, "NVVM 7.0.1", 10);
    v21 = (_BYTE *)(*(_QWORD *)(v19 + 24) + 10LL);
    *(_QWORD *)(v19 + 24) = v21;
  }
  if ( *(_BYTE **)(v19 + 16) == v21 )
  {
    sub_16E7EE0(v19, "\n", 1u);
  }
  else
  {
    *v21 = 10;
    ++*(_QWORD *)(v19 + 24);
  }
  v22 = *(_QWORD *)(a3 + 24);
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) - v22) <= 2 )
  {
    sub_16E7EE0(a3, "//\n", 3u);
    v23 = *(_BYTE **)(a3 + 24);
  }
  else
  {
    *(_BYTE *)(v22 + 2) = 10;
    *(_WORD *)v22 = 12079;
    v23 = (_BYTE *)(*(_QWORD *)(a3 + 24) + 3LL);
    *(_QWORD *)(a3 + 24) = v23;
  }
  if ( *(_BYTE **)(a3 + 16) == v23 )
  {
    sub_16E7EE0(a3, "\n", 1u);
    v24 = *(_QWORD *)(a3 + 24);
  }
  else
  {
    *v23 = 10;
    v24 = *(_QWORD *)(a3 + 24) + 1LL;
    *(_QWORD *)(a3 + 24) = v24;
  }
  v25 = *(_DWORD *)(a4 + 248);
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) - v24) <= 8 )
  {
    v26 = sub_16E7EE0(a3, ".version ", 9u);
  }
  else
  {
    *(_BYTE *)(v24 + 8) = 32;
    v26 = a3;
    *(_QWORD *)v24 = 0x6E6F69737265762ELL;
    *(_QWORD *)(a3 + 24) += 9LL;
  }
  v27 = sub_16E7A90(v26, v25 / 0xAuLL);
  v28 = v25;
  v29 = v27;
  v30 = *(_BYTE **)(v27 + 24);
  if ( *(_BYTE **)(v29 + 16) == v30 )
  {
    v45 = sub_16E7EE0(v29, ".", 1u);
    v28 = v25;
    v29 = v45;
  }
  else
  {
    *v30 = 46;
    ++*(_QWORD *)(v29 + 24);
  }
  v31 = sub_16E7A90(v29, v25 - 10 * (v28 / 0xA));
  v32 = *(_BYTE **)(v31 + 24);
  if ( *(_BYTE **)(v31 + 16) == v32 )
  {
    sub_16E7EE0(v31, "\n", 1u);
  }
  else
  {
    *v32 = 10;
    ++*(_QWORD *)(v31 + 24);
  }
  v33 = *(_QWORD **)(a3 + 24);
  if ( *(_QWORD *)(a3 + 16) - (_QWORD)v33 <= 7u )
  {
    sub_16E7EE0(a3, ".target ", 8u);
  }
  else
  {
    *v33 = 0x207465677261742ELL;
    *(_QWORD *)(a3 + 24) += 8LL;
  }
  v34 = *(_BYTE **)(a4 + 216);
  v35 = *(_QWORD *)(a4 + 224);
  v49 = (char *)v51;
  sub_214ADD0((__int64 *)&v49, v34, (__int64)&v34[v35]);
  sub_16E7EE0(a3, v49, v50);
  if ( v49 != (char *)v51 )
    j_j___libc_free_0(v49, v51[0] + 1LL);
  v36 = *(_QWORD *)(a1 + 232);
  if ( !*(_DWORD *)(v36 + 952) )
    sub_1263B40(a3, ", texmode_independent");
  v49 = "llvm.dbg.cu";
  LOWORD(v51[0]) = 259;
  v37 = (char *)sub_1632310(a2, (__int64)&v49);
  v38 = 0;
  if ( v37 )
    v38 = sub_161F520((__int64)v37);
  LODWORD(v50) = v38;
  v49 = v37;
  sub_1632FD0((__int64)&v49);
  v47 = v37;
  v48 = 0;
  sub_1632FD0((__int64)&v47);
  v39 = v50;
  LODWORD(v50) = v48;
  v49 = v47;
  if ( v48 != v39 )
  {
    while ( (unsigned int)(*(_DWORD *)(sub_1632FB0((__int64)&v49) + 36) - 1) > 1 )
    {
      LODWORD(v50) = v50 + 1;
      sub_1632FD0((__int64)&v49);
      if ( (_DWORD)v50 == v39 )
        goto LABEL_40;
    }
    v40 = *(_QWORD *)(a1 + 272);
    if ( v40 && *(_BYTE *)(v40 + 1744) )
      sub_1263B40(a3, ", debug");
  }
LABEL_40:
  v41 = *(_BYTE **)(a3 + 24);
  if ( *(_BYTE **)(a3 + 16) == v41 )
  {
    sub_16E7EE0(a3, "\n", 1u);
    v42 = *(void **)(a3 + 24);
  }
  else
  {
    *v41 = 10;
    v42 = (void *)(*(_QWORD *)(a3 + 24) + 1LL);
    *(_QWORD *)(a3 + 24) = v42;
  }
  if ( *(_QWORD *)(a3 + 16) - (_QWORD)v42 <= 0xDu )
  {
    sub_16E7EE0(a3, ".address_size ", 0xEu);
  }
  else
  {
    qmemcpy(v42, ".address_size ", 14);
    *(_QWORD *)(a3 + 24) += 14LL;
  }
  if ( *(_BYTE *)(v36 + 936) )
  {
    sub_1263B40(a3, "64");
    v43 = *(_BYTE **)(a3 + 24);
    if ( *(_BYTE **)(a3 + 16) != v43 )
      goto LABEL_46;
LABEL_49:
    sub_16E7EE0(a3, "\n", 1u);
    result = *(_BYTE **)(a3 + 24);
    if ( result != *(_BYTE **)(a3 + 16) )
      goto LABEL_47;
    return (_BYTE *)sub_16E7EE0(a3, "\n", 1u);
  }
  sub_1263B40(a3, "32");
  v43 = *(_BYTE **)(a3 + 24);
  if ( *(_BYTE **)(a3 + 16) == v43 )
    goto LABEL_49;
LABEL_46:
  *v43 = 10;
  result = (_BYTE *)(*(_QWORD *)(a3 + 24) + 1LL);
  *(_QWORD *)(a3 + 24) = result;
  if ( result != *(_BYTE **)(a3 + 16) )
  {
LABEL_47:
    *result = 10;
    ++*(_QWORD *)(a3 + 24);
    return result;
  }
  return (_BYTE *)sub_16E7EE0(a3, "\n", 1u);
}
