// Function: sub_2E70D60
// Address: 0x2e70d60
//
void __fastcall sub_2E70D60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 v9; // rsi
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned int v12; // eax
  __int64 v13; // rdx
  __int64 v14; // r14
  __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // r13
  __int64 v18; // rax
  unsigned __int64 v19; // rcx
  __int64 v20; // rdx
  int v21; // esi
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 *v24; // r13
  __int64 v25; // rax
  __int64 *v26; // r12
  __int64 v27; // r14
  __int64 v28; // rdx
  unsigned int v29; // eax
  __int64 *v30; // rsi
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r15
  __int64 v34; // rax
  unsigned __int64 v35; // r10
  unsigned __int64 v36; // rdx
  __int64 *v37; // rax
  unsigned int v38; // r8d
  __int64 v39; // rax
  __int64 *v40; // r12
  __int64 v41; // r13
  unsigned int v42; // r15d
  __int64 v43; // rdx
  unsigned int v44; // eax
  __int64 v45; // rbx
  __int64 *v46; // r14
  __int64 v47; // rax
  __int64 v48; // rdx
  unsigned int v49; // eax
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rbx
  __int64 v53; // rdx
  __int64 v54; // rbx
  __int64 v55; // r13
  __int64 v56; // r14
  __int64 v57; // rax
  __int64 *v58; // rax
  __int64 v59; // rdx
  __int64 *v60; // rax
  __int64 v61; // r10
  __int64 v62; // r11
  __int64 *v63; // rdx
  __int64 v64; // rsi
  unsigned __int64 v65; // r12
  unsigned __int64 v66; // rdi
  __int64 *v67; // rax
  __int64 v68; // rax
  __int64 v69; // rcx
  __int64 v70; // rdx
  _BYTE *v71; // r13
  _BYTE *v72; // r14
  unsigned __int64 v73; // rdi
  _QWORD *v74; // rsi
  unsigned int v75; // ebx
  unsigned __int64 v76; // rdx
  unsigned __int64 v77; // rcx
  __int64 v78; // r8
  __int64 v79; // r9
  unsigned int i; // eax
  __int64 v81; // rdx
  __int64 v82; // r14
  int v83; // r10d
  __int64 v84; // rax
  int v85; // r10d
  __int64 v86; // r13
  __int64 v87; // rax
  int v88; // eax
  __int64 v89; // rcx
  __int64 v90; // r8
  __int64 *v91; // r13
  __int64 *v92; // r10
  unsigned int v93; // r15d
  unsigned __int64 v94; // rbx
  unsigned int v95; // eax
  __int64 v96; // rax
  __int64 v97; // rax
  unsigned __int64 v98; // r11
  __int64 *v99; // rax
  __int64 v100; // r14
  __int64 v101; // rcx
  __int64 v102; // r8
  __int64 v103; // r9
  _BYTE *v104; // rbx
  unsigned __int64 v105; // r12
  unsigned __int64 v106; // rdi
  unsigned __int64 v108; // [rsp+28h] [rbp-1598h]
  __int64 v109; // [rsp+28h] [rbp-1598h]
  __int64 *v111; // [rsp+38h] [rbp-1588h]
  unsigned int v112; // [rsp+40h] [rbp-1580h]
  unsigned int v113; // [rsp+48h] [rbp-1578h]
  __int64 v114; // [rsp+48h] [rbp-1578h]
  __int64 *v115; // [rsp+48h] [rbp-1578h]
  unsigned int v116; // [rsp+50h] [rbp-1570h]
  __int64 *v117; // [rsp+50h] [rbp-1570h]
  unsigned int v118; // [rsp+50h] [rbp-1570h]
  unsigned __int64 v119; // [rsp+50h] [rbp-1570h]
  unsigned int v120; // [rsp+58h] [rbp-1568h]
  __int64 v121; // [rsp+58h] [rbp-1568h]
  int v122; // [rsp+58h] [rbp-1568h]
  unsigned __int64 v123; // [rsp+58h] [rbp-1568h]
  __int64 v124; // [rsp+68h] [rbp-1558h] BYREF
  __int64 *v125; // [rsp+70h] [rbp-1550h] BYREF
  int v126; // [rsp+78h] [rbp-1548h]
  _BYTE v127[64]; // [rsp+80h] [rbp-1540h] BYREF
  __int64 *v128; // [rsp+C0h] [rbp-1500h] BYREF
  __int64 v129; // [rsp+C8h] [rbp-14F8h]
  _BYTE v130[128]; // [rsp+D0h] [rbp-14F0h] BYREF
  _QWORD *v131; // [rsp+150h] [rbp-1470h] BYREF
  __int64 v132; // [rsp+158h] [rbp-1468h]
  _QWORD *v133; // [rsp+160h] [rbp-1460h] BYREF
  __int64 v134; // [rsp+168h] [rbp-1458h]
  _QWORD *v135; // [rsp+560h] [rbp-1060h] BYREF
  __int64 v136; // [rsp+568h] [rbp-1058h]
  _QWORD v137[64]; // [rsp+570h] [rbp-1050h] BYREF
  _BYTE *v138; // [rsp+770h] [rbp-E50h]
  __int64 v139; // [rsp+778h] [rbp-E48h]
  _BYTE v140[3584]; // [rsp+780h] [rbp-E40h] BYREF
  __int64 v141; // [rsp+1580h] [rbp-40h]

  v7 = &v135;
  v128 = (__int64 *)v130;
  v129 = 0x1000000000LL;
  v113 = *(_DWORD *)(a3 + 16);
  v138 = v140;
  v141 = a2;
  v9 = *(_QWORD *)a3;
  v135 = v137;
  v139 = 0x4000000000LL;
  v136 = 0x4000000001LL;
  v137[0] = 0;
  v131 = &v133;
  v133 = (_QWORD *)v9;
  v134 = 0;
  v132 = 0x4000000001LL;
  v120 = 0;
  *(_DWORD *)(sub_2E6F1C0((__int64)&v135, v9, a3, (__int64)&v133, a5, a6) + 4) = 0;
  v12 = v132;
  if ( (_DWORD)v132 )
  {
    do
    {
      while ( 1 )
      {
        v13 = (__int64)&v131[2 * v12 - 2];
        v14 = *(_QWORD *)v13;
        v15 = *(unsigned int *)(v13 + 8);
        LODWORD(v132) = v12 - 1;
        v116 = v15;
        v16 = sub_2E6F1C0((__int64)&v135, v14, v13, (__int64)v131, v10, v15);
        v11 = v116;
        v17 = v16;
        v18 = *(unsigned int *)(v16 + 32);
        v19 = *(unsigned int *)(v17 + 36);
        if ( v18 + 1 > v19 )
        {
          sub_C8D5F0(v17 + 24, (const void *)(v17 + 40), v18 + 1, 4u, v10, v116);
          v18 = *(unsigned int *)(v17 + 32);
          v11 = v116;
        }
        v20 = *(_QWORD *)(v17 + 24);
        *(_DWORD *)(v20 + 4 * v18) = v11;
        v21 = *(_DWORD *)v17;
        ++*(_DWORD *)(v17 + 32);
        if ( !v21 )
        {
          *(_DWORD *)(v17 + 4) = v11;
          *(_DWORD *)(v17 + 12) = ++v120;
          *(_DWORD *)(v17 + 8) = v120;
          *(_DWORD *)v17 = v120;
          sub_2E6D5A0((__int64)&v135, v14, v20, v19, v10, v11);
          sub_2E6EC80(&v125, v14, v141, v22, v23);
          v10 = (__int64)v125;
          v24 = &v125[v126];
          if ( v125 != v24 )
          {
            v25 = a1;
            v26 = v125;
            v27 = v25;
            do
            {
              while ( 1 )
              {
                v33 = *v26;
                v124 = v33;
                if ( v33 )
                {
                  v28 = (unsigned int)(*(_DWORD *)(v33 + 24) + 1);
                  v29 = *(_DWORD *)(v33 + 24) + 1;
                }
                else
                {
                  v29 = 0;
                  v28 = 0;
                }
                if ( v29 >= *(_DWORD *)(v27 + 32) )
LABEL_102:
                  BUG();
                if ( v113 < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v27 + 24) + 8 * v28) + 16LL) )
                  break;
                v30 = &v128[(unsigned int)v129];
                if ( v30 == sub_2E6C320(v128, (__int64)v30, &v124) )
                  sub_2E6D5A0((__int64)&v128, v33, v31, v32, v10, v11);
                if ( v24 == ++v26 )
                  goto LABEL_20;
              }
              v34 = (unsigned int)v132;
              v35 = v6 & 0xFFFFFFFF00000000LL | v120;
              v36 = (unsigned int)v132 + 1LL;
              v6 = v35;
              if ( v36 > HIDWORD(v132) )
              {
                v119 = v35;
                sub_C8D5F0((__int64)&v131, &v133, v36, 0x10u, v10, v11);
                v34 = (unsigned int)v132;
                v35 = v119;
              }
              ++v26;
              v37 = &v131[2 * v34];
              *v37 = v33;
              v37[1] = v35;
              LODWORD(v132) = v132 + 1;
            }
            while ( v24 != v26 );
LABEL_20:
            v24 = v125;
            a1 = v27;
          }
          if ( v24 != (__int64 *)v127 )
            break;
        }
        v12 = v132;
        if ( !(_DWORD)v132 )
          goto LABEL_23;
      }
      _libc_free((unsigned __int64)v24);
      v12 = v132;
    }
    while ( (_DWORD)v132 );
LABEL_23:
    v7 = &v135;
  }
  if ( v131 != &v133 )
    _libc_free((unsigned __int64)v131);
  if ( v128 == &v128[(unsigned int)v129] )
  {
    v52 = a3;
  }
  else
  {
    v38 = *(_DWORD *)(a1 + 32);
    v39 = a1;
    v117 = &v128[(unsigned int)v129];
    v40 = v128;
    v41 = v39;
    v114 = a3;
    v42 = v38;
    do
    {
      v51 = *v40;
      if ( *v40 )
      {
        v43 = (unsigned int)(*(_DWORD *)(v51 + 24) + 1);
        v44 = *(_DWORD *)(v51 + 24) + 1;
      }
      else
      {
        v43 = 0;
        v44 = 0;
      }
      if ( v44 >= v42 )
        BUG();
      v45 = *(_QWORD *)(v41 + 24);
      v46 = *(__int64 **)(v45 + 8 * v43);
      v47 = sub_2E6D000(v41, *v46, *(_QWORD *)a3);
      if ( v47 )
      {
        v48 = (unsigned int)(*(_DWORD *)(v47 + 24) + 1);
        v49 = *(_DWORD *)(v47 + 24) + 1;
      }
      else
      {
        v48 = 0;
        v49 = 0;
      }
      if ( v49 >= v42 )
        goto LABEL_102;
      v50 = *(_QWORD *)(v45 + 8 * v48);
      if ( (__int64 *)v50 != v46 )
      {
        if ( *(_DWORD *)(v114 + 16) <= *(_DWORD *)(v50 + 16) )
          v50 = v114;
        v114 = v50;
      }
      ++v40;
    }
    while ( v117 != v40 );
    v52 = v114;
    v7 = &v135;
    a1 = v41;
  }
  if ( !*(_QWORD *)(v52 + 8) )
  {
    sub_2E70350(a1, a2);
LABEL_99:
    sub_2E6D840((__int64)&v135);
    goto LABEL_95;
  }
  if ( v120 )
  {
    v53 = v120;
    v121 = v52;
    v54 = a1;
    v55 = 8 * v53;
    v56 = 8 * (v53 - (unsigned int)(v53 - 1));
    while ( 1 )
    {
      v10 = 0;
      v57 = v135[(unsigned __int64)v55 / 8];
      if ( v57 )
        v10 = 8LL * (unsigned int)(*(_DWORD *)(v57 + 24) + 1);
      v58 = (__int64 *)(v10 + *(_QWORD *)(v54 + 24));
      v59 = *v58;
      *(_BYTE *)(v54 + 112) = 0;
      v131 = (_QWORD *)v59;
      v11 = *(_QWORD *)(v59 + 8);
      if ( v11 )
      {
        v60 = sub_2E6C3E0(
                *(_QWORD **)(v11 + 24),
                *(_QWORD *)(v11 + 24) + 8LL * *(unsigned int *)(v11 + 32),
                (__int64 *)&v131);
        v63 = (__int64 *)(v62 + v61 - 8);
        v64 = *v60;
        *v60 = *v63;
        *v63 = v64;
        --*(_DWORD *)(v11 + 32);
        v58 = (__int64 *)(v10 + *(_QWORD *)(v54 + 24));
      }
      v65 = *v58;
      *v58 = 0;
      if ( v65 )
      {
        v66 = *(_QWORD *)(v65 + 24);
        if ( v66 != v65 + 40 )
          _libc_free(v66);
        j_j___libc_free_0(v65);
      }
      if ( v56 == v55 )
        break;
      v55 -= 8;
    }
    a1 = v54;
    v52 = v121;
  }
  if ( a3 == v52 )
    goto LABEL_99;
  v118 = *(_DWORD *)(v52 + 16);
  v67 = *(__int64 **)(v52 + 8);
  LODWORD(v136) = 0;
  v115 = v67;
  v68 = 0;
  if ( !HIDWORD(v136) )
  {
    sub_C8D5F0((__int64)&v135, v137, 1u, 8u, v10, v11);
    v68 = (unsigned int)v136;
  }
  v135[v68] = 0;
  v69 = (unsigned int)v139;
  v70 = (__int64)v138;
  LODWORD(v136) = v136 + 1;
  v71 = v138;
  v72 = &v138[56 * (unsigned int)v139];
  if ( v138 != v72 )
  {
    do
    {
      v72 -= 56;
      v73 = *((_QWORD *)v72 + 3);
      if ( (_BYTE *)v73 != v72 + 40 )
        _libc_free(v73);
    }
    while ( v71 != v72 );
  }
  LODWORD(v139) = 0;
  v74 = *(_QWORD **)v52;
  v75 = 0;
  v134 = 0;
  v131 = &v133;
  v133 = v74;
  v132 = 0x4000000001LL;
  *(_DWORD *)(sub_2E6F1C0((__int64)&v135, (__int64)v74, v70, v69, v10, v11) + 4) = 0;
  for ( i = v132; (_DWORD)v132; i = v132 )
  {
    while ( 1 )
    {
      v81 = (__int64)&v131[2 * i - 2];
      v82 = *(_QWORD *)v81;
      v83 = *(_DWORD *)(v81 + 8);
      LODWORD(v132) = i - 1;
      v74 = (_QWORD *)v82;
      v122 = v83;
      v84 = sub_2E6F1C0((__int64)v7, v82, v81, (__int64)v131, v78, v79);
      v85 = v122;
      v86 = v84;
      v87 = *(unsigned int *)(v84 + 32);
      v77 = *(unsigned int *)(v86 + 36);
      if ( v87 + 1 > v77 )
      {
        v74 = (_QWORD *)(v86 + 40);
        sub_C8D5F0(v86 + 24, (const void *)(v86 + 40), v87 + 1, 4u, v78, v79);
        v87 = *(unsigned int *)(v86 + 32);
        v85 = v122;
      }
      v76 = *(_QWORD *)(v86 + 24);
      *(_DWORD *)(v76 + 4 * v87) = v85;
      v88 = *(_DWORD *)v86;
      ++*(_DWORD *)(v86 + 32);
      if ( !v88 )
      {
        ++v75;
        *(_DWORD *)(v86 + 4) = v85;
        *(_DWORD *)(v86 + 12) = v75;
        *(_DWORD *)(v86 + 8) = v75;
        *(_DWORD *)v86 = v75;
        sub_2E6D5A0((__int64)v7, v82, v76, v77, v78, v79);
        v74 = (_QWORD *)v82;
        sub_2E6EC80(&v125, v82, v141, v89, v90);
        v91 = v125;
        v92 = &v125[v126];
        if ( v125 != v92 )
        {
          v79 = (__int64)v7;
          v78 = v118;
          v93 = v75;
          v94 = v108;
          do
          {
            v100 = *v91;
            if ( *v91 )
            {
              v76 = (unsigned int)(*(_DWORD *)(v100 + 24) + 1);
              v95 = *(_DWORD *)(v100 + 24) + 1;
            }
            else
            {
              v95 = 0;
              v76 = 0;
            }
            if ( v95 < *(_DWORD *)(a1 + 32) )
            {
              v96 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v76);
              if ( v96 )
              {
                if ( (unsigned int)v78 < *(_DWORD *)(v96 + 16) )
                {
                  v77 = HIDWORD(v132);
                  v97 = (unsigned int)v132;
                  v98 = v94 & 0xFFFFFFFF00000000LL | v93;
                  v76 = (unsigned int)v132 + 1LL;
                  v94 = v98;
                  if ( v76 > HIDWORD(v132) )
                  {
                    v74 = &v133;
                    v109 = v79;
                    v111 = v92;
                    v112 = v78;
                    v123 = v98;
                    sub_C8D5F0((__int64)&v131, &v133, v76, 0x10u, v78, v79);
                    v97 = (unsigned int)v132;
                    v79 = v109;
                    v92 = v111;
                    v78 = v112;
                    v98 = v123;
                  }
                  v99 = &v131[2 * v97];
                  *v99 = v100;
                  v99[1] = v98;
                  LODWORD(v132) = v132 + 1;
                }
              }
            }
            ++v91;
          }
          while ( v92 != v91 );
          v92 = v125;
          v108 = v94;
          v75 = v93;
          v7 = (_QWORD *)v79;
        }
        if ( v92 != (__int64 *)v127 )
          break;
      }
      i = v132;
      if ( !(_DWORD)v132 )
        goto LABEL_84;
    }
    _libc_free((unsigned __int64)v92);
  }
LABEL_84:
  if ( v131 != &v133 )
    _libc_free((unsigned __int64)v131);
  sub_2E6F370((__int64)v7, (__int64)v74, v76, v77, v78, v79);
  sub_2E6F7A0(v7, a1, *v115, v101, v102, v103);
  v104 = v138;
  v105 = (unsigned __int64)&v138[56 * (unsigned int)v139];
  if ( v138 != (_BYTE *)v105 )
  {
    do
    {
      v105 -= 56LL;
      v106 = *(_QWORD *)(v105 + 24);
      if ( v106 != v105 + 40 )
        _libc_free(v106);
    }
    while ( v104 != (_BYTE *)v105 );
    v105 = (unsigned __int64)v138;
  }
  if ( (_BYTE *)v105 != v140 )
    _libc_free(v105);
  if ( v135 != v137 )
    _libc_free((unsigned __int64)v135);
LABEL_95:
  if ( v128 != (__int64 *)v130 )
    _libc_free((unsigned __int64)v128);
}
