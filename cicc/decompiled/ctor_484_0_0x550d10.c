// Function: ctor_484_0
// Address: 0x550d10
//
int ctor_484_0()
{
  sub_D95050(&qword_5006540, 0, 0);
  qword_50065C8 = 0;
  qword_50065D8 = 0;
  qword_50065D0 = (__int64)&unk_49D9748;
  qword_5006540 = (__int64)&unk_49DC090;
  qword_50065E0 = (__int64)&unk_49DC1D0;
  qword_5006600 = (__int64)nullsub_23;
  qword_50065F8 = (__int64)sub_984030;
  sub_C53080(&qword_5006540, "enable-nontrivial-unswitch", 26);
  LOBYTE(qword_50065C8) = 0;
  LOWORD(qword_50065D8) = 256;
  qword_5006570 = 107;
  byte_500654C = byte_500654C & 0x9F | 0x20;
  qword_5006568 = (__int64)"Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.";
  sub_C53130(&qword_5006540);
  __cxa_atexit(sub_984900, &qword_5006540, &qword_4A427C0);
  sub_D95050(&qword_5006460, 0, 0);
  qword_50064E8 = 0;
  qword_5006520 = (__int64)nullsub_58;
  qword_50064F0 = (__int64)&unk_49DA090;
  qword_5006518 = (__int64)sub_B2B5F0;
  qword_50064F8 = 0;
  qword_5006460 = (__int64)&unk_49DBF90;
  qword_5006500 = (__int64)&unk_49DC230;
  sub_C53080(&qword_5006460, "unswitch-threshold", 18);
  LODWORD(qword_50064E8) = 200;
  qword_5006488 = (__int64)"The cost threshold for unswitching a loop.";
  BYTE4(qword_50064F8) = 1;
  LODWORD(qword_50064F8) = 200;
  qword_5006490 = 42;
  byte_500646C = byte_500646C & 0x9F | 0x20;
  sub_C53130(&qword_5006460);
  __cxa_atexit(sub_B2B680, &qword_5006460, &qword_4A427C0);
  sub_D95050(&qword_5006380, 0, 0);
  qword_5006410 = (__int64)&unk_49D9748;
  qword_5006440 = (__int64)nullsub_23;
  qword_5006438 = (__int64)sub_984030;
  qword_5006380 = (__int64)&unk_49DC090;
  qword_5006420 = (__int64)&unk_49DC1D0;
  qword_5006408 = 0;
  qword_5006418 = 0;
  sub_C53080(&qword_5006380, "unswitch-uniform-only", 21);
  LOWORD(qword_5006418) = 257;
  LOBYTE(qword_5006408) = 1;
  qword_50063B0 = 33;
  qword_50063A8 = (__int64)"Only unswitch uniform conditions.";
  byte_500638C = byte_500638C & 0x9F | 0x20;
  sub_C53130(&qword_5006380);
  __cxa_atexit(sub_984900, &qword_5006380, &qword_4A427C0);
  sub_D95050(&qword_50062A0, 0, 0);
  qword_5006328 = 0;
  qword_5006340 = (__int64)&unk_49DC230;
  qword_5006360 = (__int64)nullsub_58;
  qword_5006358 = (__int64)sub_B2B5F0;
  qword_50062A0 = (__int64)&unk_49DBF90;
  qword_5006330 = (__int64)&unk_49DA090;
  qword_5006338 = 0;
  sub_C53080(&qword_50062A0, "unswitch-threshold-unroll", 25);
  qword_50062C8 = (__int64)"The cost threshold for unswitching a fully unrolled loop.";
  LODWORD(qword_5006328) = 300;
  BYTE4(qword_5006338) = 1;
  LODWORD(qword_5006338) = 300;
  byte_50062AC = byte_50062AC & 0x9F | 0x20;
  qword_50062D0 = 57;
  sub_C53130(&qword_50062A0);
  __cxa_atexit(sub_B2B680, &qword_50062A0, &qword_4A427C0);
  sub_D95050(&qword_50061C0, 0, 0);
  qword_5006248 = 0;
  qword_5006280 = (__int64)nullsub_24;
  qword_5006278 = (__int64)sub_984050;
  qword_5006250 = (__int64)&unk_49D9728;
  qword_50061C0 = (__int64)&unk_49DBF10;
  qword_5006260 = (__int64)&unk_49DC290;
  qword_5006258 = 0;
  sub_C53080(&qword_50061C0, "unswitch-max-switch-cases", 25);
  LODWORD(qword_5006248) = 4;
  BYTE4(qword_5006258) = 1;
  LODWORD(qword_5006258) = 4;
  qword_50061F0 = 86;
  qword_50061E8 = (__int64)"Max switch cases for fully unrolled loops where we increase the unswitching threshold.";
  byte_50061CC = byte_50061CC & 0x9F | 0x20;
  sub_C53130(&qword_50061C0);
  __cxa_atexit(sub_984970, &qword_50061C0, &qword_4A427C0);
  sub_D95050(&qword_50060E0, 0, 0);
  qword_5006170 = (__int64)&unk_49D9748;
  qword_50061A0 = (__int64)nullsub_23;
  qword_5006198 = (__int64)sub_984030;
  qword_50060E0 = (__int64)&unk_49DC090;
  qword_5006180 = (__int64)&unk_49DC1D0;
  qword_5006168 = 0;
  qword_5006178 = 0;
  sub_C53080(&qword_50060E0, "enable-unswitch-cost-multiplier", 31);
  LOWORD(qword_5006178) = 257;
  qword_5006108 = (__int64)"Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.";
  LOBYTE(qword_5006168) = 1;
  qword_5006110 = 92;
  byte_50060EC = byte_50060EC & 0x9F | 0x20;
  sub_C53130(&qword_50060E0);
  __cxa_atexit(sub_984900, &qword_50060E0, &qword_4A427C0);
  sub_D95050(&qword_5006000, 0, 0);
  qword_5006088 = 0;
  qword_50060A0 = (__int64)&unk_49DC230;
  qword_50060C0 = (__int64)nullsub_58;
  qword_50060B8 = (__int64)sub_B2B5F0;
  qword_5006000 = (__int64)&unk_49DBF90;
  qword_5006090 = (__int64)&unk_49DA090;
  qword_5006098 = 0;
  sub_C53080(&qword_5006000, "unswitch-siblings-toplevel-div", 30);
  qword_5006028 = (__int64)"Toplevel siblings divisor for cost multiplier.";
  LODWORD(qword_5006088) = 2;
  BYTE4(qword_5006098) = 1;
  LODWORD(qword_5006098) = 2;
  byte_500600C = byte_500600C & 0x9F | 0x20;
  qword_5006030 = 46;
  sub_C53130(&qword_5006000);
  __cxa_atexit(sub_B2B680, &qword_5006000, &qword_4A427C0);
  sub_D95050(&qword_5005F20, 0, 0);
  qword_5005FA8 = 0;
  qword_5005FB0 = (__int64)&unk_49DA090;
  qword_5005FC0 = (__int64)&unk_49DC230;
  qword_5005FE0 = (__int64)nullsub_58;
  qword_5005F20 = (__int64)&unk_49DBF90;
  qword_5005FD8 = (__int64)sub_B2B5F0;
  qword_5005FB8 = 0;
  sub_C53080(&qword_5005F20, "unswitch-num-initial-unscaled-candidates", 40);
  LODWORD(qword_5005FA8) = 8;
  BYTE4(qword_5005FB8) = 1;
  LODWORD(qword_5005FB8) = 8;
  qword_5005F50 = 80;
  byte_5005F2C = byte_5005F2C & 0x9F | 0x20;
  qword_5005F48 = (__int64)"Number of unswitch candidates that are ignored when calculating cost multiplier.";
  sub_C53130(&qword_5005F20);
  __cxa_atexit(sub_B2B680, &qword_5005F20, &qword_4A427C0);
  sub_D95050(&qword_5005E40, 0, 0);
  qword_5005ED0 = (__int64)&unk_49D9748;
  qword_5005F00 = (__int64)nullsub_23;
  qword_5005E40 = (__int64)&unk_49DC090;
  qword_5005EE0 = (__int64)&unk_49DC1D0;
  qword_5005EF8 = (__int64)sub_984030;
  qword_5005EC8 = 0;
  qword_5005ED8 = 0;
  sub_C53080(&qword_5005E40, "simple-loop-unswitch-guards", 27);
  LOWORD(qword_5005ED8) = 257;
  LOBYTE(qword_5005EC8) = 1;
  qword_5005E70 = 113;
  byte_5005E4C = byte_5005E4C & 0x9F | 0x20;
  qword_5005E68 = (__int64)"If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as "
                           "unswitch candidates.";
  sub_C53130(&qword_5005E40);
  __cxa_atexit(sub_984900, &qword_5005E40, &qword_4A427C0);
  sub_D95050(&qword_5005D60, 0, 0);
  qword_5005DF0 = (__int64)&unk_49D9748;
  qword_5005E20 = (__int64)nullsub_23;
  qword_5005D60 = (__int64)&unk_49DC090;
  qword_5005E00 = (__int64)&unk_49DC1D0;
  qword_5005E18 = (__int64)sub_984030;
  qword_5005DE8 = 0;
  qword_5005DF8 = 0;
  sub_C53080(&qword_5005D60, "simple-loop-unswitch-drop-non-trivial-implicit-null-checks", 58);
  LOBYTE(qword_5005DE8) = 0;
  LOWORD(qword_5005DF8) = 256;
  qword_5005D90 = 116;
  byte_5005D6C = byte_5005D6C & 0x9F | 0x20;
  qword_5005D88 = (__int64)"If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analy"
                           "zing if we can keep it.";
  sub_C53130(&qword_5005D60);
  __cxa_atexit(sub_984900, &qword_5005D60, &qword_4A427C0);
  sub_D95050(&qword_5005C80, 0, 0);
  qword_5005D40 = (__int64)nullsub_24;
  qword_5005D10 = (__int64)&unk_49D9728;
  qword_5005D20 = (__int64)&unk_49DC290;
  qword_5005C80 = (__int64)&unk_49DBF10;
  qword_5005D38 = (__int64)sub_984050;
  qword_5005D08 = 0;
  qword_5005D18 = 0;
  sub_C53080(&qword_5005C80, "simple-loop-unswitch-memoryssa-threshold", 40);
  qword_5005CB0 = 72;
  qword_5005CA8 = (__int64)"Max number of memory uses to explore during partial unswitching analysis";
  LODWORD(qword_5005D08) = 100;
  BYTE4(qword_5005D18) = 1;
  LODWORD(qword_5005D18) = 100;
  byte_5005C8C = byte_5005C8C & 0x9F | 0x20;
  sub_C53130(&qword_5005C80);
  __cxa_atexit(sub_984970, &qword_5005C80, &qword_4A427C0);
  sub_D95050(&qword_5005BA0, 0, 0);
  qword_5005C30 = (__int64)&unk_49D9748;
  qword_5005C60 = (__int64)nullsub_23;
  qword_5005BA0 = (__int64)&unk_49DC090;
  qword_5005C40 = (__int64)&unk_49DC1D0;
  qword_5005C58 = (__int64)sub_984030;
  qword_5005C28 = 0;
  qword_5005C38 = 0;
  sub_C53080(&qword_5005BA0, "freeze-loop-unswitch-cond", 25);
  LOWORD(qword_5005C38) = 257;
  LOBYTE(qword_5005C28) = 1;
  qword_5005BD0 = 105;
  byte_5005BAC = byte_5005BAC & 0x9F | 0x20;
  qword_5005BC8 = (__int64)"If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.";
  sub_C53130(&qword_5005BA0);
  __cxa_atexit(sub_984900, &qword_5005BA0, &qword_4A427C0);
  sub_D95050(&qword_5005AC0, 0, 0);
  qword_5005B50 = (__int64)&unk_49D9748;
  qword_5005B80 = (__int64)nullsub_23;
  qword_5005AC0 = (__int64)&unk_49DC090;
  qword_5005B60 = (__int64)&unk_49DC1D0;
  qword_5005B78 = (__int64)sub_984030;
  qword_5005B48 = 0;
  qword_5005B58 = 0;
  sub_C53080(&qword_5005AC0, "simple-loop-unswitch-inject-invariant-conditions", 48);
  LOWORD(qword_5005B58) = 257;
  LOBYTE(qword_5005B48) = 1;
  qword_5005AF0 = 112;
  byte_5005ACC = byte_5005ACC & 0x9F | 0x20;
  qword_5005AE8 = (__int64)"Whether we should inject new invariants and unswitch them to eliminate some existing (non-inv"
                           "ariant) conditions.";
  sub_C53130(&qword_5005AC0);
  __cxa_atexit(sub_984900, &qword_5005AC0, &qword_4A427C0);
  sub_D95050(&qword_50059E0, 0, 0);
  qword_5005AA0 = (__int64)nullsub_24;
  qword_5005A70 = (__int64)&unk_49D9728;
  qword_50059E0 = (__int64)&unk_49DBF10;
  qword_5005A80 = (__int64)&unk_49DC290;
  qword_5005A98 = (__int64)sub_984050;
  qword_5005A68 = 0;
  qword_5005A78 = 0;
  sub_C53080(&qword_50059E0, "simple-loop-unswitch-inject-invariant-condition-hotness-threshold", 65);
  qword_5005A10 = 137;
  LODWORD(qword_5005A68) = 16;
  BYTE4(qword_5005A78) = 1;
  LODWORD(qword_5005A78) = 16;
  byte_50059EC = byte_50059EC & 0x9F | 0x20;
  qword_5005A08 = (__int64)"Only try to inject loop invariant conditions and unswitch on them to eliminate branches that "
                           "are not-taken 1/<this option> times or less.";
  sub_C53130(&qword_50059E0);
  return __cxa_atexit(sub_984970, &qword_50059E0, &qword_4A427C0);
}
