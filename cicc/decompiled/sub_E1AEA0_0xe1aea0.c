// Function: sub_E1AEA0
// Address: 0xe1aea0
//
__int64 __fastcall sub_E1AEA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // rdx
  char *v7; // r12
  signed __int64 v8; // rsi
  unsigned __int64 v9; // rdi
  __int64 result; // rax
  char *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  unsigned int v15; // eax
  unsigned __int64 v16; // rdx
  char v17; // dl
  __int64 v18; // rcx
  char v19; // dl
  unsigned __int64 v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r12
  __int16 v26; // cx
  unsigned __int8 v27; // dl
  __int16 v28; // dx
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // r12
  __int16 v34; // cx
  unsigned __int8 v35; // dl
  __int16 v36; // dx
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  unsigned __int64 v41; // r12
  char *v42; // rax
  char v43; // al
  __int64 v44; // rdx
  __int64 v45; // rcx
  __int64 v46; // r8
  __int64 v47; // r9
  __int64 v48; // rdx
  __int64 v49; // rcx
  __int64 v50; // r8
  __int64 v51; // r9
  __int64 v52; // r12
  char v53; // dl
  int v54; // edx
  signed __int64 v55; // rax
  __int64 v56; // rdx
  __int64 v57; // rcx
  __int64 v58; // r8
  __int64 v59; // r9
  __int64 v60; // r12
  char *v61; // rax
  char v62; // r13
  __int64 v63; // rdx
  __int64 v64; // rcx
  __int64 v65; // r8
  __int64 v66; // r9
  __int64 v67; // r12
  char v68; // dl
  __int64 v69; // rdx
  __int64 v70; // rcx
  __int64 v71; // r8
  __int64 v72; // r9
  __int64 v73; // r12
  __int16 v74; // cx
  unsigned __int8 v75; // dl
  __int16 v76; // dx
  __int64 v77; // r12
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 v80; // r8
  __int64 v81; // r9
  __int64 v82; // r13
  __int16 v83; // cx
  unsigned __int8 v84; // dl
  __int16 v85; // dx
  bool v86; // zf
  const char *v87; // r13
  size_t v88; // rax
  size_t v89; // r14
  __int64 v90; // rdx
  __int64 v91; // rcx
  __int64 v92; // r8
  __int64 v93; // r9
  __int64 v94; // r12
  char v95; // dl
  signed __int64 v96; // rax
  __int64 v97; // rdx
  __int64 v98; // rcx
  __int64 v99; // r8
  __int64 v100; // r9
  __int64 v101; // rdx
  __int64 v102; // rcx
  __int64 v103; // r8
  __int64 v104; // r9
  __int64 v105; // r12
  char *v106; // rax
  char v107; // dl
  __int64 v108; // rdx
  __int64 v109; // rcx
  __int64 v110; // r8
  __int64 v111; // r9
  __int64 v112; // r13
  char v113; // dl
  char *v114; // rax
  __int64 v115; // r12
  char *v116; // rax
  __int64 v117; // rdx
  __int64 v118; // rcx
  __int64 v119; // r8
  __int64 v120; // r9
  __int64 v121; // r13
  char v122; // dl
  char *v123; // rdx
  char v124; // al
  __int64 v125; // rdx
  __int64 v126; // r13
  _QWORD *v127; // r12
  _QWORD *v128; // rax
  __int64 v129; // rdx
  char v130; // dl
  unsigned __int64 v131; // rdx
  char v132; // al
  char *v133; // rcx
  char v134; // al
  char v135; // al
  __int64 v136; // rdx
  __int64 v137; // rcx
  __int64 v138; // r8
  __int64 v139; // r9
  __int64 v140; // r13
  char *v141; // rax
  char v142; // cl
  __int64 v143; // rdx
  __int64 v144; // rcx
  __int64 v145; // r8
  __int64 v146; // r9
  __int64 v147; // r10
  __int64 v148; // rdx
  __int64 v149; // rcx
  __int64 v150; // r8
  __int64 v151; // r9
  __int64 v152; // r13
  char *v153; // rax
  _QWORD *v154; // r12
  _QWORD *v155; // rax
  char v156; // dl
  __int64 v157; // rdx
  __int64 v158; // rcx
  __int64 v159; // r8
  __int64 v160; // r9
  __int64 v161; // r12
  char v162; // dl
  signed __int64 v163; // rax
  __int64 v164; // rdx
  __int64 v165; // rcx
  __int64 v166; // r8
  __int64 v167; // r9
  __int64 v168; // r8
  __int64 v169; // r9
  char *v170; // rax
  __int64 v171; // rcx
  __int64 v172; // rdx
  __int64 v173; // rcx
  __int64 v174; // r8
  __int64 v175; // r9
  char v176; // al
  char v177; // dl
  char *v178; // [rsp+8h] [rbp-38h]
  unsigned __int8 v179; // [rsp+17h] [rbp-29h] BYREF
  __int64 v180[5]; // [rsp+18h] [rbp-28h] BYREF

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(char **)a1;
  v180[0] = 0;
  if ( v7 != (char *)v6 )
  {
    v8 = (unsigned __int8)*v7;
    v9 = v6 - (_QWORD)v7;
    switch ( (char)v8 )
    {
      case 'A':
        *(_QWORD *)a1 = v7 + 1;
        if ( (char *)v6 == v7 + 1 )
          goto LABEL_158;
        v54 = v7[1];
        if ( (unsigned int)(v54 - 48) > 9 )
        {
          if ( (_BYTE)v54 == 95 )
          {
            *(_QWORD *)a1 = v7 + 2;
            v60 = 0;
            goto LABEL_104;
          }
LABEL_158:
          v60 = sub_E18BB0(a1);
          if ( !v60 )
            return 0;
        }
        else
        {
          v55 = sub_E0DEF0((char **)a1, 0);
          v60 = sub_E0FB60(a1 + 816, v55, v56, v57, v58, v59);
          if ( !v60 )
            return 0;
        }
        v61 = *(char **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v61 != 95 )
          return 0;
        *(_QWORD *)a1 = v61 + 1;
LABEL_104:
        v112 = sub_E1AEA0(a1);
        if ( !v112 )
          return 0;
        result = sub_E0E790(a1 + 816, 32, v108, v109, v110, v111);
        if ( result )
        {
          v113 = *(_BYTE *)(result + 10);
          *(_QWORD *)(result + 16) = v112;
          *(_WORD *)(result + 8) = 15;
          *(_QWORD *)(result + 24) = v60;
          *(_BYTE *)(result + 10) = v113 & 0xF0 | 4;
          v11 = (char *)&unk_49DF368;
          *(_QWORD *)result = &unk_49DF368;
          v180[0] = result;
          goto LABEL_6;
        }
        return result;
      case 'C':
        *(_QWORD *)a1 = v7 + 1;
        v52 = sub_E1AEA0(a1);
        if ( !v52 )
          return 0;
        result = sub_E0E790(a1 + 816, 40, v48, v49, v50, v51);
        if ( result )
        {
          v53 = *(_BYTE *)(result + 10);
          *(_QWORD *)(result + 16) = v52;
          *(_WORD *)(result + 8) = 16389;
          v12 = (__int64)" complex";
          *(_QWORD *)(result + 24) = 8;
          *(_QWORD *)(result + 32) = " complex";
          *(_BYTE *)(result + 10) = v53 & 0xF0 | 5;
          v11 = (char *)&unk_49DEF48;
          *(_QWORD *)result = &unk_49DEF48;
        }
        goto LABEL_4;
      case 'D':
        if ( v9 == 1 )
          return 0;
        break;
      case 'F':
        goto LABEL_19;
      case 'G':
        *(_QWORD *)a1 = v7 + 1;
        v67 = sub_E1AEA0(a1);
        if ( !v67 )
          return 0;
        result = sub_E0E790(a1 + 816, 40, v63, v64, v65, v66);
        if ( result )
        {
          v12 = (__int64)" imaginary";
          *(_QWORD *)(result + 16) = v67;
          *(_WORD *)(result + 8) = 16389;
          v68 = *(_BYTE *)(result + 10);
          *(_QWORD *)(result + 24) = 10;
          *(_QWORD *)(result + 32) = " imaginary";
          *(_BYTE *)(result + 10) = v68 & 0xF0 | 5;
          v11 = (char *)&unk_49DEF48;
          *(_QWORD *)result = &unk_49DEF48;
        }
        goto LABEL_4;
      case 'K':
      case 'V':
      case 'r':
        LOBYTE(v15) = (_BYTE)v8 == 114;
        v16 = (_BYTE)v8 == 114;
        if ( v9 <= v16 )
          goto LABEL_13;
        v17 = v7[v16];
        v15 = (unsigned __int8)v15;
        if ( v17 != 86 )
          goto LABEL_10;
        v15 = (unsigned __int8)v15 + 1;
        if ( v9 <= v15 )
          goto LABEL_13;
        v17 = v7[v15];
LABEL_10:
        if ( ((v18 = v15, v17 != 75) || (++v15, v18 = v15, v9 > v15))
          && ((v19 = v7[v18], v19 == 70)
           || v19 == 68
           && (v20 = v15 + 1, v9 > v20)
           && (v7[v20] == 111 || v7[v20] == 79 || v7[v20] == 119 || v7[v20] == 120)) )
        {
LABEL_19:
          result = sub_E20280(a1);
          v180[0] = result;
        }
        else
        {
LABEL_13:
          result = sub_E20040(a1);
          v180[0] = result;
        }
        goto LABEL_5;
      case 'M':
        *(_QWORD *)a1 = v7 + 1;
        v77 = sub_E1AEA0(a1);
        if ( !v77 )
          return 0;
        v82 = sub_E1AEA0(a1);
        if ( !v82 )
          return 0;
        result = sub_E0E790(a1 + 816, 32, v78, v79, v80, v81);
        if ( !result )
          return result;
        v83 = *(_WORD *)(result + 8);
        v84 = *(_BYTE *)(v82 + 9);
        *(_QWORD *)(result + 16) = v77;
        *(_QWORD *)(result + 24) = v82;
        *(_WORD *)(result + 8) = v83 & 0xC000 | 0xE;
        v12 = *(unsigned __int16 *)(result + 9);
        v85 = v84 >> 6 << 6;
        HIBYTE(v85) |= 5u;
        LOWORD(v12) = v12 & 0xF03F;
        *(_WORD *)(result + 9) = v12 | v85;
        v11 = (char *)&unk_49DF308;
        *(_QWORD *)result = &unk_49DF308;
        v180[0] = result;
        goto LABEL_6;
      case 'O':
        *(_QWORD *)a1 = v7 + 1;
        v73 = sub_E1AEA0(a1);
        if ( !v73 )
          return 0;
        result = sub_E0E790(a1 + 816, 32, v69, v70, v71, v72);
        if ( result )
        {
          v74 = *(_WORD *)(result + 8);
          v75 = *(_BYTE *)(v73 + 9);
          *(_QWORD *)(result + 16) = v73;
          *(_DWORD *)(result + 24) = 1;
          *(_BYTE *)(result + 28) = 0;
          *(_WORD *)(result + 8) = v74 & 0xC000 | 0xD;
          v12 = *(unsigned __int16 *)(result + 9);
          v76 = v75 >> 6 << 6;
          HIBYTE(v76) |= 5u;
          LOWORD(v12) = v12 & 0xF03F;
          *(_WORD *)(result + 9) = v12 | v76;
          v11 = (char *)&unk_49DF2A8;
          *(_QWORD *)result = &unk_49DF2A8;
        }
        goto LABEL_4;
      case 'P':
        *(_QWORD *)a1 = v7 + 1;
        v33 = sub_E1AEA0(a1);
        if ( !v33 )
          return 0;
        result = sub_E0E790(a1 + 816, 24, v29, v30, v31, v32);
        if ( result )
        {
          v34 = *(_WORD *)(result + 8);
          v35 = *(_BYTE *)(v33 + 9);
          *(_QWORD *)(result + 16) = v33;
          *(_WORD *)(result + 8) = v34 & 0xC000 | 0xC;
          v12 = *(unsigned __int16 *)(result + 9);
          v36 = v35 >> 6 << 6;
          HIBYTE(v36) |= 5u;
          LOWORD(v12) = v12 & 0xF03F;
          *(_WORD *)(result + 9) = v12 | v36;
          v11 = (char *)&unk_49DF248;
          *(_QWORD *)result = &unk_49DF248;
        }
        goto LABEL_4;
      case 'R':
        *(_QWORD *)a1 = v7 + 1;
        v25 = sub_E1AEA0(a1);
        if ( !v25 )
          return 0;
        result = sub_E0E790(a1 + 816, 32, v21, v22, v23, v24);
        if ( result )
        {
          v26 = *(_WORD *)(result + 8);
          v27 = *(_BYTE *)(v25 + 9);
          *(_QWORD *)(result + 16) = v25;
          *(_DWORD *)(result + 24) = 0;
          *(_BYTE *)(result + 28) = 0;
          *(_WORD *)(result + 8) = v26 & 0xC000 | 0xD;
          v12 = *(unsigned __int16 *)(result + 9);
          v28 = v27 >> 6 << 6;
          HIBYTE(v28) |= 5u;
          LOWORD(v12) = v12 & 0xF03F;
          *(_WORD *)(result + 9) = v12 | v28;
          v11 = (char *)&unk_49DF2A8;
          *(_QWORD *)result = &unk_49DF2A8;
        }
        goto LABEL_4;
      case 'S':
        if ( v9 != 1 && v7[1] == 116 )
          goto LABEL_3;
        v179 = 0;
        result = sub_E1EC70(a1, 0, &v179);
        v180[0] = result;
        if ( !result )
          return 0;
        v11 = *(char **)a1;
        v12 = v179;
        if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || *v11 != 73 )
        {
          if ( !v179 )
            goto LABEL_5;
          return result;
        }
        if ( v179 )
        {
          if ( !*(_BYTE *)(a1 + 776) )
            return result;
        }
        else
        {
LABEL_43:
          sub_E18380(a1 + 296, v180, (__int64)v11, v12, v13, v14);
        }
        v44 = sub_E1F700(a1, 0);
        if ( !v44 )
          return 0;
        result = sub_E0FC10(a1 + 816, v180[0], v44, v45, v46, v47);
        v180[0] = result;
        goto LABEL_5;
      case 'T':
        if ( v9 != 1 )
        {
          v43 = v7[1];
          if ( v43 == 115 || (v43 & 0xEF) == 0x65 )
            goto LABEL_3;
        }
        v180[0] = sub_E18810(a1, v8, v6, a4, a5);
        if ( !v180[0] )
          return 0;
        if ( *(_BYTE *)(a1 + 776) && *(_QWORD *)(a1 + 8) != *(_QWORD *)a1 && **(_BYTE **)a1 == 73 )
          goto LABEL_43;
        goto LABEL_6;
      case 'U':
        goto LABEL_13;
      case 'a':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "signed char");
      case 'b':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "bool");
      case 'c':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "char");
      case 'd':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "double");
      case 'e':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "long double");
      case 'f':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "float");
      case 'g':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "__float128");
      case 'h':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned char");
      case 'i':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "int");
      case 'j':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned int");
      case 'l':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "long");
      case 'm':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned long");
      case 'n':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "__int128");
      case 'o':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned __int128");
      case 's':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "short");
      case 't':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned short");
      case 'u':
        *(_QWORD *)a1 = v7 + 1;
        v41 = sub_E0F8D0(a1);
        if ( !v41 )
          return 0;
        v42 = *(char **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v42 != 73 )
        {
          result = sub_E0FB60(a1 + 816, v41, v37, v38, v39, v40);
          v180[0] = result;
          goto LABEL_5;
        }
        v178 = (char *)v37;
        *(_QWORD *)a1 = v42 + 1;
        v140 = sub_E1AEA0(a1);
        if ( !v140 )
          return 0;
        v141 = *(char **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v141 != 69 )
          return 0;
        *(_QWORD *)a1 = v141 + 1;
        result = sub_E0E790(a1 + 816, 40, v136, v137, v138, v139);
        if ( result )
        {
          v142 = *(_BYTE *)(result + 10);
          v11 = v178;
          *(_WORD *)(result + 8) = 16391;
          *(_QWORD *)(result + 16) = v41;
          *(_QWORD *)(result + 24) = v178;
          *(_QWORD *)(result + 32) = v140;
          *(_BYTE *)(result + 10) = v142 & 0xF0 | 5;
          v12 = (__int64)&unk_49DF0C8;
          *(_QWORD *)result = &unk_49DF0C8;
        }
        goto LABEL_4;
      case 'v':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "void");
      case 'w':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "wchar_t");
      case 'x':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "long long");
      case 'y':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "unsigned long long");
      case 'z':
        *(_QWORD *)a1 = v7 + 1;
        return sub_E0FD70(a1 + 816, "...");
      default:
        goto LABEL_3;
    }
    v62 = v7[1];
    switch ( v62 )
    {
      case 'A':
        v123 = v7 + 3;
        if ( v9 == 2 )
          goto LABEL_170;
        v124 = v7[2];
        *(_QWORD *)a1 = v123;
        switch ( v124 )
        {
          case 'i':
            result = sub_E0FD70(a1 + 816, "_Accum");
            break;
          case 'j':
            result = sub_E0FD70(a1 + 816, "unsigned _Accum");
            break;
          case 'l':
            result = sub_E0FD70(a1 + 816, "long _Accum");
            break;
          case 'm':
            result = sub_E0FD70(a1 + 816, "unsigned long _Accum");
            break;
          case 's':
            result = sub_E0FD70(a1 + 816, "short _Accum");
            break;
          case 't':
            result = sub_E0FD70(a1 + 816, "unsigned short _Accum");
            break;
          default:
            return 0;
        }
        return result;
      case 'B':
      case 'U':
        *(_QWORD *)a1 = v7 + 2;
        if ( v7 + 2 == (char *)v6 || (unsigned int)(v7[2] - 48) > 9 )
        {
          v105 = sub_E18BB0(a1);
        }
        else
        {
          v96 = sub_E0DEF0((char **)a1, 0);
          v105 = sub_E0FB60(a1 + 816, v96, v97, v98, v99, v100);
        }
        if ( !v105 )
          return 0;
        v106 = *(char **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v106 != 95 )
          return 0;
        *(_QWORD *)a1 = v106 + 1;
        result = sub_E0E790(a1 + 816, 32, v101, v102, v103, v104);
        if ( result )
        {
          v107 = *(_BYTE *)(result + 10);
          *(_WORD *)(result + 8) = 16416;
          *(_QWORD *)(result + 16) = v105;
          *(_BYTE *)(result + 10) = v107 & 0xF0 | 5;
          *(_QWORD *)result = &unk_49DF008;
          *(_BYTE *)(result + 24) = v62 == 66;
        }
        return result;
      case 'F':
        *(_QWORD *)a1 = v7 + 2;
        if ( (unsigned __int8)sub_E0F5E0((const void **)a1, 3u, "16b") )
          return sub_E0FD70(a1 + 816, "std::bfloat16_t");
        v8 = sub_E0DEF0((char **)a1, 0);
        v152 = sub_E0FB60(v147, v8, v143, v144, v145, v146);
        if ( !v152 )
          return 0;
        v153 = *(char **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v153 != 95 )
          return 0;
        v154 = *(_QWORD **)(a1 + 4912);
        *(_QWORD *)a1 = v153 + 1;
        if ( (unsigned __int64)(v154[1] + 32LL) > 0xFEF )
        {
          v155 = (_QWORD *)malloc(4096, v8, v148, v149, v150, v151);
          if ( !v155 )
LABEL_207:
            sub_2207530(4096, v8, v129);
          v155[1] = 0;
          *(_QWORD *)(a1 + 4912) = v155;
          *v155 = v154;
          v154 = v155;
        }
        v154[1] += 32LL;
        result = *(_QWORD *)(a1 + 4912) + *(_QWORD *)(*(_QWORD *)(a1 + 4912) + 8LL) - 16LL;
        v156 = *(_BYTE *)(result + 10);
        *(_WORD *)(result + 8) = 16415;
        *(_QWORD *)(result + 16) = v152;
        *(_BYTE *)(result + 10) = v156 & 0xF0 | 5;
        *(_QWORD *)result = &unk_49DF9C8;
        return result;
      case 'K':
      case 'k':
        v86 = v62 == 107;
        v87 = " auto";
        if ( !v86 )
          v87 = " decltype(auto)";
        v88 = strlen(v87);
        *(_QWORD *)a1 = v7 + 2;
        v89 = v88;
        v94 = sub_E1D370(a1, 0);
        if ( !v94 )
          return 0;
        result = sub_E0E790(a1 + 816, 40, v90, v91, v92, v93);
        if ( result )
        {
          v95 = *(_BYTE *)(result + 10);
          *(_WORD *)(result + 8) = 16389;
          *(_QWORD *)(result + 16) = v94;
          *(_QWORD *)(result + 24) = v89;
          *(_QWORD *)(result + 32) = v87;
          *(_BYTE *)(result + 10) = v95 & 0xF0 | 5;
          *(_QWORD *)result = &unk_49DEF48;
        }
        return result;
      case 'O':
      case 'o':
      case 'w':
      case 'x':
        goto LABEL_19;
      case 'R':
        v123 = v7 + 3;
        if ( v9 == 2 )
        {
LABEL_170:
          *(_QWORD *)a1 = v123;
          return 0;
        }
        else
        {
          v135 = v7[2];
          *(_QWORD *)a1 = v123;
          switch ( v135 )
          {
            case 'i':
              result = sub_E0FD70(a1 + 816, "_Fract");
              break;
            case 'j':
              result = sub_E0FD70(a1 + 816, "unsigned _Fract");
              break;
            case 'l':
              result = sub_E0FD70(a1 + 816, "long _Fract");
              break;
            case 'm':
              result = sub_E0FD70(a1 + 816, "unsigned long _Fract");
              break;
            case 's':
              result = sub_E0FD70(a1 + 816, "short _Fract");
              break;
            case 't':
              result = sub_E0FD70(a1 + 816, "unsigned short _Fract");
              break;
            default:
              return 0;
          }
        }
        return result;
      case 'S':
        *(_QWORD *)a1 = v7 + 2;
        if ( v7 + 2 == (char *)v6 )
          return 0;
        v131 = v6 - (_QWORD)(v7 + 2);
        if ( v7[2] != 68 || v131 <= 1 )
          return 0;
        v132 = v7[3];
        if ( v132 != 65 )
        {
          if ( v132 != 82 )
            return 0;
          v133 = v7 + 5;
          if ( v131 != 2 )
          {
            v134 = v7[4];
            *(_QWORD *)a1 = v133;
            switch ( v134 )
            {
              case 'i':
                result = sub_E0FD70(a1 + 816, "_Sat _Fract");
                break;
              case 'j':
                result = sub_E0FD70(a1 + 816, "_Sat unsigned _Fract");
                break;
              case 'l':
                result = sub_E0FD70(a1 + 816, "_Sat long _Fract");
                break;
              case 'm':
                result = sub_E0FD70(a1 + 816, "_Sat unsigned long _Fract");
                break;
              case 's':
                result = sub_E0FD70(a1 + 816, "_Sat short _Fract");
                break;
              case 't':
                result = sub_E0FD70(a1 + 816, "_Sat unsigned short _Fract");
                break;
              default:
                return 0;
            }
            return result;
          }
LABEL_196:
          *(_QWORD *)a1 = v133;
          return 0;
        }
        v133 = v7 + 5;
        if ( v131 == 2 )
          goto LABEL_196;
        v176 = v7[4];
        *(_QWORD *)a1 = v133;
        switch ( v176 )
        {
          case 'i':
            result = sub_E0FD70(a1 + 816, "_Sat _Accum");
            break;
          case 'j':
            result = sub_E0FD70(a1 + 816, "_Sat unsigned _Accum");
            break;
          case 'l':
            result = sub_E0FD70(a1 + 816, "_Sat long _Accum");
            break;
          case 'm':
            result = sub_E0FD70(a1 + 816, "_Sat unsigned long _Accum");
            break;
          case 's':
            result = sub_E0FD70(a1 + 816, "_Sat short _Accum");
            break;
          case 't':
            result = sub_E0FD70(a1 + 816, "_Sat unsigned short _Accum");
            break;
          default:
            return 0;
        }
        return result;
      case 'T':
      case 't':
        result = sub_E1AB20((_QWORD *)a1);
        v180[0] = result;
        goto LABEL_5;
      case 'a':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "auto");
      case 'c':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "decltype(auto)");
      case 'd':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "decimal64");
      case 'e':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "decimal128");
      case 'f':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "decimal32");
      case 'h':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "half");
      case 'i':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "char32_t");
      case 'n':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "std::nullptr_t");
      case 'p':
        *(_QWORD *)a1 = v7 + 2;
        v126 = sub_E1AEA0(a1);
        if ( !v126 )
          return 0;
        v127 = *(_QWORD **)(a1 + 4912);
        if ( (unsigned __int64)(v127[1] + 32LL) <= 0xFEF )
          goto LABEL_126;
        v128 = (_QWORD *)malloc(4096, v8, v125, v12, v13, v14);
        if ( !v128 )
          goto LABEL_207;
        v128[1] = 0;
        *(_QWORD *)(a1 + 4912) = v128;
        *v128 = v127;
        v127 = v128;
LABEL_126:
        v127[1] += 32LL;
        result = *(_QWORD *)(a1 + 4912) + *(_QWORD *)(*(_QWORD *)(a1 + 4912) + 8LL) - 16LL;
        v130 = *(_BYTE *)(result + 10);
        *(_WORD *)(result + 8) = 16426;
        *(_QWORD *)(result + 16) = v126;
        *(_BYTE *)(result + 10) = v130 & 0xF0 | 5;
        v11 = (char *)&unk_49DFD88;
        *(_QWORD *)result = &unk_49DFD88;
        goto LABEL_117;
      case 's':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "char16_t");
      case 'u':
        *(_QWORD *)a1 = v7 + 2;
        return sub_E0FD70(a1 + 816, "char8_t");
      case 'v':
        if ( !(unsigned __int8)sub_E0F5E0((const void **)a1, 2u, "Dv") )
          return 0;
        v114 = *(char **)a1;
        if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 )
          goto LABEL_111;
        if ( (unsigned __int8)(*v114 - 49) <= 8u )
        {
          v163 = sub_E0DEF0((char **)a1, 0);
          v115 = sub_E0FB60(a1 + 816, v163, v164, v165, v166, v167);
          if ( !v115 )
            return 0;
          v170 = *(char **)a1;
          v171 = *(_QWORD *)(a1 + 8);
          if ( *(_QWORD *)a1 == v171 || *v170 != 95 )
            return 0;
          *(_QWORD *)a1 = v170 + 1;
          if ( (char *)v171 == v170 + 1 || v170[1] != 112 )
          {
            v121 = sub_E1AEA0(a1);
            if ( v121 )
            {
              result = sub_E0E790(a1 + 816, 32, v172, v173, v174, v175);
              if ( !result )
                return result;
              goto LABEL_116;
            }
            return 0;
          }
          *(_QWORD *)a1 = v170 + 2;
          result = sub_E0E790(a1 + 816, 24, (__int64)(v170 + 1), v171, v168, v169);
          if ( !result )
            return result;
          v177 = *(_BYTE *)(result + 10);
          *(_WORD *)(result + 8) = 16414;
          *(_QWORD *)(result + 16) = v115;
          *(_BYTE *)(result + 10) = v177 & 0xF0 | 5;
          v11 = (char *)&unk_49DF968;
          *(_QWORD *)result = &unk_49DF968;
        }
        else
        {
          if ( *v114 != 95 )
          {
LABEL_111:
            v115 = sub_E18BB0(a1);
            if ( v115 )
            {
              v116 = *(char **)a1;
              if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v116 == 95 )
              {
                *(_QWORD *)a1 = v116 + 1;
                v121 = sub_E1AEA0(a1);
                if ( v121 )
                {
                  result = sub_E0E790(a1 + 816, 32, v117, v118, v119, v120);
                  if ( !result )
                    return result;
LABEL_116:
                  v122 = *(_BYTE *)(result + 10);
                  *(_WORD *)(result + 8) = 16413;
                  *(_QWORD *)(result + 16) = v121;
                  *(_QWORD *)(result + 24) = v115;
                  *(_BYTE *)(result + 10) = v122 & 0xF0 | 5;
                  v11 = (char *)&unk_49DF908;
                  *(_QWORD *)result = &unk_49DF908;
                  goto LABEL_117;
                }
              }
            }
            return 0;
          }
          *(_QWORD *)a1 = v114 + 1;
          v161 = sub_E1AEA0(a1);
          if ( !v161 )
            return 0;
          result = sub_E0E790(a1 + 816, 32, v157, v158, v159, v160);
          if ( !result )
            return result;
          v162 = *(_BYTE *)(result + 10);
          *(_WORD *)(result + 8) = 16413;
          *(_QWORD *)(result + 16) = v161;
          *(_QWORD *)(result + 24) = 0;
          *(_BYTE *)(result + 10) = v162 & 0xF0 | 5;
          v11 = (char *)&unk_49DF908;
          *(_QWORD *)result = &unk_49DF908;
        }
LABEL_117:
        v180[0] = result;
        goto LABEL_6;
      default:
        return 0;
    }
  }
LABEL_3:
  result = sub_E1D980(a1);
LABEL_4:
  v180[0] = result;
LABEL_5:
  if ( result )
  {
LABEL_6:
    sub_E18380(a1 + 296, v180, (__int64)v11, v12, v13, v14);
    return v180[0];
  }
  return result;
}
