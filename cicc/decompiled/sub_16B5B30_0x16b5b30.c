// Function: sub_16B5B30
// Address: 0x16b5b30
//
__int64 __fastcall sub_16B5B30(size_t a1, int a2, const void *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const void *v6; // r10
  size_t v9; // r8
  void *v11; // rsi
  size_t v12; // rsi
  const char *v13; // r12
  unsigned __int64 v14; // rdx
  _BYTE *v15; // r14
  size_t v16; // r12
  __int64 v17; // rax
  unsigned __int64 *v18; // rdx
  _BYTE *v19; // rdi
  __int64 v20; // rdx
  char *v21; // rdi
  unsigned __int64 *v22; // rax
  __int64 v23; // rdi
  unsigned __int64 v24; // rdi
  __int64 v25; // r14
  const char *v26; // rax
  __int64 *v27; // r13
  __int64 v28; // r12
  __int64 *v29; // r15
  __int64 v30; // r12
  __int64 v31; // rax
  int v32; // ebx
  __int64 v33; // rcx
  __int64 v34; // r8
  void *v35; // r9
  __int32 v36; // ebx
  __int64 v37; // r10
  void *v38; // r12
  unsigned int v39; // ebx
  char v40; // r15
  __int64 v41; // r13
  __int64 v42; // rdx
  __int64 v43; // rax
  __int64 v44; // r9
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // r12
  unsigned int v49; // r15d
  __int64 v50; // r14
  __int64 v51; // rdx
  const char *v52; // rsi
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rdx
  const char *v59; // rsi
  __int64 v60; // rax
  __int64 v61; // rax
  __int64 v62; // rax
  unsigned int v63; // ebx
  size_t v64; // rax
  __int64 v65; // rax
  unsigned __int8 v66; // r13
  __int64 v67; // r12
  unsigned int v68; // r14d
  __int64 v69; // rbx
  __int64 v70; // rax
  char **v71; // rax
  char *v72; // rcx
  __int64 v73; // r8
  __int64 v74; // rax
  unsigned int v75; // ebx
  __int64 v76; // rax
  unsigned __int8 v77; // r12
  __int64 v78; // rdi
  char **v79; // rax
  char *v80; // rcx
  __int64 v81; // r8
  char v82; // al
  __int64 v83; // rdx
  _QWORD *v84; // rcx
  _QWORD *v85; // r12
  __int64 v86; // rax
  _QWORD *v87; // r13
  __int64 v88; // r14
  __int64 v89; // r15
  _QWORD *v90; // rax
  __int64 v91; // rdx
  _QWORD *v92; // rax
  _DWORD *v93; // r8
  __int64 v94; // rcx
  __int64 v95; // r15
  __int64 v96; // rax
  __int64 v97; // r9
  __int64 v98; // rax
  _DWORD *v99; // r9
  _DWORD *v100; // r8
  __int64 v101; // rcx
  char v102; // al
  _BYTE *v103; // rbx
  size_t v104; // rax
  __int64 v105; // rdx
  size_t v106; // r12
  __int64 v107; // rax
  __int64 v108; // rax
  __int64 v109; // r9
  size_t v110; // rax
  size_t v111; // rax
  __int64 v112; // rax
  __m128i *v113; // rax
  __int64 v114; // rbx
  int v115; // r12d
  __int64 v116; // r13
  size_t v117; // rax
  __m128i *v118; // rax
  __int64 v119; // rdx
  const char *v120; // rsi
  __int64 v121; // rax
  __int64 v122; // rax
  __int64 v123; // rax
  __int64 v124; // rax
  const char *v125; // rsi
  __int64 v126; // rdi
  __int64 v127; // rax
  const char *v128; // rsi
  __int64 v129; // rdi
  __int64 v130; // rax
  __int64 v131; // rax
  __int64 v132; // rax
  unsigned __int64 *v133; // r13
  unsigned __int64 *v134; // rbx
  unsigned __int64 v135; // rdi
  unsigned __int64 *v136; // rbx
  unsigned __int64 *v137; // r13
  unsigned __int64 v138; // rdi
  __int64 *v140; // rbx
  __int64 *v141; // r12
  __int64 v142; // r14
  size_t v143; // r9
  void (__fastcall *v144)(__int64, _QWORD, const char *, _QWORD, const char *, size_t, _QWORD); // r15
  const char *v145; // r8
  unsigned int v146; // r13d
  size_t v147; // rax
  unsigned __int64 *v148; // rdi
  unsigned __int64 v149; // rcx
  unsigned __int64 v150; // rdi
  __int64 v151; // rdx
  size_t v152; // r12
  __int64 v153; // rax
  __int64 v154; // rdx
  const char *v155; // rsi
  __int64 v156; // rax
  __int64 v157; // rax
  __int64 v158; // rax
  __int64 v159; // r8
  char *v160; // rcx
  unsigned int v161; // r12d
  unsigned int v162; // ebx
  unsigned __int8 v163; // al
  __int64 v164; // rax
  char **v165; // rax
  char *v166; // rcx
  __int64 v167; // r8
  bool v168; // zf
  char **v169; // rax
  char *v170; // rcx
  __int64 v171; // r8
  __int64 v172; // rdx
  size_t v173; // r8
  char *v174; // r12
  __int32 v175; // ebx
  __int64 v176; // rdi
  unsigned __int64 v177; // rdx
  unsigned __int64 v178; // rax
  __int64 v179; // r10
  __int64 v180; // rax
  char v181; // al
  __int64 v182; // rsi
  unsigned __int64 v183; // rax
  __int64 v184; // rdx
  __int64 v185; // rdi
  __int64 v186; // rdx
  __int64 v187; // rdx
  __int64 *v188; // rax
  __int64 *v189; // r12
  __int64 v190; // rcx
  unsigned int v191; // r14d
  __int64 v192; // rcx
  __int64 v193; // rbx
  unsigned __int8 v194; // al
  __int128 v195; // kr00_16
  const __m128i *v196; // r12
  unsigned int v197; // ebx
  unsigned int v198; // eax
  unsigned int v199; // ecx
  _BYTE *v200; // rdi
  __int64 v201; // r8
  size_t v202; // rdi
  _BYTE *v203; // rdi
  _BYTE *v204; // rax
  __int64 v205; // r8
  size_t v206; // rdx
  __int64 v207; // rax
  __int64 *v208; // rax
  __int64 v209; // rdx
  size_t v210; // rdx
  __int64 v211; // rax
  __int64 v212; // rax
  __int64 v213; // r9
  __int64 v214; // rcx
  __m128i v215; // xmm5
  size_t v216; // [rsp-10h] [rbp-4B0h]
  __int64 v217; // [rsp-10h] [rbp-4B0h]
  size_t v218; // [rsp-10h] [rbp-4B0h]
  __int64 v219; // [rsp-10h] [rbp-4B0h]
  unsigned __int64 v220; // [rsp-8h] [rbp-4A8h]
  void *v221; // [rsp-8h] [rbp-4A8h]
  size_t v222; // [rsp-8h] [rbp-4A8h]
  __int64 *v223; // [rsp+8h] [rbp-498h]
  __int64 *v224; // [rsp+10h] [rbp-490h]
  int v225; // [rsp+1Ch] [rbp-484h]
  __int64 v226; // [rsp+20h] [rbp-480h]
  __int64 v227; // [rsp+28h] [rbp-478h]
  const __m128i *v228; // [rsp+30h] [rbp-470h]
  __int64 v229; // [rsp+40h] [rbp-460h]
  __int64 v230; // [rsp+50h] [rbp-450h]
  __int64 v231; // [rsp+90h] [rbp-410h]
  unsigned int v232; // [rsp+98h] [rbp-408h]
  bool v233; // [rsp+9Dh] [rbp-403h]
  char v234; // [rsp+9Eh] [rbp-402h]
  unsigned __int8 v235; // [rsp+9Fh] [rbp-401h]
  __int64 v236; // [rsp+A0h] [rbp-400h]
  __int64 v237; // [rsp+A0h] [rbp-400h]
  const char *v238; // [rsp+A0h] [rbp-400h]
  __int64 v239; // [rsp+A0h] [rbp-400h]
  unsigned int v240; // [rsp+A0h] [rbp-400h]
  unsigned int v241; // [rsp+A0h] [rbp-400h]
  unsigned int v242; // [rsp+A0h] [rbp-400h]
  const char *s2; // [rsp+B8h] [rbp-3E8h]
  void *s2b; // [rsp+B8h] [rbp-3E8h]
  void *s2d; // [rsp+B8h] [rbp-3E8h]
  void *s2a; // [rsp+B8h] [rbp-3E8h]
  void *s2c; // [rsp+B8h] [rbp-3E8h]
  size_t n; // [rsp+C8h] [rbp-3D8h]
  __int32 na; // [rsp+C8h] [rbp-3D8h]
  size_t nb; // [rsp+C8h] [rbp-3D8h]
  int v252; // [rsp+D0h] [rbp-3D0h]
  __int64 v254; // [rsp+D0h] [rbp-3D0h]
  __int64 v255; // [rsp+D8h] [rbp-3C8h]
  unsigned int v256; // [rsp+D8h] [rbp-3C8h]
  int v257; // [rsp+E4h] [rbp-3BCh] BYREF
  _QWORD *v258; // [rsp+E8h] [rbp-3B8h] BYREF
  char *v259; // [rsp+F0h] [rbp-3B0h] BYREF
  __int64 v260; // [rsp+F8h] [rbp-3A8h]
  __m128i v261; // [rsp+100h] [rbp-3A0h] BYREF
  __m128i v262; // [rsp+110h] [rbp-390h] BYREF
  __m128i v263; // [rsp+120h] [rbp-380h] BYREF
  _QWORD v264[2]; // [rsp+130h] [rbp-370h] BYREF
  __int16 v265; // [rsp+140h] [rbp-360h]
  _QWORD v266[2]; // [rsp+150h] [rbp-350h] BYREF
  __int16 v267; // [rsp+160h] [rbp-340h]
  void *v268; // [rsp+170h] [rbp-330h] BYREF
  size_t v269; // [rsp+178h] [rbp-328h]
  _QWORD v270[2]; // [rsp+180h] [rbp-320h] BYREF
  __m128i v271; // [rsp+190h] [rbp-310h] BYREF
  __int64 v272; // [rsp+1A0h] [rbp-300h] BYREF
  __int64 v273; // [rsp+1A8h] [rbp-2F8h]
  size_t v274[2]; // [rsp+1B0h] [rbp-2F0h] BYREF
  _QWORD v275[2]; // [rsp+1C0h] [rbp-2E0h] BYREF
  _QWORD v276[2]; // [rsp+1D0h] [rbp-2D0h] BYREF
  unsigned __int64 *v277; // [rsp+1E0h] [rbp-2C0h]
  __int64 v278; // [rsp+1E8h] [rbp-2B8h]
  _BYTE v279[32]; // [rsp+1F0h] [rbp-2B0h] BYREF
  unsigned __int64 *v280; // [rsp+210h] [rbp-290h]
  __int64 v281; // [rsp+218h] [rbp-288h]
  _QWORD v282[4]; // [rsp+220h] [rbp-280h] BYREF
  char **v283; // [rsp+240h] [rbp-260h] BYREF
  __int64 v284; // [rsp+248h] [rbp-258h]
  _QWORD v285[12]; // [rsp+250h] [rbp-250h] BYREF
  _BYTE *v286; // [rsp+2B0h] [rbp-1F0h] BYREF
  __int64 v287; // [rsp+2B8h] [rbp-1E8h]
  _BYTE v288[160]; // [rsp+2C0h] [rbp-1E0h] BYREF
  __m128i v289; // [rsp+360h] [rbp-140h] BYREF
  unsigned __int64 v290; // [rsp+370h] [rbp-130h] BYREF
  __int64 v291; // [rsp+378h] [rbp-128h]
  int v292; // [rsp+380h] [rbp-120h]
  size_t *v293; // [rsp+388h] [rbp-118h]

  v6 = a3;
  v9 = 8LL * a2;
  v286 = v288;
  v287 = 0x1400000000LL;
  if ( v9 > 0xA0 )
  {
    sub_16CD150(&v286, v288, a2, 8);
    v9 = 8LL * a2;
    v6 = a3;
    v19 = &v286[8 * (unsigned int)v287];
  }
  else
  {
    if ( !v9 )
      goto LABEL_3;
    v19 = v288;
  }
  memcpy(v19, v6, v9);
  LODWORD(v9) = v287;
LABEL_3:
  v276[0] = 0;
  LODWORD(v287) = a2 + v9;
  v258 = v276;
  v277 = (unsigned __int64 *)v279;
  v278 = 0x400000000LL;
  v280 = v282;
  v276[1] = 0;
  v281 = 0;
  v282[0] = 0;
  v282[1] = 1;
  sub_16C0270(&v283);
  LOWORD(v275[0]) = 260;
  v274[0] = (size_t)&v283;
  sub_16E1010(&v289);
  if ( HIDWORD(v293) == 15 )
    v11 = sub_16B5630;
  else
    v11 = sub_16B1040;
  sub_16B1B60(
    (__int64)&v258,
    (void (__fastcall *)(_BYTE *, size_t, __int64, __int64, _QWORD))v11,
    (__int64 *)&v286,
    0,
    0);
  if ( (unsigned __int64 *)v289.m128i_i64[0] != &v290 )
    j_j___libc_free_0(v289.m128i_i64[0], v290 + 1);
  if ( v283 != v285 )
    j_j___libc_free_0(v283, v285[0] + 1LL);
  v12 = 0;
  v13 = *(const char **)v286;
  v255 = (__int64)v286;
  v252 = v287;
  if ( *(_QWORD *)v286 )
    v12 = strlen(v13);
  v15 = (_BYTE *)sub_16C40A0(v13, v12, 2);
  v16 = v14;
  if ( !v15 )
  {
    LOBYTE(v290) = 0;
    v20 = 0;
    v289.m128i_i64[0] = (__int64)&v290;
    v21 = *(char **)a1;
LABEL_18:
    *(_QWORD *)(a1 + 8) = v20;
    v21[v20] = 0;
    v22 = (unsigned __int64 *)v289.m128i_i64[0];
    goto LABEL_19;
  }
  v283 = (char **)v14;
  v17 = v14;
  v289.m128i_i64[0] = (__int64)&v290;
  if ( v14 > 0xF )
  {
    v289.m128i_i64[0] = sub_22409D0(&v289, &v283, 0);
    v148 = (unsigned __int64 *)v289.m128i_i64[0];
    v290 = (unsigned __int64)v283;
LABEL_174:
    memcpy(v148, v15, v16);
    v17 = (__int64)v283;
    v18 = (unsigned __int64 *)v289.m128i_i64[0];
    goto LABEL_175;
  }
  if ( v14 == 1 )
  {
    LOBYTE(v290) = *v15;
    v18 = &v290;
    goto LABEL_175;
  }
  if ( v14 )
  {
    v148 = &v290;
    goto LABEL_174;
  }
  v18 = &v290;
LABEL_175:
  v12 = a1;
  v289.m128i_i64[1] = v17;
  *((_BYTE *)v18 + v17) = 0;
  v20 = v289.m128i_i64[0];
  v21 = *(char **)a1;
  v22 = *(unsigned __int64 **)a1;
  if ( (unsigned __int64 *)v289.m128i_i64[0] == &v290 )
  {
    v20 = v289.m128i_i64[1];
    if ( v289.m128i_i64[1] )
    {
      if ( v289.m128i_i64[1] == 1 )
      {
        *v21 = v290;
      }
      else
      {
        v12 = (size_t)&v290;
        memcpy(v21, &v290, v289.m128i_u64[1]);
      }
      v20 = v289.m128i_i64[1];
      v21 = *(char **)a1;
    }
    goto LABEL_18;
  }
  v12 = v289.m128i_u64[1];
  v149 = v290;
  if ( v21 == (char *)(a1 + 16) )
  {
    *(_QWORD *)a1 = v289.m128i_i64[0];
    *(_QWORD *)(a1 + 8) = v12;
    *(_QWORD *)(a1 + 16) = v149;
  }
  else
  {
    v150 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)a1 = v289.m128i_i64[0];
    *(_QWORD *)(a1 + 8) = v12;
    *(_QWORD *)(a1 + 16) = v149;
    if ( v22 )
    {
      v289.m128i_i64[0] = (__int64)v22;
      v290 = v150;
      goto LABEL_19;
    }
  }
  v289.m128i_i64[0] = (__int64)&v290;
  v22 = &v290;
LABEL_19:
  v289.m128i_i64[1] = 0;
  *(_BYTE *)v22 = 0;
  v23 = v289.m128i_i64[0];
  if ( (unsigned __int64 *)v289.m128i_i64[0] != &v290 )
  {
    v12 = v290 + 1;
    j_j___libc_free_0(v289.m128i_i64[0], v290 + 1);
  }
  v230 = a6;
  *(_QWORD *)(a1 + 32) = a4;
  *(_QWORD *)(a1 + 40) = a5;
  if ( !a6 )
    v230 = sub_16E8CB0(v23, v12, v20);
  v24 = (unsigned __int64)&unk_4FA0190;
  v25 = sub_16B4B80((__int64)&unk_4FA0190);
  if ( v252 <= 1 )
  {
    v32 = 1;
    *(_QWORD *)(sub_16B0440(&unk_4FA0190, v12) + 312) = v25;
    v227 = v25 + 128;
    v232 = *(_DWORD *)(v25 + 40);
    if ( !v232 )
    {
      v283 = (char **)v285;
      v284 = 0x400000000LL;
      goto LABEL_215;
    }
LABEL_42:
    v33 = 0;
    na = v32;
    v37 = a6;
    v235 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v35 = (void *)v232;
    do
    {
      v41 = *(_QWORD *)(*(_QWORD *)(v25 + 32) + 8LL * (_QWORD)v38);
      v42 = *(_BYTE *)(v41 + 12) & 7;
      if ( (*(_BYTE *)(v41 + 12) & 7u) - 2 <= 1 )
      {
        ++v39;
      }
      else if ( *(_QWORD *)(v25 + 160) )
      {
        if ( *(_DWORD *)(v25 + 40) > 1u )
        {
          v235 = 1;
          if ( !v37 )
          {
            s2b = v35;
            v43 = sub_16E8CB0(v24, v12, v42);
            v12 = (size_t)&v289;
            v24 = v41;
            v289.m128i_i64[0] = (__int64)"error - this positional option will never be matched, because it does not Requi"
                                         "re a value, and a cl::ConsumeAfter option is active!";
            LOWORD(v290) = 259;
            sub_16B1F90(v41, (__int64)&v289, 0, 0, v43, v44);
            v35 = s2b;
            v37 = 0;
            LOBYTE(v42) = *(_BYTE *)(v41 + 12) & 7;
          }
        }
      }
      else if ( v40 && !*(_QWORD *)(v41 + 32) )
      {
        if ( !v37 )
        {
          s2c = v35;
          v212 = sub_16E8CB0(v24, v12, v42);
          v289.m128i_i64[0] = (__int64)"error - option can never match, because another positional argument will match an"
                                       " unbounded number of values, and this option does not require a value!";
          LOWORD(v290) = 259;
          sub_16B1F90(v41, (__int64)&v289, 0, 0, v212, v213);
          v37 = 0;
          v35 = s2c;
        }
        v237 = v37;
        s2d = v35;
        v45 = sub_16E7EE0(v230, *(const char **)a1, *(_QWORD *)(a1 + 8));
        v46 = sub_1263B40(v45, ": CommandLine Error: Option '");
        v47 = sub_1549FF0(v46, *(const char **)(v41 + 24), *(_QWORD *)(v41 + 32));
        sub_1263B40(v47, "' is all messed up!\n");
        v12 = *(unsigned int *)(v25 + 40);
        v24 = v230;
        sub_16E7A90(v230, v12);
        v235 = v40;
        v37 = v237;
        v35 = s2d;
        LOBYTE(v42) = *(_BYTE *)(v41 + 12) & 7;
      }
      v38 = (char *)v38 + 1;
      v40 |= (v42 & 0xFD) == 1;
    }
    while ( v38 != v35 );
    v232 = v39;
    v36 = na;
    v233 = v40;
    if ( !v40 )
      v233 = *(_QWORD *)(v25 + 160) != 0;
    v257 = na;
    v283 = (char **)v285;
    v284 = 0x400000000LL;
    v229 = v232;
    if ( v252 <= na )
    {
      v63 = 0;
LABEL_71:
      if ( v232 > v63 )
        goto LABEL_144;
LABEL_72:
      v64 = *(unsigned int *)(v25 + 40);
      if ( !v233 && (unsigned int)v64 < v63 )
      {
        v274[1] = 0;
        v274[0] = (size_t)v275;
        LOBYTE(v275[0]) = 0;
        v292 = 1;
        v289.m128i_i64[0] = (__int64)&unk_49EFBE0;
        v291 = 0;
        v154 = *(_QWORD *)(a1 + 8);
        v155 = *(const char **)a1;
        v290 = 0;
        v289.m128i_i64[1] = 0;
        v293 = v274;
        v156 = sub_16E7EE0(&v289, v155, v154, v33, v34, v35);
        v157 = sub_1263B40(v156, ": Too many positional arguments specified!\n");
        v158 = sub_1263B40(v157, "Can specify at most ");
        v128 = " positional arguments: See: ";
        v129 = sub_16E7A90(v158, *(unsigned int *)(v25 + 40));
        goto LABEL_147;
      }
LABEL_74:
      nb = v64;
      if ( *(_QWORD *)(v25 + 160) )
      {
        if ( v64 == 1 )
          goto LABEL_190;
        v65 = v25;
        v66 = v235;
        v67 = 1;
        v68 = 0;
        v69 = v65;
        do
        {
          v24 = *(_QWORD *)(*(_QWORD *)(v69 + 32) + 8 * v67);
          if ( (*(_BYTE *)(v24 + 12) & 7u) - 2 <= 1 )
          {
            v70 = v68++;
            v71 = &v283[3 * v70];
            v72 = *v71;
            v73 = (__int64)v71[1];
            v289.m128i_i32[0] = *((_DWORD *)v71 + 4);
            v12 = *(_QWORD *)(v24 + 24);
            v66 |= sub_16B2140((const char *)v24, v12, *(_QWORD *)(v24 + 32), v72, v73, 0, 0, &v289);
          }
          ++v67;
        }
        while ( v67 != nb );
        v74 = v69;
        v235 = v66;
        v75 = v68;
        v25 = v74;
        if ( *(_DWORD *)(v74 + 40) == 1 && !v75 )
        {
LABEL_190:
          if ( !(_DWORD)v284 )
            goto LABEL_87;
          v75 = 1;
          v24 = **(_QWORD **)(v25 + 32);
          v159 = (__int64)v283[1];
          v160 = *v283;
          v289.m128i_i32[0] = *((_DWORD *)v283 + 4);
          v12 = *(_QWORD *)(v24 + 24);
          v235 |= sub_16B2140((const char *)v24, v12, *(_QWORD *)(v24 + 32), v160, v159, 0, 0, &v289);
          v76 = 1;
        }
        else
        {
          v76 = v75;
        }
        if ( (_DWORD)v284 != v75 )
        {
          v77 = v235;
          do
          {
            v78 = *(_QWORD *)(v25 + 160);
            v79 = &v283[3 * v76];
            v80 = *v79;
            v81 = (__int64)v79[1];
            v289.m128i_i32[0] = *((_DWORD *)v79 + 4);
            v82 = sub_16B2140((const char *)v78, *(_QWORD *)(v78 + 24), *(_QWORD *)(v78 + 32), v80, v81, 0, 0, &v289);
            v12 = v216;
            v24 = v220;
            v77 |= v82;
            v76 = v75 + 1;
            v75 = v76;
          }
          while ( (_DWORD)v76 != (_DWORD)v284 );
          v235 = v77;
        }
      }
      else if ( v64 )
      {
        v256 = v63;
        v161 = v232;
        v254 = 0;
        v162 = 0;
        do
        {
          v24 = *(_QWORD *)(*(_QWORD *)(v25 + 32) + 8 * v254);
          v163 = *(_BYTE *)(v24 + 12) & 7;
          if ( (unsigned int)v163 - 2 <= 1 )
          {
            v164 = v162++;
            --v161;
            v165 = &v283[3 * v164];
            v166 = *v165;
            v167 = (__int64)v165[1];
            v289.m128i_i32[0] = *((_DWORD *)v165 + 4);
            sub_16B2140((const char *)v24, *(_QWORD *)(v24 + 24), *(_QWORD *)(v24 + 32), v166, v167, 0, 0, &v289);
            v12 = v218;
            v24 = *(_QWORD *)(*(_QWORD *)(v25 + 32) + 8 * v254);
            v163 = *(_BYTE *)(v24 + 12) & 7;
          }
          if ( v161 < v256 - v162 && v163 != 2 )
          {
            while ( 1 )
            {
              v168 = v163 == 0;
              v169 = &v283[3 * v162];
              v170 = *v169;
              v171 = (__int64)v169[1];
              v289.m128i_i32[0] = *((_DWORD *)v169 + 4);
              v12 = *(_QWORD *)(v24 + 24);
              v172 = *(_QWORD *)(v24 + 32);
              if ( v168 )
                break;
              ++v162;
              sub_16B2140((const char *)v24, v12, v172, v170, v171, 0, 0, &v289);
              if ( v161 >= v256 - v162 )
                goto LABEL_199;
              v24 = *(_QWORD *)(*(_QWORD *)(v25 + 32) + 8 * v254);
              v163 = *(_BYTE *)(v24 + 12) & 7;
            }
            ++v162;
            sub_16B2140((const char *)v24, v12, v172, v170, v171, 0, 0, &v289);
          }
LABEL_199:
          ++v254;
        }
        while ( v254 != nb );
      }
LABEL_87:
      LODWORD(v83) = *(_DWORD *)(v25 + 136);
      if ( !(_DWORD)v83 )
        goto LABEL_148;
      goto LABEL_88;
    }
    goto LABEL_58;
  }
  v26 = *(const char **)(v255 + 8);
  s2 = v26;
  if ( *v26 == 45 )
    goto LABEL_169;
  n = strlen(v26);
  if ( !n
    || (sub_16B5AB0(&v283, (__int64 *)(a1 + 240), *(_QWORD **)(a1 + 256)),
        v12 = a1 + 240,
        v27 = (__int64 *)v283,
        v28 = v284,
        sub_16B55A0(&v289, (__int64 *)(a1 + 240)),
        (__int64 *)v289.m128i_i64[0] == v27) )
  {
LABEL_36:
    v25 = sub_16B4B80((__int64)&unk_4FA0190);
  }
  else
  {
    v236 = a6;
    v29 = (__int64 *)v28;
    v30 = v289.m128i_i64[0];
    while ( 1 )
    {
      v25 = *v27;
      if ( v25 != sub_16B4B80((__int64)&unk_4FA0170) )
      {
        v31 = *(_QWORD *)(v25 + 8);
        if ( v31 )
        {
          if ( n == v31 )
          {
            v12 = (size_t)s2;
            if ( !memcmp(*(const void **)v25, s2, n) )
              break;
          }
        }
      }
      do
        ++v27;
      while ( v27 != v29 && (unsigned __int64)*v27 >= 0xFFFFFFFFFFFFFFFELL );
      if ( (__int64 *)v30 == v27 )
      {
        a6 = v236;
        goto LABEL_36;
      }
    }
    a6 = v236;
  }
  v24 = (unsigned __int64)&unk_4FA0190;
  if ( v25 == sub_16B4B80((__int64)&unk_4FA0190) )
  {
LABEL_169:
    *(_QWORD *)(sub_16B0440(&unk_4FA0190, v12) + 312) = v25;
    v227 = v25 + 128;
    v232 = *(_DWORD *)(v25 + 40);
    if ( !v232 )
    {
      v235 = 0;
      v36 = 1;
      v257 = 1;
      v283 = (char **)v285;
      v284 = 0x400000000LL;
      v229 = 0;
      v233 = 0;
      goto LABEL_58;
    }
    v32 = 1;
    goto LABEL_42;
  }
  v32 = 2;
  *(_QWORD *)(sub_16B0440(&unk_4FA0190, v12) + 312) = v25;
  v227 = v25 + 128;
  v232 = *(_DWORD *)(v25 + 40);
  if ( v232 )
    goto LABEL_42;
  v257 = 2;
  v283 = (char **)v285;
  v284 = 0x400000000LL;
  if ( v252 == 2 )
  {
LABEL_215:
    v235 = 0;
    v64 = *(unsigned int *)(v25 + 40);
    v63 = 0;
    v232 = 0;
    goto LABEL_74;
  }
  v229 = 0;
  v36 = 2;
  v235 = 0;
  v233 = 0;
LABEL_58:
  v234 = 0;
  s2a = 0;
  v231 = v25;
  while ( 1 )
  {
    v12 = v255;
    v269 = 0;
    LOBYTE(v270[0]) = 0;
    v268 = v270;
    v261.m128i_i64[0] = (__int64)byte_3F871B3;
    v259 = 0;
    v260 = 0;
    v261.m128i_i64[1] = 0;
    v48 = *(_QWORD *)(v255 + 8LL * v36);
    if ( *(_BYTE *)v48 != 45 )
      break;
    v102 = *(_BYTE *)(v48 + 1);
    if ( (unsigned __int8)v234 | (v102 == 0) )
      break;
    if ( v102 == 45 && !*(_BYTE *)(v48 + 2) )
    {
      v234 = 1;
      goto LABEL_69;
    }
    v103 = (_BYTE *)(v48 + 1);
    v104 = strlen((const char *)(v48 + 1));
    if ( s2a && (*((_BYTE *)s2a + 13) & 4) != 0 )
    {
      v105 = v48 + v104 + 1;
      v261.m128i_i64[0] = v48 + 1;
      v106 = v104 + v48;
      v261.m128i_i64[1] = v104;
      if ( v104 )
      {
        do
        {
          if ( *v103 != 45 )
            break;
          v107 = v106 - (_QWORD)v103++;
          v261.m128i_i64[0] = (__int64)v103;
          v261.m128i_i64[1] = v107;
        }
        while ( v103 != (_BYTE *)v105 );
      }
      v12 = (size_t)&v261;
      v108 = sub_16B0DE0(v231, &v261, (unsigned __int64 *)&v259);
      if ( !v108 || ((*(_WORD *)(v108 + 12) >> 7) & 3) != 1 )
      {
        v173 = 0;
        v174 = *(char **)(v255 + 8LL * v257);
        v175 = v257;
        if ( v174 )
          v173 = strlen(*(const char **)(v255 + 8LL * v257));
        v289.m128i_i32[0] = v175;
        sub_16B2140((const char *)s2a, *((_QWORD *)s2a + 3), *((_QWORD *)s2a + 4), v174, v173, 0, 0, &v289);
        v33 = v219;
        v12 = v222;
        v234 = 0;
        goto LABEL_67;
      }
      s2a = (void *)v108;
      goto LABEL_128;
    }
    v151 = v48 + v104 + 1;
    v261.m128i_i64[0] = v48 + 1;
    v152 = v104 + v48;
    v261.m128i_i64[1] = v104;
    if ( v104 )
    {
      do
      {
        if ( *v103 != 45 )
          break;
        v153 = v152 - (_QWORD)v103++;
        v261.m128i_i64[0] = (__int64)v103;
        v261.m128i_i64[1] = v153;
      }
      while ( v103 != (_BYTE *)v151 );
    }
    v12 = (size_t)&v261;
    v50 = sub_16B0DE0(v231, &v261, (unsigned __int64 *)&v259);
    if ( !v50 )
    {
      if ( v261.m128i_i64[1] == 1 )
        goto LABEL_225;
      v12 = v261.m128i_u64[1];
      v289.m128i_i64[0] = 0;
      v176 = sub_16B05C0(
               v261.m128i_i64[0],
               v261.m128i_u64[1],
               (unsigned __int64 *)&v289,
               (unsigned __int8 (__fastcall *)(_QWORD))sub_16AFD90,
               v227);
      if ( !v176 )
        goto LABEL_225;
      v177 = v289.m128i_i64[0];
      v178 = v261.m128i_u64[1];
      if ( ((*(_WORD *)(v176 + 12) >> 7) & 3) != 2 )
      {
        while ( 1 )
        {
          v182 = v261.m128i_i64[0];
          if ( v177 <= v178 )
          {
            v179 = v177;
            v180 = v178 - v177;
          }
          else
          {
            v177 = v178;
            v179 = v178;
            v180 = 0;
          }
          v261.m128i_i64[0] += v177;
          v261.m128i_i64[1] = v180;
          LODWORD(v274[0]) = 0;
          v181 = sub_16B2140((const char *)v176, v182, v179, 0, 0, 0, 0, v274);
          v12 = v261.m128i_u64[1];
          v235 |= v181;
          v176 = sub_16B05C0(
                   v261.m128i_i64[0],
                   v261.m128i_u64[1],
                   (unsigned __int64 *)&v289,
                   (unsigned __int8 (__fastcall *)(_QWORD))sub_16AFD80,
                   v227);
          if ( !v176 )
            break;
          v178 = v261.m128i_u64[1];
          v177 = v289.m128i_i64[0];
          if ( v261.m128i_i64[1] == v289.m128i_i64[0] )
            goto LABEL_297;
        }
LABEL_225:
        v49 = *(_DWORD *)(v231 + 88);
        if ( v49 )
          goto LABEL_164;
        v262 = _mm_load_si128(&v261);
        if ( !v262.m128i_i64[1] )
          goto LABEL_64;
        v289.m128i_i8[0] = 61;
        v183 = sub_16D20C0(&v262, &v289, 1, 0);
        if ( v183 == -1 )
        {
          v215 = _mm_load_si128(&v262);
          v272 = 0;
          v273 = 0;
          v271 = v215;
        }
        else
        {
          v184 = v183 + 1;
          if ( v183 + 1 > v262.m128i_i64[1] )
            v184 = v262.m128i_i64[1];
          v185 = v262.m128i_i64[1] - v184;
          v186 = v262.m128i_i64[0] + v184;
          if ( v183 && v183 > v262.m128i_i64[1] )
            v183 = v262.m128i_u64[1];
          v271.m128i_i64[0] = v262.m128i_i64[0];
          v271.m128i_i64[1] = v183;
          v272 = v186;
          v273 = v185;
        }
        v187 = *(unsigned int *)(v231 + 136);
        if ( (_DWORD)v187 )
        {
          v188 = *(__int64 **)(v231 + 128);
          v189 = v188;
          if ( !*v188 || *v188 == -8 )
          {
            do
            {
              do
              {
                v190 = v189[1];
                ++v189;
              }
              while ( v190 == -8 );
            }
            while ( !v190 );
          }
          v224 = &v188[v187];
          if ( v224 != v189 )
          {
            v239 = 0;
            v191 = 0;
            while ( 1 )
            {
              v192 = *(_QWORD *)(*v189 + 8);
              v289.m128i_i64[0] = (__int64)&v290;
              v193 = v192;
              v289.m128i_i64[1] = 0x1000000000LL;
              v226 = v192;
              (*(void (__fastcall **)(__int64, __m128i *))(*(_QWORD *)v192 + 72LL))(v192, &v289);
              if ( *(_QWORD *)(v193 + 32) )
              {
                v211 = v289.m128i_u32[2];
                if ( v289.m128i_i32[2] >= (unsigned __int32)v289.m128i_i32[3] )
                {
                  sub_16CD150(&v289, &v290, 0, 16);
                  v211 = v289.m128i_u32[2];
                }
                *(__m128i *)(v289.m128i_i64[0] + 16 * v211) = _mm_loadu_si128((const __m128i *)(v226 + 24));
                ++v289.m128i_i32[2];
              }
              v194 = *(_BYTE *)(v226 + 12);
              v225 = (v194 & 0x18) != 0
                   ? (v194 >> 3) & 3
                   : (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v226 + 8LL))(v226);
              v195 = v225 == 3 ? *(_OWORD *)&v262 : *(_OWORD *)&v271;
              v228 = (const __m128i *)(v289.m128i_i64[0] + 16LL * v289.m128i_u32[2]);
              if ( (const __m128i *)v289.m128i_i64[0] != v228 )
                break;
LABEL_270:
              if ( v228 != (const __m128i *)&v290 )
                _libc_free((unsigned __int64)v228);
              v207 = v189[1];
              if ( v207 && v207 != -8 )
              {
                ++v189;
              }
              else
              {
                v208 = v189 + 2;
                do
                {
                  do
                  {
                    v209 = *v208;
                    v189 = v208++;
                  }
                  while ( !v209 );
                }
                while ( v209 == -8 );
              }
              if ( v224 == v189 )
              {
                v50 = v239;
                goto LABEL_279;
              }
            }
            v223 = v189;
            v196 = (const __m128i *)v289.m128i_i64[0];
            v197 = v191;
            while ( 2 )
            {
              v263 = _mm_loadu_si128(v196);
              *(__m128i *)v274 = v263;
              v198 = sub_16D3240(v274, v195, *((_QWORD *)&v195 + 1), 1, (unsigned int)v195);
              v199 = v198;
              if ( v239 && v197 <= v198 )
              {
LABEL_249:
                if ( v228 == ++v196 )
                {
                  v189 = v223;
                  v191 = v197;
                  v228 = (const __m128i *)v289.m128i_i64[0];
                  goto LABEL_270;
                }
                continue;
              }
              break;
            }
            if ( v273 && v225 != 3 )
            {
              v240 = v198;
              v264[0] = &v263;
              v264[1] = "=";
              v265 = 773;
              v266[0] = v264;
              v266[1] = &v272;
              v267 = 1282;
              sub_16E2FC0(v274, v266);
              v200 = v268;
              v199 = v240;
              if ( (_QWORD *)v274[0] == v275 )
              {
                v210 = v274[1];
                if ( v274[1] )
                {
                  if ( v274[1] == 1 )
                  {
                    *(_BYTE *)v268 = v275[0];
                    v210 = v274[1];
                    v200 = v268;
                  }
                  else
                  {
                    memcpy(v268, v275, v274[1]);
                    v210 = v274[1];
                    v200 = v268;
                    v199 = v240;
                  }
                }
                v269 = v210;
                v200[v210] = 0;
                v200 = (_BYTE *)v274[0];
              }
              else
              {
                if ( v268 == v270 )
                {
                  v268 = (void *)v274[0];
                  v269 = v274[1];
                  v270[0] = v275[0];
                }
                else
                {
                  v201 = v270[0];
                  v268 = (void *)v274[0];
                  v269 = v274[1];
                  v270[0] = v275[0];
                  if ( v200 )
                  {
                    v274[0] = (size_t)v200;
                    v275[0] = v201;
                    goto LABEL_257;
                  }
                }
                v274[0] = (size_t)v275;
                v200 = v275;
              }
LABEL_257:
              v274[1] = 0;
              *v200 = 0;
              v202 = v274[0];
              if ( (_QWORD *)v274[0] != v275 )
              {
LABEL_258:
                v241 = v199;
                j_j___libc_free_0(v202, v275[0] + 1LL);
                v199 = v241;
              }
LABEL_259:
              v197 = v199;
              v239 = v226;
              goto LABEL_249;
            }
            if ( v263.m128i_i64[0] )
            {
              v242 = v198;
              v274[0] = (size_t)v275;
              sub_16B0480((__int64 *)v274, v263.m128i_i64[0], v263.m128i_i64[0] + v263.m128i_i64[1]);
              v203 = v268;
              v199 = v242;
              v204 = v268;
              if ( (_QWORD *)v274[0] != v275 )
              {
                if ( v268 == v270 )
                {
                  v268 = (void *)v274[0];
                  v269 = v274[1];
                  v270[0] = v275[0];
                }
                else
                {
                  v205 = v270[0];
                  v268 = (void *)v274[0];
                  v269 = v274[1];
                  v270[0] = v275[0];
                  if ( v204 )
                  {
                    v274[0] = (size_t)v204;
                    v275[0] = v205;
                    goto LABEL_265;
                  }
                }
                v204 = v275;
                v274[0] = (size_t)v275;
LABEL_265:
                v274[1] = 0;
                *v204 = 0;
                v202 = v274[0];
                if ( (_QWORD *)v274[0] != v275 )
                  goto LABEL_258;
                goto LABEL_259;
              }
              v206 = v274[1];
              if ( v274[1] )
              {
                if ( v274[1] == 1 )
                {
                  *(_BYTE *)v268 = v275[0];
                  v206 = v274[1];
                  v203 = v268;
                }
                else
                {
                  memcpy(v268, v275, v274[1]);
                  v206 = v274[1];
                  v203 = v268;
                  v199 = v242;
                }
              }
            }
            else
            {
              LOBYTE(v275[0]) = 0;
              v206 = 0;
              v203 = v268;
              v274[0] = (size_t)v275;
            }
            v269 = v206;
            v203[v206] = 0;
            v204 = (_BYTE *)v274[0];
            goto LABEL_265;
          }
        }
LABEL_279:
        v49 = *(_DWORD *)(v231 + 88);
LABEL_63:
        if ( v49 )
        {
LABEL_164:
          v140 = *(__int64 **)(v231 + 80);
          v141 = &v140[v49];
          do
          {
            v142 = *v140;
            v143 = 0;
            v144 = *(void (__fastcall **)(__int64, _QWORD, const char *, _QWORD, const char *, size_t, _QWORD))(*(_QWORD *)*v140 + 80LL);
            v145 = *(const char **)(v255 + 8LL * v257);
            v146 = v257;
            if ( v145 )
            {
              v238 = *(const char **)(v255 + 8LL * v257);
              v147 = strlen(v238);
              v145 = v238;
              v143 = v147;
            }
            ++v140;
            v12 = v146;
            v144(v142, v146, byte_3F871B3, 0, v145, v143, 0);
          }
          while ( v141 != v140 );
        }
        else
        {
LABEL_64:
          v271 = (__m128i)(unsigned __int64)&v272;
          v51 = *(_QWORD *)(a1 + 8);
          v52 = *(const char **)a1;
          LOBYTE(v272) = 0;
          v292 = 1;
          v291 = 0;
          v290 = 0;
          v289.m128i_i64[1] = 0;
          v289.m128i_i64[0] = (__int64)&unk_49EFBE0;
          v293 = (size_t *)&v271;
          v53 = sub_16E7EE0(&v289, v52, v51);
          v54 = sub_1263B40(v53, ": Unknown command line argument '");
          v55 = sub_1263B40(v54, *(const char **)(v255 + 8LL * v257));
          v56 = sub_1263B40(v55, "'.  Try: '");
          v57 = sub_1263B40(v56, *(const char **)v255);
          sub_1263B40(v57, " -help'\n");
          sub_16E7BC0(&v289);
          v12 = 1;
          sub_1C3EFD0(&v271, 1);
          if ( v50 )
          {
            v58 = *(_QWORD *)(a1 + 8);
            v59 = *(const char **)a1;
            v289.m128i_i64[0] = (__int64)&unk_49EFBE0;
            v274[1] = 0;
            v274[0] = (size_t)v275;
            LOBYTE(v275[0]) = 0;
            v292 = 1;
            v291 = 0;
            v290 = 0;
            v289.m128i_i64[1] = 0;
            v293 = v274;
            v60 = sub_16E7EE0(&v289, v59, v58);
            v61 = sub_1263B40(v60, ": Did you mean '-");
            v62 = sub_16E7EE0(v61, (const char *)v268, v269);
            sub_1263B40(v62, "'?\n");
            sub_16E7BC0(&v289);
            v12 = 1;
            sub_1C3EFD0(v274, 1);
            sub_2240A30(v274);
          }
          sub_2240A30(&v271);
          v235 = 1;
        }
        goto LABEL_67;
      }
      v214 = 0;
      if ( v289.m128i_i64[0] <= (unsigned __int64)v261.m128i_i64[1] )
      {
        v214 = v261.m128i_i64[1] - v289.m128i_i64[0];
        v178 = v289.m128i_i64[0];
      }
      v260 = v214;
      v261.m128i_i64[1] = v178;
      v259 = (char *)(v178 + v261.m128i_i64[0]);
LABEL_297:
      v50 = v176;
    }
    if ( ((*(_WORD *)(v50 + 12) >> 7) & 3) == 1 )
    {
      s2a = (void *)v50;
LABEL_128:
      if ( (*((_BYTE *)s2a + 13) & 4) != 0 && v260 )
      {
        v12 = (size_t)&v289;
        v289.m128i_i64[0] = (__int64)"This argument does not take a value.\n"
                                     "\tInstead, it consumes any positional arguments until the next recognized option.";
        LOWORD(v290) = 259;
        sub_16B1F90((__int64)s2a, (__int64)&v289, 0, 0, v230, v109);
        v235 = 1;
      }
      goto LABEL_188;
    }
    v12 = v261.m128i_i64[0];
    v235 |= sub_16B2140(
              (const char *)v50,
              v261.m128i_i64[0],
              v261.m128i_i64[1],
              v259,
              v260,
              v252,
              (const char *)v255,
              &v257);
LABEL_188:
    v24 = (unsigned __int64)&v268;
    sub_2240A30(&v268);
    v234 = 0;
LABEL_69:
    v36 = v257 + 1;
    v257 = v36;
    if ( v36 >= v252 )
    {
      v25 = v231;
      v63 = v284;
      goto LABEL_71;
    }
  }
  if ( s2a )
  {
    v110 = strlen(*(const char **)(v255 + 8LL * v36));
    v289.m128i_i32[0] = v36;
    v12 = *((_QWORD *)s2a + 3);
    sub_16B2140((const char *)s2a, v12, *((_QWORD *)s2a + 4), (char *)v48, v110, 0, 0, &v289);
    v34 = v217;
    v35 = v221;
    goto LABEL_67;
  }
  if ( !*(_DWORD *)(v231 + 40) )
  {
    v49 = *(_DWORD *)(v231 + 88);
    v50 = 0;
    goto LABEL_63;
  }
  v111 = strlen(*(const char **)(v255 + 8LL * v36));
  v289.m128i_i64[0] = v48;
  v289.m128i_i64[1] = v111;
  v112 = (unsigned int)v284;
  LODWORD(v290) = v36;
  if ( (unsigned int)v284 >= HIDWORD(v284) )
  {
    sub_16CD150(&v283, v285, 0, 24);
    v112 = (unsigned int)v284;
  }
  v12 = (size_t)&v289;
  v113 = (__m128i *)&v283[3 * v112];
  *v113 = _mm_load_si128(&v289);
  v113[1].m128i_i64[0] = v290;
  v114 = (unsigned int)(v284 + 1);
  LODWORD(v284) = v114;
  if ( (unsigned int)v114 < v232 || (v25 = v231, !*(_QWORD *)(v231 + 160)) )
  {
LABEL_67:
    v24 = (unsigned __int64)v268;
    if ( v268 != v270 )
    {
      v12 = v270[0] + 1LL;
      j_j___libc_free_0(v268, v270[0] + 1LL);
    }
    goto LABEL_69;
  }
  v115 = v257 + 1;
  v257 = v115;
  if ( v115 < v252 )
  {
    do
    {
      v116 = *(_QWORD *)(v255 + 8LL * v115);
      v117 = 0;
      if ( v116 )
        v117 = strlen(*(const char **)(v255 + 8LL * v115));
      v289.m128i_i64[0] = v116;
      v289.m128i_i64[1] = v117;
      LODWORD(v290) = v115;
      if ( (unsigned int)v114 >= HIDWORD(v284) )
      {
        v12 = (size_t)v285;
        sub_16CD150(&v283, v285, 0, 24);
        v114 = (unsigned int)v284;
      }
      v118 = (__m128i *)&v283[3 * v114];
      *v118 = _mm_load_si128(&v289);
      v118[1].m128i_i64[0] = v290;
      v114 = (unsigned int)(v284 + 1);
      LODWORD(v284) = v284 + 1;
      v115 = v257 + 1;
      v257 = v115;
    }
    while ( v115 < v252 );
    v25 = v231;
  }
  v24 = (unsigned __int64)&v268;
  sub_2240A30(&v268);
  v63 = v284;
  if ( v232 <= (unsigned int)v284 )
    goto LABEL_72;
LABEL_144:
  v274[1] = 0;
  v274[0] = (size_t)v275;
  LOBYTE(v275[0]) = 0;
  v292 = 1;
  v289.m128i_i64[0] = (__int64)&unk_49EFBE0;
  v291 = 0;
  v119 = *(_QWORD *)(a1 + 8);
  v120 = *(const char **)a1;
  v290 = 0;
  v289.m128i_i64[1] = 0;
  v293 = v274;
  v121 = sub_16E7EE0(&v289, v120, v119, v33, v34, v35);
  v122 = sub_1263B40(v121, ": Not enough positional command line arguments specified!\n");
  v123 = sub_1263B40(v122, "Must specify at least ");
  v124 = sub_16E7A90(v123, v229);
  v125 = "s";
  v126 = sub_1263B40(v124, " positional argument");
  if ( v232 <= 1 )
    v125 = byte_3F871B3;
  v127 = sub_1263B40(v126, v125);
  v128 = ": See: ";
  v129 = v127;
LABEL_147:
  v130 = sub_1263B40(v129, v128);
  v131 = sub_1263B40(v130, *(const char **)v255);
  sub_1263B40(v131, " -help\n");
  sub_16E7BC0(&v289);
  v12 = 1;
  sub_1C3EFD0(v274, 1);
  v24 = (unsigned __int64)v274;
  sub_2240A30(v274);
  LODWORD(v83) = *(_DWORD *)(v25 + 136);
  v235 = 1;
  if ( (_DWORD)v83 )
  {
LABEL_88:
    v84 = *(_QWORD **)(v25 + 128);
    v85 = v84;
    if ( !*v84 || *v84 == -8 )
    {
      do
      {
        do
        {
          v86 = v85[1];
          ++v85;
        }
        while ( v86 == -8 );
      }
      while ( !v86 );
    }
    v83 = (unsigned int)v83;
    v87 = &v84[(unsigned int)v83];
    if ( v87 != v85 )
    {
      while ( 1 )
      {
        v88 = *v85;
        v89 = *(_QWORD *)(*v85 + 8LL);
        if ( (*(_BYTE *)(v89 + 12) & 7u) - 2 <= 1 )
        {
          v24 = sub_16D5D50(v24, v12, v83);
          v92 = *(_QWORD **)&dword_4FA0208[2];
          if ( !*(_QWORD *)&dword_4FA0208[2] )
            goto LABEL_107;
          v93 = dword_4FA0208;
          do
          {
            while ( 1 )
            {
              v94 = v92[2];
              v91 = v92[3];
              if ( v24 <= v92[4] )
                break;
              v92 = (_QWORD *)v92[3];
              if ( !v91 )
                goto LABEL_105;
            }
            v93 = v92;
            v92 = (_QWORD *)v92[2];
          }
          while ( v94 );
LABEL_105:
          if ( v93 == dword_4FA0208 )
            goto LABEL_107;
          if ( v24 < *((_QWORD *)v93 + 4) )
            goto LABEL_107;
          v98 = *((_QWORD *)v93 + 7);
          v99 = v93 + 12;
          if ( !v98 )
            goto LABEL_107;
          v24 = *(unsigned int *)(v89 + 8);
          v100 = v93 + 12;
          do
          {
            while ( 1 )
            {
              v101 = *(_QWORD *)(v98 + 16);
              v91 = *(_QWORD *)(v98 + 24);
              if ( *(_DWORD *)(v98 + 32) >= (int)v24 )
                break;
              v98 = *(_QWORD *)(v98 + 24);
              if ( !v91 )
                goto LABEL_113;
            }
            v100 = (_DWORD *)v98;
            v98 = *(_QWORD *)(v98 + 16);
          }
          while ( v101 );
LABEL_113:
          if ( v100 == v99 || (int)v24 < v100[8] || !v100[9] )
          {
LABEL_107:
            v95 = *(_QWORD *)(v88 + 8);
            v96 = sub_16E8CB0(v24, v12, v91);
            v12 = (size_t)&v289;
            v24 = v95;
            v289.m128i_i64[0] = (__int64)"must be specified at least once!";
            LOWORD(v290) = 259;
            sub_16B1F90(v95, (__int64)&v289, 0, 0, v96, v97);
            v235 = 1;
          }
        }
        v83 = v85[1];
        v90 = v85 + 1;
        if ( v83 == -8 || !v83 )
        {
          do
          {
            do
            {
              v83 = v90[1];
              ++v90;
            }
            while ( !v83 );
          }
          while ( v83 == -8 );
        }
        if ( v87 == v90 )
          break;
        v85 = v90;
      }
    }
  }
LABEL_148:
  v132 = *(_QWORD *)(a1 + 48);
  if ( v132 != *(_QWORD *)(a1 + 56) )
    *(_QWORD *)(a1 + 56) = v132;
  if ( v283 != v285 )
    _libc_free((unsigned __int64)v283);
  v133 = v277;
  v134 = &v277[(unsigned int)v278];
  if ( v277 != v134 )
  {
    do
    {
      v135 = *v133++;
      _libc_free(v135);
    }
    while ( v134 != v133 );
  }
  v136 = v280;
  v137 = &v280[2 * (unsigned int)v281];
  if ( v280 != v137 )
  {
    do
    {
      v138 = *v136;
      v136 += 2;
      _libc_free(v138);
    }
    while ( v137 != v136 );
    v137 = v280;
  }
  if ( v137 != v282 )
    _libc_free((unsigned __int64)v137);
  if ( v277 != (unsigned __int64 *)v279 )
    _libc_free((unsigned __int64)v277);
  if ( v286 != v288 )
    _libc_free((unsigned __int64)v286);
  return v235 ^ 1u;
}
