// Function: sub_1E8D750
// Address: 0x1e8d750
//
char __fastcall sub_1E8D750(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  unsigned int v7; // r13d
  __int64 v8; // r12
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rax
  unsigned __int16 *v11; // r15
  __int64 v12; // rcx
  __int64 v13; // rdx
  const char *v14; // rsi
  __int64 v15; // rsi
  __int64 v16; // rbx
  __int64 v17; // rdi
  int v18; // ebx
  unsigned int v19; // eax
  __int64 v20; // r9
  char v21; // al
  unsigned int v22; // ecx
  const char *v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rbx
  __int64 v26; // rcx
  unsigned __int64 v27; // rdi
  int v28; // r15d
  __int64 **v29; // rbx
  unsigned __int64 v30; // r9
  __int64 *v31; // r11
  __int64 *v32; // rcx
  __int64 v33; // r8
  int v34; // esi
  int v35; // ebx
  char v36; // al
  __int64 v37; // r8
  int v38; // esi
  int v39; // esi
  __int64 v40; // rdx
  unsigned int v41; // ecx
  __int64 *v42; // rcx
  __int64 v43; // rbx
  __int64 v44; // rax
  __int16 *v45; // rdx
  __int64 v46; // r10
  __int16 v47; // cx
  __int64 v48; // rax
  __int16 v49; // ax
  bool v50; // al
  __int64 v51; // r9
  __int16 v52; // ax
  __int64 **v53; // rdx
  __int64 **v54; // rsi
  __int64 v55; // rax
  unsigned __int64 v56; // rax
  void *v57; // rax
  __int64 v58; // r12
  __int64 v59; // rdi
  __int64 v60; // rax
  unsigned __int64 v61; // r14
  __int64 v62; // rdi
  __int64 (__fastcall *v63)(__int64, __int64); // rax
  _QWORD *v64; // r15
  unsigned int v65; // r9d
  __int64 *v66; // rdi
  unsigned __int64 v67; // rsi
  __int64 v68; // rax
  __int64 (__fastcall *v69)(__int64, __int64); // rcx
  __int64 v70; // rax
  void *v71; // rax
  __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // rax
  __int64 v75; // rdi
  unsigned __int64 v76; // rax
  char v77; // al
  unsigned __int8 v78; // al
  int v79; // r8d
  __int64 v80; // rsi
  _QWORD *v81; // rax
  __int64 v82; // r11
  __int64 v83; // rdi
  __int64 v84; // rsi
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  unsigned __int16 v88; // ax
  int v89; // r11d
  unsigned __int64 v90; // r15
  __int64 v91; // r13
  __int64 v92; // r14
  __int64 v93; // rbx
  int v94; // r12d
  __int64 v95; // rax
  unsigned int v96; // eax
  _QWORD *v97; // rax
  _QWORD *v98; // r9
  __int64 v99; // rdx
  __int64 v100; // rax
  int v101; // edx
  __int64 v102; // rdx
  __int64 v103; // rax
  __int64 v104; // rax
  __int64 v105; // rax
  __int64 v106; // r9
  _QWORD *v107; // r10
  unsigned __int64 v108; // rbx
  unsigned int v109; // eax
  void *v110; // rax
  __int64 v111; // r12
  __int64 v112; // rbx
  __int64 v113; // r9
  __int64 v114; // rax
  __int64 v115; // rax
  unsigned int v116; // eax
  unsigned int v117; // eax
  __int64 v118; // rcx
  __int64 v119; // r8
  _BYTE *v120; // r9
  __int64 v121; // r10
  __int64 v122; // rdx
  int v123; // eax
  int v124; // eax
  char *v125; // rdi
  __int64 v126; // rax
  __int64 v127; // rdi
  int v128; // eax
  int v129; // esi
  __int64 v130; // rcx
  int v131; // r8d
  __int64 v132; // rax
  __int64 v133; // rdx
  __int64 v134; // rax
  __int64 v135; // rcx
  __int64 v136; // r8
  int v137; // r9d
  int v138; // esi
  int v139; // edx
  _WORD *v140; // rax
  unsigned __int16 *v141; // rdi
  int v142; // ebx
  unsigned __int16 *v143; // r14
  int v144; // eax
  __int64 v145; // rdi
  __int64 v146; // rax
  __int64 v147; // rdx
  __int64 v148; // r8
  unsigned __int16 v149; // ax
  int v150; // r11d
  __int64 v151; // r14
  __int64 v152; // r12
  unsigned int v153; // r15d
  __int64 v154; // r13
  int v155; // ebx
  int v156; // eax
  int v157; // r11d
  int v158; // eax
  char v159; // al
  __int64 v160; // rdx
  __int16 *v161; // rax
  __int16 v162; // dx
  __int16 *v163; // rax
  unsigned __int16 v164; // r12
  __int16 *v165; // r15
  __int16 v166; // dx
  unsigned int v167; // eax
  __int64 v168; // r11
  __int64 v169; // rdx
  unsigned __int16 *v170; // rsi
  unsigned __int16 *v171; // rax
  unsigned __int16 *v172; // rax
  unsigned __int16 *v173; // rax
  char *v174; // rax
  char *v175; // rcx
  char *v176; // rax
  __int64 v177; // rdx
  char *v178; // rdx
  __int64 v179; // rax
  void *v180; // rax
  __int64 v181; // rax
  const char *v182; // rsi
  __int64 v183; // rdi
  __int64 v184; // rax
  __int64 v185; // rdi
  void *v186; // rax
  __int64 v187; // rax
  __int64 v188; // rax
  __int64 v189; // rax
  void *v190; // rax
  __int64 v191; // rax
  __int64 v192; // rax
  __int64 v193; // rax
  __int64 v194; // rax
  __int64 v195; // r12
  unsigned int v196; // eax
  __int64 v197; // rax
  __int64 v198; // rdx
  __int64 v199; // rax
  char v200; // al
  __int64 v201; // rdi
  void *v202; // rax
  __int64 v203; // r15
  unsigned int v204; // eax
  __int64 *v205; // r11
  __int64 v206; // rax
  int v207; // ecx
  unsigned int v208; // esi
  int v209; // ecx
  __int64 v210; // rax
  __int64 v211; // rax
  signed __int64 v212; // rdx
  int v213; // eax
  int v214; // eax
  _BYTE *v216; // [rsp-10h] [rbp-B0h]
  __int64 v217; // [rsp-10h] [rbp-B0h]
  int v218; // [rsp+4h] [rbp-9Ch]
  int v219; // [rsp+8h] [rbp-98h]
  __int64 v220; // [rsp+8h] [rbp-98h]
  int v221; // [rsp+10h] [rbp-90h]
  unsigned __int16 *v222; // [rsp+10h] [rbp-90h]
  __int64 v223; // [rsp+10h] [rbp-90h]
  __int64 v224; // [rsp+18h] [rbp-88h]
  unsigned __int64 v225; // [rsp+18h] [rbp-88h]
  __int64 v226; // [rsp+18h] [rbp-88h]
  __int64 *v227; // [rsp+18h] [rbp-88h]
  __int64 v228; // [rsp+18h] [rbp-88h]
  __int64 v229; // [rsp+18h] [rbp-88h]
  __int64 v230; // [rsp+18h] [rbp-88h]
  unsigned int v231; // [rsp+20h] [rbp-80h]
  __int64 v232; // [rsp+20h] [rbp-80h]
  unsigned __int64 v233; // [rsp+20h] [rbp-80h]
  __int64 v234; // [rsp+20h] [rbp-80h]
  unsigned __int16 *v235; // [rsp+20h] [rbp-80h]
  __int64 v236; // [rsp+20h] [rbp-80h]
  __int64 *v237; // [rsp+20h] [rbp-80h]
  __int64 *v238; // [rsp+20h] [rbp-80h]
  __int64 v239; // [rsp+28h] [rbp-78h]
  __int64 v240; // [rsp+28h] [rbp-78h]
  __int64 v241; // [rsp+28h] [rbp-78h]
  __int64 v242; // [rsp+28h] [rbp-78h]
  int v243; // [rsp+28h] [rbp-78h]
  _QWORD *v244; // [rsp+28h] [rbp-78h]
  __int64 v245; // [rsp+28h] [rbp-78h]
  __int64 v246; // [rsp+28h] [rbp-78h]
  __int64 v247; // [rsp+28h] [rbp-78h]
  __int64 v248; // [rsp+28h] [rbp-78h]
  __int64 v249; // [rsp+28h] [rbp-78h]
  __int64 v250; // [rsp+28h] [rbp-78h]
  __int64 v251; // [rsp+28h] [rbp-78h]
  __int64 v252; // [rsp+28h] [rbp-78h]
  __int64 *v253; // [rsp+28h] [rbp-78h]
  char v254; // [rsp+28h] [rbp-78h]
  __int64 v255; // [rsp+28h] [rbp-78h]
  __int64 v256; // [rsp+28h] [rbp-78h]
  __int64 v257; // [rsp+30h] [rbp-70h]
  unsigned int v258; // [rsp+30h] [rbp-70h]
  __int64 v259; // [rsp+30h] [rbp-70h]
  __int64 v260; // [rsp+30h] [rbp-70h]
  unsigned __int16 *v261; // [rsp+30h] [rbp-70h]
  __int64 v262; // [rsp+30h] [rbp-70h]
  _QWORD *v263; // [rsp+30h] [rbp-70h]
  __int64 v264; // [rsp+30h] [rbp-70h]
  __int64 v265; // [rsp+30h] [rbp-70h]
  __int64 v266; // [rsp+30h] [rbp-70h]
  __int64 v267; // [rsp+30h] [rbp-70h]
  char v268; // [rsp+30h] [rbp-70h]
  __int64 v269; // [rsp+30h] [rbp-70h]
  unsigned __int16 v270; // [rsp+30h] [rbp-70h]
  int v271; // [rsp+30h] [rbp-70h]
  __int64 v272; // [rsp+38h] [rbp-68h]
  __int64 v273; // [rsp+38h] [rbp-68h]
  __int64 v274; // [rsp+38h] [rbp-68h]
  __int64 v275; // [rsp+38h] [rbp-68h]
  __int64 v276; // [rsp+38h] [rbp-68h]
  char v277; // [rsp+38h] [rbp-68h]
  char v278; // [rsp+38h] [rbp-68h]
  __int64 v279; // [rsp+38h] [rbp-68h]
  __int64 v280; // [rsp+38h] [rbp-68h]
  __int64 v281; // [rsp+38h] [rbp-68h]
  __int64 v282; // [rsp+38h] [rbp-68h]
  unsigned __int64 v283; // [rsp+38h] [rbp-68h]
  unsigned __int64 v284; // [rsp+38h] [rbp-68h]
  __int64 v285; // [rsp+38h] [rbp-68h]
  __int64 v286; // [rsp+38h] [rbp-68h]
  void *v287; // [rsp+38h] [rbp-68h]
  __int64 v288; // [rsp+38h] [rbp-68h]
  __int64 v289; // [rsp+38h] [rbp-68h]
  unsigned int v290; // [rsp+38h] [rbp-68h]
  _QWORD *v291; // [rsp+38h] [rbp-68h]
  __int64 v292; // [rsp+38h] [rbp-68h]
  unsigned int v293; // [rsp+38h] [rbp-68h]
  __int64 v294; // [rsp+38h] [rbp-68h]
  __int64 v295; // [rsp+38h] [rbp-68h]
  __int64 v296; // [rsp+38h] [rbp-68h]
  unsigned int v297; // [rsp+38h] [rbp-68h]
  __int64 v298; // [rsp+38h] [rbp-68h]
  unsigned int v299; // [rsp+44h] [rbp-5Ch] BYREF
  __int64 v300; // [rsp+48h] [rbp-58h] BYREF
  __int64 v301; // [rsp+50h] [rbp-50h] BYREF
  unsigned __int64 v302; // [rsp+58h] [rbp-48h]

  v7 = a3;
  v8 = (__int64)a2;
  v9 = *((_QWORD *)a2 + 2);
  LOBYTE(v10) = *a2;
  v11 = *(unsigned __int16 **)(v9 + 16);
  v12 = *a2;
  if ( *v11 == 21 )
  {
    if ( !a3 )
    {
      if ( !(_BYTE)v10 )
      {
        if ( *((_BYTE *)v11 + 4) )
        {
          v13 = *((_QWORD *)v11 + 5);
LABEL_4:
          LOBYTE(v10) = a2[3];
          if ( (v10 & 0x10) == 0 && (*(_BYTE *)(v13 + 2) & 4) == 0 )
          {
            LODWORD(v12) = v7;
            v14 = "Explicit definition marked as use";
            v13 = v8;
LABEL_12:
            v272 = a1;
            sub_1E86D40(a1, v14, v13, v12, 0);
            LOBYTE(v10) = *(_BYTE *)v8;
            a1 = v272;
            goto LABEL_13;
          }
          if ( (v10 & 0x20) != 0 )
          {
            LODWORD(v12) = v7;
            v14 = "Explicit definition marked as implicit";
            v13 = v8;
            goto LABEL_12;
          }
LABEL_28:
          v18 = *(_DWORD *)(v8 + 8);
          goto LABEL_29;
        }
        v13 = v11[1];
        if ( v11[1] )
        {
          v15 = *((_QWORD *)v11 + 5);
          v16 = 0;
          v17 = v15;
          goto LABEL_65;
        }
LABEL_23:
        v18 = *((_DWORD *)a2 + 2);
        if ( (a2[3] & 0x20) != 0 || (v11[4] & 1) != 0 )
        {
LABEL_29:
          if ( !v18 )
            return v10;
          goto LABEL_30;
        }
        if ( !v18 )
          return v10;
        LODWORD(v12) = v7;
        v14 = "Extra explicit operand on non-variadic instruction";
        v13 = v8;
        goto LABEL_12;
      }
      v13 = v11[1];
      if ( v11[1] )
      {
        v17 = *((_QWORD *)v11 + 5);
LABEL_10:
        if ( (*(_BYTE *)(v17 + 4) & 1) == 0 )
          goto LABEL_13;
        goto LABEL_11;
      }
LABEL_22:
      if ( (_BYTE)v12 )
        goto LABEL_13;
      goto LABEL_23;
    }
  }
  else if ( a3 < *((unsigned __int8 *)v11 + 4) )
  {
    v12 = *((_QWORD *)v11 + 5);
    v13 = v12 + 8LL * a3;
    if ( (_BYTE)v10 )
    {
      v13 = (__int64)a2;
      v14 = "Explicit definition must be a register";
      LODWORD(v12) = v7;
      goto LABEL_12;
    }
    goto LABEL_4;
  }
  v13 = v11[1];
  if ( v7 >= (unsigned int)v13 )
    goto LABEL_22;
  v15 = *((_QWORD *)v11 + 5);
  v16 = 8LL * v7;
  v17 = v15 + v16;
  if ( (_BYTE)v12 )
    goto LABEL_10;
LABEL_65:
  if ( (v11[4] & 1) != 0 )
  {
    v13 = (unsigned int)(v13 - 1);
    if ( (_DWORD)v13 == v7 )
    {
      v35 = *(_DWORD *)(v17 + 4);
      if ( (v35 & 1) != 0 )
        goto LABEL_68;
LABEL_260:
      if ( (*(_WORD *)(v8 + 2) & 0xFF0) != 0 )
      {
        LODWORD(v12) = v7;
        v14 = "Explicit operand should not be tied";
        v13 = v8;
        goto LABEL_12;
      }
      goto LABEL_28;
    }
  }
  v36 = *(_BYTE *)(v8 + 3);
  if ( (v36 & 0x10) == 0 || (*(_BYTE *)(v17 + 2) & 4) != 0 )
  {
    if ( (v36 & 0x20) == 0 )
    {
      LOBYTE(v10) = 0;
      goto LABEL_77;
    }
    goto LABEL_157;
  }
  v275 = a1;
  sub_1E86D40(a1, "Explicit operand marked as def", v8, v7, 0);
  a1 = v275;
  if ( (*(_BYTE *)(v8 + 3) & 0x20) != 0 )
  {
LABEL_157:
    v289 = a1;
    sub_1E86D40(a1, "Explicit operand marked as implicit", v8, v7, 0);
    a1 = v289;
  }
  v13 = v11[1];
  LOBYTE(v10) = *(_BYTE *)v8;
  if ( v7 >= (unsigned int)v13 )
    goto LABEL_259;
  v15 = *((_QWORD *)v11 + 5);
LABEL_77:
  v35 = *(_DWORD *)(v15 + v16 + 4);
  if ( (v35 & 1) == 0 )
  {
LABEL_259:
    if ( (_BYTE)v10 )
    {
LABEL_13:
      if ( (_BYTE)v10 != 5 )
      {
        if ( (unsigned __int8)v10 <= 5u )
        {
          if ( (_BYTE)v10 )
          {
LABEL_16:
            if ( (_BYTE)v10 != 4 )
              return v10;
            LODWORD(v10) = **(unsigned __int16 **)(v9 + 16);
            if ( **(_WORD **)(v9 + 16) )
            {
              if ( (_DWORD)v10 != 45 )
                return v10;
            }
            v273 = a1;
            LOBYTE(v10) = sub_1DD6970(*(_QWORD *)(v8 + 24), *(_QWORD *)(v9 + 24));
            a1 = v273;
            if ( (_BYTE)v10 )
              return v10;
            v22 = v7;
            v23 = "PHI operand is not in the CFG";
            v24 = v8;
LABEL_124:
            LOBYTE(v10) = sub_1E86D40(a1, v23, v24, v22, 0);
            return v10;
          }
          goto LABEL_28;
        }
LABEL_41:
        if ( (_BYTE)v10 == 12 )
        {
          v25 = *(_QWORD *)(v8 + 24);
          v10 = *(unsigned int *)(a1 + 480);
          if ( (unsigned int)v10 >= *(_DWORD *)(a1 + 484) )
          {
            v288 = a1;
            sub_16CD150(a1 + 472, (const void *)(a1 + 488), 0, 8, a5, a6);
            a1 = v288;
            v10 = *(unsigned int *)(v288 + 480);
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 472) + 8 * v10) = v25;
          ++*(_DWORD *)(a1 + 480);
        }
        return v10;
      }
LABEL_45:
      v26 = *(_QWORD *)(a1 + 576);
      if ( !v26 )
        return v10;
      v27 = *(_QWORD *)(v26 + 352);
      v28 = *(_DWORD *)(v8 + 24);
      v10 = *(_QWORD *)(v26 + 344);
      v29 = *(__int64 ***)(v10 + 8 * (v28 % v27));
      v30 = v28 % v27;
      if ( !v29 )
        return v10;
      v31 = *v29;
      if ( !*v29 )
        return v10;
      LODWORD(v10) = *((_DWORD *)v31 + 2);
      v32 = *v29;
      v33 = 0;
      v34 = v10;
      do
      {
        if ( v28 == v34 )
        {
          ++v33;
        }
        else if ( v33 )
        {
          goto LABEL_81;
        }
        v32 = (__int64 *)*v32;
        if ( !v32 )
          break;
        v34 = *((_DWORD *)v32 + 2);
        v10 = v34 / v27;
      }
      while ( v30 == v34 % v27 );
      if ( !v33 )
        return v10;
LABEL_81:
      v10 = *(_QWORD *)(a1 + 568);
      if ( !v10 )
        return v10;
      v37 = *(_QWORD *)(v10 + 272);
      v38 = *(_DWORD *)(v37 + 384);
      if ( !v38 )
        return v10;
      v39 = v38 - 1;
      v40 = *(_QWORD *)(v37 + 368);
      v41 = v39 & (((unsigned int)v9 >> 9) ^ ((unsigned int)v9 >> 4));
      v10 = *(_QWORD *)(v40 + 16LL * v41);
      if ( v9 != v10 )
      {
        v271 = 1;
        while ( v10 != -8 )
        {
          v41 = v39 & (v271 + v41);
          ++v271;
          v10 = *(_QWORD *)(v40 + 16LL * v41);
          if ( v9 == v10 )
            goto LABEL_84;
        }
        return v10;
      }
LABEL_84:
      if ( v28 == *((_DWORD *)v31 + 2) )
      {
LABEL_88:
        v42 = *v29;
      }
      else
      {
        while ( 1 )
        {
          v42 = (__int64 *)*v31;
          if ( !*v31 )
            break;
          v29 = (__int64 **)v31;
          if ( v30 != *((int *)v42 + 2) % v27 )
          {
            v42 = 0;
            break;
          }
          v31 = (__int64 *)*v31;
          if ( v28 == *((_DWORD *)v42 + 2) )
            goto LABEL_88;
        }
      }
      v276 = a1;
      v43 = (__int64)(v42 + 2);
      v44 = sub_1E85F30(v37, v9);
      v45 = *(__int16 **)(v9 + 16);
      v46 = v276;
      v257 = v44;
      v47 = *v45;
      if ( *v45 == 1 && (v48 = *(_QWORD *)(*(_QWORD *)(v9 + 32) + 64LL), (v48 & 0x10) != 0) )
      {
        LOBYTE(v51) = 1;
        if ( (v48 & 8) != 0 )
        {
LABEL_100:
          v53 = *(__int64 ***)(v9 + 56);
          v54 = &v53[*(unsigned __int8 *)(v9 + 49)];
          if ( v53 == v54 )
          {
LABEL_192:
            v295 = v46;
            sub_1E86C30(v46, "Missing fixed stack memoperand.", v9);
            v46 = v295;
            LOBYTE(v51) = 1;
LABEL_107:
            v240 = v46;
            v278 = v51;
            LOBYTE(v10) = sub_1E85FD0(v43, v257 & 0xFFFFFFFFFFFFFFF8LL | 2);
            LOBYTE(v51) = v278;
            v46 = v240;
            if ( !(_BYTE)v10 )
            {
              v201 = v240;
              v254 = v278;
              v298 = v46;
              sub_1E86D40(v201, "Instruction loads from dead spill slot", v8, v7, 0);
              v202 = sub_16E8CB0();
              v203 = sub_1263B40((__int64)v202, "Live stack: ");
              sub_1DB53F0(v43, v203);
              LOBYTE(v10) = sub_1549FC0(v203, 0xAu);
              LOBYTE(v51) = v254;
              v46 = v298;
            }
LABEL_109:
            if ( !(_BYTE)v51 )
              return v10;
            goto LABEL_110;
          }
          while ( 1 )
          {
            v55 = **v53;
            if ( (v55 & 4) != 0 )
            {
              v56 = v55 & 0xFFFFFFFFFFFFFFF8LL;
              if ( v56 )
              {
                if ( *(_DWORD *)(v56 + 8) == 4 && v28 == *(_DWORD *)(v56 + 16) )
                  break;
              }
            }
            if ( v54 == ++v53 )
              goto LABEL_192;
          }
          if ( ((*v53)[4] & 2) != 0 )
          {
LABEL_110:
            v279 = v46;
            LOBYTE(v10) = sub_1E85FD0(v43, v257 & 0xFFFFFFFFFFFFFFF8LL | 4);
            if ( !(_BYTE)v10 )
            {
              sub_1E86D40(v279, "Instruction stores to dead spill slot", v8, v7, 0);
              v57 = sub_16E8CB0();
              v58 = sub_1263B40((__int64)v57, "Live stack: ");
              sub_1DB53F0(v43, v58);
              LOBYTE(v10) = sub_1549FC0(v58, 0xAu);
            }
            return v10;
          }
LABEL_106:
          LOBYTE(v51) = 0;
          goto LABEL_107;
        }
      }
      else
      {
        v49 = *(_WORD *)(v9 + 46);
        if ( (v49 & 4) != 0 || (v49 & 8) == 0 )
        {
          v51 = (*((_QWORD *)v45 + 1) >> 17) & 1LL;
        }
        else
        {
          v50 = sub_1E15D00(v9, 0x20000u, 1);
          v45 = *(__int16 **)(v9 + 16);
          v46 = v276;
          LOBYTE(v51) = v50;
          v47 = *v45;
        }
        if ( v47 == 1 && (*(_BYTE *)(*(_QWORD *)(v9 + 32) + 64LL) & 8) != 0 )
        {
          if ( !(_BYTE)v51 )
            goto LABEL_106;
          goto LABEL_100;
        }
      }
      v52 = *(_WORD *)(v9 + 46);
      if ( (v52 & 4) != 0 || (v52 & 8) == 0 )
      {
        v10 = (*((_QWORD *)v45 + 1) >> 16) & 1LL;
      }
      else
      {
        v239 = v46;
        v277 = v51;
        LOBYTE(v10) = sub_1E15D00(v9, 0x10000u, 1);
        LOBYTE(v51) = v277;
        v46 = v239;
      }
      if ( !(_BYTE)v51 )
      {
        if ( !(_BYTE)v10 )
          return v10;
        goto LABEL_107;
      }
      if ( !(_BYTE)v10 )
        goto LABEL_109;
      goto LABEL_100;
    }
    goto LABEL_260;
  }
  if ( (_BYTE)v10 )
  {
LABEL_11:
    LODWORD(v12) = v7;
    v14 = "Tied use must be a register";
    v13 = v8;
    goto LABEL_12;
  }
LABEL_68:
  if ( (*(_WORD *)(v8 + 2) & 0xFF0) == 0 )
  {
    LODWORD(v12) = v7;
    v14 = "Operand should be tied";
    v13 = v8;
    goto LABEL_12;
  }
  v292 = a1;
  v116 = sub_1E16AB0(v9, v7, v13, v12, a5, (_BYTE *)a6);
  a1 = v292;
  v12 = v116;
  if ( v116 != BYTE2(v35) )
  {
    sub_1E86D40(v292, "Tied def doesn't match MCInstrDesc", v8, v7, 0);
    LOBYTE(v10) = *(_BYTE *)v8;
    a1 = v292;
    goto LABEL_13;
  }
  v18 = *(_DWORD *)(v8 + 8);
  if ( v18 <= 0 )
  {
    LOBYTE(v10) = *(_BYTE *)v8;
    goto LABEL_13;
  }
  a5 = 0;
  v14 = "Tied counterpart must be a register";
  v13 = *(_QWORD *)(v9 + 32) + 40LL * (int)v116;
  if ( *(_BYTE *)v13 )
    goto LABEL_12;
  v124 = *(_DWORD *)(v13 + 8);
  if ( v18 != v124 )
  {
    a5 = 0;
    v14 = "Tied physical registers must match.";
    if ( v124 > 0 )
      goto LABEL_12;
  }
  LOBYTE(v10) = *(_BYTE *)v8;
  if ( *(_BYTE *)v8 == 5 )
    goto LABEL_45;
  if ( (unsigned __int8)v10 > 5u )
    goto LABEL_41;
  if ( (_BYTE)v10 )
    goto LABEL_16;
LABEL_30:
  if ( (**(_BYTE **)(**(_QWORD **)(a1 + 48) + 352LL) & 4) == 0 || **(_WORD **)(v9 + 16) == 12 )
    goto LABEL_32;
  v76 = *(_QWORD *)(v8 + 16);
  v299 = v18;
  v283 = v76;
  v77 = *(_BYTE *)(v8 + 4);
  if ( (v77 & 1) != 0 || (v77 & 2) != 0 )
    goto LABEL_189;
  v78 = *(_BYTE *)(v8 + 3);
  if ( (v78 & 0x10) != 0 )
  {
    v79 = v18;
    if ( (*(_DWORD *)v8 & 0xFFF00) == 0 )
      goto LABEL_130;
  }
  else if ( (v78 & 0x40) != 0 )
  {
    v265 = a1;
    sub_1E84EF0(a1, a1 + 392, v18, v12, a5, a6);
    a1 = v265;
  }
  v125 = *(char **)(a1 + 560);
  if ( !v125 || (v299 & 0x80000000) == 0 || (((*(_BYTE *)(v8 + 3) & 0x40) != 0) & ((*(_BYTE *)(v8 + 3) >> 4) ^ 1)) == 0 )
    goto LABEL_198;
  v269 = a1;
  v174 = sub_1DCC790(v125, v299);
  a1 = v269;
  v175 = (char *)*((_QWORD *)v174 + 5);
  v176 = (char *)*((_QWORD *)v174 + 4);
  v177 = (v175 - v176) >> 5;
  if ( v177 > 0 )
  {
    v178 = &v176[32 * v177];
    while ( v283 != *(_QWORD *)v176 )
    {
      if ( v283 == *((_QWORD *)v176 + 1) )
      {
        v176 += 8;
        break;
      }
      if ( v283 == *((_QWORD *)v176 + 2) )
      {
        v176 += 16;
        break;
      }
      if ( v283 == *((_QWORD *)v176 + 3) )
      {
        v176 += 24;
        break;
      }
      v176 += 32;
      if ( v178 == v176 )
        goto LABEL_336;
    }
LABEL_271:
    if ( v175 != v176 )
      goto LABEL_198;
    goto LABEL_272;
  }
LABEL_336:
  v212 = v175 - v176;
  if ( v175 - v176 != 16 )
  {
    if ( v212 != 24 )
    {
      if ( v212 != 8 )
        goto LABEL_272;
      goto LABEL_339;
    }
    if ( v283 == *(_QWORD *)v176 )
      goto LABEL_271;
    v176 += 8;
  }
  if ( v283 == *(_QWORD *)v176 )
    goto LABEL_271;
  v176 += 8;
LABEL_339:
  if ( v283 == *(_QWORD *)v176 )
    goto LABEL_271;
LABEL_272:
  sub_1E86D40(v269, "Kill missing from LiveVariables", v8, v7, 0);
  a1 = v269;
LABEL_198:
  v126 = *(_QWORD *)(a1 + 568);
  if ( v126 )
  {
    v127 = *(_QWORD *)(v126 + 272);
    v128 = *(_DWORD *)(v127 + 384);
    if ( v128 )
    {
      v129 = v128 - 1;
      v130 = *(_QWORD *)(v127 + 368);
      v131 = 1;
      LODWORD(v132) = (v128 - 1) & (((unsigned int)v283 >> 9) ^ ((unsigned int)v283 >> 4));
      v133 = *(_QWORD *)(v130 + 16LL * (unsigned int)v132);
      if ( v283 != v133 )
      {
        while ( v133 != -8 )
        {
          v132 = v129 & (unsigned int)(v132 + v131);
          v133 = *(_QWORD *)(v130 + 16 * v132);
          if ( v283 == v133 )
            goto LABEL_201;
          ++v131;
        }
        goto LABEL_226;
      }
LABEL_201:
      v266 = a1;
      v134 = sub_1E85F30(v127, v283);
      v138 = v299;
      a1 = v266;
      v248 = v134;
      if ( (int)v299 > 0 )
      {
        if ( v299 < *(_DWORD *)(v266 + 192)
          && (*(_QWORD *)(*(_QWORD *)(v266 + 176) + 8LL * (v299 >> 6)) & (1LL << v299)) != 0 )
        {
          goto LABEL_226;
        }
        v135 = *(_QWORD *)(v266 + 40);
        if ( !v135 )
          BUG();
        v233 = v9;
        v221 = v18;
        v139 = v299 * (*(_DWORD *)(*(_QWORD *)(v135 + 8) + 24LL * v299 + 16) & 0xF);
        v140 = (_WORD *)(*(_QWORD *)(v135 + 56) + 2LL * (*(_DWORD *)(*(_QWORD *)(v135 + 8) + 24LL * v299 + 16) >> 4));
        LOWORD(v139) = *v140 + v139;
        v141 = v140 + 1;
        v142 = v139;
        while ( 1 )
        {
          v143 = v141;
          if ( !v141 )
            break;
          while ( 1 )
          {
            if ( !(unsigned __int8)sub_1E6A680(*(_QWORD **)(v266 + 48), (unsigned __int16)v142) )
            {
              v136 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v266 + 568) + 672LL) + 8LL * (unsigned __int16)v142);
              if ( v136 )
                sub_1E86DD0(v266, v8, v7, v248, v136, (unsigned __int16)v142, 0);
            }
            v144 = *v143;
            v141 = 0;
            ++v143;
            if ( !(_WORD)v144 )
              break;
            v142 += v144;
            if ( !v143 )
              goto LABEL_212;
          }
        }
LABEL_212:
        a1 = v266;
        v9 = v233;
        v18 = v221;
        v138 = v299;
      }
      if ( v138 >= 0 )
        goto LABEL_226;
      v145 = *(_QWORD *)(a1 + 568);
      v146 = v138 & 0x7FFFFFFF;
      if ( (unsigned int)v146 >= *(_DWORD *)(v145 + 408)
        || (v147 = *(_QWORD *)(v145 + 400), !*(_QWORD *)(v147 + 8 * v146)) )
      {
        v256 = a1;
        sub_1E86D40(a1, "Virtual register has no live interval", v8, v7, 0);
        a1 = v256;
        goto LABEL_226;
      }
      v224 = a1;
      v234 = sub_1E86160(v145, v138, v147, v135, v136, v137);
      sub_1E86DD0(v224, v8, v7, v248, v234, v299, 0);
      a1 = v224;
      v148 = *(_QWORD *)(v234 + 104);
      if ( v148 )
      {
        if ( (*(_BYTE *)(v8 + 3) & 0x10) == 0 )
        {
          v149 = (*(_DWORD *)v8 >> 8) & 0xFFF;
          if ( v149 )
          {
            v150 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v224 + 40) + 248LL) + 4LL * v149);
          }
          else
          {
            v214 = sub_1E69F40(*(_QWORD *)(v224 + 48), v299);
            a1 = v224;
            v150 = v214;
            v148 = *(_QWORD *)(v234 + 104);
            if ( !v148 )
              goto LABEL_351;
          }
          v225 = v9;
          v151 = v8;
          v152 = v148;
          v222 = v11;
          v153 = v7;
          v154 = a1;
          v219 = v18;
          v155 = 0;
          v156 = v150;
          do
          {
            if ( (*(_DWORD *)(v152 + 112) & v156) != 0 )
            {
              v218 = v156;
              sub_1E86DD0(v154, v151, v153, v248, v152, v299, *(_DWORD *)(v152 + 112));
              sub_1E86030((__int64)&v301, v152, v248);
              v156 = v218;
              if ( v301 )
                v155 |= *(_DWORD *)(v152 + 112);
            }
            v152 = *(_QWORD *)(v152 + 104);
          }
          while ( v152 );
          v157 = v156;
          v158 = v155;
          a1 = v154;
          v8 = v151;
          v7 = v153;
          v18 = v219;
          v9 = v225;
          v11 = v222;
          if ( (v157 & v158) != 0 )
            goto LABEL_226;
LABEL_351:
          v230 = a1;
          sub_1E86D40(a1, "No live subrange at use", v8, v7, 0);
          sub_1E85B20(v234);
          sub_1E85AA0(v248);
          a1 = v230;
        }
      }
    }
  }
LABEL_226:
  v249 = a1;
  v226 = a1 + 200;
  v159 = sub_1DF91F0(a1 + 200, (int *)&v299, &v301);
  a1 = v249;
  if ( !v159 )
  {
    v12 = v299;
    a5 = (__int64)&v299;
    if ( (int)v299 <= 0 )
    {
      v198 = *(_QWORD *)(v249 + 48);
      if ( v299 )
        v199 = *(_QWORD *)(*(_QWORD *)(v198 + 24) + 16LL * (v299 & 0x7FFFFFFF) + 8);
      else
        v199 = **(_QWORD **)(v198 + 272);
      if ( v199
        && ((*(_BYTE *)(v199 + 3) & 0x10) != 0
         || (v210 = *(_QWORD *)(v199 + 32)) != 0 && (*(_BYTE *)(v210 + 3) & 0x10) != 0) )
      {
        v236 = v249;
        v301 = *(_QWORD *)(v283 + 24);
        v253 = sub_1E855C0(v249 + 528, &v301);
        v200 = sub_1DF91F0((__int64)(v253 + 6), (int *)&v299, &v301);
        a1 = v236;
        if ( v200 )
        {
          sub_1E86D40(v236, "Using a killed virtual register", v8, v7, 0);
          a1 = v236;
        }
        else if ( **(_WORD **)(v283 + 16) != 45 )
        {
          if ( **(_WORD **)(v283 + 16) )
          {
            LODWORD(v301) = v299;
            v227 = v253;
            v255 = (__int64)(v253 + 2);
            v302 = v283;
            v204 = sub_1E8ACA0(v255, (int *)&v301, &v300);
            v13 = (__int64)&v300;
            a5 = v204;
            v205 = v227;
            v206 = v300;
            a1 = v236;
            if ( !(_BYTE)a5 )
            {
              v207 = *((_DWORD *)v227 + 8);
              v208 = *((_DWORD *)v227 + 10);
              ++v227[2];
              v209 = v207 + 1;
              a6 = (unsigned int)(4 * v209);
              if ( (unsigned int)a6 >= 3 * v208 )
              {
                v228 = v236;
                v237 = v205;
                sub_1E8D590(v255, 2 * v208);
                sub_1E8ACA0(v255, (int *)&v301, &v300);
                v206 = v300;
                v205 = v237;
                a1 = v228;
              }
              else
              {
                a5 = v208 - *((_DWORD *)v227 + 9) - v209;
                v12 = v208 >> 3;
                if ( (unsigned int)a5 <= (unsigned int)v12 )
                {
                  v229 = v236;
                  v238 = v205;
                  sub_1E8D590(v255, v208);
                  sub_1E8ACA0(v255, (int *)&v301, &v300);
                  v206 = v300;
                  a1 = v229;
                  v205 = v238;
                }
              }
              ++*((_DWORD *)v205 + 8);
              if ( *(_DWORD *)v206 != -1 )
                --*((_DWORD *)v205 + 9);
              *(_DWORD *)v206 = v301;
              v13 = v302;
              *(_QWORD *)(v206 + 8) = v302;
            }
          }
        }
      }
      else
      {
        sub_1E86D40(v249, "Reading virtual register without a def", v8, v7, 0);
        a1 = v249;
      }
    }
    else if ( v299 >= *(_DWORD *)(v249 + 192)
           || (v13 = v299 >> 6, (*(_QWORD *)(*(_QWORD *)(v249 + 176) + 8 * v13) & (1LL << v299)) == 0) )
    {
      v160 = *(_QWORD *)(v249 + 40);
      if ( !v160 )
LABEL_354:
        BUG();
      v235 = v11;
      v223 = v249;
      v161 = (__int16 *)(*(_QWORD *)(v160 + 56) + 2LL * *(unsigned int *)(*(_QWORD *)(v160 + 8) + 24LL * v299 + 4));
      v220 = v8;
      v162 = *v161;
      v163 = v161 + 1;
      if ( !v162 )
        v163 = 0;
      v164 = v162 + v299;
LABEL_234:
      v165 = v163;
      if ( v163 )
      {
        while ( 1 )
        {
          LODWORD(v300) = v164;
          if ( (unsigned __int8)sub_1DF91F0(v226, (int *)&v300, &v301) )
            break;
          v166 = *v165;
          v163 = 0;
          ++v165;
          if ( !v166 )
            goto LABEL_234;
          v164 += v166;
          if ( !v165 )
            goto LABEL_238;
        }
        v11 = v235;
        a1 = v249;
        v8 = v220;
      }
      else
      {
LABEL_238:
        v11 = v235;
        v8 = v220;
        v250 = *(_QWORD *)(v283 + 32);
        v267 = v250 + 40LL * *(unsigned int *)(v283 + 40);
        v167 = sub_1E163A0(v283);
        v13 = v250;
        v168 = v267;
        a1 = v223;
        a5 = v250 + 40LL * v167;
        if ( v267 == a5 )
          goto LABEL_304;
        v268 = 1;
        do
        {
          if ( !*(_BYTE *)a5 && (*(_BYTE *)(a5 + 3) & 0x20) != 0 )
          {
            v169 = *(_QWORD *)(v223 + 40);
            if ( !v169 )
              goto LABEL_354;
            v170 = 0;
            a6 = v299;
            v171 = (unsigned __int16 *)(*(_QWORD *)(v169 + 56)
                                      + 2LL
                                      * *(unsigned int *)(*(_QWORD *)(v169 + 8) + 24LL * *(unsigned int *)(a5 + 8) + 4));
            v13 = *v171;
            v172 = v171 + 1;
            v12 = (unsigned int)v13 + *(unsigned __int16 *)(a5 + 8);
            if ( (_WORD)v13 )
              v170 = v172;
LABEL_246:
            v173 = v170;
            if ( v170 )
            {
              while ( 1 )
              {
                v13 = (unsigned __int16)v12;
                if ( (unsigned __int16)v12 == v299 )
                  break;
                v13 = *v173;
                v170 = 0;
                ++v173;
                if ( !(_WORD)v13 )
                  goto LABEL_246;
                v12 = (unsigned int)(v13 + v12);
                if ( !v173 )
                  goto LABEL_240;
              }
              v268 = 0;
            }
          }
LABEL_240:
          a5 += 40;
        }
        while ( v168 != a5 );
        if ( v268 )
        {
LABEL_304:
          sub_1E86D40(v223, "Using an undefined physical register", v220, v7, 0);
          a1 = v223;
        }
      }
    }
  }
LABEL_189:
  v78 = *(_BYTE *)(v8 + 3);
  if ( (v78 & 0x10) == 0 )
    goto LABEL_32;
  v79 = v299;
LABEL_130:
  v80 = a1 + 312;
  if ( (((v78 & 0x10) != 0) & (v78 >> 6)) == 0 )
    v80 = a1 + 232;
  v259 = a1;
  sub_1E84EF0(a1, v80, v79, v12, v79, a6);
  a1 = v259;
  v81 = *(_QWORD **)(v259 + 48);
  v13 = *(_QWORD *)(*v81 + 352LL);
  if ( (*(_BYTE *)v13 & 1) != 0 )
  {
    v13 = v299;
    if ( (v299 & 0x80000000) != 0 )
    {
      v13 = v81[3] + 16LL * (v299 & 0x7FFFFFFF);
      v188 = *(_QWORD *)(v13 + 8);
      if ( v188 )
      {
        if ( (*(_BYTE *)(v188 + 3) & 0x10) == 0 )
        {
          v188 = *(_QWORD *)(v188 + 32);
          if ( v188 )
          {
            if ( (*(_BYTE *)(v188 + 3) & 0x10) == 0 )
              BUG();
          }
        }
      }
      v189 = *(_QWORD *)(v188 + 32);
      if ( v189 && (*(_BYTE *)(v189 + 3) & 0x10) != 0 )
      {
        sub_1E86D40(v259, "Multiple virtual register defs in SSA form", v8, v7, 0);
        a1 = v259;
      }
    }
  }
  v82 = *(_QWORD *)(a1 + 568);
  if ( v82 )
  {
    v83 = *(_QWORD *)(v82 + 272);
    v13 = *(unsigned int *)(v83 + 384);
    if ( (_DWORD)v13 )
    {
      a6 = v283;
      v13 = (unsigned int)(v13 - 1);
      v84 = *(_QWORD *)(v83 + 368);
      a5 = 1;
      LODWORD(v85) = v13 & (((unsigned int)v283 >> 9) ^ ((unsigned int)v283 >> 4));
      v12 = *(_QWORD *)(v84 + 16LL * (unsigned int)v85);
      if ( v283 == v12 )
      {
LABEL_137:
        v260 = a1;
        v241 = *(_QWORD *)(a1 + 568);
        v86 = sub_1E85F30(v83, v283);
        a1 = v260;
        v13 = v86;
        v12 = (*(_BYTE *)(v8 + 4) & 4) == 0 ? 4LL : 2LL;
        if ( (v299 & 0x80000000) == 0 )
          goto LABEL_32;
        v87 = v299 & 0x7FFFFFFF;
        if ( (unsigned int)v87 >= *(_DWORD *)(v241 + 408) || !*(_QWORD *)(*(_QWORD *)(v241 + 400) + 8 * v87) )
        {
          sub_1E86D40(v260, "Virtual register has no Live interval", v8, v7, 0);
          a1 = v260;
          goto LABEL_32;
        }
        v284 = v12 | v13 & 0xFFFFFFFFFFFFFFF8LL;
        v242 = sub_1E86160(v241, v299, v13, v12, a5, a6);
        sub_1E86FC0(v260, v8, v7, v284, v242, v299, 0);
        a6 = (unsigned __int64)v216;
        a1 = v260;
        a5 = *(_QWORD *)(v242 + 104);
        if ( !a5 )
          goto LABEL_32;
        v88 = (*(_DWORD *)v8 >> 8) & 0xFFF;
        if ( v88 )
        {
          v89 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v260 + 40) + 248LL) + 4LL * v88);
        }
        else
        {
          v213 = sub_1E69F40(*(_QWORD *)(v260 + 48), v299);
          a1 = v260;
          a5 = *(_QWORD *)(v242 + 104);
          v89 = v213;
          if ( !a5 )
            goto LABEL_32;
        }
        v261 = v11;
        v13 = v7;
        v90 = v9;
        v91 = a1;
        v243 = v18;
        v92 = v8;
        v93 = a5;
        v94 = v89;
        do
        {
          if ( (*(_DWORD *)(v93 + 112) & v94) != 0 )
          {
            v231 = v13;
            sub_1E86FC0(v91, v92, v13, v284, v93, v299, *(_DWORD *)(v93 + 112));
            v13 = v231;
            v12 = v217;
          }
          v93 = *(_QWORD *)(v93 + 104);
        }
        while ( v93 );
        a1 = v91;
        v8 = v92;
        v18 = v243;
        v9 = v90;
        v7 = v13;
        v11 = v261;
      }
      else
      {
        while ( v12 != -8 )
        {
          a6 = (unsigned int)(a5 + 1);
          v85 = (unsigned int)v13 & ((_DWORD)v85 + (_DWORD)a5);
          v12 = *(_QWORD *)(v84 + 16 * v85);
          if ( v283 == v12 )
            goto LABEL_137;
          a5 = (unsigned int)a6;
        }
      }
    }
  }
LABEL_32:
  if ( (*(_WORD *)(v8 + 2) & 0xFF0) != 0 )
  {
    v246 = a1;
    v117 = sub_1E16AB0(v9, v7, v13, v12, a5, (_BYTE *)a6);
    v121 = v246;
    v293 = v117;
    v122 = 5LL * v117;
    v232 = v117;
    v264 = *(_QWORD *)(v9 + 32) + 40LL * v117;
    if ( *(_BYTE *)v264 )
    {
      sub_1E86D40(v246, "Must be tied to a register", v8, v7, 0);
      v121 = v246;
    }
    if ( (*(_WORD *)(v264 + 2) & 0xFF0) == 0 )
    {
      v251 = v121;
      sub_1E86D40(v121, "Missing tie flags on tied operand", v8, v7, 0);
      v121 = v251;
    }
    v247 = v121;
    v123 = sub_1E16AB0(v9, v293, v122, v118, v119, v120);
    a1 = v247;
    if ( v123 != v7 )
    {
      sub_1E86D40(v247, "Inconsistent tie links", v8, v7, 0);
      a1 = v247;
    }
    if ( v7 < *((unsigned __int8 *)v11 + 4) )
    {
      if ( v293 >= v11[1] )
      {
        if ( (*(_BYTE *)(v264 + 3) & 0x20) == 0 )
        {
          v296 = a1;
          sub_1E86D40(a1, "Explicit def should be tied to implicit use", v8, v7, 0);
          a1 = v296;
        }
      }
      else
      {
        v12 = v232;
        if ( (*(_BYTE *)(*((_QWORD *)v11 + 5) + 8 * v232 + 4) & 1) == 0 )
        {
          v294 = a1;
          sub_1E86D40(a1, "Explicit def tied to explicit use without tie constraint", v8, v7, 0);
          a1 = v294;
        }
      }
    }
  }
  if ( (**(_BYTE **)(**(_QWORD **)(a1 + 48) + 352LL) & 1) == 0 && (*(_BYTE *)(v8 + 3) & 0x10) == 0 )
  {
    v95 = *(_QWORD *)(v9 + 32) + 40LL * v7;
    if ( !*(_BYTE *)v95 && (*(_BYTE *)(v95 + 3) & 0x10) == 0 && (*(_WORD *)(v95 + 2) & 0xFF0) != 0 )
    {
      v285 = a1;
      v96 = sub_1E16AB0(v9, v7, 5LL * v7, v12, a5, (_BYTE *)a6);
      a1 = v285;
      if ( *(_DWORD *)(*(_QWORD *)(v9 + 32) + 40LL * v96 + 8) != v18 )
      {
        sub_1E86D40(v285, "Two-address instruction operands must be identical", v8, v7, 0);
        a1 = v285;
      }
    }
  }
  v19 = (*(_DWORD *)v8 >> 8) & 0xFFF;
  v20 = v19;
  if ( v18 > 0 )
  {
    if ( v19 )
    {
      v22 = v7;
      v23 = "Illegal subregister index for physical register";
      v24 = v8;
    }
    else
    {
      if ( v7 < v11[1] )
      {
        v286 = a1;
        v97 = (_QWORD *)sub_1F3AD60(*(_QWORD *)(a1 + 32), v11, v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16), v19);
        a1 = v286;
        v98 = v97;
        if ( v97 )
        {
          v99 = *v97;
          v100 = (unsigned int)v18 >> 3;
          if ( (unsigned int)v100 >= *(unsigned __int16 *)(v99 + 22)
            || (v101 = *(unsigned __int8 *)(*(_QWORD *)(v99 + 8) + v100), !_bittest(&v101, v18 & 7)) )
          {
            v244 = v98;
            v262 = v286;
            sub_1E86D40(v286, "Illegal physical register for instruction", v8, v7, 0);
            v287 = sub_16E8CB0();
            sub_1F4AA00(&v301, (unsigned int)v18, *(_QWORD *)(v262 + 40), 0, 0);
            sub_1E869D0((__int64)&v301, (__int64)v287, v102);
            v103 = sub_1263B40((__int64)v287, " is not a ");
            v104 = sub_1263B40(
                     v103,
                     (const char *)(*(_QWORD *)(*(_QWORD *)(v262 + 40) + 80LL) + *(unsigned int *)(*v244 + 16LL)));
            sub_1263B40(v104, " register.\n");
            sub_A17130((__int64)&v301);
            a1 = v262;
          }
        }
      }
      v274 = a1;
      v21 = sub_1E31310(v8);
      a1 = v274;
      if ( v21
        && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v274 + 48) + 304LL) + 8LL * ((unsigned int)v18 >> 6)) & (1LL << v18)) != 0 )
      {
        v22 = v7;
        v23 = "isRenamable set on reserved register";
        v24 = v8;
      }
      else
      {
        v10 = *(_QWORD *)(v9 + 16);
        if ( *(_WORD *)v10 != 12 || (*(_BYTE *)(v8 + 3) & 0x10) != 0 || (*(_BYTE *)(v8 + 4) & 8) != 0 )
          return v10;
        v22 = v7;
        v23 = "Use-reg is not IsDebug in a DBG_VALUE";
        v24 = v8;
      }
    }
    goto LABEL_124;
  }
  v59 = *(_QWORD *)(a1 + 48);
  v60 = *(_QWORD *)(*(_QWORD *)(v59 + 24) + 16LL * (v18 & 0x7FFFFFFF));
  if ( (v60 & 4) == 0 )
  {
    v61 = v60 & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v60 & 0xFFFFFFFFFFFFFFF8LL) != 0 )
    {
      if ( !(_DWORD)v20
        || (v62 = *(_QWORD *)(a1 + 40),
            v63 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v62 + 112LL),
            v63 == sub_1E15B90) )
      {
LABEL_116:
        LODWORD(v10) = v11[1];
        if ( v7 >= (unsigned int)v10 )
          return v10;
        v258 = v20;
        v280 = a1;
        v10 = sub_1F3AD60(*(_QWORD *)(a1 + 32), v11, v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 16), v20);
        v64 = (_QWORD *)v10;
        if ( !v10 )
          return v10;
        v65 = v258;
        a1 = v280;
        if ( v258 )
        {
          v66 = *(__int64 **)(v280 + 40);
          v67 = v61;
          v68 = *v66;
          v69 = *(__int64 (__fastcall **)(__int64, __int64))(*v66 + 160);
          if ( v69 != sub_1E693B0 )
          {
            v211 = ((__int64 (__fastcall *)(__int64 *, unsigned __int64, _QWORD))v69)(v66, v61, *(_QWORD *)(v280 + 16));
            a1 = v280;
            v67 = v211;
            if ( !v211 )
            {
              v22 = v7;
              v23 = "No largest legal super class exists.";
              v24 = v8;
              goto LABEL_124;
            }
            v66 = *(__int64 **)(v280 + 40);
            v65 = v258;
            v68 = *v66;
          }
          v281 = a1;
          v70 = (*(__int64 (__fastcall **)(__int64 *, unsigned __int64, _QWORD *, _QWORD))(v68 + 96))(
                  v66,
                  v67,
                  v64,
                  v65);
          a1 = v281;
          v64 = (_QWORD *)v70;
          if ( !v70 )
          {
            v22 = v7;
            v23 = "No matching super-reg register class.";
            v24 = v8;
            goto LABEL_124;
          }
        }
        LODWORD(v10) = *(_DWORD *)(v64[1] + 4 * ((unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)v61 + 24LL) >> 5));
        if ( !_bittest((const int *)&v10, *(unsigned __int16 *)(*(_QWORD *)v61 + 24LL)) )
        {
          v282 = a1;
          sub_1E86D40(a1, "Illegal virtual register for instruction", v8, v7, 0);
          v71 = sub_16E8CB0();
          v72 = sub_1263B40((__int64)v71, "Expected a ");
          v73 = sub_1263B40(
                  v72,
                  (const char *)(*(_QWORD *)(*(_QWORD *)(v282 + 40) + 80LL) + *(unsigned int *)(*v64 + 16LL)));
          v74 = sub_1263B40(v73, " register, but got a ");
          v75 = sub_1263B40(
                  v74,
                  (const char *)(*(_QWORD *)(*(_QWORD *)(v282 + 40) + 80LL) + *(unsigned int *)(*(_QWORD *)v61 + 16LL)));
          LOBYTE(v10) = sub_1263B40(v75, " register\n");
        }
        return v10;
      }
      v252 = a1;
      v270 = (*(_DWORD *)v8 >> 8) & 0xFFF;
      v297 = v20;
      v179 = ((__int64 (__fastcall *)(__int64, unsigned __int64, _QWORD, __int64))v63)(v62, v61, (unsigned int)v20, v12);
      v20 = v297;
      a1 = v252;
      if ( v179 )
      {
        if ( v61 == v179 )
          goto LABEL_116;
        sub_1E86D40(v252, "Invalid register class for subregister index", v8, v7, 0);
        v186 = sub_16E8CB0();
        v187 = sub_1263B40((__int64)v186, "Register class ");
        v182 = " does not fully support subreg index ";
        v183 = sub_1263B40(
                 v187,
                 (const char *)(*(_QWORD *)(*(_QWORD *)(v252 + 40) + 80LL) + *(unsigned int *)(*(_QWORD *)v61 + 16LL)));
      }
      else
      {
        sub_1E86D40(v252, "Invalid subregister index for virtual register", v8, v7, 0);
        v180 = sub_16E8CB0();
        v181 = sub_1263B40((__int64)v180, "Register class ");
        v182 = " does not support subreg index ";
        v183 = sub_1263B40(
                 v181,
                 (const char *)(*(_QWORD *)(*(_QWORD *)(v252 + 40) + 80LL) + *(unsigned int *)(*(_QWORD *)v61 + 16LL)));
      }
      v184 = sub_1263B40(v183, v182);
      v185 = sub_16E7A90(v184, v270);
      LOBYTE(v10) = sub_1263B40(v185, "\n");
      return v10;
    }
  }
  if ( *(_BYTE *)(a1 + 61) )
  {
    v22 = v7;
    v23 = "Generic virtual register invalid in a Selected function";
    v24 = v8;
    goto LABEL_124;
  }
  v245 = a1;
  v263 = (_QWORD *)(*(_QWORD *)(v59 + 24) + 16LL * (v18 & 0x7FFFFFFF));
  v290 = v20;
  v105 = sub_1E85F00(v59, v18);
  v106 = v290;
  v301 = v105;
  v107 = (_QWORD *)v245;
  if ( (v105 & 0xFFFFFFFFFFFFFFFCLL) == 0 )
  {
    LOBYTE(v10) = sub_1E86D40(v245, "Generic virtual register must have a valid type", v8, v7, 0);
    return v10;
  }
  if ( (*v263 & 4) != 0 && (v108 = *v263 & 0xFFFFFFFFFFFFFFF8LL) != 0 )
  {
    v109 = sub_1E85E20(&v301);
    v106 = v290;
    v107 = (_QWORD *)v245;
    if ( v109 > *(_DWORD *)(v108 + 16) )
    {
      sub_1E86D40(v245, "Register bank is too small for virtual register", v8, v7, 0);
      v190 = sub_16E8CB0();
      v191 = sub_1263B40((__int64)v190, "Register bank ");
      v192 = sub_1263B40(v191, *(const char **)(v108 + 8));
      v193 = sub_1263B40(v192, " too small(");
      v194 = sub_16E7A90(v193, *(unsigned int *)(v108 + 16));
      v195 = sub_1263B40(v194, ") to fit ");
      v196 = sub_1E85E20(&v301);
      v197 = sub_16E7A90(v195, v196);
      LOBYTE(v10) = sub_1263B40(v197, "-bits\n");
      return v10;
    }
  }
  else if ( *(_BYTE *)(v245 + 60) )
  {
    LOBYTE(v10) = sub_1E86D40(
                    v245,
                    "Generic virtual register must have a bank in a RegBankSelected function",
                    v8,
                    v7,
                    0);
    return v10;
  }
  if ( (_DWORD)v106 )
  {
    LOBYTE(v10) = sub_1E86D40((__int64)v107, "Generic virtual register does not subregister index", v8, v7, 0);
  }
  else
  {
    LODWORD(v10) = *v11 - 34;
    if ( (unsigned int)v10 > 0x5B )
    {
      LODWORD(v10) = v11[1];
      if ( v7 < (unsigned int)v10 )
      {
        v291 = v107;
        v10 = sub_1F3AD60(v107[4], v11, v7, v107[5], v107[2], v106);
        if ( v10 )
        {
          sub_1E86D40((__int64)v291, "Virtual register does not match instruction constraint", v8, v7, 0);
          v110 = sub_16E8CB0();
          v111 = sub_1263B40((__int64)v110, "Expect register class ");
          v112 = v291[5];
          v114 = sub_1F3AD60(v291[4], v11, v7, v112, v291[2], v113);
          v115 = sub_1263B40(v111, (const char *)(*(_QWORD *)(v112 + 80) + *(unsigned int *)(*(_QWORD *)v114 + 16LL)));
          LOBYTE(v10) = sub_1263B40(v115, " but got nothing\n");
        }
      }
    }
  }
  return v10;
}
