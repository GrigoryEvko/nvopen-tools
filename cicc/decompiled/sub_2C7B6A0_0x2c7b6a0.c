// Function: sub_2C7B6A0
// Address: 0x2c7b6a0
//
void __fastcall sub_2C7B6A0(__int64 a1, __int64 a2)
{
  const char *v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rdx
  char *v6; // rcx
  __int64 v8; // r12
  __int64 v9; // rax
  unsigned int v10; // eax
  __int64 v11; // rax
  const char *v12; // r13
  unsigned __int8 v13; // al
  bool v14; // dl
  int v15; // ecx
  __int64 v16; // rbx
  __int64 v17; // r15
  const char *v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rdx
  __int64 v22; // rdi
  _WORD *v23; // rdx
  char *v24; // rsi
  __int64 v25; // rdi
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // rdi
  __m128i *v29; // rdx
  _BYTE *v30; // rax
  _BYTE *v31; // rax
  __int64 v32; // rdi
  unsigned int v33; // r15d
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rdi
  __int64 v37; // r13
  unsigned __int8 *v38; // rax
  size_t v39; // rdx
  void *v40; // rdi
  __int64 v41; // rdx
  char *v42; // rcx
  __int64 v43; // rax
  _QWORD *v44; // rbx
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rdx
  char *v48; // rcx
  __int64 v49; // rdi
  char v50; // al
  __int64 v51; // rax
  __int64 v52; // rax
  __int64 v53; // rdx
  char *v54; // rcx
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rdx
  char *v58; // rcx
  int v59; // eax
  __int64 v60; // rax
  _QWORD *v61; // r13
  unsigned int v62; // ebx
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rdx
  char *v66; // rcx
  int v67; // eax
  __int64 v68; // rax
  __int64 v69; // rax
  __int64 v70; // rdx
  char *v71; // rcx
  __int64 v72; // rdx
  _QWORD *v73; // rax
  __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rdx
  char *v77; // rcx
  __int64 v78; // rax
  __int64 v79; // rsi
  _QWORD *v80; // rdx
  __int64 v81; // rdi
  int v82; // eax
  __int64 v83; // rdx
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rdx
  char *v87; // rcx
  __int64 v88; // rax
  __int64 v89; // rdx
  __int64 v90; // rax
  __int64 v91; // rax
  __int64 v92; // rdx
  char *v93; // rcx
  __int64 v94; // rdx
  _QWORD *v95; // rax
  __int64 v96; // rax
  __int64 v97; // rax
  __int64 v98; // rdx
  char *v99; // rcx
  __int64 v100; // rax
  __int64 v101; // rax
  __int64 v102; // rdx
  char *v103; // rcx
  __int64 v104; // rax
  __int64 v105; // r13
  __int64 v106; // rax
  unsigned __int64 v107; // rbx
  __int64 v108; // rax
  _QWORD *v109; // rdi
  unsigned __int64 v110; // rbx
  __int64 v111; // rax
  __int64 v112; // rax
  char *v113; // rcx
  __int64 v114; // rdx
  __int64 v115; // rdi
  __m128i si128; // xmm0
  _BYTE *v117; // rax
  bool v118; // bl
  __int64 v119; // rdx
  _QWORD *v120; // rax
  unsigned int v121; // ebx
  unsigned int v122; // r13d
  const char *v123; // rsi
  __int64 v124; // rdi
  __int64 v125; // rax
  __m128i *v126; // rdx
  char *v127; // rcx
  __int64 v128; // rcx
  const char *v129; // rsi
  __int64 v130; // rdi
  __int64 v131; // rax
  __int64 v132; // rdx
  char *v133; // rcx
  __int64 v134; // rax
  __int64 v135; // rdi
  __m128i v136; // xmm0
  _BYTE *v137; // rax
  __int64 v138; // rdx
  __int64 v139; // r13
  __int64 v140; // rbx
  __int64 j; // r15
  __int64 v142; // rax
  __int64 v143; // rax
  __int64 v144; // rdx
  char *v145; // rcx
  __int64 v146; // rdi
  unsigned __int8 v147; // al
  __int64 v148; // rax
  __int64 v149; // r8
  __int16 v150; // r13d^2
  unsigned int v151; // ecx
  char v152; // r9
  __int64 v153; // r13
  __int64 v154; // rax
  __int64 v155; // rax
  __int64 v156; // rdx
  char *v157; // rcx
  __int64 v158; // r13
  __int64 v159; // rax
  __int64 v160; // rax
  __int64 v161; // rdx
  char *v162; // rcx
  __int64 v163; // rax
  __int64 v164; // rax
  __int64 v165; // rax
  __int64 v166; // rdx
  char *v167; // rcx
  __int64 v168; // rdi
  int v169; // eax
  __int64 v170; // rdx
  unsigned __int64 v171; // rax
  const char *v172; // rsi
  __int64 v173; // rdi
  __int64 v174; // rax
  __int64 v175; // rdx
  char *v176; // rcx
  __int64 v177; // rax
  __int64 v178; // rax
  __int64 v179; // rax
  __int64 v180; // rdx
  char *v181; // rcx
  __int64 v182; // rax
  __int64 v183; // rax
  __int64 v184; // rdx
  char *v185; // rcx
  __int64 v186; // rdx
  _QWORD *v187; // rax
  int v188; // r13d
  unsigned int v189; // ebx
  __int64 v190; // rax
  __int64 v191; // rax
  __int64 v192; // rax
  __int64 v193; // rdx
  char *v194; // rcx
  __int64 v195; // rax
  __int64 v196; // rax
  __int64 v197; // rdx
  char *v198; // rcx
  __int64 v199; // rax
  __int64 v200; // rax
  __int64 v201; // rax
  __int64 v202; // rax
  __int64 v203; // rdx
  char *v204; // rcx
  __int64 v205; // rdx
  _QWORD *v206; // rax
  int v207; // ebx
  __int64 v208; // rax
  __int64 v209; // rax
  __int64 v210; // rdx
  char *v211; // rcx
  __int64 v212; // rax
  __int64 v213; // rax
  __int64 v214; // rax
  __int64 v215; // rdx
  char *v216; // rcx
  __int64 v217; // rax
  unsigned __int8 *v218; // rdx
  _BYTE *v219; // rbx
  _BYTE *v220; // rax
  __int64 v221; // rax
  __int64 v222; // rax
  __int64 v223; // rdx
  char *v224; // rcx
  __int64 v225; // rax
  __int64 v226; // rax
  __int64 v227; // rdx
  char *v228; // rcx
  int v229; // eax
  const char *v230; // rsi
  __int64 v231; // rdi
  __int64 v232; // rax
  __int64 v233; // rdx
  char *v234; // rcx
  __int64 v235; // rax
  _QWORD *v236; // rdx
  __int64 v237; // rax
  __int64 v238; // rax
  __int64 v239; // rdx
  char *v240; // rcx
  __int64 v241; // rax
  __int64 v242; // rax
  __int64 v243; // rax
  __int64 v244; // rdx
  char *v245; // rcx
  __int64 v246; // rax
  _QWORD *v247; // rbx
  __int64 v248; // rdi
  __int64 v249; // rax
  __int64 v250; // rax
  __int64 v251; // rdx
  char *v252; // rcx
  __int64 v253; // rax
  __int64 v254; // rax
  __int64 v255; // rdx
  char *v256; // rcx
  __int64 v257; // rdx
  _QWORD *v258; // rax
  __int64 v259; // rax
  __int64 v260; // rcx
  _QWORD *v261; // rdx
  __int64 v262; // rbx
  __int64 v263; // rax
  __int64 v264; // rax
  __int64 v265; // rdx
  char *v266; // rcx
  __int64 v267; // rax
  __int64 v268; // rax
  __int64 v269; // rax
  __int64 v270; // rdx
  char *v271; // rcx
  _QWORD *v272; // rdx
  unsigned __int64 v273; // rax
  __int64 v274; // rcx
  __int64 v275; // rax
  int v276; // edx
  __int64 v277; // rax
  int v278; // ebx
  __int64 v279; // rax
  __int64 v280; // rax
  __int64 v281; // rdx
  char *v282; // rcx
  __int64 v283; // rdx
  __int64 v284; // rsi
  _QWORD *v285; // rax
  int v286; // ebx
  __int64 v287; // rax
  __int64 v288; // rax
  __int64 v289; // rdx
  char *v290; // rcx
  __int64 v291; // r13
  __int64 v292; // rax
  __int64 v293; // rax
  __int64 v294; // rax
  __int64 v295; // rdx
  char *v296; // rcx
  __int64 v297; // rax
  __int64 v298; // rax
  __int64 v299; // rdx
  char *v300; // rcx
  __int64 v301; // rax
  _QWORD *v302; // rbx
  __int64 v303; // rax
  __int64 v304; // rax
  __int64 v305; // rdx
  char *v306; // rcx
  __int64 v307; // rax
  __int64 v308; // rax
  __int64 v309; // rdx
  char *v310; // rcx
  __int64 v311; // rax
  __int64 v312; // rdx
  char *v313; // rcx
  int v314; // eax
  __int64 v315; // rdx
  __int64 v316; // rax
  __int64 v317; // rax
  __int64 v318; // rdx
  char *v319; // rcx
  const char *v320; // rsi
  __int64 v321; // rdi
  __int64 v322; // rax
  __int64 v323; // rdx
  char *v324; // rcx
  const char *v325; // rsi
  __int64 v326; // rdi
  __int64 v327; // rax
  __int64 v328; // rdx
  char *v329; // rcx
  __int64 v330; // rax
  __int64 v331; // rax
  __int64 v332; // rdx
  char *v333; // rcx
  __int64 v334; // rax
  __int64 v335; // rdx
  char *v336; // rcx
  __int64 v337; // rax
  __int64 v338; // rax
  __int64 v339; // rdx
  char *v340; // rcx
  __int64 v341; // rdx
  __int64 v342; // r13
  __int64 v343; // rbx
  _QWORD *v344; // rax
  _QWORD *v345; // rax
  const char *v346; // rsi
  __int64 v347; // rdi
  __int64 v348; // rax
  __int64 v349; // rdx
  char *v350; // rcx
  int v351; // edx
  __int64 v352; // rax
  __int64 v353; // rax
  __int64 v354; // rdx
  char *v355; // rcx
  __int64 v356; // rbx
  __int64 v357; // rax
  _BYTE *v358; // rcx
  _BYTE *v359; // rcx
  __int64 v360; // r13
  char v361; // al
  __int64 *v362; // rax
  __int64 v363; // rdi
  int v364; // eax
  __int64 *v365; // rdx
  __int64 v366; // rdi
  unsigned __int64 v367; // rcx
  __int64 v368; // rax
  __int64 v369; // rax
  __int64 v370; // rdx
  char *v371; // rcx
  __int64 v372; // rax
  int v373; // ecx
  __int64 v374; // rax
  __int64 v375; // rax
  __int64 v376; // rdx
  char *v377; // rcx
  int v378; // edx
  unsigned int v379; // eax
  __int64 *v380; // rax
  __int64 v381; // rdi
  bool v382; // al
  _QWORD *v383; // rax
  _QWORD *v384; // rax
  const char *v385; // rsi
  __int64 v386; // rdi
  __int64 v387; // rax
  __int64 v388; // rdx
  char *v389; // rcx
  _QWORD *v390; // rax
  _QWORD *v391; // rax
  __int64 v392; // rax
  __int64 v393; // rax
  __int64 v394; // rdx
  char *v395; // rcx
  __int64 v396; // rax
  __int64 v397; // rdx
  __int64 v398; // rbx
  __int64 v399; // r13
  __int64 v400; // r9
  unsigned __int64 v401; // r10
  __int64 v402; // rax
  __int64 v403; // rax
  __int64 v404; // rdx
  char *v405; // rcx
  _QWORD *v406; // rax
  const char *v407; // rsi
  __int64 v408; // rdi
  __int64 v409; // rax
  __int64 v410; // rdx
  char *v411; // rcx
  int v412; // edx
  _QWORD *v413; // rax
  const char *v414; // rsi
  __int64 v415; // rdi
  __int64 v416; // rax
  __int64 v417; // rdx
  char *v418; // rcx
  int v419; // edx
  __int64 v420; // rax
  __int64 v421; // rax
  __int64 v422; // rdx
  char *v423; // rcx
  __int64 v424; // rax
  __int64 v425; // rax
  __int64 v426; // rdx
  char *v427; // rcx
  __int64 v428; // rdx
  _QWORD *v429; // rax
  char v430; // bl
  __int64 v431; // rax
  __int64 v432; // rax
  __int64 v433; // rdx
  char *v434; // rcx
  __int64 v435; // rax
  __int64 v436; // rax
  __int64 v437; // rdx
  char *v438; // rcx
  __int64 v439; // rax
  __int64 v440; // rdx
  _QWORD *v441; // rbx
  __int64 v442; // rax
  __int64 v443; // r13
  int v444; // ebx
  __int64 v445; // rax
  __int64 v446; // rax
  __int64 v447; // rdx
  char *v448; // rcx
  __int64 v449; // rax
  __int64 v450; // rax
  __int64 v451; // rdx
  char *v452; // rcx
  int v453; // eax
  __int64 v454; // rax
  __int64 v455; // rax
  __int64 v456; // rdx
  char *v457; // rcx
  __int64 v458; // rax
  __int64 v459; // rax
  __int64 v460; // rdx
  char *v461; // rcx
  __int64 v462; // rax
  __int64 v463; // rax
  __int64 v464; // rax
  __int64 v465; // rdx
  char *v466; // rcx
  __int64 i; // rbx
  __int64 v468; // rdx
  const char *v469; // rsi
  __int64 v470; // rdi
  __int64 v471; // rax
  __int64 v472; // rdx
  char *v473; // rcx
  __int64 v474; // rdx
  __int64 v475; // rax
  unsigned __int64 v476; // rax
  __int64 v477; // rax
  __int64 v478; // rax
  __int64 v479; // rdx
  char *v480; // rcx
  __int64 v481; // rax
  __int64 v482; // rax
  __int64 v483; // rdx
  char *v484; // rcx
  __int64 v485; // rax
  __int64 v486; // rax
  __int64 v487; // rdx
  char *v488; // rcx
  __int64 v489; // rdx
  unsigned __int64 v490; // rax
  __int64 v491; // rdx
  __int64 v492; // rax
  __int64 v493; // rdx
  char *v494; // rcx
  __int64 v495; // r13
  __int64 v496; // rax
  __int64 v497; // rax
  __int64 v498; // rax
  __int64 v499; // rdx
  char *v500; // rcx
  __int64 v501; // rdx
  unsigned __int64 v502; // rax
  __int64 v503; // rdx
  __int64 v504; // rdx
  unsigned __int64 v505; // rbx
  int v506; // eax
  __int64 v507; // rax
  unsigned __int64 v508; // rbx
  char v509; // r13
  __int64 v510; // rax
  __int64 v511; // rax
  __int64 v512; // rdx
  char *v513; // rcx
  __int64 v514; // rax
  __int64 v515; // rax
  __int64 v516; // rdx
  char *v517; // rcx
  __int64 v518; // rax
  __int64 v519; // rax
  __int64 v520; // rdx
  char *v521; // rcx
  __int64 v522; // rdx
  _QWORD *v523; // rax
  char v524; // bl
  int v525; // eax
  __int64 v526; // rax
  __int64 v527; // rax
  __int64 v528; // rdx
  char *v529; // rcx
  __int64 v530; // rax
  __int64 v531; // rax
  __int64 v532; // rdx
  char *v533; // rcx
  __int64 v534; // rax
  __int64 v535; // rax
  __int64 v536; // rdx
  char *v537; // rcx
  int v538; // edx
  char v539; // al
  char v540; // di
  __int64 v541; // rax
  __int64 v542; // rax
  __int64 v543; // rdx
  char *v544; // rcx
  __int64 v545; // rax
  const char *v546; // rsi
  __int64 v547; // rdi
  __int64 v548; // rax
  __int64 v549; // rdx
  char *v550; // rcx
  __int64 v551; // rdi
  __int64 v552; // rax
  __int64 v553; // rax
  __int64 v554; // rdx
  char *v555; // rcx
  __int64 v556; // rax
  __int64 v557; // rax
  __int64 v558; // rdx
  char *v559; // rcx
  const char *v560; // rsi
  __int64 v561; // rdi
  __int64 v562; // rax
  __int64 v563; // rdx
  char *v564; // rcx
  __int64 v565; // rax
  __int64 v566; // rax
  __int64 v567; // rdx
  char *v568; // rcx
  __int64 v569; // rax
  __int64 v570; // rax
  __int64 v571; // rdx
  char *v572; // rcx
  __int64 *v573; // rax
  __int64 v574; // rdi
  int v575; // esi
  __int64 v576; // rdx
  __int64 v577; // rax
  __int64 v578; // rax
  __int64 v579; // rdx
  char *v580; // rcx
  __int64 v581; // rax
  __int64 v582; // rax
  __int64 v583; // rdx
  char *v584; // rcx
  __int64 v585; // rax
  __int64 v586; // rax
  __int64 v587; // rdx
  char *v588; // rcx
  int v589; // eax
  __int64 v590; // rax
  __int64 v591; // rax
  __int64 v592; // rdx
  char *v593; // rcx
  const char *v594; // rsi
  __int64 v595; // rdi
  __int64 v596; // rax
  __int64 v597; // rdx
  char *v598; // rcx
  __int64 v599; // rdx
  __int64 v600; // rax
  __int64 v601; // rax
  __int64 v602; // rax
  __int64 v603; // rdx
  char *v604; // rcx
  __int64 v605; // rdx
  _QWORD *v606; // rax
  char v607; // bl
  __int64 v608; // rax
  __int64 v609; // rax
  __int64 v610; // rdx
  char *v611; // rcx
  __int64 v612; // rax
  __int64 v613; // rax
  __int64 v614; // rdx
  char *v615; // rcx
  __int64 v616; // rax
  _QWORD *v617; // rbx
  _QWORD *v618; // rdx
  __int64 v619; // rax
  __int64 v620; // rax
  __int64 v621; // rdx
  char *v622; // rcx
  __int64 v623; // rax
  __int64 v624; // rax
  __int64 v625; // rdx
  char *v626; // rcx
  __int64 v627; // rax
  __int64 v628; // rax
  __int64 v629; // rdx
  char *v630; // rcx
  __int64 v631; // rax
  __int64 v632; // rax
  __int64 v633; // rax
  __int64 v634; // rdx
  char *v635; // rcx
  __int64 v636; // rax
  __int64 v637; // rax
  __int64 v638; // rdx
  char *v639; // rcx
  const char *v640; // rsi
  __int64 v641; // rdi
  __int64 v642; // rax
  __int64 v643; // rdx
  char *v644; // rcx
  __int64 v645; // rax
  __int64 v646; // rax
  __int64 v647; // rax
  __int64 v648; // rdx
  char *v649; // rcx
  __int64 v650; // rax
  __int64 v651; // rax
  __int64 v652; // rdx
  char *v653; // rcx
  __int64 v654; // rax
  __int64 v655; // rax
  __int64 v656; // rdx
  char *v657; // rcx
  __int64 v658; // rdx
  unsigned __int64 v659; // rax
  __int64 v660; // rdx
  __int64 v661; // rax
  __int64 v662; // rax
  __int64 v663; // rdx
  char *v664; // rcx
  __int64 v665; // rax
  __int64 v666; // rax
  __int64 v667; // rax
  __int64 v668; // rdx
  char *v669; // rcx
  __int64 v670; // rax
  __int64 v671; // rax
  __int64 v672; // rdx
  char *v673; // rcx
  __int64 *v674; // rax
  __int64 v675; // rdi
  __int64 v676; // rax
  __int64 v677; // rax
  __int64 v678; // rdx
  char *v679; // rcx
  __int64 v680; // rax
  __int64 v681; // rax
  __int64 v682; // rdx
  char *v683; // rcx
  __int64 v684; // rax
  __int64 v685; // rax
  __int64 v686; // rdx
  char *v687; // rcx
  __int64 v688; // rax
  __int64 v689; // rax
  __int64 v690; // rdx
  char *v691; // rcx
  const char *v692; // rsi
  __int64 v693; // rdi
  __int64 v694; // rax
  __int64 v695; // rdx
  char *v696; // rcx
  __int64 v697; // rdx
  _QWORD *v698; // rax
  unsigned int v699; // ebx
  __int64 v700; // rax
  __int64 v701; // rax
  __int64 v702; // rdx
  char *v703; // rcx
  const char *v704; // rsi
  __int64 v705; // rdi
  __int64 v706; // rax
  __int64 v707; // rdx
  char *v708; // rcx
  const char *v709; // rsi
  __int64 v710; // rdi
  __int64 v711; // rax
  __int64 v712; // rdx
  char *v713; // rcx
  __int64 v714; // rax
  __int64 v715; // rax
  __int64 v716; // rdx
  char *v717; // rcx
  __int64 v718; // rax
  __int64 v719; // rax
  __int64 v720; // rdx
  char *v721; // rcx
  __int64 v722; // rax
  __int64 v723; // rax
  __int64 v724; // rdx
  char *v725; // rcx
  __int64 v726; // rax
  __int64 v727; // rax
  __int64 v728; // rdx
  char *v729; // rcx
  __int64 v730; // rax
  __int64 v731; // rax
  __int64 v732; // rdx
  char *v733; // rcx
  __int64 v734; // rax
  __int64 v735; // rax
  __int64 v736; // rdx
  char *v737; // rcx
  __int64 v738; // rax
  __int64 v739; // rax
  __int64 v740; // rdx
  char *v741; // rcx
  __int64 v742; // rax
  __int64 v743; // rax
  __int64 v744; // rdx
  char *v745; // rcx
  __int64 v746; // rax
  __int64 v747; // rax
  __int64 v748; // rdx
  char *v749; // rcx
  __int64 v750; // rax
  __int64 v751; // rax
  __int64 v752; // rdx
  char *v753; // rcx
  __int64 v754; // rbx
  __int64 v755; // rax
  __int64 v756; // rax
  __int64 v757; // rdx
  char *v758; // rcx
  __int64 v759; // rax
  __int64 v760; // rax
  __int64 v761; // rax
  __int64 v762; // rdx
  char *v763; // rcx
  int v764; // eax
  __int64 v765; // rax
  __int64 v766; // rax
  __int64 v767; // rdx
  char *v768; // rcx
  __int64 v769; // rax
  __int64 v770; // rax
  __int64 v771; // rdx
  char *v772; // rcx
  __int64 v773; // rax
  __int64 v774; // rax
  __int64 v775; // rdx
  char *v776; // rcx
  __int64 v777; // rax
  __int64 v778; // rax
  __int64 v779; // rdx
  char *v780; // rcx
  __int64 v781; // rax
  __int64 v782; // rax
  __int64 v783; // rdx
  char *v784; // rcx
  __int64 v785; // rax
  __int64 v786; // rax
  __int64 v787; // rdx
  char *v788; // rcx
  __int64 v789; // rax
  __int64 v790; // rax
  __int64 v791; // rdx
  char *v792; // rcx
  __int64 v793; // rdx
  _QWORD *v794; // rax
  __int16 v795; // r13d^2
  unsigned __int16 v796; // bx
  __int64 v797; // rax
  __int64 v798; // rax
  __int64 v799; // rdx
  char *v800; // rcx
  __int64 v801; // rax
  __int64 v802; // rax
  __int64 v803; // rdx
  char *v804; // rcx
  int v805; // eax
  __int64 v806; // rax
  int v807; // ecx
  _BYTE *v808; // rdx
  __int64 v809; // rax
  __int64 v810; // rax
  __int64 v811; // rdx
  char *v812; // rcx
  __int64 v813; // rax
  __int64 v814; // rax
  __int64 v815; // rdx
  char *v816; // rcx
  __int64 v817; // rax
  __int64 v818; // rax
  __int64 v819; // rdx
  char *v820; // rcx
  __int64 v821; // rax
  __int64 v822; // rax
  __int64 v823; // rdx
  char *v824; // rcx
  const char *v825; // rsi
  __int64 v826; // rdi
  __int64 v827; // rax
  __int64 v828; // rdx
  char *v829; // rcx
  __int64 v830; // rax
  __int64 v831; // rax
  __int64 v832; // rdx
  char *v833; // rcx
  __int64 v834; // rdx
  __int64 v835; // rax
  __int64 v836; // rax
  __int64 v837; // rdx
  char *v838; // rcx
  __int64 v839; // rax
  __int64 v840; // rax
  __int64 v841; // rdx
  char *v842; // rcx
  __int64 v843; // rax
  __int64 v844; // rax
  __int64 v845; // rdx
  char *v846; // rcx
  __int64 v847; // rax
  __int64 v848; // rax
  __int64 v849; // rdx
  char *v850; // rcx
  __int64 v851; // rax
  __int64 v852; // rax
  __int64 v853; // rdx
  char *v854; // rcx
  __int64 v855; // rax
  __int64 v856; // rax
  __int64 v857; // rdx
  char *v858; // rcx
  __int64 v859; // rax
  __int64 v860; // rax
  __int64 v861; // rdx
  char *v862; // rcx
  __int64 v863; // rax
  int v864; // eax
  __int64 v865; // rbx
  __int64 v866; // rax
  __int64 v867; // rax
  __int64 v868; // rdx
  char *v869; // rcx
  __int64 v870; // rdx
  _QWORD *v871; // rax
  unsigned int v872; // edx
  _QWORD *v873; // rax
  __int64 v874; // rax
  __int64 v875; // rax
  __int64 v876; // rdx
  char *v877; // rcx
  __int64 v878; // rax
  __int64 v879; // rax
  __int64 v880; // rdx
  char *v881; // rcx
  __int64 v882; // rax
  __int64 v883; // rax
  __int64 v884; // rdx
  char *v885; // rcx
  __int64 v886; // rax
  _QWORD *v887; // rbx
  __int64 v888; // rdx
  _QWORD *v889; // rax
  const char *v890; // rsi
  __int64 v891; // rdi
  __int64 v892; // rax
  __int64 v893; // rdx
  char *v894; // rcx
  __int64 v895; // rax
  _QWORD *v896; // rbx
  __int64 v897; // rax
  __int64 v898; // rax
  __int64 v899; // rdx
  char *v900; // rcx
  __int64 v901; // rax
  __int64 v902; // rax
  __int64 v903; // rdx
  char *v904; // rcx
  const char *v905; // rsi
  __int64 v906; // rdi
  __int64 v907; // rax
  __int64 v908; // rdx
  char *v909; // rcx
  __int64 v910; // rax
  __int64 v911; // rax
  __int64 v912; // rax
  __int64 v913; // rdx
  char *v914; // rcx
  __int64 v915; // rax
  __int64 v916; // rax
  __int64 v917; // rdx
  char *v918; // rcx
  __int64 v919; // rax
  __int64 v920; // rax
  __int64 v921; // rdx
  char *v922; // rcx
  __int64 v923; // rax
  __int64 v924; // rax
  __int64 v925; // rdx
  char *v926; // rcx
  __int64 v927; // rax
  __int64 v928; // rax
  __int64 v929; // rdx
  char *v930; // rcx
  __int64 v931; // rax
  __int64 v932; // rax
  __int64 v933; // rdx
  char *v934; // rcx
  __int64 v935; // rax
  __int64 v936; // rax
  __int64 v937; // rdx
  char *v938; // rcx
  __int64 v939; // rax
  __int64 v940; // rax
  __int64 v941; // rdx
  char *v942; // rcx
  unsigned __int64 v943; // [rsp+8h] [rbp-88h]
  char v944; // [rsp+14h] [rbp-7Ch]
  int v945; // [rsp+14h] [rbp-7Ch]
  __int64 v946; // [rsp+18h] [rbp-78h]
  _BYTE *v947; // [rsp+20h] [rbp-70h]
  unsigned __int64 v948; // [rsp+20h] [rbp-70h]
  unsigned __int64 v949; // [rsp+20h] [rbp-70h]
  unsigned int v950; // [rsp+20h] [rbp-70h]
  unsigned __int64 v951; // [rsp+20h] [rbp-70h]
  __int16 v952; // [rsp+20h] [rbp-70h]
  _QWORD *v953; // [rsp+20h] [rbp-70h]
  __int64 v954; // [rsp+28h] [rbp-68h]
  int v955; // [rsp+28h] [rbp-68h]
  __int16 v956; // [rsp+28h] [rbp-68h]
  int v957; // [rsp+28h] [rbp-68h]
  int v958; // [rsp+28h] [rbp-68h]
  __int64 v959; // [rsp+28h] [rbp-68h]
  __int64 v960; // [rsp+28h] [rbp-68h]
  _BYTE *v961; // [rsp+30h] [rbp-60h]
  char v962; // [rsp+30h] [rbp-60h]
  __int64 v963; // [rsp+30h] [rbp-60h]
  int v964; // [rsp+30h] [rbp-60h]
  unsigned int v965; // [rsp+30h] [rbp-60h]
  unsigned int v966; // [rsp+30h] [rbp-60h]
  __int64 v967; // [rsp+30h] [rbp-60h]
  __int64 v968; // [rsp+38h] [rbp-58h]
  __int64 v969; // [rsp+38h] [rbp-58h]
  int v970; // [rsp+38h] [rbp-58h]
  char v971; // [rsp+38h] [rbp-58h]
  size_t v972; // [rsp+38h] [rbp-58h]
  unsigned int v973; // [rsp+38h] [rbp-58h]
  char v974; // [rsp+38h] [rbp-58h]
  __int64 v975; // [rsp+44h] [rbp-4Ch]
  int v976; // [rsp+4Ch] [rbp-44h]
  __int64 v977; // [rsp+50h] [rbp-40h] BYREF
  __int64 v978; // [rsp+58h] [rbp-38h]

  v8 = a2;
  v9 = *(_QWORD *)(a2 - 32);
  if ( *(_DWORD *)(*(_QWORD *)(v9 + 8) + 8LL) >> 8 )
  {
    v112 = sub_2C76A00(a1, a2, 0);
    v114 = *(_QWORD *)(v112 + 32);
    v115 = v112;
    if ( (unsigned __int64)(*(_QWORD *)(v112 + 24) - v114) <= 0x30 )
    {
      a2 = (__int64)"Function pointers should always use addrspace(0).";
      v115 = sub_CB6200(v112, "Function pointers should always use addrspace(0).", 0x31u);
      v117 = *(_BYTE **)(v115 + 32);
    }
    else
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_42D0B70);
      *(_BYTE *)(v114 + 48) = 46;
      *(__m128i *)v114 = si128;
      *(__m128i *)(v114 + 16) = _mm_load_si128((const __m128i *)&xmmword_42D0B80);
      *(__m128i *)(v114 + 32) = _mm_load_si128((const __m128i *)&xmmword_42D0B90);
      v117 = (_BYTE *)(*(_QWORD *)(v112 + 32) + 49LL);
      *(_QWORD *)(v115 + 32) = v117;
    }
    if ( v117 == *(_BYTE **)(v115 + 24) )
    {
      a2 = (__int64)"\n";
      sub_CB6200(v115, (unsigned __int8 *)"\n", 1u);
    }
    else
    {
      *v117 = 10;
      ++*(_QWORD *)(v115 + 32);
    }
    sub_2C76240(a1, a2, v114, v113);
    v9 = *(_QWORD *)(v8 - 32);
    if ( !v9 )
    {
      v10 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
      if ( !v10 )
        goto LABEL_5;
      goto LABEL_199;
    }
  }
  if ( !*(_BYTE *)v9 && *(_QWORD *)(v9 + 24) == *(_QWORD *)(v8 + 80) && (*(_BYTE *)(v9 + 33) & 0x20) != 0 )
  {
    v33 = *(_DWORD *)(v9 + 36);
    if ( v33 <= 0x232D )
    {
      if ( v33 > 0x2278 )
      {
        switch ( v33 )
        {
          case 0x2279u:
          case 0x232Du:
            v314 = *(_DWORD *)(a1 + 8);
            if ( v314 && v314 <= 899 )
            {
              v785 = sub_2C76A00(a1, v8, 0);
              v786 = sub_904010(v785, "this intrinsic is only supported for Hopper+");
              a2 = (__int64)"\n";
              sub_904010(v786, "\n");
              sub_2C76240(a1, (__int64)"\n", v787, v788);
            }
            v977 = sub_BCAE30(*(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL));
            v978 = v315;
            if ( (unsigned __int64)sub_CA1930(&v977) <= 0x3F )
            {
              v316 = sub_2C76A00(a1, v8, 0);
              v317 = sub_904010(v316, "this intrinsic is only supported when pointer size is >= 64 bits");
              a2 = (__int64)"\n";
              sub_904010(v317, "\n");
              sub_2C76240(a1, (__int64)"\n", v318, v319);
            }
            goto LABEL_54;
          case 0x2281u:
          case 0x2282u:
          case 0x2283u:
          case 0x2284u:
          case 0x228Fu:
          case 0x2290u:
          case 0x2291u:
          case 0x2292u:
          case 0x2299u:
          case 0x229Au:
          case 0x229Bu:
          case 0x229Cu:
            v199 = *(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)));
            if ( !v199 )
              BUG();
            if ( *(_BYTE *)v199 != 17
              || (*(_DWORD *)(v199 + 32) <= 0x40u ? (v200 = *(_QWORD *)(v199 + 24)) : (v200 = **(_QWORD **)(v199 + 24)),
                  v200) )
            {
              v201 = sub_2C76A00(a1, v8, 0);
              v202 = sub_904010(v201, "satf operand must be a constant zero");
              a2 = (__int64)"\n";
              sub_904010(v202, "\n");
              sub_2C76240(a1, (__int64)"\n", v203, v204);
            }
            goto LABEL_54;
          case 0x2287u:
          case 0x2288u:
          case 0x2289u:
          case 0x228Au:
            v257 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
            if ( *(_BYTE *)v257 != 17 )
            {
              v619 = sub_2C76A00(a1, v8, 0);
              v620 = sub_904010(v619, "arg0 of intrinsic not constant");
              a2 = (__int64)"\n";
              sub_904010(v620, "\n");
              sub_2C76240(a1, (__int64)"\n", v621, v622);
              goto LABEL_54;
            }
            v258 = *(_QWORD **)(v257 + 24);
            if ( *(_DWORD *)(v257 + 32) > 0x40u )
              v258 = (_QWORD *)*v258;
            if ( (_DWORD)v258 )
              goto LABEL_643;
            goto LABEL_54;
          case 0x22D8u:
          case 0x22DCu:
            if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) != 17 )
            {
              v311 = sub_2C76A00(a1, v8, 0);
              a2 = (__int64)"Flag argument must be an immediate.\n";
              sub_904010(v311, "Flag argument must be an immediate.\n");
              sub_2C76240(a1, (__int64)"Flag argument must be an immediate.\n", v312, v313);
            }
            goto LABEL_54;
          case 0x22DDu:
            goto LABEL_266;
          case 0x22E4u:
            v453 = *(_DWORD *)(a1 + 8);
            if ( v453 && v453 <= 899 )
              goto LABEL_561;
            goto LABEL_54;
          case 0x22E9u:
          case 0x22EBu:
            goto LABEL_164;
          case 0x2310u:
            v439 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
            v440 = *(_QWORD *)(v8 - 32 * v439);
            if ( *(_BYTE *)v440 != 17 )
              goto LABEL_756;
            v441 = *(_QWORD **)(v440 + 24);
            if ( *(_DWORD *)(v440 + 32) > 0x40u )
              v441 = (_QWORD *)*v441;
            if ( ((unsigned int)v441 & 0xFFFFFFF0) != 0 )
            {
              v769 = sub_2C76A00(a1, v8, 0);
              v770 = sub_904010(v769, "reserved flag bits used");
              sub_904010(v770, "\n");
              sub_2C76240(a1, (__int64)"\n", v771, v772);
              v439 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
            }
            v442 = *(_QWORD *)(v8 + 32 * (1 - v439));
            v443 = *(_QWORD *)(v442 + 8);
            v444 = (unsigned __int8)v441 & 3;
            if ( v444 )
            {
              if ( (_BYTE)v444 != 1 )
              {
                v445 = sub_2C76A00(a1, v8, 0);
                v446 = sub_904010(v445, "Invalid constant load kind");
                sub_904010(v446, "\n");
                sub_2C76240(a1, (__int64)"\n", v447, v448);
              }
              a2 = 64;
              if ( !sub_BCAC40(v443, 64) )
              {
                v449 = sub_2C76A00(a1, v8, 0);
                v450 = sub_904010(v449, "Bindless bank must be i64");
                a2 = (__int64)"\n";
                sub_904010(v450, "\n");
                sub_2C76240(a1, (__int64)"\n", v451, v452);
              }
            }
            else
            {
              a2 = 32;
              if ( !sub_BCAC40(*(_QWORD *)(v442 + 8), 32) )
              {
                v765 = sub_2C76A00(a1, v8, 0);
                v766 = sub_904010(v765, "Bound bank must be i32");
                a2 = (__int64)"\n";
                sub_904010(v766, "\n");
                sub_2C76240(a1, (__int64)"\n", v767, v768);
              }
            }
            goto LABEL_54;
          case 0x2311u:
          case 0x2312u:
          case 0x2313u:
          case 0x2314u:
          case 0x2315u:
          case 0x2316u:
          case 0x2317u:
          case 0x2318u:
            goto LABEL_137;
          case 0x2319u:
          case 0x231Au:
          case 0x231Bu:
            v301 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
            if ( *(_BYTE *)v301 == 17 )
            {
              v302 = *(_QWORD **)(v301 + 24);
              if ( *(_DWORD *)(v301 + 32) > 0x40u )
                v302 = (_QWORD *)*v302;
              if ( ((unsigned int)v302 & 0xFFFFFFE0) != 0 )
              {
                v750 = sub_2C76A00(a1, v8, 0);
                v751 = sub_904010(v750, "reserved flag bits used");
                a2 = (__int64)"\n";
                sub_904010(v751, "\n");
                sub_2C76240(a1, (__int64)"\n", v752, v753);
              }
              if ( ((unsigned __int8)v302 & 0x1E) != 0 && ((unsigned __int8)v302 & 1) != 0 )
              {
                v851 = sub_2C76A00(a1, v8, 0);
                v852 = sub_904010(v851, "ColMajor is not supported for this size");
                a2 = (__int64)"\n";
                sub_904010(v852, "\n");
                sub_2C76240(a1, (__int64)"\n", v853, v854);
              }
              if ( (((unsigned int)v302 >> 1) & 0xF) > 4 )
              {
                v303 = sub_2C76A00(a1, v8, 0);
                v304 = sub_904010(v303, "Invalid size");
                a2 = (__int64)"\n";
                sub_904010(v304, "\n");
                sub_2C76240(a1, (__int64)"\n", v305, v306);
              }
            }
            else
            {
              v627 = sub_2C76A00(a1, v8, 0);
              v628 = sub_904010(v627, "arg0 of intrinsic not constant");
              a2 = (__int64)"\n";
              sub_904010(v628, "\n");
              sub_2C76240(a1, (__int64)"\n", v629, v630);
              v631 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
              if ( *(_BYTE *)(v631 + 8) == 14 )
              {
                if ( *(_DWORD *)(v631 + 8) >> 8 != 3 )
                {
                  v722 = sub_2C76A00(a1, v8, 0);
                  v723 = sub_904010(v722, "arg1 invalid addrspace");
                  a2 = (__int64)"\n";
                  sub_904010(v723, "\n");
                  sub_2C76240(a1, (__int64)"\n", v724, v725);
                }
              }
              else
              {
                v632 = sub_2C76A00(a1, v8, 0);
                v633 = sub_904010(v632, "arg0 of intrinsic not pointer");
                a2 = (__int64)"\n";
                sub_904010(v633, "\n");
                sub_2C76240(a1, (__int64)"\n", v634, v635);
              }
            }
            goto LABEL_54;
          case 0x231Cu:
            v428 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
            if ( *(_BYTE *)v428 == 17 )
            {
              v429 = *(_QWORD **)(v428 + 24);
              if ( *(_DWORD *)(v428 + 32) > 0x40u )
                v429 = (_QWORD *)*v429;
              v430 = (char)v429;
              if ( (unsigned int)v429 >> 16 )
              {
                v773 = sub_2C76A00(a1, v8, 0);
                v774 = sub_904010(v773, "reserved flag bits used");
                a2 = (__int64)"\n";
                sub_904010(v774, "\n");
                sub_2C76240(a1, (__int64)"\n", v775, v776);
              }
              if ( (v430 & 7u) <= 2 )
              {
LABEL_545:
                if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL)
                               + 8LL) >> 8 != 1 )
                {
                  v431 = sub_2C76A00(a1, v8, 0);
                  v432 = sub_904010(v431, "pointer address space not global");
                  a2 = (__int64)"\n";
                  sub_904010(v432, "\n");
                  sub_2C76240(a1, (__int64)"\n", v433, v434);
                }
                goto LABEL_54;
              }
              v640 = "invalid load bounds check type";
              v641 = sub_2C76A00(a1, v8, 0);
            }
            else
            {
              v640 = "op0 of intrinsic not constant";
              v641 = sub_2C76A00(a1, v8, 0);
            }
            v642 = sub_904010(v641, v640);
            a2 = (__int64)"\n";
            sub_904010(v642, "\n");
            sub_2C76240(a1, (__int64)"\n", v643, v644);
            goto LABEL_545;
          case 0x2323u:
            if ( **(_BYTE **)(v8 + 32 * (3LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) != 17 )
            {
              v435 = sub_2C76A00(a1, v8, 0);
              v436 = sub_904010(v435, "fourth argument must be a constant integer");
              a2 = (__int64)"\n";
              sub_904010(v436, "\n");
              sub_2C76240(a1, (__int64)"\n", v437, v438);
            }
            goto LABEL_54;
          default:
            goto LABEL_54;
        }
      }
      if ( v33 <= 0x2073 )
      {
        if ( v33 > 0x1FF4 )
        {
          switch ( v33 )
          {
            case 0x1FF5u:
            case 0x1FF6u:
            case 0x1FF7u:
            case 0x1FF8u:
            case 0x1FFBu:
            case 0x1FFCu:
            case 0x1FFDu:
            case 0x1FFEu:
              v205 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
              v206 = *(_QWORD **)(v205 + 24);
              if ( *(_DWORD *)(v205 + 32) > 0x40u )
                v206 = (_QWORD *)*v206;
              v207 = (int)v206;
              if ( BYTE2(v206) != 14 )
              {
                v208 = sub_2C76A00(a1, v8, 0);
                v209 = sub_904010(v208, "the opcode of atomic_cas must be CAS");
                a2 = (__int64)"\n";
                sub_904010(v209, "\n");
                sub_2C76240(a1, (__int64)"\n", v210, v211);
              }
              if ( (v207 & 0x1000000) != 0 )
              {
                v212 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
                if ( (unsigned int)*(unsigned __int8 *)(v212 + 8) - 17 <= 1 )
                  v212 = **(_QWORD **)(v212 + 16);
                if ( *(_DWORD *)(v212 + 8) > 0x1FFu )
                {
                  v213 = sub_2C76A00(a1, v8, 0);
                  v214 = sub_904010(v213, "Global ordering on atomics is only allowed on generic/global pointers");
                  a2 = (__int64)"\n";
                  sub_904010(v214, "\n");
                  sub_2C76240(a1, (__int64)"\n", v215, v216);
                }
              }
              goto LABEL_54;
            case 0x1FFFu:
            case 0x2000u:
              v283 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              v284 = *(_QWORD *)(v8 - 32 * v283);
              v285 = *(_QWORD **)(v284 + 24);
              if ( *(_DWORD *)(v284 + 32) > 0x40u )
                v285 = (_QWORD *)*v285;
              v286 = (int)v285;
              if ( (unsigned __int8)(BYTE2(v285) - 15) > 1u )
              {
                v287 = sub_2C76A00(a1, v8, 0);
                v288 = sub_904010(v287, "the opcode of atomic_cast must be CAST or CAST_SPIN");
                sub_904010(v288, "\n");
                sub_2C76240(a1, (__int64)"\n", v289, v290);
                v283 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              }
              a2 = 32;
              v291 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (2 - v283)) + 8LL);
              if ( !sub_BCAC40(v291, 32) )
              {
                a2 = 64;
                if ( !sub_BCAC40(v291, 64) )
                {
                  v670 = sub_2C76A00(a1, v8, 0);
                  v671 = sub_904010(v670, "atomic.cast only overloads on i32 and i64");
                  a2 = (__int64)"\n";
                  sub_904010(v671, "\n");
                  sub_2C76240(a1, (__int64)"\n", v672, v673);
                }
              }
              v292 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v292 + 8) - 17 <= 1 )
                v292 = **(_QWORD **)(v292 + 16);
              if ( *(_DWORD *)(v292 + 8) >> 8 != 3 )
              {
                v293 = sub_2C76A00(a1, v8, 0);
                v294 = sub_904010(v293, "atomic.cast is only allowed on shared pointers");
                a2 = (__int64)"\n";
                sub_904010(v294, "\n");
                sub_2C76240(a1, (__int64)"\n", v295, v296);
              }
              if ( (v286 & 0x1000000) != 0 )
              {
                v297 = sub_2C76A00(a1, v8, 0);
                v298 = sub_904010(v297, "atomic.cast works on shared memory, so cannot be ordered");
                a2 = (__int64)"\n";
                sub_904010(v298, "\n");
                sub_2C76240(a1, (__int64)"\n", v299, v300);
              }
              goto LABEL_54;
            case 0x200Fu:
            case 0x2010u:
            case 0x2011u:
            case 0x2012u:
            case 0x2013u:
            case 0x2014u:
            case 0x2019u:
            case 0x201Au:
            case 0x201Bu:
            case 0x201Cu:
            case 0x201Du:
            case 0x201Eu:
              v186 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
              v187 = *(_QWORD **)(v186 + 24);
              if ( *(_DWORD *)(v186 + 32) > 0x40u )
                v187 = (_QWORD *)*v187;
              v188 = (int)v187;
              v189 = (unsigned int)v187 >> 16;
              if ( (unsigned __int8)(BYTE2(v187) - 14) <= 2u )
              {
                v666 = sub_2C76A00(a1, v8, 0);
                v667 = sub_904010(v666, "the opcode of atomic_rmw must not be CAS, CAST or CAST_SPIN");
                a2 = (__int64)"\n";
                sub_904010(v667, "\n");
                sub_2C76240(a1, (__int64)"\n", v668, v669);
              }
              if ( (v188 & 0x1000000) != 0 )
              {
                v190 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
                if ( (unsigned int)*(unsigned __int8 *)(v190 + 8) - 17 <= 1 )
                  v190 = **(_QWORD **)(v190 + 16);
                if ( *(_DWORD *)(v190 + 8) > 0x1FFu )
                {
                  v191 = sub_2C76A00(a1, v8, 0);
                  v192 = sub_904010(v191, "Global ordering on atomics is only allowed on generic/global pointers");
                  a2 = (__int64)"\n";
                  sub_904010(v192, "\n");
                  sub_2C76240(a1, (__int64)"\n", v193, v194);
                }
              }
              if ( (v33 == 8220 || v33 == 8210) && (_BYTE)v189 )
              {
                v195 = sub_2C76A00(a1, v8, 0);
                v196 = sub_904010(v195, "only atomic EXCH allowed for 128b atomic rmw");
                a2 = (__int64)"\n";
                sub_904010(v196, "\n");
                sub_2C76240(a1, (__int64)"\n", v197, v198);
              }
              goto LABEL_54;
            case 0x2017u:
            case 0x2018u:
            case 0x201Fu:
            case 0x2020u:
              v235 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              a2 = *(_QWORD *)(v8 - 32 * v235);
              v236 = *(_QWORD **)(a2 + 24);
              if ( *(_DWORD *)(a2 + 32) > 0x40u )
                v236 = (_QWORD *)*v236;
              if ( BYTE2(v236) != 11 )
              {
                v237 = sub_2C76A00(a1, v8, 0);
                v238 = sub_904010(v237, "the opcode of atomic_rmw_v2f32 and atomic_rmw_v4f32 must be FADD");
                a2 = (__int64)"\n";
                sub_904010(v238, "\n");
                sub_2C76240(a1, (__int64)"\n", v239, v240);
                v235 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              }
              v241 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1 - v235)) + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v241 + 8) - 17 <= 1 )
                v241 = **(_QWORD **)(v241 + 16);
              if ( *(_DWORD *)(v241 + 8) > 0x1FFu )
              {
                v242 = sub_2C76A00(a1, v8, 0);
                v243 = sub_904010(v242, "Vector atomics are only allowed on generic/global pointers");
                a2 = (__int64)"\n";
                sub_904010(v243, "\n");
                sub_2C76240(a1, (__int64)"\n", v244, v245);
              }
              goto LABEL_54;
            case 0x2027u:
            case 0x2028u:
            case 0x2029u:
            case 0x202Au:
            case 0x202Bu:
            case 0x202Cu:
              v229 = *(_DWORD *)(a1 + 8);
              if ( v229 && v229 <= 899 )
                goto LABEL_561;
              goto LABEL_54;
            case 0x205Cu:
            case 0x205Eu:
            case 0x205Fu:
            case 0x2060u:
              v246 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
              if ( *(_BYTE *)v246 != 17 )
                goto LABEL_756;
              v247 = *(_QWORD **)(v246 + 24);
              if ( *(_DWORD *)(v246 + 32) > 0x40u )
                v247 = (_QWORD *)*v247;
              if ( ((unsigned __int8)v247 & 0xFu) > 4 )
              {
                v760 = sub_2C76A00(a1, v8, 0);
                v761 = sub_904010(v760, "invalid cache type");
                a2 = (__int64)"\n";
                sub_904010(v761, "\n");
                sub_2C76240(a1, (__int64)"\n", v762, v763);
              }
              if ( v33 == 8284 )
              {
                if ( ((unsigned __int8)v247 & 0xF0) == 0 )
                  goto LABEL_340;
              }
              else if ( (char)v247 >= 0 )
              {
                goto LABEL_340;
              }
              v730 = sub_2C76A00(a1, v8, 0);
              v731 = sub_904010(v730, "invalid cache op");
              a2 = (__int64)"\n";
              sub_904010(v731, "\n");
              sub_2C76240(a1, (__int64)"\n", v732, v733);
LABEL_340:
              if ( ((unsigned int)v247 & 0xFFFF8000) != 0 )
                goto LABEL_643;
              goto LABEL_54;
            case 0x206Eu:
              v356 = *(_QWORD *)(v8 + 8);
              v357 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              v358 = *(_BYTE **)(v8 - 32 * v357);
              if ( *v358 != 17 )
                v358 = 0;
              v947 = v358;
              v954 = *(_QWORD *)(v8 + 32 * (4 - v357));
              v359 = *(_BYTE **)(v8 + 32 * (6 - v357));
              if ( *v359 != 17 )
                v359 = 0;
              v360 = *(_QWORD *)(v8 + 32 * (7 - v357));
              v961 = v359;
              if ( *(_BYTE *)v360 != 17 )
                v360 = 0;
              v968 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1 - v357)) + 8LL);
              v361 = *(_BYTE *)(v356 + 8);
              if ( *(_BYTE *)(v968 + 8) == 17 )
              {
                if ( v361 == 17 )
                {
                  v573 = *(__int64 **)(v968 + 16);
                  if ( !*(_BYTE *)(*v573 + 8) || sub_BCAC40(*v573, 8) )
                  {
LABEL_450:
                    v364 = *(unsigned __int8 *)(v356 + 8);
                    if ( (unsigned int)(v364 - 17) > 1 )
                    {
                      if ( !(_BYTE)v364 )
                        goto LABEL_455;
                    }
                    else
                    {
                      v365 = *(__int64 **)(v356 + 16);
                      v366 = *v365;
                      if ( !*(_BYTE *)(*v365 + 8) )
                        goto LABEL_455;
                      if ( v364 == 18 )
                        goto LABEL_453;
                    }
                    v366 = v356;
                    if ( v364 == 17 )
                      v366 = **(_QWORD **)(v356 + 16);
LABEL_453:
                    if ( !sub_BCAC40(v366, 32) )
                    {
                      v847 = sub_2C76A00(a1, v8, 0);
                      v848 = sub_904010(v847, "result must be f16/i32 vector type");
                      sub_904010(v848, "\n");
                      sub_2C76240(a1, (__int64)"\n", v849, v850);
                    }
LABEL_455:
                    if ( !v947 )
                    {
                      v825 = "flags must be constant";
                      v826 = sub_2C76A00(a1, v8, 0);
                      goto LABEL_861;
                    }
                    v367 = *((_QWORD *)v947 + 3);
                    if ( *((_DWORD *)v947 + 8) > 0x40u )
                      v367 = **((_QWORD **)v947 + 3);
                    if ( (v367 & 0xFFFFFF8000000000LL) != 0 )
                    {
                      v951 = v367;
                      v700 = sub_2C76A00(a1, v8, 0);
                      v701 = sub_904010(v700, "reserved flag bits used");
                      sub_904010(v701, "\n");
                      sub_2C76240(a1, (__int64)"\n", v702, v703);
                      v367 = v951;
                    }
                    v944 = BYTE1(v367);
                    v946 = v367 & 0x1FE0000000LL;
                    a2 = BYTE1(v367) == 1;
                    if ( (((unsigned __int8)(a2 | (BYTE1(v367) == 4)) & ((_BYTE)v367 == 1 || (_BYTE)v367 == 4)) == 0
                       || (v367 & 0x1FE0000000LL) != 1610612736 && (v367 & 0x1FE0000000LL) != 3221225472)
                      && (v367 & 0x1FE000FFFFLL) != 0 )
                    {
                      v948 = v367;
                      v368 = sub_2C76A00(a1, v8, 0);
                      v369 = sub_904010(v368, "Combination of Input, Matrix, Result not supported");
                      a2 = (__int64)"\n";
                      sub_904010(v369, "\n");
                      sub_2C76240(a1, (__int64)"\n", v370, v371);
                      v367 = v948;
                    }
                    v949 = v367;
                    v372 = sub_AD6530(*(_QWORD *)(v954 + 8), a2);
                    v373 = v949;
                    if ( v954 != v372 && (unsigned __int8)(v949 >> 29) != BYTE2(v949) )
                    {
                      v374 = sub_2C76A00(a1, v8, 0);
                      v375 = sub_904010(v374, "Bias interpretation must match result interpretation");
                      a2 = (__int64)"\n";
                      sub_904010(v375, "\n");
                      sub_2C76240(a1, (__int64)"\n", v376, v377);
                      v373 = v949;
                    }
                    if ( !v356 )
                      goto LABEL_473;
                    v378 = *(unsigned __int8 *)(v356 + 8);
                    v379 = v378 - 17;
                    if ( v946 )
                    {
                      if ( v379 <= 1 )
                      {
                        v381 = **(_QWORD **)(v356 + 16);
                        goto LABEL_471;
                      }
                    }
                    else
                    {
                      if ( v379 <= 1 )
                      {
                        v380 = *(__int64 **)(v356 + 16);
                        v381 = *v380;
                        if ( *(_BYTE *)(*v380 + 8) )
                          goto LABEL_471;
LABEL_473:
                        if ( (HIBYTE(v373) & 0xFu) > 2 )
                        {
                          v958 = v373;
                          v688 = sub_2C76A00(a1, v8, 0);
                          v689 = sub_904010(v688, "MatrixLayout not a supported value");
                          a2 = (__int64)"\n";
                          sub_904010(v689, "\n");
                          sub_2C76240(a1, (__int64)"\n", v690, v691);
                          v373 = v958;
                        }
                        if ( (v373 & 0x10000000) == 0 || !v944 )
                        {
LABEL_477:
                          if ( v961 )
                          {
                            v383 = (_QWORD *)*((_QWORD *)v961 + 3);
                            if ( *((_DWORD *)v961 + 8) > 0x40u )
                              v383 = (_QWORD *)*v383;
                            if ( !v383 )
                            {
                              v684 = sub_2C76A00(a1, v8, 0);
                              v685 = sub_904010(v684, "N must be greater than zero");
                              a2 = (__int64)"\n";
                              sub_904010(v685, "\n");
                              sub_2C76240(a1, (__int64)"\n", v686, v687);
                            }
                            if ( !v356 )
                              goto LABEL_488;
                            v384 = (_QWORD *)*((_QWORD *)v961 + 3);
                            if ( *((_DWORD *)v961 + 8) > 0x40u )
                              v384 = (_QWORD *)*v384;
                            if ( (_QWORD *)*(unsigned int *)(v356 + 32) == v384 )
                              goto LABEL_488;
                            v385 = "N must be the number of components in the result type";
                            v386 = sub_2C76A00(a1, v8, 0);
                          }
                          else
                          {
                            v385 = "N must be constant";
                            v386 = sub_2C76A00(a1, v8, 0);
                          }
                          v387 = sub_904010(v386, v385);
                          a2 = (__int64)"\n";
                          sub_904010(v387, "\n");
                          sub_2C76240(a1, (__int64)"\n", v388, v389);
LABEL_488:
                          if ( v360 )
                          {
                            v390 = *(_QWORD **)(v360 + 24);
                            if ( *(_DWORD *)(v360 + 32) > 0x40u )
                              v390 = (_QWORD *)*v390;
                            if ( !v390 )
                            {
                              v680 = sub_2C76A00(a1, v8, 0);
                              v681 = sub_904010(v680, "K must be greater than zero");
                              a2 = (__int64)"\n";
                              sub_904010(v681, "\n");
                              sub_2C76240(a1, (__int64)"\n", v682, v683);
                            }
                            if ( v968 )
                            {
                              v391 = *(_QWORD **)(v360 + 24);
                              if ( *(_DWORD *)(v360 + 32) > 0x40u )
                                v391 = (_QWORD *)*v391;
                              if ( (_QWORD *)*(unsigned int *)(v968 + 32) != v391 )
                              {
                                v392 = sub_2C76A00(a1, v8, 0);
                                v393 = sub_904010(v392, "K must be the number of components in the input vector type");
                                a2 = (__int64)"\n";
                                sub_904010(v393, "\n");
                                sub_2C76240(a1, (__int64)"\n", v394, v395);
                              }
                            }
                          }
                          else
                          {
                            v821 = sub_2C76A00(a1, v8, 0);
                            v822 = sub_904010(v821, "K must be constant");
                            a2 = (__int64)"\n";
                            sub_904010(v822, "\n");
                            sub_2C76240(a1, (__int64)"\n", v823, v824);
                          }
                          goto LABEL_54;
                        }
                        v825 = "Transpose not a supported value";
                        v826 = sub_2C76A00(a1, v8, 0);
LABEL_861:
                        v827 = sub_904010(v826, v825);
                        a2 = (__int64)"\n";
                        sub_904010(v827, "\n");
                        sub_2C76240(a1, (__int64)"\n", v828, v829);
                        goto LABEL_477;
                      }
                      if ( !(_BYTE)v378 )
                        goto LABEL_473;
                    }
                    v381 = v356;
LABEL_471:
                    a2 = 32;
                    v955 = v373;
                    v382 = sub_BCAC40(v381, 32);
                    v373 = v955;
                    if ( !v382 )
                    {
                      v817 = sub_2C76A00(a1, v8, 0);
                      v818 = sub_904010(v817, "ResultTy must match ResultInterpretation");
                      a2 = (__int64)"\n";
                      sub_904010(v818, "\n");
                      sub_2C76240(a1, (__int64)"\n", v819, v820);
                      v373 = v955;
                    }
                    goto LABEL_473;
                  }
                }
                else
                {
                  v362 = *(__int64 **)(v968 + 16);
                  if ( !*(_BYTE *)(*v362 + 8) || sub_BCAC40(*v362, 8) )
                    goto LABEL_841;
                  v356 = 0;
                }
                v363 = v968;
                if ( (unsigned int)*(unsigned __int8 *)(v968 + 8) - 17 <= 1 )
                  v363 = **(_QWORD **)(v968 + 16);
                if ( !sub_BCAC40(v363, 32) )
                {
                  v859 = sub_2C76A00(a1, v8, 0);
                  v860 = sub_904010(v859, "inputVec must be i8/i32/f16 vector type");
                  sub_904010(v860, "\n");
                  sub_2C76240(a1, (__int64)"\n", v861, v862);
                }
              }
              else
              {
                if ( v361 != 17 )
                  v356 = 0;
                v623 = sub_2C76A00(a1, v8, 0);
                v624 = sub_904010(v623, "inputVec must be a vector type");
                sub_904010(v624, "\n");
                sub_2C76240(a1, (__int64)"\n", v625, v626);
                v968 = 0;
              }
              if ( v356 )
                goto LABEL_450;
LABEL_841:
              v356 = 0;
              v801 = sub_2C76A00(a1, v8, 0);
              v802 = sub_904010(v801, "result must be a vector type");
              sub_904010(v802, "\n");
              sub_2C76240(a1, (__int64)"\n", v803, v804);
              goto LABEL_455;
            case 0x206Fu:
              a2 = 0;
              v396 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              v397 = *(_QWORD *)(v8 - 32 * v396);
              if ( *(_BYTE *)v397 != 17 )
                v397 = 0;
              v398 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (4 - v396)) + 8LL);
              v399 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (3 - v396)) + 8LL);
              if ( *(_BYTE *)(v399 + 8) != 17 )
                v399 = 0;
              if ( *(_BYTE *)(v398 + 8) != 17 )
                v398 = 0;
              v400 = *(_QWORD *)(v8 + 32 * (6 - v396));
              if ( *(_BYTE *)v400 != 17 )
                v400 = 0;
              if ( **(_BYTE **)(v8 + 32 * (7 - v396)) == 17 )
                a2 = *(_QWORD *)(v8 + 32 * (7 - v396));
              v969 = a2;
              if ( v397 )
              {
                v401 = *(_QWORD *)(v397 + 24);
                if ( *(_DWORD *)(v397 + 32) > 0x40u )
                  v401 = *(_QWORD *)v401;
                v962 = v401;
                if ( (v401 & 0xF0) != 0 )
                {
                  v953 = (_QWORD *)v401;
                  v960 = v400;
                  v718 = sub_2C76A00(a1, v8, 0);
                  v719 = sub_904010(v718, "reserved flag bits used");
                  a2 = (__int64)"\n";
                  sub_904010(v719, "\n");
                  sub_2C76240(a1, (__int64)"\n", v720, v721);
                  v401 = (unsigned __int64)v953;
                  v400 = v960;
                }
                if ( (v401 & 0xFFFFFFFFFFFF0000LL) != 0 )
                {
                  v952 = v401;
                  v959 = v400;
                  v714 = sub_2C76A00(a1, v8, 0);
                  v715 = sub_904010(v714, "reserved2 flag bits used");
                  a2 = (__int64)"\n";
                  sub_904010(v715, "\n");
                  sub_2C76240(a1, (__int64)"\n", v716, v717);
                  LOWORD(v401) = v952;
                  v400 = v959;
                }
                if ( (v962 & 0xF) != 3 )
                {
                  v956 = v401;
                  v963 = v400;
                  v402 = sub_2C76A00(a1, v8, 0);
                  v403 = sub_904010(v402, "MatrixLayout must be TrainingOptimal");
                  a2 = (__int64)"\n";
                  sub_904010(v403, "\n");
                  sub_2C76240(a1, (__int64)"\n", v404, v405);
                  LOWORD(v401) = v956;
                  v400 = v963;
                }
                if ( (v401 & 0xFF00) == 0 )
                {
LABEL_518:
                  if ( !v399 )
                  {
                    v704 = "V1 must be a vector";
                    v705 = sub_2C76A00(a1, v8, 0);
                    goto LABEL_791;
                  }
                  if ( v400 )
                  {
                    v406 = *(_QWORD **)(v400 + 24);
                    if ( *(_DWORD *)(v400 + 32) > 0x40u )
                      v406 = (_QWORD *)*v406;
                    if ( (_QWORD *)*(unsigned int *)(v399 + 32) == v406 )
                      goto LABEL_525;
                    v407 = "M must equal the number of components in V1";
                    v408 = sub_2C76A00(a1, v8, 0);
                  }
                  else
                  {
                    v407 = "M must be constant";
                    v408 = sub_2C76A00(a1, v8, 0);
                  }
                  v409 = sub_904010(v408, v407);
                  a2 = (__int64)"\n";
                  sub_904010(v409, "\n");
                  sub_2C76240(a1, (__int64)"\n", v410, v411);
LABEL_525:
                  v412 = *(unsigned __int8 *)(v399 + 8);
                  if ( (unsigned int)(v412 - 17) <= 1 )
                    LOBYTE(v412) = *(_BYTE *)(**(_QWORD **)(v399 + 16) + 8LL);
                  if ( !(_BYTE)v412 )
                  {
LABEL_528:
                    if ( !v398 )
                    {
                      v797 = sub_2C76A00(a1, v8, 0);
                      v798 = sub_904010(v797, "V2 must be a vector");
                      a2 = (__int64)"\n";
                      sub_904010(v798, "\n");
                      sub_2C76240(a1, (__int64)"\n", v799, v800);
                      goto LABEL_54;
                    }
                    if ( v969 )
                    {
                      v413 = *(_QWORD **)(v969 + 24);
                      if ( *(_DWORD *)(v969 + 32) > 0x40u )
                        v413 = (_QWORD *)*v413;
                      if ( (_QWORD *)*(unsigned int *)(v398 + 32) == v413 )
                        goto LABEL_535;
                      v414 = "N must equal the number of components in V2";
                      v415 = sub_2C76A00(a1, v8, 0);
                    }
                    else
                    {
                      v414 = "N must be constant";
                      v415 = sub_2C76A00(a1, v8, 0);
                    }
                    v416 = sub_904010(v415, v414);
                    a2 = (__int64)"\n";
                    sub_904010(v416, "\n");
                    sub_2C76240(a1, (__int64)"\n", v417, v418);
LABEL_535:
                    v419 = *(unsigned __int8 *)(v398 + 8);
                    if ( (unsigned int)(v419 - 17) <= 1 )
                      LOBYTE(v419) = *(_BYTE *)(**(_QWORD **)(v398 + 16) + 8LL);
                    if ( (_BYTE)v419 )
                    {
                      v420 = sub_2C76A00(a1, v8, 0);
                      v421 = sub_904010(v420, "Element type must be f16");
                      a2 = (__int64)"\n";
                      sub_904010(v421, "\n");
                      sub_2C76240(a1, (__int64)"\n", v422, v423);
                    }
                    goto LABEL_54;
                  }
                  v704 = "Element type must be f16";
                  v705 = sub_2C76A00(a1, v8, 0);
LABEL_791:
                  v706 = sub_904010(v705, v704);
                  a2 = (__int64)"\n";
                  sub_904010(v706, "\n");
                  sub_2C76240(a1, (__int64)"\n", v707, v708);
                  goto LABEL_528;
                }
                v967 = v400;
                v709 = "MatrixInterpretation must be Float16";
                v710 = sub_2C76A00(a1, v8, 0);
              }
              else
              {
                v967 = v400;
                v709 = "flags must be constant";
                v710 = sub_2C76A00(a1, v8, 0);
              }
              v711 = sub_904010(v710, v709);
              a2 = (__int64)"\n";
              sub_904010(v711, "\n");
              sub_2C76240(a1, (__int64)"\n", v712, v713);
              v400 = v967;
              goto LABEL_518;
            case 0x2070u:
              v341 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              a2 = *(_QWORD *)(v8 - 32 * v341);
              if ( *(_BYTE *)a2 != 17 )
                a2 = 0;
              v342 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (3 - v341)) + 8LL);
              if ( *(_BYTE *)(v342 + 8) != 17 )
                v342 = 0;
              v343 = *(_QWORD *)(v8 + 32 * (4 - v341));
              if ( *(_BYTE *)v343 != 17 )
                v343 = 0;
              if ( a2 )
              {
                v344 = *(_QWORD **)(a2 + 24);
                if ( *(_DWORD *)(a2 + 32) > 0x40u )
                  v344 = (_QWORD *)*v344;
                if ( !v344 )
                {
LABEL_423:
                  if ( !v342 )
                  {
                    v809 = sub_2C76A00(a1, v8, 0);
                    v810 = sub_904010(v809, "V must be a vector");
                    a2 = (__int64)"\n";
                    sub_904010(v810, "\n");
                    sub_2C76240(a1, (__int64)"\n", v811, v812);
                    goto LABEL_54;
                  }
                  if ( v343 )
                  {
                    v345 = *(_QWORD **)(v343 + 24);
                    if ( *(_DWORD *)(v343 + 32) > 0x40u )
                      v345 = (_QWORD *)*v345;
                    if ( (_QWORD *)*(unsigned int *)(v342 + 32) == v345 )
                      goto LABEL_430;
                    v346 = "N must equal the number of components in V";
                    v347 = sub_2C76A00(a1, v8, 0);
                  }
                  else
                  {
                    v346 = "N must be constant";
                    v347 = sub_2C76A00(a1, v8, 0);
                  }
                  v348 = sub_904010(v347, v346);
                  a2 = (__int64)"\n";
                  sub_904010(v348, "\n");
                  sub_2C76240(a1, (__int64)"\n", v349, v350);
LABEL_430:
                  v351 = *(unsigned __int8 *)(v342 + 8);
                  if ( (unsigned int)(v351 - 17) <= 1 )
                    LOBYTE(v351) = *(_BYTE *)(**(_QWORD **)(v342 + 16) + 8LL);
                  if ( (v351 & 0xFD) != 0 )
                  {
                    v352 = sub_2C76A00(a1, v8, 0);
                    v353 = sub_904010(v352, "Element type must be f16 or f32");
                    a2 = (__int64)"\n";
                    sub_904010(v353, "\n");
                    sub_2C76240(a1, (__int64)"\n", v354, v355);
                  }
                  goto LABEL_54;
                }
                v692 = "reserved flag bits used";
                v693 = sub_2C76A00(a1, v8, 0);
              }
              else
              {
                v692 = "flags must be constant";
                v693 = sub_2C76A00(a1, v8, 0);
              }
              v694 = sub_904010(v693, v692);
              a2 = (__int64)"\n";
              sub_904010(v694, "\n");
              sub_2C76240(a1, (__int64)"\n", v695, v696);
              goto LABEL_423;
            case 0x2073u:
              goto LABEL_152;
            default:
              goto LABEL_54;
          }
        }
        if ( v33 <= 0x174 )
        {
          if ( v33 > 0xA9 )
          {
            switch ( v33 )
            {
              case 0xAAu:
              case 0xDAu:
              case 0xDBu:
              case 0xDCu:
              case 0x11Bu:
              case 0x11Cu:
              case 0x11Du:
              case 0x11Eu:
              case 0x12Fu:
              case 0x145u:
                goto LABEL_43;
              case 0xB2u:
              case 0xB6u:
              case 0xB7u:
              case 0xB8u:
              case 0x133u:
              case 0x156u:
              case 0x157u:
                if ( *(_DWORD *)a1 != 1 )
                  goto LABEL_46;
                if ( v33 - 342 <= 1 )
                  goto LABEL_54;
                goto LABEL_44;
              case 0xC3u:
              case 0xFAu:
              case 0x11Au:
              case 0x134u:
              case 0x135u:
              case 0x154u:
              case 0x155u:
              case 0x163u:
                goto LABEL_46;
              case 0x138u:
              case 0x14Du:
              case 0x153u:
              case 0x168u:
              case 0x171u:
              case 0x174u:
                v248 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
                if ( *(_BYTE *)(v248 + 8) == 12 )
                {
                  v977 = sub_BCAE30(v248);
                  v978 = v658;
                  v659 = sub_CA1930(&v977) - 16;
                  if ( v659 > 0x30 || (v660 = 0x1000000010001LL, !_bittest64(&v660, v659)) )
                  {
                    v661 = sub_2C76A00(a1, v8, 0);
                    v662 = sub_904010(v661, "Invalid type for arithmetic overflow intrinsic,");
                    a2 = (__int64)" need i16, i32, or i64\n";
                    sub_904010(v662, " need i16, i32, or i64\n");
                    sub_2C76240(a1, (__int64)" need i16, i32, or i64\n", v663, v664);
                  }
                }
                else
                {
                  v249 = sub_2C76A00(a1, v8, 0);
                  v250 = sub_904010(v249, "arithmetic overflow operand 0 not an integer?");
                  a2 = (__int64)"\n";
                  sub_904010(v250, "\n");
                  sub_2C76240(a1, (__int64)"\n", v251, v252);
                }
                goto LABEL_54;
              default:
                goto LABEL_54;
            }
          }
          if ( v33 != 4 )
          {
            switch ( v33 )
            {
              case '?':
              case 'X':
              case 'Z':
LABEL_43:
                if ( *(_DWORD *)a1 != 1 )
                  break;
LABEL_44:
                if ( v33 != 170 && v33 != 286 )
                  break;
                goto LABEL_54;
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'V':
                break;
              default:
                goto LABEL_54;
            }
          }
LABEL_46:
          v34 = sub_2C76A00(a1, v8, 0);
          v35 = sub_904010(v34, "Unsupported intrinsic: ");
          v36 = *(_QWORD *)(v8 - 32);
          v37 = v35;
          if ( v36 )
          {
            if ( *(_BYTE *)v36 )
            {
              v36 = 0;
            }
            else if ( *(_QWORD *)(v8 + 80) != *(_QWORD *)(v36 + 24) )
            {
              v36 = 0;
            }
          }
          v38 = (unsigned __int8 *)sub_BD5D20(v36);
          v40 = *(void **)(v37 + 32);
          if ( v39 > *(_QWORD *)(v37 + 24) - (_QWORD)v40 )
          {
            v37 = sub_CB6200(v37, v38, v39);
          }
          else if ( v39 )
          {
            v972 = v39;
            memcpy(v40, v38, v39);
            *(_QWORD *)(v37 + 32) += v972;
          }
          a2 = (__int64)"\n";
          sub_904010(v37, "\n");
          sub_2C76240(a1, (__int64)"\n", v41, v42);
        }
LABEL_54:
        if ( (unsigned __int8)sub_CEA320(v33) && *(int *)(a1 + 8) <= 1199 )
        {
          v164 = sub_2C76A00(a1, v8, 0);
          v165 = sub_904010(v164, ".offset.bindless intrinsics are not supported on pre-Blackwell architectures");
          a2 = (__int64)"\n";
          sub_904010(v165, "\n");
          sub_2C76240(a1, (__int64)"\n", v166, v167);
        }
        if ( sub_CEA270(v33) )
        {
          v43 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v43 != 17 )
          {
            a2 = v8;
            v134 = sub_2C76A00(a1, v8, 0);
            v126 = *(__m128i **)(v134 + 32);
            v135 = v134;
            if ( *(_QWORD *)(v134 + 24) - (_QWORD)v126 <= 0x1Cu )
            {
              a2 = (__int64)"op0 of intrinsic not constant";
              v135 = sub_CB6200(v134, "op0 of intrinsic not constant", 0x1Du);
              v137 = *(_BYTE **)(v135 + 32);
            }
            else
            {
              v136 = _mm_load_si128((const __m128i *)&xmmword_42D0BE0);
              qmemcpy(&v126[1], " not constant", 13);
              *v126 = v136;
              v137 = (_BYTE *)(*(_QWORD *)(v134 + 32) + 29LL);
              *(_QWORD *)(v135 + 32) = v137;
            }
            if ( v137 == *(_BYTE **)(v135 + 24) )
            {
              a2 = (__int64)"\n";
              sub_CB6200(v135, (unsigned __int8 *)"\n", 1u);
            }
            else
            {
              *v137 = 10;
              ++*(_QWORD *)(v135 + 32);
            }
LABEL_193:
            sub_2C76240(a1, a2, (__int64)v126, v127);
            if ( v33 == 241 )
              goto LABEL_194;
            goto LABEL_66;
          }
          v44 = *(_QWORD **)(v43 + 24);
          if ( *(_DWORD *)(v43 + 32) > 0x40u )
            v44 = (_QWORD *)*v44;
          if ( ((unsigned __int8)v44 & 7) == 0 || ((unsigned __int8)v44 & 7u) > 4 )
          {
            v45 = sub_2C76A00(a1, v8, 0);
            v46 = sub_904010(v45, "rounding mode not a valid value");
            a2 = (__int64)"\n";
            sub_904010(v46, "\n");
            sub_2C76240(a1, (__int64)"\n", v47, v48);
          }
          if ( ((unsigned int)v44 & 0xFFFFFC00) == 0 )
            goto LABEL_65;
          goto LABEL_191;
        }
        v118 = sub_CEA310(v33);
        if ( v118 )
        {
          v119 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v119 == 17 )
          {
            v120 = *(_QWORD **)(v119 + 24);
            if ( *(_DWORD *)(v119 + 32) > 0x40u )
              v120 = (_QWORD *)*v120;
            v121 = (unsigned int)v120;
            v122 = (unsigned int)v120;
            if ( ((unsigned __int8)v120 & 0x1C) == 0 || (((unsigned int)v120 >> 2) & 7) > 4 )
            {
              v159 = sub_2C76A00(a1, v8, 0);
              v160 = sub_904010(v159, "rounding mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v160, "\n");
              sub_2C76240(a1, (__int64)"\n", v161, v162);
            }
            if ( ((v122 >> 7) & 7) > 2 )
            {
              v485 = sub_2C76A00(a1, v8, 0);
              v486 = sub_904010(v485, "src subword mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v486, "\n");
              sub_2C76240(a1, (__int64)"\n", v487, v488);
            }
            if ( ((v122 >> 10) & 7) > 2 )
            {
              v481 = sub_2C76A00(a1, v8, 0);
              v482 = sub_904010(v481, "dest subword mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v482, "\n");
              sub_2C76240(a1, (__int64)"\n", v483, v484);
            }
            if ( HIBYTE(v121) )
            {
LABEL_191:
              v123 = "reserved flag bits used";
              v124 = sub_2C76A00(a1, v8, 0);
LABEL_192:
              v125 = sub_904010(v124, v123);
              a2 = (__int64)"\n";
              sub_904010(v125, "\n");
              goto LABEL_193;
            }
LABEL_65:
            if ( v33 == 241 )
              goto LABEL_194;
LABEL_66:
            if ( v33 != 238 )
              goto LABEL_67;
LABEL_194:
            v128 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
            if ( *(_BYTE *)(v128 + 8) == 14 )
            {
              if ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL) + 8LL) == 14 )
              {
                if ( *(_DWORD *)(v128 + 8) >> 8 != 4 )
                  goto LABEL_5;
                v129 = "memmove/memcpy cannot target constant address space";
                v130 = sub_2C76A00(a1, v8, 0);
              }
              else
              {
                v129 = "memmove/memcpy operand 1 not a pointer?";
                v130 = sub_2C76A00(a1, v8, 0);
              }
            }
            else
            {
              v129 = "memmove/memcpy operand 0 not a pointer?";
              v130 = sub_2C76A00(a1, v8, 0);
            }
            goto LABEL_196;
          }
          goto LABEL_248;
        }
        if ( sub_CEA3C0(v33) )
        {
          v148 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v148 == 17 )
          {
            v149 = *(_QWORD *)(v148 + 24);
            if ( *(_DWORD *)(v148 + 32) > 0x40u )
              v149 = **(_QWORD **)(v148 + 24);
            v150 = WORD1(v149);
            v151 = v149;
            if ( ((unsigned __int8)v149 & 0xFu) > 8 )
            {
              v965 = v149;
              v971 = v149;
              v569 = sub_2C76A00(a1, v8, 0);
              v570 = sub_904010(v569, "dimensionality not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v570, "\n");
              sub_2C76240(a1, (__int64)"\n", v571, v572);
              v151 = v965;
              LOBYTE(v149) = v971;
            }
            v152 = v149;
            if ( (v149 & 0xF) == 6 )
            {
              v966 = v151;
              v974 = v149;
              v654 = sub_2C76A00(a1, v8, 0);
              v655 = sub_904010(v654, "dimensionality not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v655, "\n");
              sub_2C76240(a1, (__int64)"\n", v656, v657);
              v151 = v966;
              v152 = v974;
            }
            if ( (v152 & 0x30) == 0x30 )
            {
              v973 = v151;
              v650 = sub_2C76A00(a1, v8, 0);
              v651 = sub_904010(v650, "LOD Adjust mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v651, "\n");
              sub_2C76240(a1, (__int64)"\n", v652, v653);
              v151 = v973;
            }
            if ( ((v151 >> 10) & 7) > 2 )
            {
              v565 = sub_2C76A00(a1, v8, 0);
              v566 = sub_904010(v565, "Binding Mode is not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v566, "\n");
              sub_2C76240(a1, (__int64)"\n", v567, v568);
            }
            if ( (v150 & 0xFFE0) == 0 )
            {
LABEL_223:
              if ( v33 - 10490 <= 1 )
                goto LABEL_68;
              v153 = *(_QWORD *)(v8 + 8);
              if ( *(_BYTE *)(v153 + 8) != 15 )
                goto LABEL_225;
              if ( *(_DWORD *)(v153 + 12) == 2 )
              {
                v674 = *(__int64 **)(v153 + 16);
                v675 = v674[1];
                v153 = *v674;
                if ( *(_BYTE *)(v675 + 8) == 12 )
                {
                  v977 = sub_BCAE30(v675);
                  v978 = v834;
                  if ( sub_CA1930(&v977) == 1 )
                    goto LABEL_225;
                }
                v560 = "type not i1";
                v561 = sub_2C76A00(a1, v8, 0);
              }
              else
              {
                v560 = "not struct of 2 elements";
                v561 = sub_2C76A00(a1, v8, 0);
              }
              v562 = sub_904010(v561, v560);
              a2 = (__int64)"\n";
              sub_904010(v562, "\n");
              sub_2C76240(a1, (__int64)"\n", v563, v564);
LABEL_225:
              if ( *(int *)(a1 + 8) > 1199 )
                v118 = !sub_CEA3F0(v33);
              if ( (unsigned int)*(unsigned __int8 *)(v153 + 8) - 17 > 1 )
              {
                v123 = "type not a vector";
                v124 = sub_2C76A00(a1, v8, 0);
                goto LABEL_192;
              }
              if ( *(_DWORD *)(v153 + 32) != 4 )
              {
                v154 = sub_2C76A00(a1, v8, 0);
                v155 = sub_904010(v154, "type not v4");
                a2 = (__int64)"\n";
                sub_904010(v155, "\n");
                sub_2C76240(a1, (__int64)"\n", v156, v157);
              }
              v158 = *(_QWORD *)(v153 + 24);
              if ( (*(_BYTE *)(v158 + 8) & 0xFD) != 0 )
              {
                a2 = 32;
                if ( !sub_BCAC40(v158, 32) )
                {
                  a2 = 16;
                  if ( !sub_BCAC40(v158, 16) || !v118 )
                  {
                    if ( v33 - 10492 <= 3 )
                    {
                      a2 = 64;
                      if ( sub_BCAC40(v158, 64) )
                      {
LABEL_67:
                        if ( v33 == 243 )
                        {
                          v163 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
                          if ( *(_BYTE *)(v163 + 8) == 14 )
                          {
                            if ( *(_DWORD *)(v163 + 8) >> 8 != 4 )
                              goto LABEL_5;
                            v129 = "memset cannot point to constant address space";
                            v130 = sub_2C76A00(a1, v8, 0);
                          }
                          else
                          {
                            v129 = "memset operand 0 not a pointer?";
                            v130 = sub_2C76A00(a1, v8, 0);
                          }
                          goto LABEL_196;
                        }
LABEL_68:
                        if ( v33 == 15 )
                        {
                          v168 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
                          if ( *(_BYTE *)(v168 + 8) == 12 )
                          {
                            v977 = sub_BCAE30(v168);
                            v978 = v489;
                            v490 = sub_CA1930(&v977) - 16;
                            if ( v490 > 0x30 || (v491 = 0x1000000010001LL, !_bittest64(&v491, v490)) )
                            {
                              v492 = sub_2C76A00(a1, v8, 0);
                              sub_904010(v492, "Invalid type for bswap, need i16, i32, or i64\n");
                              sub_2C76240(a1, (__int64)"Invalid type for bswap, need i16, i32, or i64\n", v493, v494);
                            }
                            goto LABEL_5;
                          }
                          v129 = "bswap operand 0 not an integer?";
                          v130 = sub_2C76A00(a1, v8, 0);
                          goto LABEL_196;
                        }
LABEL_69:
                        if ( v33 - 65 <= 2 )
                        {
                          v49 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
                          v50 = *(_BYTE *)(v49 + 8);
                          if ( v50 == 17 )
                          {
                            v49 = *(_QWORD *)(v49 + 24);
                            v50 = *(_BYTE *)(v49 + 8);
                          }
                          if ( v50 != 12
                            || (v977 = sub_BCAE30(v49), v978 = v501, v502 = sub_CA1930(&v977) - 8, v502 > 0x38)
                            || (v503 = 0x100000001000101LL, !_bittest64(&v503, v502)) )
                          {
                            v51 = sub_2C76A00(a1, v8, 0);
                            v52 = sub_904010(v51, "Invalid type for ctpop/ctlz/cttz, need i8, i16, i32, ");
                            sub_904010(v52, "i64, or vector of these\n");
                            sub_2C76240(a1, (__int64)"i64, or vector of these\n", v53, v54);
                          }
                          goto LABEL_5;
                        }
                        switch ( v33 )
                        {
                          case 0x2277u:
                            v495 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
                            v496 = *(_QWORD *)(v495 + 8);
                            if ( (unsigned int)*(unsigned __int8 *)(v496 + 8) - 17 <= 1 )
                              v496 = **(_QWORD **)(v496 + 16);
                            if ( *(_DWORD *)(v496 + 8) >> 8 != 4 )
                            {
                              v497 = sub_2C76A00(a1, v8, 0);
                              v498 = sub_904010(v497, "Operand must be in constant address space");
                              a2 = (__int64)"\n";
                              sub_904010(v498, "\n");
                              sub_2C76240(a1, (__int64)"\n", v499, v500);
                            }
                            if ( *sub_BD3990((unsigned __int8 *)v495, a2) == 3 )
                              goto LABEL_5;
                            v129 = "Operand must be a global variable or a bitcast from a global variable";
                            v130 = sub_2C76A00(a1, v8, 0);
                            goto LABEL_196;
                          case 0x2360u:
                          case 0x2363u:
                            v259 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
                            v260 = *(_QWORD *)(v8 - 32 * v259);
                            if ( *(_BYTE *)v260 == 17 )
                            {
                              v261 = *(_QWORD **)(v260 + 24);
                              if ( *(_DWORD *)(v260 + 32) > 0x40u )
                                v261 = (_QWORD *)*v261;
                              if ( ((unsigned int)v261 & 0xFFFFFFFE) != 0 )
                              {
                                v608 = sub_2C76A00(a1, v8, 0);
                                v609 = sub_904010(v608, "reserved bits used");
                                sub_904010(v609, "\n");
                                sub_2C76240(a1, (__int64)"\n", v610, v611);
                                v259 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
                              }
                              v262 = *(_QWORD *)(v8 + 32 * (3 - v259));
                              if ( *(_BYTE *)v262 != 17 )
                              {
                                v262 = 0;
                                v263 = sub_2C76A00(a1, v8, 0);
                                v264 = sub_904010(v263, "Byte size is not constant");
                                sub_904010(v264, "\n");
                                sub_2C76240(a1, (__int64)"\n", v265, v266);
                                v259 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
                              }
                              v267 = *(_QWORD *)(v8 + 32 * (4 - v259));
                              if ( *(_BYTE *)v267 != 17 )
                              {
                                v268 = sub_2C76A00(a1, v8, 0);
                                v269 = sub_904010(v268, "Source size is not constant");
                                sub_904010(v269, "\n");
                                sub_2C76240(a1, (__int64)"\n", v270, v271);
                                v267 = 0;
                              }
                              v272 = *(_QWORD **)(v262 + 24);
                              if ( *(_DWORD *)(v262 + 32) > 0x40u )
                                v272 = (_QWORD *)*v272;
                              if ( *(_DWORD *)(v267 + 32) <= 0x40u )
                                v273 = *(_QWORD *)(v267 + 24);
                              else
                                v273 = **(_QWORD **)(v267 + 24);
                              if ( v273 <= (unsigned __int64)v272 )
                              {
                                v612 = sub_2C76A00(a1, v8, 0);
                                v613 = sub_904010(v612, "Byte size must be less than or equal to source size");
                                sub_904010(v613, "\n");
                                sub_2C76240(a1, (__int64)"\n", v614, v615);
                              }
                              v274 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
                              v275 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1 - v274)) + 8LL);
                              if ( (unsigned int)*(unsigned __int8 *)(v275 + 8) - 17 <= 1 )
                                v275 = **(_QWORD **)(v275 + 16);
                              v276 = *(_DWORD *)(v275 + 8) >> 8;
                              v277 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (2 - v274)) + 8LL);
                              if ( (unsigned int)*(unsigned __int8 *)(v277 + 8) - 17 <= 1 )
                                v277 = **(_QWORD **)(v277 + 16);
                              v278 = *(_DWORD *)(v277 + 8) >> 8;
                              if ( v276 != 3 )
                              {
                                v279 = sub_2C76A00(a1, v8, 0);
                                v280 = sub_904010(v279, "Destination must be in shared memory space");
                                sub_904010(v280, "\n");
                                sub_2C76240(a1, (__int64)"\n", v281, v282);
                              }
                              if ( v278 == 1 )
                                goto LABEL_5;
                              v129 = "Source must be in global memory space";
                              v130 = sub_2C76A00(a1, v8, 0);
                              goto LABEL_196;
                            }
                            break;
                          case 0x2362u:
                            v605 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
                            if ( *(_BYTE *)v605 == 17 )
                            {
                              v606 = *(_QWORD **)(v605 + 24);
                              if ( *(_DWORD *)(v605 + 32) > 0x40u )
                                v606 = (_QWORD *)*v606;
                              v607 = (char)v606;
                              if ( ((unsigned int)v606 & 0xFFFFFFF0) != 0 )
                              {
                                v813 = sub_2C76A00(a1, v8, 0);
                                v814 = sub_904010(v813, "reserved bits used");
                                sub_904010(v814, "\n");
                                sub_2C76240(a1, (__int64)"\n", v815, v816);
                              }
                              if ( (v607 & 0xFu) <= 2 )
                                goto LABEL_5;
                              v129 = "Invalid wait mode";
                              v130 = sub_2C76A00(a1, v8, 0);
                              goto LABEL_196;
                            }
                            break;
                          case 0x2361u:
                            v665 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
                            if ( (unsigned int)*(unsigned __int8 *)(v665 + 8) - 17 <= 1 )
                              v665 = **(_QWORD **)(v665 + 16);
                            if ( *(_DWORD *)(v665 + 8) >> 8 == 3 )
                              goto LABEL_5;
                            v129 = "Barrier pointer must be in shared memory space";
                            v130 = sub_2C76A00(a1, v8, 0);
LABEL_196:
                            v131 = sub_904010(v130, v129);
                            sub_904010(v131, "\n");
                            sub_2C76240(a1, (__int64)"\n", v132, v133);
                            goto LABEL_5;
                          default:
                            goto LABEL_256;
                        }
LABEL_941:
                        v2 = "Mode operand is not constant";
                        v3 = sub_2C76A00(a1, v8, 0);
LABEL_940:
                        v4 = sub_904010(v3, v2);
                        sub_904010(v4, "\n");
                        sub_2C76240(a1, (__int64)"\n", v5, v6);
                        BUG();
                      }
                    }
                    v123 = "texture element type not legal";
                    v124 = sub_2C76A00(a1, v8, 0);
                    goto LABEL_192;
                  }
                }
              }
              goto LABEL_65;
            }
            v230 = "reserved flag bits used";
            v231 = sub_2C76A00(a1, v8, 0);
          }
          else
          {
            v230 = "op0 of intrinsic not constant";
            v231 = sub_2C76A00(a1, v8, 0);
          }
          v232 = sub_904010(v231, v230);
          a2 = (__int64)"\n";
          sub_904010(v232, "\n");
          sub_2C76240(a1, (__int64)"\n", v233, v234);
          goto LABEL_223;
        }
        if ( sub_CEA400(v33) )
        {
          v504 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v504 == 17 )
          {
            v505 = *(_QWORD *)(v504 + 24);
            if ( *(_DWORD *)(v504 + 32) > 0x40u )
              v505 = **(_QWORD **)(v504 + 24);
            if ( (v505 & 0xF) > 8 )
            {
              v738 = sub_2C76A00(a1, v8, 0);
              v739 = sub_904010(v738, "dimensionality not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v739, "\n");
              sub_2C76240(a1, (__int64)"\n", v740, v741);
            }
            if ( (v505 & 0x30) == 0x30 )
            {
              v843 = sub_2C76A00(a1, v8, 0);
              v844 = sub_904010(v843, "border mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v844, "\n");
              sub_2C76240(a1, (__int64)"\n", v845, v846);
            }
            if ( (v505 & 0x180) == 0x180 )
            {
              v839 = sub_2C76A00(a1, v8, 0);
              v840 = sub_904010(v839, "address mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v840, "\n");
              sub_2C76240(a1, (__int64)"\n", v841, v842);
            }
            if ( ((v505 >> 20) & 7) > 2 )
            {
              v734 = sub_2C76A00(a1, v8, 0);
              v735 = sub_904010(v734, "address mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v735, "\n");
              sub_2C76240(a1, (__int64)"\n", v736, v737);
            }
            if ( ((v505 >> 31) & 0xF) > 2 )
            {
              v746 = sub_2C76A00(a1, v8, 0);
              v747 = sub_904010(v746, "scope not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v747, "\n");
              sub_2C76240(a1, (__int64)"\n", v748, v749);
            }
            if ( ((v505 >> 27) & 0xF) > 6 )
            {
              v742 = sub_2C76A00(a1, v8, 0);
              v743 = sub_904010(v742, "semantic mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v743, "\n");
              sub_2C76240(a1, (__int64)"\n", v744, v745);
            }
            if ( (v505 & 0xC000000000LL) != 0 )
            {
              v777 = sub_2C76A00(a1, v8, 0);
              v778 = sub_904010(v777, "query mode is not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v778, "\n");
              sub_2C76240(a1, (__int64)"\n", v779, v780);
            }
            if ( (v505 & 0xFFFFE00000000000LL) != 0 )
              goto LABEL_191;
            goto LABEL_65;
          }
LABEL_248:
          v123 = "op0 of intrinsic not constant";
          v124 = sub_2C76A00(a1, v8, 0);
          goto LABEL_192;
        }
        if ( sub_CEA440(v33) )
        {
          v616 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v616 == 17 )
          {
            v617 = *(_QWORD **)(v616 + 24);
            if ( *(_DWORD *)(v616 + 32) > 0x40u )
              v617 = (_QWORD *)*v617;
            if ( ((unsigned __int8)v617 & 0xFu) > 8 )
            {
              v882 = sub_2C76A00(a1, v8, 0);
              v883 = sub_904010(v882, "dimensionality not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v883, "\n");
              sub_2C76240(a1, (__int64)"\n", v884, v885);
            }
            if ( (unsigned __int8)v617 > 0x8Fu )
            {
              v878 = sub_2C76A00(a1, v8, 0);
              v879 = sub_904010(v878, "query mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v879, "\n");
              sub_2C76240(a1, (__int64)"\n", v880, v881);
            }
            if ( (((unsigned int)v617 >> 9) & 7) > 2 )
            {
              v874 = sub_2C76A00(a1, v8, 0);
              v875 = sub_904010(v874, "Binding Mode is not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v875, "\n");
              sub_2C76240(a1, (__int64)"\n", v876, v877);
            }
            if ( ((unsigned int)v617 & 0xFFFFE000) != 0 )
              goto LABEL_191;
            goto LABEL_65;
          }
          goto LABEL_248;
        }
        if ( sub_CEA230(v33) )
        {
          v793 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v793 == 17 )
          {
            v794 = *(_QWORD **)(v793 + 24);
            if ( *(_DWORD *)(v793 + 32) > 0x40u )
              v794 = (_QWORD *)*v794;
            v795 = WORD1(v794);
            v796 = (unsigned __int16)v794;
            if ( ((unsigned __int8)v794 & 0xFu) > 6 )
            {
              v931 = sub_2C76A00(a1, v8, 0);
              v932 = sub_904010(v931, "ordering mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v932, "\n");
              sub_2C76240(a1, (__int64)"\n", v933, v934);
            }
            if ( (unsigned __int8)v796 > 0x2Fu )
            {
              v927 = sub_2C76A00(a1, v8, 0);
              v928 = sub_904010(v927, "scope mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v928, "\n");
              sub_2C76240(a1, (__int64)"\n", v929, v930);
            }
            if ( (unsigned __int8)(v796 >> 12) > 6u )
            {
              v923 = sub_2C76A00(a1, v8, 0);
              v924 = sub_904010(v923, "Cache operation hint not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v924, "\n");
              sub_2C76240(a1, (__int64)"\n", v925, v926);
            }
            if ( (unsigned __int8)v795 > 0x10u || (_BYTE)v795 == 4 )
            {
              v901 = sub_2C76A00(a1, v8, 0);
              v902 = sub_904010(v901, "operation mode not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v902, "\n");
              sub_2C76240(a1, (__int64)"\n", v903, v904);
            }
            if ( (v795 & 0xF800u) != 0 )
              goto LABEL_191;
            goto LABEL_65;
          }
          goto LABEL_248;
        }
        if ( v33 != 8821 )
        {
          if ( v33 != 8975 && v33 != 9567 )
          {
            if ( v33 == 9279 || v33 == 11197 )
            {
              v864 = *(_DWORD *)(v8 + 4);
              v865 = *(_QWORD *)(v8 - 32LL * (v864 & 0x7FFFFFF));
              if ( *(_BYTE *)v865 != 17 )
              {
                v865 = 0;
                v866 = sub_2C76A00(a1, v8, 0);
                v867 = sub_904010(v866, "Mode operand is not constant");
                a2 = (__int64)"\n";
                sub_904010(v867, "\n");
                sub_2C76240(a1, (__int64)"\n", v868, v869);
                v864 = *(_DWORD *)(v8 + 4);
              }
              v870 = *(_QWORD *)(v8 + 32 * (1LL - (v864 & 0x7FFFFFF)));
              if ( *(_BYTE *)v870 != 17 )
              {
                v2 = "Attribute is not constant";
                v3 = sub_2C76A00(a1, v8, 0);
                goto LABEL_940;
              }
              v871 = *(_QWORD **)(v870 + 24);
              if ( *(_DWORD *)(v870 + 32) > 0x40u )
                v871 = (_QWORD *)*v871;
              if ( (unsigned int)v871 > 0x45 )
              {
                v939 = sub_2C76A00(a1, v8, 0);
                v940 = sub_904010(v939, "Attribute out of range");
                a2 = (__int64)"\n";
                sub_904010(v940, "\n");
                sub_2C76240(a1, (__int64)"\n", v941, v942);
              }
              v872 = *(_DWORD *)(v865 + 32);
              v873 = *(_QWORD **)(v865 + 24);
              if ( v33 == 9279 )
              {
                if ( v872 > 0x40 )
                  v873 = (_QWORD *)*v873;
                if ( ((unsigned int)v873 & 0xFFFFFFF0) != 0 )
                {
                  v935 = sub_2C76A00(a1, v8, 0);
                  v936 = sub_904010(v935, "reserved flag bits used");
                  a2 = (__int64)"\n";
                  sub_904010(v936, "\n");
                  sub_2C76240(a1, (__int64)"\n", v937, v938);
                }
                goto LABEL_69;
              }
              if ( v872 > 0x40 )
                v873 = (_QWORD *)*v873;
              if ( (_DWORD)v873 )
                goto LABEL_191;
            }
            goto LABEL_65;
          }
          v895 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v895 == 17 )
          {
            v896 = *(_QWORD **)(v895 + 24);
            if ( *(_DWORD *)(v895 + 32) > 0x40u )
              v896 = (_QWORD *)*v896;
            if ( (WORD1(v896) & 0xFFF0) != 0 )
            {
              v911 = sub_2C76A00(a1, v8, 0);
              v912 = sub_904010(v911, "reserved flag bits used");
              a2 = (__int64)"\n";
              sub_904010(v912, "\n");
              sub_2C76240(a1, (__int64)"\n", v913, v914);
            }
            if ( v33 == 8975 )
              goto LABEL_69;
            if ( ((unsigned __int8)v896 & 1) != 0 )
            {
              v123 = "Use Texture Domain flag not allowed on stores";
              v124 = sub_2C76A00(a1, v8, 0);
              goto LABEL_192;
            }
            goto LABEL_65;
          }
          goto LABEL_248;
        }
        v886 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
        if ( *(_BYTE *)v886 != 17 )
        {
          v890 = "op0 of intrinsic not constant";
          v891 = sub_2C76A00(a1, v8, 0);
          goto LABEL_908;
        }
        v887 = *(_QWORD **)(v886 + 24);
        if ( *(_DWORD *)(v886 + 32) > 0x40u )
          v887 = (_QWORD *)*v887;
        if ( ((unsigned __int8)v887 & 3) == 3 )
        {
          v919 = sub_2C76A00(a1, v8, 0);
          v920 = sub_904010(v919, "geometry out mode not a valid value");
          sub_904010(v920, "\n");
          sub_2C76240(a1, (__int64)"\n", v921, v922);
        }
        if ( ((unsigned int)v887 & 0xFFFFFFFC) != 0 )
        {
          v915 = sub_2C76A00(a1, v8, 0);
          v916 = sub_904010(v915, "reserved flag bits used");
          sub_904010(v916, "\n");
          sub_2C76240(a1, (__int64)"\n", v917, v918);
        }
        if ( ((unsigned __int8)v887 & 3) == 1 )
        {
          v888 = *(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)));
          if ( *(_BYTE *)v888 != 17 )
          {
            v890 = "op1 of GeometryOut intrinsic must be constant when CUT mode";
            v891 = sub_2C76A00(a1, v8, 0);
            goto LABEL_908;
          }
          v889 = *(_QWORD **)(v888 + 24);
          if ( *(_DWORD *)(v888 + 32) > 0x40u )
            v889 = (_QWORD *)*v889;
          if ( v889 )
          {
            v890 = "op1 of GeometryOut intrinsic must be 0 when CUT mode";
            v891 = sub_2C76A00(a1, v8, 0);
LABEL_908:
            v892 = sub_904010(v891, v890);
            sub_904010(v892, "\n");
            sub_2C76240(a1, (__int64)"\n", v893, v894);
          }
        }
LABEL_256:
        if ( v33 - 9383 > 1 )
        {
          if ( v33 - 8282 > 1 )
          {
            if ( v33 == 9556 )
            {
              v863 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v863 + 8) - 17 <= 1 )
                v863 = **(_QWORD **)(v863 + 16);
              if ( *(_DWORD *)(v863 + 8) >> 8 == 5 )
                goto LABEL_5;
              v129 = "llvm.nvvm.stackrestore is only supported with local address space pointers";
              v130 = sub_2C76A00(a1, v8, 0);
            }
            else if ( v33 == 9557 )
            {
              v910 = *(_QWORD *)(v8 + 8);
              if ( (unsigned int)*(unsigned __int8 *)(v910 + 8) - 17 <= 1 )
                v910 = **(_QWORD **)(v910 + 16);
              if ( *(_DWORD *)(v910 + 8) >> 8 == 5 )
                goto LABEL_5;
              v129 = "llvm.nvvm.stacksave is only supported with local address space pointers";
              v130 = sub_2C76A00(a1, v8, 0);
            }
            else
            {
              if ( v33 != 8306 || **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) == 17 )
                goto LABEL_5;
              v129 = "llvm.nvvm.coro.create.suspend must have exactly one argument, which must be a constant integer";
              v130 = sub_2C76A00(a1, v8, 0);
            }
            goto LABEL_196;
          }
          v805 = *(_DWORD *)(a1 + 8);
          if ( !v805 )
            goto LABEL_845;
          if ( v33 == 8282 )
          {
            if ( v805 > 699 )
              goto LABEL_845;
            v905 = "llvm.nvvm.branch.if.all.convergent is not supported on pre-Volta Architectures";
            v906 = sub_2C76A00(a1, v8, 0);
          }
          else
          {
            if ( v805 > 799 )
              goto LABEL_845;
            v905 = "llvm.nvvm.branch.if.convergent is not supported on pre-Ampere Architectures";
            v906 = sub_2C76A00(a1, v8, 0);
          }
          v907 = sub_904010(v906, v905);
          sub_904010(v907, "\n");
          sub_2C76240(a1, (__int64)"\n", v908, v909);
LABEL_845:
          v806 = *(_QWORD *)(v8 + 16);
          if ( v806 )
          {
            v807 = 0;
            do
            {
              v808 = *(_BYTE **)(v806 + 24);
              v806 = *(_QWORD *)(v806 + 8);
              if ( *v808 != 31 )
                v808 = 0;
              ++v807;
            }
            while ( v806 );
            if ( v808 && v807 == 1 )
              goto LABEL_5;
          }
          v129 = "result of llvm.nvvm.branch.if.convergent and llvm.nvvm.branch.if.all.convergent can only be used by exa"
                 "ctly one branch instruction";
          v130 = sub_2C76A00(a1, v8, 0);
          goto LABEL_196;
        }
        v697 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
        if ( *(_BYTE *)v697 == 17 )
        {
          v698 = *(_QWORD **)(v697 + 24);
          if ( *(_DWORD *)(v697 + 32) > 0x40u )
            v698 = (_QWORD *)*v698;
          v699 = (unsigned int)v698;
          if ( ((unsigned int)v698 & 0xFFFFFFF0) != 0 )
          {
            v855 = sub_2C76A00(a1, v8, 0);
            v856 = sub_904010(v855, "reserved bits used");
            sub_904010(v856, "\n");
            sub_2C76240(a1, (__int64)"\n", v857, v858);
          }
          if ( ((v699 >> 1) & 7) <= 5 )
            goto LABEL_5;
          v129 = "Invalid subop mode";
          v130 = sub_2C76A00(a1, v8, 0);
          goto LABEL_196;
        }
        goto LABEL_941;
      }
      switch ( v33 )
      {
        case 0x2107u:
          v506 = *(_DWORD *)(a1 + 8);
          if ( v506 && v506 <= 889 )
          {
            v789 = sub_2C76A00(a1, v8, 0);
            v790 = sub_904010(v789, "this instrinsic is only supported for Ada (sm_89)+");
            a2 = (__int64)"\n";
            sub_904010(v790, "\n");
            sub_2C76240(a1, (__int64)"\n", v791, v792);
          }
          v507 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v507 == 17 )
          {
            v508 = *(_QWORD *)(v507 + 24);
            if ( *(_DWORD *)(v507 + 32) > 0x40u )
              v508 = *(_QWORD *)v508;
            v509 = v508 & 0xF;
            if ( (v508 & 0xF) > 0xC || !v509 )
            {
              v510 = sub_2C76A00(a1, v8, 0);
              v511 = sub_904010(v510, "Invalid dst type");
              a2 = (__int64)"\n";
              sub_904010(v511, "\n");
              sub_2C76240(a1, (__int64)"\n", v512, v513);
            }
            if ( (unsigned __int8)v508 > 0xCFu )
            {
              v726 = sub_2C76A00(a1, v8, 0);
              v727 = sub_904010(v726, "Invalid src type");
              a2 = (__int64)"\n";
              sub_904010(v727, "\n");
              sub_2C76240(a1, (__int64)"\n", v728, v729);
            }
            if ( v509 == (unsigned __int8)v508 >> 4 )
            {
              v835 = sub_2C76A00(a1, v8, 0);
              v836 = sub_904010(v835, "Src and dst type must be different types");
              a2 = (__int64)"\n";
              sub_904010(v836, "\n");
              sub_2C76240(a1, (__int64)"\n", v837, v838);
            }
            if ( (v508 & 0xE) == 2 && (v508 & 0xE0) == 0x20 )
            {
              v514 = sub_2C76A00(a1, v8, 0);
              v515 = sub_904010(v514, "Src and dst type must be different bit widths");
              a2 = (__int64)"\n";
              sub_904010(v515, "\n");
              sub_2C76240(a1, (__int64)"\n", v516, v517);
            }
            if ( (v508 & 0xFFFFFFFFFFFE0000LL) == 0 )
              goto LABEL_54;
LABEL_643:
            v518 = sub_2C76A00(a1, v8, 0);
            v519 = sub_904010(v518, "reserved flag bits used");
            a2 = (__int64)"\n";
            sub_904010(v519, "\n");
            sub_2C76240(a1, (__int64)"\n", v520, v521);
            goto LABEL_54;
          }
          break;
        case 0x2122u:
LABEL_84:
          if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) != 17 )
          {
            v55 = sub_2C76A00(a1, v8, 0);
            v56 = sub_904010(v55, "the task_id parameter must be constant");
            a2 = (__int64)"\n";
            sub_904010(v56, "\n");
            sub_2C76240(a1, (__int64)"\n", v57, v58);
          }
          goto LABEL_54;
        case 0x2106u:
          v59 = *(_DWORD *)(a1 + 8);
          if ( v59 && v59 <= 719 )
          {
            v307 = sub_2C76A00(a1, v8, 0);
            v308 = sub_904010(v307, "this instrinsic is only supported for Volta (sm_72)+");
            a2 = (__int64)"\n";
            sub_904010(v308, "\n");
            sub_2C76240(a1, (__int64)"\n", v309, v310);
          }
          v60 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v60 == 17 )
          {
            v61 = *(_QWORD **)(v60 + 24);
            if ( *(_DWORD *)(v60 + 32) > 0x40u )
              v61 = (_QWORD *)*v61;
            v62 = ((unsigned int)v61 >> 1) & 7;
            if ( ((unsigned __int8)v61 & 0xE) == 0 || (unsigned __int8)v62 > 4u )
            {
              v63 = sub_2C76A00(a1, v8, 0);
              v64 = sub_904010(v63, "conversion type not a valid value");
              a2 = (__int64)"\n";
              sub_904010(v64, "\n");
              sub_2C76240(a1, (__int64)"\n", v65, v66);
            }
            if ( (unsigned __int8)v62 > 2u )
            {
              v67 = *(_DWORD *)(a1 + 8);
              if ( v67 )
              {
                if ( v67 <= 749 )
                {
                  v897 = sub_2C76A00(a1, v8, 0);
                  v898 = sub_904010(v897, "conversion type only supported for Turing (sm_75)+");
                  a2 = (__int64)"\n";
                  sub_904010(v898, "\n");
                  sub_2C76240(a1, (__int64)"\n", v899, v900);
                }
              }
            }
            if ( ((unsigned int)v61 & 0xFFFFFFF0) == 0 )
              goto LABEL_54;
            goto LABEL_643;
          }
          break;
        default:
          goto LABEL_54;
      }
LABEL_756:
      v636 = sub_2C76A00(a1, v8, 0);
      v637 = sub_904010(v636, "op0 of intrinsic not constant");
      a2 = (__int64)"\n";
      sub_904010(v637, "\n");
      sub_2C76240(a1, (__int64)"\n", v638, v639);
      goto LABEL_54;
    }
    if ( v33 != 10078 )
    {
      if ( v33 > 0x275E )
      {
        if ( v33 == 11201 )
        {
          v522 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
          if ( *(_BYTE *)v522 == 17 )
          {
            v523 = *(_QWORD **)(v522 + 24);
            if ( *(_DWORD *)(v522 + 32) > 0x40u )
              v523 = (_QWORD *)*v523;
            v524 = (char)v523;
            v525 = (unsigned __int8)v523 & 6;
            if ( v525 && (_BYTE)v525 != 6 )
            {
              v526 = sub_2C76A00(a1, v8, 0);
              v527 = sub_904010(v526, "Only writes to MAP or ATTR are supported");
              a2 = (__int64)"\n";
              sub_904010(v527, "\n");
              sub_2C76240(a1, (__int64)"\n", v528, v529);
            }
            if ( (v524 & 1) != 0 )
            {
              v530 = sub_2C76A00(a1, v8, 0);
              v531 = sub_904010(v530, "Cannot write to input ISBE");
              a2 = (__int64)"\n";
              sub_904010(v531, "\n");
              sub_2C76240(a1, (__int64)"\n", v532, v533);
            }
          }
          else
          {
LABEL_345:
            v253 = sub_2C76A00(a1, v8, 0);
            v254 = sub_904010(v253, "Mode operand must be constant");
            a2 = (__int64)"\n";
            sub_904010(v254, "\n");
            sub_2C76240(a1, (__int64)"\n", v255, v256);
          }
          goto LABEL_54;
        }
        if ( v33 > 0x2BC1 )
        {
          if ( v33 != 11206 )
          {
            if ( v33 == 11209 )
            {
              a2 = 32;
              if ( !sub_BCAC40(*(_QWORD *)(*(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL), 32) )
              {
                v424 = sub_2C76A00(a1, v8, 0);
                v425 = sub_904010(v424, "Data type must be i32");
                a2 = (__int64)"\n";
                sub_904010(v425, "\n");
                sub_2C76240(a1, (__int64)"\n", v426, v427);
              }
              if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) == 17 )
                goto LABEL_54;
              goto LABEL_112;
            }
            if ( v33 != 11205 )
              goto LABEL_54;
            v78 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
            v79 = *(_QWORD *)(v8 - 32 * v78);
            if ( *(_BYTE *)v79 == 17 )
            {
              v80 = *(_QWORD **)(v79 + 24);
              if ( *(_DWORD *)(v79 + 32) > 0x40u )
                v80 = (_QWORD *)*v80;
              if ( (unsigned __int64)v80 <= 7 )
              {
LABEL_129:
                v81 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1 - v78)) + 8LL);
                v82 = *(unsigned __int8 *)(v81 + 8);
                a2 = (unsigned int)(v82 - 17);
                if ( (unsigned int)a2 > 1 )
                {
                  if ( (_BYTE)v82 == 2 )
                    goto LABEL_54;
                }
                else
                {
                  v83 = **(_QWORD **)(v81 + 16);
                  if ( *(_BYTE *)(v83 + 8) == 2 )
                    goto LABEL_54;
                  if ( v82 == 18 )
                    goto LABEL_132;
                }
                if ( v82 != 17 )
                {
LABEL_133:
                  a2 = 32;
                  if ( !sub_BCAC40(v81, 32) )
                  {
                    v84 = sub_2C76A00(a1, v8, 0);
                    v85 = sub_904010(v84, "op1 of intrinsic not containing f32 or i32 element\n");
                    a2 = (__int64)"\n";
                    sub_904010(v85, "\n");
                    sub_2C76240(a1, (__int64)"\n", v86, v87);
                  }
                  goto LABEL_54;
                }
                v83 = **(_QWORD **)(v81 + 16);
LABEL_132:
                v81 = v83;
                goto LABEL_133;
              }
              v320 = "op0 not between 0 and 7\n";
              v321 = sub_2C76A00(a1, v8, 0);
            }
            else
            {
              v320 = "op0 of intrinsic not constant\n";
              v321 = sub_2C76A00(a1, v8, 0);
            }
            v322 = sub_904010(v321, v320);
            sub_904010(v322, "\n");
            sub_2C76240(a1, (__int64)"\n", v323, v324);
            v78 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
            goto LABEL_129;
          }
          v545 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
          a2 = *(_QWORD *)(v8 - 32 * v545);
          if ( *(_BYTE *)a2 == 17 )
          {
            v618 = *(_QWORD **)(a2 + 24);
            if ( *(_DWORD *)(a2 + 32) > 0x40u )
              v618 = (_QWORD *)*v618;
            if ( (unsigned __int64)v618 <= 7 )
              goto LABEL_670;
            v546 = "op0 not between 0 and 7\n";
            v547 = sub_2C76A00(a1, v8, 0);
          }
          else
          {
            v546 = "op0 of intrinsic not constant\n";
            v547 = sub_2C76A00(a1, v8, 0);
          }
          v548 = sub_904010(v547, v546);
          a2 = (__int64)"\n";
          sub_904010(v548, "\n");
          sub_2C76240(a1, (__int64)"\n", v549, v550);
          v545 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
LABEL_670:
          v551 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (2 - v545)) + 8LL);
          if ( *(_BYTE *)(v551 + 8) != 2 )
          {
            a2 = 32;
            if ( !sub_BCAC40(v551, 32) )
            {
              v552 = sub_2C76A00(a1, v8, 0);
              v553 = sub_904010(v552, "op2 of intrinsic not f32 or i32\n");
              a2 = (__int64)"\n";
              sub_904010(v553, "\n");
              sub_2C76240(a1, (__int64)"\n", v554, v555);
            }
          }
          goto LABEL_54;
        }
        switch ( v33 )
        {
          case 0x2952u:
            v217 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
            if ( *(_BYTE *)v217 != 24 || (v218 = *(unsigned __int8 **)(v217 + 24), (unsigned int)*v218 - 1 > 1) )
            {
              v556 = sub_2C76A00(a1, v8, 0);
              v557 = sub_904010(
                       v556,
                       "Op0 of nvvm.texsurf.handle must be a metadata wrapper around a tex/surf GlobalVariable (e.g. meta"
                       "data i64 addrspace(1)* @tex )");
              sub_904010(v557, "\n");
              sub_2C76240(a1, (__int64)"\n", v558, v559);
              goto LABEL_314;
            }
            v219 = (_BYTE *)*((_QWORD *)v218 + 17);
            if ( *v219 == 3 )
            {
              if ( (unsigned __int8)sub_CE8750(*((_BYTE **)v218 + 17)) || (unsigned __int8)sub_CE87C0(v219) )
              {
LABEL_312:
                v220 = *(_BYTE **)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)));
                if ( *v220 == 3 && v219 == v220 )
                  goto LABEL_54;
LABEL_314:
                v221 = sub_2C76A00(a1, v8, 0);
                v222 = sub_904010(v221, "Op1 must be the same tex/surf GV from Op0");
                a2 = (__int64)"\n";
                sub_904010(v222, "\n");
                sub_2C76240(a1, (__int64)"\n", v223, v224);
                goto LABEL_54;
              }
            }
            else
            {
              v219 = 0;
            }
            v830 = sub_2C76A00(a1, v8, 0);
            v831 = sub_904010(
                     v830,
                     "Op0 of nvvm.texsurf.handle must be a metadata wrapper around a tex/surf GlobalVariable (e.g. metada"
                     "ta i64 addrspace(1)* @tex )");
            a2 = (__int64)"\n";
            sub_904010(v831, "\n");
            sub_2C76240(a1, (__int64)"\n", v832, v833);
            goto LABEL_312;
          case 0x296Du:
            goto LABEL_84;
          case 0x2973u:
          case 0x2975u:
            v170 = *(_QWORD *)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)));
            if ( *(_BYTE *)v170 == 17 )
            {
              v171 = *(_QWORD *)(v170 + 24);
              if ( *(_DWORD *)(v170 + 32) > 0x40u )
                v171 = *(_QWORD *)v171;
              if ( (v171 & 0xFFFFFFFFFFFF000FLL) == 0 )
              {
LABEL_275:
                if ( v33 == 10613 )
                {
                  v645 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (2LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
                  if ( *(_DWORD *)(v645 + 32) != 2 || (a2 = 64, !sub_BCAC40(*(_QWORD *)(v645 + 24), 64)) )
                  {
                    v646 = sub_2C76A00(a1, v8, 0);
                    v647 = sub_904010(v646, "Non-supported store type");
                    a2 = (__int64)"\n";
                    sub_904010(v647, "\n");
                    sub_2C76240(a1, (__int64)"\n", v648, v649);
                  }
                }
                else if ( v33 == 10611 )
                {
                  v177 = *(_QWORD *)(v8 + 8);
                  if ( *(_DWORD *)(v177 + 32) != 2 || (a2 = 64, !sub_BCAC40(*(_QWORD *)(v177 + 24), 64)) )
                  {
                    v178 = sub_2C76A00(a1, v8, 0);
                    v179 = sub_904010(v178, "Non-supported load type");
                    a2 = (__int64)"\n";
                    sub_904010(v179, "\n");
                    sub_2C76240(a1, (__int64)"\n", v180, v181);
                  }
                  if ( **(_BYTE **)(v8 + 32 * (2LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) != 17 )
                  {
                    v182 = sub_2C76A00(a1, v8, 0);
                    v183 = sub_904010(v182, "'close' argument must be constant");
                    a2 = (__int64)"\n";
                    sub_904010(v183, "\n");
                    sub_2C76240(a1, (__int64)"\n", v184, v185);
                  }
                }
                goto LABEL_54;
              }
              v172 = "Offset must be aligned 16 bytes";
              v173 = sub_2C76A00(a1, v8, 0);
            }
            else
            {
              v172 = "Offset must be constant";
              v173 = sub_2C76A00(a1, v8, 0);
            }
            v174 = sub_904010(v173, v172);
            a2 = (__int64)"\n";
            sub_904010(v174, "\n");
            sub_2C76240(a1, (__int64)"\n", v175, v176);
            goto LABEL_275;
          case 0x2974u:
            if ( **(_BYTE **)(v8 + 32 * (1LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) != 17 )
            {
              v225 = sub_2C76A00(a1, v8, 0);
              v226 = sub_904010(v225, "'is_dual' argument must be constant.");
              a2 = (__int64)"\n";
              sub_904010(v226, "\n");
              sub_2C76240(a1, (__int64)"\n", v227, v228);
            }
            goto LABEL_54;
          default:
            goto LABEL_54;
        }
      }
      if ( v33 == 9375 )
      {
        a2 = 32;
        if ( !sub_BCAC40(*(_QWORD *)(v8 + 8), 32) )
        {
          v676 = sub_2C76A00(a1, v8, 0);
          v677 = sub_904010(v676, "Data type must be i32");
          a2 = (__int64)"\n";
          sub_904010(v677, "\n");
          sub_2C76240(a1, (__int64)"\n", v678, v679);
        }
        if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) == 17 )
          goto LABEL_54;
LABEL_112:
        v68 = sub_2C76A00(a1, v8, 0);
        v69 = sub_904010(v68, "Index must be constant");
        a2 = (__int64)"\n";
        sub_904010(v69, "\n");
        sub_2C76240(a1, (__int64)"\n", v70, v71);
        goto LABEL_54;
      }
      if ( v33 > 0x249F )
      {
        if ( v33 != 9554 )
        {
          if ( v33 > 0x2552 )
          {
            if ( v33 > 0x2567 )
            {
              if ( v33 == 10075 )
              {
                v72 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
                if ( *(_BYTE *)v72 == 17 )
                {
                  v73 = *(_QWORD **)(v72 + 24);
                  if ( *(_DWORD *)(v72 + 32) > 0x40u )
                    v73 = (_QWORD *)*v73;
                  if ( (_DWORD)v73 )
                  {
                    v74 = sub_2C76A00(a1, v8, 0);
                    v75 = sub_904010(v74, "syncwarp mode not a valid value");
                    a2 = (__int64)"\n";
                    sub_904010(v75, "\n");
                    sub_2C76240(a1, (__int64)"\n", v76, v77);
                  }
                }
                else
                {
                  v330 = sub_2C76A00(a1, v8, 0);
                  v331 = sub_904010(v330, "the mode parameter must be constant");
                  a2 = (__int64)"\n";
                  sub_904010(v331, "\n");
                  sub_2C76240(a1, (__int64)"\n", v332, v333);
                }
              }
              goto LABEL_54;
            }
            if ( v33 <= 0x255F )
              goto LABEL_54;
LABEL_137:
            v88 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
            v89 = *(_QWORD *)(*(_QWORD *)(v8 - 32 * v88) + 8LL);
            if ( *(_BYTE *)(v89 + 8) == 14 )
            {
              if ( ((*(_DWORD *)(v89 + 8) >> 8) & 0xFFFFFFFD) == 1 )
                goto LABEL_139;
              v325 = "arg0 invalid addrspace";
              v326 = sub_2C76A00(a1, v8, 0);
            }
            else
            {
              v325 = "arg0 of intrinsic not pointer";
              v326 = sub_2C76A00(a1, v8, 0);
            }
            v327 = sub_904010(v326, v325);
            a2 = (__int64)"\n";
            sub_904010(v327, "\n");
            sub_2C76240(a1, (__int64)"\n", v328, v329);
            v88 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
LABEL_139:
            if ( **(_BYTE **)(v8 + 32 * (2 - v88)) != 17 )
            {
              v90 = sub_2C76A00(a1, v8, 0);
              v91 = sub_904010(v90, "arg2 not constant");
              a2 = (__int64)"\n";
              sub_904010(v91, "\n");
              sub_2C76240(a1, (__int64)"\n", v92, v93);
            }
            goto LABEL_54;
          }
          if ( v33 == 9430 )
          {
            v94 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
            if ( *(_BYTE *)v94 == 17 )
            {
              v95 = *(_QWORD **)(v94 + 24);
              if ( *(_DWORD *)(v94 + 32) > 0x40u )
                v95 = (_QWORD *)*v95;
              if ( v95 != (_QWORD *)0xFFFFFFFFLL )
              {
                v96 = sub_2C76A00(a1, v8, 0);
                v97 = sub_904010(v96, "Mask must be 0xFFFFFFFF");
                a2 = (__int64)"\n";
                sub_904010(v97, "\n");
                sub_2C76240(a1, (__int64)"\n", v98, v99);
              }
            }
            else
            {
              v337 = sub_2C76A00(a1, v8, 0);
              v338 = sub_904010(v337, "Mask must be a constant integer");
              a2 = (__int64)"\n";
              sub_904010(v338, "\n");
              sub_2C76240(a1, (__int64)"\n", v339, v340);
            }
            goto LABEL_54;
          }
          if ( v33 <= 0x24D5 )
            goto LABEL_54;
          if ( v33 == 9466 )
          {
LABEL_152:
            if ( (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL) + 8LL) & 0xFD) != 0 )
            {
              v100 = sub_2C76A00(a1, v8, 0);
              v101 = sub_904010(v100, "arg0 must be either half or float");
              a2 = (__int64)"\n";
              sub_904010(v101, "\n");
              sub_2C76240(a1, (__int64)"\n", v102, v103);
            }
            goto LABEL_54;
          }
          if ( v33 != 9549 )
            goto LABEL_54;
        }
LABEL_164:
        v108 = *(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF));
        if ( *(_BYTE *)v108 == 17 )
        {
          v109 = *(_QWORD **)(v108 + 24);
          if ( *(_DWORD *)(v108 + 32) > 0x40u )
            v109 = (_QWORD *)*v109;
          v110 = sub_CE1160((__int64)v109);
          if ( (v110 & 0x400) != 0 )
          {
            v759 = sub_2C76A00(a1, v8, 1u);
            a2 = (__int64)"Bit 10 of mode argument is reserved and should be unset.\n";
            sub_904010(v759, "Bit 10 of mode argument is reserved and should be unset.\n");
          }
          if ( v33 != 8937 )
            goto LABEL_170;
          if ( ((v110 >> 16) & 0xF0) != 0 )
          {
            v754 = *(_QWORD *)(v8 + 8);
            if ( *(_BYTE *)(v754 + 8) != 17
              || *(_DWORD *)(v754 + 32) != 8
              || (a2 = 32, !sub_BCAC40(*(_QWORD *)(v754 + 24), 32)) && *(_BYTE *)(*(_QWORD *)(v754 + 24) + 8LL) != 2 )
            {
              v755 = sub_2C76A00(a1, v8, 0);
              v756 = sub_904010(v755, "COP2 is supported for v8i32 and v8f32 only");
              a2 = (__int64)"\n";
              sub_904010(v756, "\n");
              sub_2C76240(a1, (__int64)"\n", v757, v758);
            }
          }
        }
        else
        {
          v334 = sub_2C76A00(a1, v8, 0);
          a2 = (__int64)"Flag argument must be an immediate.\n";
          sub_904010(v334, "Flag argument must be an immediate.\n");
          sub_2C76240(a1, (__int64)"Flag argument must be an immediate.\n", v335, v336);
        }
        if ( v33 == 8937 )
        {
LABEL_171:
          if ( (unsigned int)**(unsigned __int8 **)(v8 + 32 * ((v33 != 8937) + 2LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)))
             - 12 > 1 )
          {
            v111 = sub_2C76A00(a1, v8, 1u);
            a2 = (__int64)"Desc parameter is deprecated and should be undef.\n";
            sub_904010(v111, "Desc parameter is deprecated and should be undef.\n");
          }
          goto LABEL_54;
        }
LABEL_170:
        if ( v33 != 9549 )
          goto LABEL_54;
        goto LABEL_171;
      }
      if ( v33 == 9236 )
      {
        if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) != 17 )
        {
          v534 = sub_2C76A00(a1, v8, 0);
          v535 = sub_904010(v534, "the mask parameter must be constant");
          a2 = (__int64)"\n";
          sub_904010(v535, "\n");
          sub_2C76240(a1, (__int64)"\n", v536, v537);
        }
        goto LABEL_54;
      }
      if ( v33 > 0x2414 )
      {
        switch ( v33 )
        {
          case 0x2444u:
            if ( **(_BYTE **)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) != 17 )
              goto LABEL_345;
            break;
          case 0x244Du:
          case 0x244Eu:
          case 0x244Fu:
          case 0x2450u:
          case 0x2452u:
          case 0x2453u:
          case 0x2454u:
          case 0x2455u:
          case 0x2457u:
          case 0x2458u:
          case 0x2459u:
          case 0x2487u:
          case 0x2488u:
          case 0x2489u:
LABEL_266:
            v169 = *(_DWORD *)(a1 + 8);
            if ( v169 && v169 <= 899 )
            {
LABEL_561:
              v454 = sub_2C76A00(a1, v8, 0);
              v455 = sub_904010(v454, "this intrinsic is only supported for Hopper+");
              a2 = (__int64)"\n";
              sub_904010(v455, "\n");
              sub_2C76240(a1, (__int64)"\n", v456, v457);
            }
            break;
          default:
            goto LABEL_54;
        }
        goto LABEL_54;
      }
      if ( v33 != 9062 )
        goto LABEL_54;
      v104 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
      v105 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (1 - v104)) + 8LL);
      if ( (unsigned int)*(unsigned __int8 *)(v105 + 8) - 17 <= 1 )
        v105 = **(_QWORD **)(v105 + 16);
      v106 = *(_QWORD *)(v8 - 32 * v104);
      if ( *(_BYTE *)v106 != 17 )
      {
        v594 = "arg0 of intrinsic not constant";
        v595 = sub_2C76A00(a1, v8, 0);
        goto LABEL_706;
      }
      v107 = *(_QWORD *)(v106 + 24);
      if ( *(_DWORD *)(v106 + 32) > 0x40u )
        v107 = *(_QWORD *)v107;
      if ( (v107 & 0xFFC00000C0000000LL) != 0 )
      {
        v781 = sub_2C76A00(a1, v8, 0);
        v782 = sub_904010(v781, "Reserved bits-used");
        sub_904010(v782, "\n");
        sub_2C76240(a1, (__int64)"\n", v783, v784);
      }
      HIDWORD(v975) = 0;
      v976 = 0;
      switch ( BYTE4(v107) )
      {
        case 1:
          v976 = 8;
          v975 = 0x400000008LL;
          goto LABEL_574;
        case 2:
          v976 = 8;
          v975 = 0x1000000008LL;
          goto LABEL_574;
        case 3:
          v976 = 8;
          v975 = 0x2000000008LL;
          goto LABEL_574;
        case 4:
          v976 = 8;
          v975 = 0x4000000008LL;
          goto LABEL_574;
        case 5:
          v976 = 8;
          v975 = 0x8000000008LL;
          goto LABEL_574;
        case 6:
          v976 = 32;
          v975 = 0x1000000008LL;
          goto LABEL_574;
        case 0x10:
          v976 = 8;
          v975 = 0x400000010LL;
          goto LABEL_574;
        case 0x11:
          v976 = 8;
          v975 = 0x800000010LL;
          goto LABEL_574;
        case 0x12:
          v976 = 8;
          v975 = 0x1000000010LL;
          goto LABEL_574;
        case 0x13:
          v976 = 8;
          v975 = 0x2000000010LL;
          goto LABEL_574;
        case 0x14:
          v976 = 8;
          v975 = 0x4000000010LL;
          goto LABEL_574;
        case 0x15:
          v976 = 8;
          v975 = 0x8000000010LL;
          goto LABEL_574;
        case 0x16:
          v976 = 8;
          v975 = 0x10000000010LL;
          goto LABEL_574;
        case 0x17:
          v976 = 16;
          v975 = 0x1000000010LL;
          goto LABEL_574;
        case 0x18:
          v976 = 8;
          v975 = 0x1000000020LL;
          goto LABEL_574;
        case 0x19:
          v976 = 16;
          v975 = 0x800000010LL;
LABEL_574:
          v957 = HIDWORD(v975);
          v964 = v975;
          v945 = v976 * v975;
          break;
        default:
          v957 = 0;
          v964 = 0;
          v945 = 0;
          v458 = sub_2C76A00(a1, v8, 0);
          v459 = sub_904010(v458, "Invalid MMA MNK");
          sub_904010(v459, "\n");
          sub_2C76240(a1, (__int64)"\n", v460, v461);
          break;
      }
      v970 = BYTE1(v107);
      v462 = (unsigned int)BYTE1(v107) - 1;
      if ( (unsigned int)v462 > 0xC || (v950 = dword_43A2620[v462]) == 0 )
      {
        v463 = sub_2C76A00(a1, v8, 0);
        v464 = sub_904010(v463, "Invalid MMA AType");
        sub_904010(v464, "\n");
        sub_2C76240(a1, (__int64)"\n", v465, v466);
        v950 = 0;
      }
      v943 = v107;
      for ( i = 1; ; i = 2 )
      {
        v977 = sub_BCAE30(*(_QWORD *)(*(_QWORD *)(v8 + 32 * (i - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL));
        v978 = v468;
        if ( (v950 * v957 * v964) >> 5 != sub_CA1930(&v977) )
        {
          v469 = "Invalid MMA FragBSize";
          v470 = sub_2C76A00(a1, v8, 0);
          if ( i == 1 )
            v469 = "Invalid MMA FragASize";
          v471 = sub_904010(v470, v469);
          sub_904010(v471, "\n");
          sub_2C76240(a1, (__int64)"\n", v472, v473);
        }
        if ( i == 2 )
          break;
        v964 = HIDWORD(v975);
        v957 = v976;
      }
      v574 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (3LL - (*(_DWORD *)(v8 + 4) & 0x7FFFFFF))) + 8LL);
      if ( v970 != 6 )
        goto LABEL_686;
      v764 = *(unsigned __int8 *)(v574 + 8);
      if ( (unsigned int)(v764 - 17) <= 1 )
        LOBYTE(v764) = *(_BYTE *)(**(_QWORD **)(v574 + 16) + 8LL);
      v575 = 16;
      if ( (_BYTE)v764 != 12 )
      {
LABEL_686:
        v575 = 16;
        if ( BYTE5(v943) != 6 )
          v575 = sub_BCB060(v574);
      }
      v977 = sub_BCAE30(v574);
      v978 = v576;
      if ( (unsigned int)(v575 * v945) >> 5 != sub_CA1930(&v977) )
      {
        v577 = sub_2C76A00(a1, v8, 0);
        v578 = sub_904010(v577, "Invalid MMA FragCSize");
        sub_904010(v578, "\n");
        sub_2C76240(a1, (__int64)"\n", v579, v580);
      }
      if ( v950 > 0x20 || !sub_BCAC40(v105, 32) )
      {
        if ( v970 == 8 )
        {
          if ( *(_BYTE *)(v105 + 8) == 2 )
          {
            if ( (v943 & 7) != 0 )
              goto LABEL_697;
LABEL_786:
            v589 = (unsigned __int8)v943 >> 4;
            goto LABEL_787;
          }
        }
        else if ( v970 == 9 && *(_BYTE *)(v105 + 8) == 3 )
        {
LABEL_784:
          if ( (v943 & 7) == 0 || (v943 & 7) > 4 )
            goto LABEL_697;
          goto LABEL_786;
        }
        v581 = sub_2C76A00(a1, v8, 0);
        v582 = sub_904010(v581, "Invalid fragA type");
        sub_904010(v582, "\n");
        sub_2C76240(a1, (__int64)"\n", v583, v584);
      }
      if ( v970 != 9 )
      {
        if ( (v943 & 7) == 0 )
        {
LABEL_698:
          v589 = (unsigned __int8)v943 >> 4;
          if ( v970 != 1 )
          {
LABEL_788:
            if ( !v589 )
            {
LABEL_702:
              if ( v970 != BYTE2(v943) )
              {
                if ( (unsigned int)(v970 - 4) > 1 )
                {
                  if ( (unsigned int)(v970 - 2) <= 1 && (unsigned int)BYTE2(v943) - 2 <= 1 )
                    goto LABEL_707;
                  goto LABEL_705;
                }
                if ( (unsigned int)BYTE2(v943) - 4 > 1 )
                {
LABEL_705:
                  v594 = "Mismatched MMA A B Type";
                  v595 = sub_2C76A00(a1, v8, 0);
LABEL_706:
                  v596 = sub_904010(v595, v594);
                  sub_904010(v596, "\n");
                  sub_2C76240(a1, (__int64)"\n", v597, v598);
                }
              }
LABEL_707:
              v599 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
              a2 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (2 - v599)) + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(a2 + 8) - 17 <= 1 )
                a2 = **(_QWORD **)(a2 + 16);
              v600 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (3 - v599)) + 8LL);
              if ( (unsigned int)*(unsigned __int8 *)(v600 + 8) - 17 <= 1 )
                v600 = **(_QWORD **)(v600 + 16);
              if ( v105 != a2 || v600 != v105 && (*(_BYTE *)(v600 + 8) != 2 || (a2 = 32, !sub_BCAC40(v105, 32))) )
              {
                v601 = sub_2C76A00(a1, v8, 0);
                v602 = sub_904010(v601, "Mismatched fragA, fragB and fragC element type");
                a2 = (__int64)"\n";
                sub_904010(v602, "\n");
                sub_2C76240(a1, (__int64)"\n", v603, v604);
              }
              goto LABEL_54;
            }
LABEL_701:
            v590 = sub_2C76A00(a1, v8, 0);
            v591 = sub_904010(v590, "Invalid MMA Opcode");
            sub_904010(v591, "\n");
            sub_2C76240(a1, (__int64)"\n", v592, v593);
            goto LABEL_702;
          }
          if ( (unsigned __int8)v943 >> 4 )
          {
            if ( (unsigned __int8)((unsigned __int8)v943 >> 4) <= 2u )
            {
              if ( BYTE2(v943) == 1 )
                goto LABEL_707;
              goto LABEL_705;
            }
            goto LABEL_701;
          }
LABEL_787:
          if ( v970 == 1 )
            goto LABEL_701;
          goto LABEL_788;
        }
LABEL_697:
        v585 = sub_2C76A00(a1, v8, 0);
        v586 = sub_904010(v585, "Invalid MMA Rounding Mode");
        sub_904010(v586, "\n");
        sub_2C76240(a1, (__int64)"\n", v587, v588);
        goto LABEL_698;
      }
      goto LABEL_784;
    }
    a2 = *(_QWORD *)(*(_QWORD *)(v8 - 32LL * (*(_DWORD *)(v8 + 4) & 0x7FFFFFF)) + 8LL);
    v538 = *(unsigned __int8 *)(a2 + 8);
    v539 = *(_BYTE *)(a2 + 8);
    if ( (unsigned int)(v538 - 17) > 1 )
    {
      if ( !(_BYTE)v538 )
        goto LABEL_54;
    }
    else
    {
      v540 = *(_BYTE *)(**(_QWORD **)(a2 + 16) + 8LL);
      if ( !v540 )
        goto LABEL_54;
      if ( v538 == 18 )
        goto LABEL_661;
    }
    if ( v538 != 17 )
    {
LABEL_662:
      if ( v539 != 2 )
      {
        v541 = sub_2C76A00(a1, v8, 0);
        v542 = sub_904010(v541, "arg0 must be either half (vector) or float (vector)");
        a2 = (__int64)"\n";
        sub_904010(v542, "\n");
        sub_2C76240(a1, (__int64)"\n", v543, v544);
      }
      goto LABEL_54;
    }
    v540 = *(_BYTE *)(**(_QWORD **)(a2 + 16) + 8LL);
LABEL_661:
    v539 = v540;
    goto LABEL_662;
  }
  v10 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
  if ( !v10 )
    goto LABEL_5;
LABEL_199:
  v138 = v10;
  if ( **(_BYTE **)(v8 + 32 * (v10 - 1 - (unsigned __int64)v10)) == 25 && v10 != 1 )
  {
    v139 = 0x100000001000101LL;
    v140 = v10 - 2;
    for ( j = 0; ; ++j )
    {
      v146 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * (j - v138)) + 8LL);
      v147 = *(_BYTE *)(v146 + 8);
      if ( v147 == 12 )
      {
        v977 = sub_BCAE30(v146);
        v978 = v474;
        v475 = sub_CA1930(&v977);
        if ( v475 != 1 )
        {
          v476 = v475 - 8;
          if ( v476 > 0x38 || !_bittest64(&v139, v476) )
          {
            v477 = sub_2C76A00(a1, v8, 0);
            v478 = sub_904010(v477, "Invalid type in inline assembly, must be");
            sub_904010(v478, " i1, i8, i16, i32, i64, float, or double\n");
            sub_2C76240(a1, (__int64)" i1, i8, i16, i32, i64, float, or double\n", v479, v480);
          }
        }
      }
      else
      {
        if ( v147 <= 0xCu )
        {
          if ( (unsigned __int8)(v147 - 2) <= 1u )
            goto LABEL_204;
LABEL_203:
          v142 = sub_2C76A00(a1, v8, 0);
          v143 = sub_904010(v142, "Invalid type in inline assembly, must be ");
          sub_904010(v143, "i1, i8, i16, i32, i64, float, or double\n");
          sub_2C76240(a1, (__int64)"i1, i8, i16, i32, i64, float, or double\n", v144, v145);
          goto LABEL_204;
        }
        if ( v147 != 14 )
          goto LABEL_203;
      }
LABEL_204:
      if ( j == v140 )
        break;
      v138 = *(_DWORD *)(v8 + 4) & 0x7FFFFFF;
    }
  }
LABEL_5:
  if ( *(_QWORD *)(v8 + 48) || (*(_BYTE *)(v8 + 7) & 0x20) != 0 )
  {
    v11 = sub_B91F50(v8, "callalign", 9u);
    v12 = (const char *)v11;
    if ( v11 )
    {
      v13 = *(_BYTE *)(v11 - 16);
      v14 = (v13 & 2) != 0;
      v15 = (v13 & 2) != 0 ? *((_DWORD *)v12 - 6) : (*((_WORD *)v12 - 8) >> 6) & 0xF;
      if ( v15 > 0 )
      {
        v16 = 0;
        v17 = 8LL * (unsigned int)(v15 - 1);
        while ( 1 )
        {
          if ( v14 )
            v18 = (const char *)*((_QWORD *)v12 - 4);
          else
            v18 = &v12[-16 - 8LL * ((v13 >> 2) & 0xF)];
          v19 = *(_QWORD *)&v18[v16];
          if ( *(_BYTE *)v19 != 1 || **(_BYTE **)(v19 + 136) != 17 )
          {
            v20 = *(_QWORD *)(a1 + 24);
            v21 = *(_QWORD *)(v20 + 32);
            if ( (unsigned __int64)(*(_QWORD *)(v20 + 24) - v21) <= 6 )
            {
              sub_CB6200(v20, (unsigned __int8 *)"Error: ", 7u);
            }
            else
            {
              *(_DWORD *)v21 = 1869771333;
              *(_WORD *)(v21 + 4) = 14962;
              *(_BYTE *)(v21 + 6) = 32;
              *(_QWORD *)(v20 + 32) += 7LL;
            }
            v22 = *(_QWORD *)(a1 + 24);
            v23 = *(_WORD **)(v22 + 32);
            if ( *(_QWORD *)(v22 + 24) - (_QWORD)v23 <= 1u )
            {
              sub_CB6200(v22, (unsigned __int8 *)": ", 2u);
            }
            else
            {
              *v23 = 8250;
              *(_QWORD *)(v22 + 32) += 2LL;
            }
            v24 = *(char **)(a1 + 24);
            sub_A61DE0(v12, (__int64)v24, 0);
            v25 = *(_QWORD *)(a1 + 24);
            v26 = *(_QWORD *)(v25 + 32);
            if ( (unsigned __int64)(*(_QWORD *)(v25 + 24) - v26) <= 2 )
            {
              v24 = "\n  ";
              sub_CB6200(v25, "\n  ", 3u);
            }
            else
            {
              v27 = 8202;
              *(_BYTE *)(v26 + 2) = 32;
              *(_WORD *)v26 = 8202;
              *(_QWORD *)(v25 + 32) += 3LL;
            }
            v28 = *(_QWORD *)(a1 + 24);
            v29 = *(__m128i **)(v28 + 32);
            if ( *(_QWORD *)(v28 + 24) - (_QWORD)v29 <= 0x2Fu )
            {
              v24 = "callalign metadata operands not integer literals";
              v28 = sub_CB6200(v28, "callalign metadata operands not integer literals", 0x30u);
              v30 = *(_BYTE **)(v28 + 32);
            }
            else
            {
              *v29 = _mm_load_si128((const __m128i *)&xmmword_42D0C60);
              v29[1] = _mm_load_si128((const __m128i *)&xmmword_42D0C70);
              v29[2] = _mm_load_si128((const __m128i *)&xmmword_42D0C80);
              v30 = (_BYTE *)(*(_QWORD *)(v28 + 32) + 48LL);
              *(_QWORD *)(v28 + 32) = v30;
            }
            if ( v30 == *(_BYTE **)(v28 + 24) )
            {
              v24 = "\n";
              sub_CB6200(v28, (unsigned __int8 *)"\n", 1u);
            }
            else
            {
              *v30 = 10;
              ++*(_QWORD *)(v28 + 32);
            }
            v31 = *(_BYTE **)(a1 + 16);
            if ( v31 )
              *v31 = 0;
            if ( !*(_DWORD *)(a1 + 4) )
            {
              v32 = *(_QWORD *)(a1 + 24);
              if ( *(_QWORD *)(v32 + 32) != *(_QWORD *)(v32 + 16) )
              {
                sub_CB5AE0((__int64 *)v32);
                v32 = *(_QWORD *)(a1 + 24);
              }
              sub_CEB520(*(_QWORD **)(v32 + 48), (__int64)v24, (__int64)v29, (char *)v27);
            }
          }
          if ( v16 == v17 )
            break;
          v13 = *(v12 - 16);
          v16 += 8;
          v14 = (v13 & 2) != 0;
        }
      }
    }
  }
  sub_2C795F0(a1, v8);
}
