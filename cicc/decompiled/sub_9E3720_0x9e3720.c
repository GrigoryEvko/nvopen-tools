// Function: sub_9E3720
// Address: 0x9e3720
//
__int64 *__fastcall sub_9E3720(__int64 *a1, _QWORD *a2)
{
  __int64 *v2; // r15
  __int64 *v3; // r14
  __int64 v4; // r13
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 *v8; // rsi
  char v9; // dl
  __int64 v10; // rdi
  unsigned int v11; // r12d
  char v12; // dl
  int v13; // r8d
  const char *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rax
  __int128 *v18; // rdi
  __int64 v19; // rcx
  unsigned int v20; // eax
  __int64 v21; // rcx
  int v22; // edx
  __int64 v23; // rax
  __int64 v24; // r13
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  char *v27; // rcx
  size_t v28; // r9
  __int64 v29; // r10
  __int64 i; // rdx
  __int64 v31; // rdi
  __int64 v32; // rsi
  __int64 v33; // rax
  __int64 v34; // rdi
  __int64 v35; // rcx
  unsigned __int64 v36; // rax
  char v37; // r12
  __int64 v38; // rax
  __int64 *v39; // rdi
  __int64 v40; // r8
  unsigned __int64 v41; // rax
  unsigned __int64 *v42; // r10
  __int64 v43; // rdx
  __int64 v44; // rsi
  unsigned int v45; // r12d
  char v46; // r11
  __int64 v47; // rsi
  int v48; // r9d
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rdx
  size_t v51; // r8
  __int64 v52; // r9
  char *v53; // rcx
  __int64 v54; // rax
  __int64 v55; // r8
  __int64 v56; // rdi
  __int64 v57; // rsi
  int v58; // eax
  __int64 v59; // rcx
  __int64 v60; // r8
  char v61; // si
  __int64 v62; // rdx
  __int64 v63; // rax
  _QWORD *v64; // rax
  int v65; // edx
  __int64 v66; // rax
  __int64 v67; // rax
  __int64 v68; // r8
  __int64 *v69; // rdx
  __int64 v70; // rbx
  int v71; // r12d
  __int64 *v72; // r15
  __int64 v73; // r14
  __int64 v74; // r13
  int v75; // eax
  unsigned __int64 v76; // rax
  __int64 v77; // rax
  unsigned __int64 v78; // rax
  int v79; // eax
  __int64 v80; // rcx
  __int64 v81; // rdx
  __int64 v82; // rax
  __int64 v83; // rax
  unsigned int v84; // edx
  __int64 v85; // rax
  __int64 v86; // rax
  unsigned __int64 *v87; // r10
  unsigned __int64 v88; // rax
  char v89; // si
  __int64 v90; // rax
  __int64 v91; // rsi
  unsigned int v92; // r11d
  char v93; // r9
  __int64 v94; // rsi
  int v95; // eax
  unsigned __int64 v96; // r12
  unsigned __int64 v97; // rdx
  __int64 v98; // rax
  char v99; // al
  unsigned __int64 *v100; // r10
  __int64 v101; // rdx
  __int64 v102; // rsi
  unsigned int v103; // r12d
  char v104; // r11
  __int64 v105; // rsi
  int v106; // r9d
  unsigned __int64 v107; // rax
  unsigned __int64 v108; // rdx
  __int64 v109; // rax
  __int64 v110; // rdx
  unsigned __int8 v111; // al
  char v112; // dl
  __int64 v113; // rax
  __int64 v114; // r12
  __int64 v115; // rax
  __int64 v116; // rax
  unsigned __int64 *v117; // r10
  __int64 v118; // rax
  __int64 v119; // rsi
  unsigned int v120; // r12d
  char v121; // r11
  __int64 v122; // rsi
  int v123; // r9d
  unsigned __int64 v124; // rax
  unsigned __int64 v125; // rdx
  __int64 v126; // rax
  __int64 v127; // rax
  __int64 v128; // rcx
  int v129; // edx
  __int64 *v130; // rax
  __int64 v131; // rax
  __int64 v132; // rdx
  unsigned __int64 v133; // rsi
  __int64 v134; // rax
  int v135; // eax
  __int64 v136; // rcx
  __int64 v137; // rdx
  __int64 v138; // rcx
  __int64 v139; // r8
  __int64 v140; // rax
  __int64 v141; // rcx
  __int64 v142; // r8
  __int64 v143; // rsi
  int v144; // edx
  unsigned __int64 v145; // rax
  unsigned __int64 v146; // rsi
  unsigned __int64 v147; // r14
  unsigned __int64 v148; // rcx
  __int64 v149; // rax
  unsigned __int64 v150; // rdx
  unsigned __int64 v151; // r13
  unsigned __int64 v152; // r14
  unsigned __int64 v153; // rcx
  __int64 v154; // rax
  unsigned __int64 v155; // rdx
  unsigned __int64 v156; // r13
  unsigned __int64 v157; // r14
  unsigned __int64 v158; // rcx
  __int64 v159; // rax
  unsigned __int64 v160; // rdx
  unsigned __int64 v161; // r13
  const char *v162; // rax
  __int64 v163; // rax
  __int64 v164; // rcx
  size_t v165; // rdx
  __int64 v166; // r8
  char *v167; // rcx
  __int64 v168; // rax
  size_t v169; // rdx
  __int64 v170; // rdi
  const char *v171; // rax
  __int64 v172; // r12
  __int64 v173; // rax
  const void *v174; // r12
  unsigned int v175; // eax
  int v176; // eax
  unsigned __int64 v177; // rax
  unsigned int v178; // r12d
  unsigned __int64 v179; // r14
  unsigned __int64 v180; // rcx
  __int64 v181; // rax
  unsigned __int64 v182; // rdx
  unsigned __int64 v183; // r13
  unsigned __int64 v184; // rax
  __int64 v185; // rdx
  __int64 v186; // rcx
  __int64 v187; // r8
  __int64 v188; // rdi
  size_t v189; // rsi
  __int128 *v190; // rdi
  __int64 v191; // rcx
  __int64 v192; // rax
  __int64 v193; // rdx
  char v194; // dl
  __int64 v195; // rcx
  unsigned __int8 v196; // al
  unsigned __int64 v197; // rax
  __int64 v198; // rax
  unsigned __int64 v199; // rax
  unsigned __int64 v200; // rax
  __int64 v201; // rax
  size_t v202; // r10
  __int64 v203; // rdi
  __int64 v204; // r9
  __int64 v205; // rax
  int v206; // [rsp-18h] [rbp-468h]
  _BOOL4 v207; // [rsp-10h] [rbp-460h]
  __int64 v208; // [rsp+8h] [rbp-448h]
  bool v209; // [rsp+10h] [rbp-440h]
  __int64 v210; // [rsp+10h] [rbp-440h]
  __int64 v211; // [rsp+18h] [rbp-438h]
  int v212; // [rsp+18h] [rbp-438h]
  bool v213; // [rsp+18h] [rbp-438h]
  __int64 v214; // [rsp+20h] [rbp-430h]
  bool v215; // [rsp+20h] [rbp-430h]
  __int64 v216; // [rsp+20h] [rbp-430h]
  bool v217; // [rsp+2Ch] [rbp-424h]
  char v218; // [rsp+2Ch] [rbp-424h]
  unsigned int v219; // [rsp+30h] [rbp-420h]
  int v220; // [rsp+30h] [rbp-420h]
  unsigned int v221; // [rsp+30h] [rbp-420h]
  unsigned int v222; // [rsp+30h] [rbp-420h]
  unsigned __int64 *v223; // [rsp+38h] [rbp-418h]
  unsigned __int64 *v224; // [rsp+38h] [rbp-418h]
  unsigned __int64 *v225; // [rsp+38h] [rbp-418h]
  unsigned __int64 *v226; // [rsp+38h] [rbp-418h]
  unsigned __int64 v227; // [rsp+40h] [rbp-410h]
  unsigned int v228; // [rsp+40h] [rbp-410h]
  unsigned __int64 v229; // [rsp+40h] [rbp-410h]
  unsigned __int64 v230; // [rsp+40h] [rbp-410h]
  __int64 v231; // [rsp+48h] [rbp-408h]
  int v232; // [rsp+48h] [rbp-408h]
  int v233; // [rsp+48h] [rbp-408h]
  int v234; // [rsp+48h] [rbp-408h]
  int v235; // [rsp+48h] [rbp-408h]
  __int64 v236; // [rsp+48h] [rbp-408h]
  __int64 v237; // [rsp+50h] [rbp-400h]
  char v238; // [rsp+50h] [rbp-400h]
  char v239; // [rsp+50h] [rbp-400h]
  char v240; // [rsp+50h] [rbp-400h]
  char v241; // [rsp+50h] [rbp-400h]
  __int64 *v242; // [rsp+50h] [rbp-400h]
  __int64 *v243; // [rsp+50h] [rbp-400h]
  __int64 *v244; // [rsp+50h] [rbp-400h]
  __int64 *v245; // [rsp+50h] [rbp-400h]
  __int64 v246; // [rsp+58h] [rbp-3F8h]
  __int64 v247; // [rsp+58h] [rbp-3F8h]
  __int64 v248; // [rsp+58h] [rbp-3F8h]
  __int64 v249; // [rsp+58h] [rbp-3F8h]
  __int64 v250; // [rsp+58h] [rbp-3F8h]
  __int64 v251; // [rsp+58h] [rbp-3F8h]
  __int64 v252; // [rsp+58h] [rbp-3F8h]
  __int64 v253; // [rsp+58h] [rbp-3F8h]
  __int64 v254; // [rsp+58h] [rbp-3F8h]
  __int64 v255; // [rsp+58h] [rbp-3F8h]
  void *src; // [rsp+60h] [rbp-3F0h]
  __int64 *srca; // [rsp+60h] [rbp-3F0h]
  int srcd; // [rsp+60h] [rbp-3F0h]
  void *srce; // [rsp+60h] [rbp-3F0h]
  void *srcf; // [rsp+60h] [rbp-3F0h]
  void *srcg; // [rsp+60h] [rbp-3F0h]
  void *srch; // [rsp+60h] [rbp-3F0h]
  void *srci; // [rsp+60h] [rbp-3F0h]
  void *srcb; // [rsp+60h] [rbp-3F0h]
  void *srcj; // [rsp+60h] [rbp-3F0h]
  void *srck; // [rsp+60h] [rbp-3F0h]
  void *srcc; // [rsp+60h] [rbp-3F0h]
  size_t n; // [rsp+68h] [rbp-3E8h]
  size_t nf; // [rsp+68h] [rbp-3E8h]
  size_t nc; // [rsp+68h] [rbp-3E8h]
  size_t ng; // [rsp+68h] [rbp-3E8h]
  size_t nd; // [rsp+68h] [rbp-3E8h]
  size_t ne; // [rsp+68h] [rbp-3E8h]
  __int64 na; // [rsp+68h] [rbp-3E8h]
  size_t nh; // [rsp+68h] [rbp-3E8h]
  size_t ni; // [rsp+68h] [rbp-3E8h]
  size_t nj; // [rsp+68h] [rbp-3E8h]
  size_t nb; // [rsp+68h] [rbp-3E8h]
  size_t v279; // [rsp+70h] [rbp-3E0h]
  int v280; // [rsp+70h] [rbp-3E0h]
  size_t v281; // [rsp+70h] [rbp-3E0h]
  int v282; // [rsp+70h] [rbp-3E0h]
  size_t v283; // [rsp+70h] [rbp-3E0h]
  __int64 *v284; // [rsp+70h] [rbp-3E0h]
  size_t v285; // [rsp+70h] [rbp-3E0h]
  size_t v286; // [rsp+70h] [rbp-3E0h]
  int v287; // [rsp+70h] [rbp-3E0h]
  int v288; // [rsp+70h] [rbp-3E0h]
  int v289; // [rsp+70h] [rbp-3E0h]
  size_t v290; // [rsp+70h] [rbp-3E0h]
  size_t v291; // [rsp+70h] [rbp-3E0h]
  int v292; // [rsp+70h] [rbp-3E0h]
  size_t v293; // [rsp+70h] [rbp-3E0h]
  size_t v294; // [rsp+70h] [rbp-3E0h]
  size_t v295; // [rsp+70h] [rbp-3E0h]
  size_t v296; // [rsp+70h] [rbp-3E0h]
  size_t v297; // [rsp+70h] [rbp-3E0h]
  size_t v298; // [rsp+70h] [rbp-3E0h]
  size_t v299; // [rsp+70h] [rbp-3E0h]
  size_t v300; // [rsp+70h] [rbp-3E0h]
  size_t v301; // [rsp+70h] [rbp-3E0h]
  __int64 v302; // [rsp+80h] [rbp-3D0h]
  char v303; // [rsp+88h] [rbp-3C8h]
  unsigned int v304; // [rsp+88h] [rbp-3C8h]
  unsigned int v305; // [rsp+8Ch] [rbp-3C4h]
  __int64 v306; // [rsp+90h] [rbp-3C0h]
  unsigned int v307; // [rsp+A0h] [rbp-3B0h]
  unsigned int v308; // [rsp+BCh] [rbp-394h] BYREF
  __int64 v309; // [rsp+C0h] [rbp-390h] BYREF
  char v310; // [rsp+C8h] [rbp-388h]
  __int64 v311; // [rsp+D0h] [rbp-380h] BYREF
  char v312; // [rsp+D8h] [rbp-378h]
  __int128 v313; // [rsp+E0h] [rbp-370h] BYREF
  __int128 v314; // [rsp+F0h] [rbp-360h] BYREF
  __int64 v315; // [rsp+100h] [rbp-350h]
  unsigned __int64 v316; // [rsp+110h] [rbp-340h] BYREF
  __int64 v317; // [rsp+118h] [rbp-338h]
  unsigned __int64 v318; // [rsp+120h] [rbp-330h] BYREF
  int v319; // [rsp+128h] [rbp-328h]
  char v320; // [rsp+130h] [rbp-320h]
  unsigned __int64 v321; // [rsp+140h] [rbp-310h] BYREF
  unsigned __int64 v322; // [rsp+148h] [rbp-308h]
  unsigned __int64 v323; // [rsp+150h] [rbp-300h] BYREF
  unsigned int v324; // [rsp+158h] [rbp-2F8h]
  unsigned __int64 v325; // [rsp+160h] [rbp-2F0h]
  int v326; // [rsp+168h] [rbp-2E8h]
  __int64 v327; // [rsp+170h] [rbp-2E0h]
  __int64 v328; // [rsp+180h] [rbp-2D0h] BYREF
  __int64 v329; // [rsp+188h] [rbp-2C8h]
  __int64 v330; // [rsp+190h] [rbp-2C0h] BYREF
  char v331[8]; // [rsp+198h] [rbp-2B8h] BYREF
  char v332; // [rsp+1A0h] [rbp-2B0h]
  char v333; // [rsp+1A1h] [rbp-2AFh]
  __int64 v334; // [rsp+1B0h] [rbp-2A0h]
  __int64 v335; // [rsp+210h] [rbp-240h] BYREF
  __int64 v336; // [rsp+218h] [rbp-238h]
  _BYTE v337[560]; // [rsp+220h] [rbp-230h] BYREF

  v2 = &v335;
  v3 = a1;
  v4 = (__int64)(a2 + 4);
  v5 = a2;
  sub_A4DCE0(&v335, a2 + 4, 11, 0);
  if ( (v335 & 0xFFFFFFFFFFFFFFFELL) != 0 )
  {
    *a1 = v335 & 0xFFFFFFFFFFFFFFFELL | 1;
    return v3;
  }
  v6 = a2[54];
  v335 = (__int64)v337;
  v336 = 0x4000000000LL;
  v306 = sub_BCB2D0(v6);
  v302 = 0;
  v305 = sub_9E2F80((__int64)a2, v306, 0, 0);
  v307 = (__int64)(a2[94] - a2[93]) >> 5;
LABEL_3:
  while ( 2 )
  {
    v8 = (__int64 *)v4;
    sub_9CEFB0((__int64)&v309, v4, 0, v7);
    v9 = v310 & 1;
    v310 = (2 * (v310 & 1)) | v310 & 0xFD;
    if ( v9 )
    {
      v8 = &v309;
      sub_9C9090(v3, &v309);
      goto LABEL_12;
    }
    if ( (_DWORD)v309 == 1 )
    {
      if ( v307 == (unsigned int)((__int64)(v5[94] - v5[93]) >> 5) )
      {
        *v3 = 1;
        goto LABEL_14;
      }
      v333 = 1;
      v15 = "Invalid constant reference";
LABEL_11:
      v8 = v5 + 1;
      v328 = (__int64)v15;
      v332 = 3;
      sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v328);
      goto LABEL_12;
    }
    if ( (v309 & 0xFFFFFFFD) == 0 )
    {
      v333 = 1;
      v15 = "Malformed block";
      goto LABEL_11;
    }
    v10 = v5[54];
    v11 = HIDWORD(v309);
    LODWORD(v336) = 0;
    v279 = sub_BCB120(v10);
    sub_A4B600(&v311, v4, v11, v2, 0);
    v12 = v312 & 1;
    v312 = (2 * (v312 & 1)) | v312 & 0xFD;
    if ( v12 )
    {
      v8 = &v311;
      sub_9C8CD0(v3, &v311);
      goto LABEL_45;
    }
    v13 = v311;
    switch ( (int)v311 )
    {
      case 1:
        if ( !(_DWORD)v336
          || (v132 = v5[66], v133 = *(_QWORD *)v335, *(_QWORD *)v335 >= (unsigned __int64)((v5[67] - v132) >> 3))
          || (v134 = *(_QWORD *)(v132 + 8 * v133)) == 0 )
        {
          v333 = 1;
          v162 = "Invalid settype record";
          break;
        }
        if ( v134 == v279 )
        {
          v333 = 1;
          v162 = "Invalid constant type";
          break;
        }
        v305 = *(_QWORD *)v335;
        v306 = *(_QWORD *)(v132 + 8LL * (unsigned int)v133);
        v302 = sub_9CAE40(v5, v133);
        sub_9CE2A0(&v311);
        sub_9CEF80(&v309);
        continue;
      case 2:
        v99 = *(_BYTE *)(v306 + 8);
        if ( (unsigned __int8)(v99 - 7) > 1u && v99 != 13 && (v99 != 20 || (unsigned __int8)sub_BCEE90(v306, 1)) )
        {
          v35 = sub_AD6530(v306);
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid type for a constant null value";
        goto LABEL_267;
      case 4:
        v144 = *(unsigned __int8 *)(v306 + 8);
        if ( (unsigned int)(v144 - 17) <= 1 )
          LOBYTE(v144) = *(_BYTE *)(**(_QWORD **)(v306 + 16) + 8LL);
        if ( (_BYTE)v144 == 12 && (_DWORD)v336 )
        {
          v145 = *(_QWORD *)v335;
          if ( (*(_QWORD *)v335 & 1) != 0 )
          {
            v146 = -(__int64)(v145 >> 1);
            if ( v145 == 1 )
              v146 = 0x8000000000000000LL;
          }
          else
          {
            v146 = v145 >> 1;
          }
          v35 = sub_AD64C0(v306, v146, 0);
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid integer const record";
        goto LABEL_267;
      case 5:
        v128 = v306;
        v129 = *(unsigned __int8 *)(v306 + 8);
        if ( (unsigned int)(v129 - 17) <= 1 )
        {
          v130 = *(__int64 **)(v306 + 16);
          v128 = *v130;
          LOBYTE(v129) = *(_BYTE *)(*v130 + 8);
        }
        if ( (_BYTE)v129 == 12 && (_DWORD)v336 )
        {
          sub_9C7EB0((__int64)&v328, v335, (unsigned int)v336, *(_DWORD *)(v128 + 8) >> 8);
          v131 = sub_AD8D80(v306, &v328);
          v35 = v131;
          if ( (unsigned int)v329 > 0x40 && v328 )
          {
            v290 = v131;
            j_j___libc_free_0_0(v328);
            v35 = v290;
          }
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid wide integer const record";
        goto LABEL_267;
      case 6:
        if ( (_DWORD)v336 )
        {
          v135 = *(unsigned __int8 *)(v306 + 8);
          v136 = (unsigned int)(v135 - 17);
          if ( (unsigned int)v136 <= 1 )
            LOBYTE(v135) = *(_BYTE *)(**(_QWORD **)(v306 + 16) + 8LL);
          switch ( (_BYTE)v135 )
          {
            case 0:
              v184 = *(unsigned __int16 *)v335;
              LODWORD(v322) = 16;
              v321 = v184;
              v295 = sub_C332F0(&v311, v306, (unsigned int)v336, v136);
              if ( v295 == sub_C33340(&v311, v306, v185, v186, v187) )
                sub_C3C640(&v328, v295, &v321);
              else
                sub_C3B160(&v328, v295, &v321);
              v296 = sub_AD8F10(v306, &v328);
              sub_91D830(&v328);
              v35 = v296;
              if ( (unsigned int)v322 > 0x40 && v321 )
              {
                j_j___libc_free_0_0(v321);
                v35 = v296;
              }
              goto LABEL_43;
            case 1:
              v197 = *(unsigned int *)v335;
              LODWORD(v322) = 16;
              v321 = v197;
              v198 = sub_C33300();
              break;
            case 2:
              v199 = *(unsigned int *)v335;
              LODWORD(v322) = 32;
              v321 = v199;
              v198 = sub_C33310(&v311, v306);
              break;
            case 3:
              v200 = *(_QWORD *)v335;
              LODWORD(v322) = 64;
              v321 = v200;
              v198 = sub_C33320(&v311);
              break;
            default:
              switch ( (_BYTE)v135 )
              {
                case 4:
                  v316 = (*(_QWORD *)v335 << 16) | *(unsigned __int16 *)(v335 + 8);
                  v317 = HIWORD(*(_QWORD *)v335);
                  sub_C438C0(&v321, 80, &v316, 2);
                  v140 = sub_C33420();
                  break;
                case 5:
                  sub_C438C0(&v321, 128, v335, (unsigned int)v336);
                  v140 = sub_C33330();
                  break;
                case 6:
                  sub_C438C0(&v321, 128, v335, (unsigned int)v336);
                  v140 = sub_C33340(&v321, 128, v137, v138, v139);
                  break;
                default:
LABEL_42:
                  v35 = sub_ACADE0(v306);
                  goto LABEL_43;
              }
              v143 = v140;
              goto LABEL_207;
          }
          v143 = v198;
LABEL_207:
          sub_991450((__int64)&v328, v143, (__int64)&v321, v141, v142);
          nf = sub_AD8F10(v306, &v328);
          sub_91D830(&v328);
          sub_969240((__int64 *)&v321);
          v35 = nf;
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid float const record";
        goto LABEL_267;
      case 7:
        if ( (_DWORD)v336 )
        {
          v32 = 0x1000000000LL;
          v328 = (__int64)&v330;
          v68 = 0;
          v329 = 0x1000000000LL;
          v69 = &v330;
          n = (size_t)v5;
          v70 = 8;
          srca = v2;
          v71 = *(_DWORD *)v335;
          v72 = v3;
          v73 = v4;
          v284 = &v330;
          v74 = 8LL * (unsigned int)v336;
          while ( 1 )
          {
            *((_DWORD *)v69 + v68) = v71;
            v68 = (unsigned int)(v329 + 1);
            LODWORD(v329) = v329 + 1;
            if ( v70 == v74 )
              break;
            v71 = *(_DWORD *)(v335 + v70);
            if ( v68 + 1 > (unsigned __int64)HIDWORD(v329) )
            {
              v32 = (__int64)&v330;
              sub_C8D5F0(&v328, &v330, v68 + 1, 4);
              v68 = (unsigned int)v329;
            }
            v69 = (__int64 *)v328;
            v70 += 8;
          }
          v4 = v73;
          v5 = (_QWORD *)n;
          v3 = v72;
          v2 = srca;
          v75 = *(unsigned __int8 *)(v306 + 8);
          if ( (_BYTE)v75 == 15 )
          {
            v320 = 0;
            v321 = 255;
          }
          else if ( (_BYTE)v75 == 16 )
          {
            v320 = 0;
            v321 = 254;
          }
          else
          {
            if ( (unsigned int)(v75 - 17) > 1 )
            {
              v35 = sub_ACADE0(v306);
              goto LABEL_107;
            }
            v320 = 0;
            v321 = 253;
          }
          v32 = v306;
          v322 = 0;
          v327 = 0;
          v76 = sub_9D1FB0((__int64 *)(n + 648), v306, (__int16 *)&v321, (const void *)v328, v68);
          v35 = v76;
          if ( (_BYTE)v327 )
          {
            nd = v76;
            sub_9963D0((__int64)&v323);
            v35 = nd;
          }
          if ( v320 )
          {
            ne = v35;
            sub_9963D0((__int64)&v316);
            v35 = ne;
          }
LABEL_107:
          v34 = v328;
          if ( (__int64 *)v328 == v284 )
            goto LABEL_43;
          goto LABEL_108;
        }
        v333 = 1;
        v162 = "Invalid aggregate record";
        goto LABEL_267;
      case 8:
      case 9:
        if ( (_DWORD)v336 )
        {
          v27 = v331;
          v28 = (unsigned int)v336;
          v329 = 0;
          v29 = v335;
          v328 = (__int64)v331;
          v330 = 16;
          if ( (unsigned int)v336 > 0x10uLL )
          {
            v251 = v335;
            srcd = v311;
            nc = (unsigned int)v336;
            sub_C8D290(&v328, v331, (unsigned int)v336, 1);
            v29 = v251;
            v13 = srcd;
            v28 = nc;
            v27 = (char *)(v328 + v329);
          }
          for ( i = 0; i != v28; ++i )
            v27[i] = *(_QWORD *)(v29 + 8 * i);
          v31 = v5[54];
          v32 = v328;
          v329 += i;
          v33 = sub_AC9B20(v31, v328, v329, v13 == 9);
          v34 = v328;
          v35 = v33;
          if ( (char *)v328 == v331 )
            goto LABEL_43;
LABEL_108:
          v285 = v35;
          _libc_free(v34, v32);
          v35 = v285;
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid string record";
        goto LABEL_267;
      case 10:
        if ( (unsigned int)v336 > 2uLL )
        {
          v57 = v306;
          v58 = sub_9C4130(*(_DWORD *)v335, v306);
          if ( v58 >= 0 )
          {
            v61 = 0;
            if ( v59 != 3 )
            {
              if ( (v58 & 0xFFFFFFFD) == 0xD || (v58 & 0xFFFFFFF7) == 0x11 )
              {
                v61 = *(_BYTE *)(v60 + 24) & 3;
              }
              else if ( (unsigned int)(v58 - 19) <= 1 || (unsigned int)(v58 - 26) <= 1 )
              {
                v61 = *(_BYTE *)(v60 + 24) & 1;
              }
            }
            v39 = v5 + 81;
            LODWORD(v316) = *(_QWORD *)(v60 + 8);
            v62 = *(_QWORD *)(v60 + 16);
            v40 = 2;
            LOBYTE(v325) = 0;
            HIDWORD(v316) = v62;
            LOBYTE(v328) = v58;
            BYTE1(v328) = v61;
            HIDWORD(v328) = 0;
            v329 = 0;
            LOBYTE(v334) = 0;
            goto LABEL_51;
          }
LABEL_262:
          v35 = sub_ACADE0(v57);
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid binary op constexpr record";
        goto LABEL_267;
      case 11:
        if ( (unsigned int)v336 <= 2 )
          goto LABEL_402;
        if ( (unsigned int)*(_QWORD *)v335 > 0xC )
          goto LABEL_42;
        v37 = *(_QWORD *)v335 + 38;
        if ( sub_9CAD80(v5, *(_QWORD *)(v335 + 8)) )
        {
          v38 = *(_QWORD *)(v335 + 16);
          LOBYTE(v325) = 0;
          LOBYTE(v328) = v37;
          LODWORD(v316) = v38;
LABEL_50:
          BYTE1(v328) = 0;
          v39 = v5 + 81;
          v40 = 1;
          HIDWORD(v328) = 0;
          v329 = 0;
          LOBYTE(v334) = 0;
LABEL_51:
          v41 = sub_9D1FB0(v39, v306, (__int16 *)&v328, &v316, v40);
          v35 = v41;
          if ( (_BYTE)v334 )
          {
            v291 = v41;
            sub_9963D0((__int64)&v330);
            v35 = v291;
          }
          if ( (_BYTE)v325 )
          {
            v281 = v35;
            sub_9963D0((__int64)&v321);
            v35 = v281;
          }
          goto LABEL_43;
        }
LABEL_402:
        v333 = 1;
        v162 = "Invalid cast constexpr record";
        goto LABEL_267;
      case 12:
      case 20:
      case 24:
      case 31:
      case 32:
        if ( (unsigned int)v336 <= 1 )
        {
          v333 = 1;
          v162 = "Constant GEP record must have at least two elements";
          goto LABEL_267;
        }
        v16 = v335;
        v308 = 0;
        if ( (unsigned int)(v311 - 31) <= 1 || (_DWORD)v311 == 24 )
        {
          v308 = 1;
          v292 = v311;
          v163 = sub_9CAD80(v5, *(_QWORD *)v335);
          v13 = v292;
          v315 = 0;
          src = (void *)v163;
          v313 = 0;
          v314 = 0;
          if ( v292 == 24 )
          {
            v16 = v335;
            v195 = v308;
            v20 = ++v308;
            v237 = *(_QWORD *)(v335 + 8 * v195) & 1LL;
            goto LABEL_28;
          }
          if ( v292 == 31 )
          {
            v193 = v308++;
            v192 = v308;
            v237 = *(_QWORD *)(v335 + 8 * v193);
            if ( (unsigned int)v336 == (unsigned __int64)v308 )
            {
              v333 = 1;
              v328 = (__int64)"Too few records for range";
              v332 = 3;
              sub_9C81F0((__int64 *)&v316, (__int64)(v5 + 1), (__int64)&v328);
              LOBYTE(v325) = v325 | 1;
              v321 = v316 & 0xFFFFFFFFFFFFFFFELL;
            }
            else
            {
              v308 = v193 + 2;
              sub_9C8500((__int64)&v321, (__int64)v5, v335, (unsigned int)v336, &v308, *(_DWORD *)(v335 + 8 * v192));
            }
            v194 = v325 & 1;
            LOBYTE(v325) = (2 * (v325 & 1)) | v325 & 0xFD;
            if ( v194 )
            {
              v8 = (__int64 *)&v321;
              sub_9C94E0(v3, (__int64 *)&v321);
              sub_9D2150(&v321);
              goto LABEL_283;
            }
            if ( (_BYTE)v315 )
            {
              if ( DWORD2(v313) <= 0x40 && (unsigned int)v322 <= 0x40 )
              {
                DWORD2(v313) = v322;
                *(_QWORD *)&v313 = v321;
              }
              else
              {
                sub_C43990(&v313, &v321);
              }
              if ( DWORD2(v314) <= 0x40 && v324 <= 0x40 )
              {
                DWORD2(v314) = v324;
                *(_QWORD *)&v314 = v323;
              }
              else
              {
                sub_C43990(&v314, &v323);
              }
            }
            else
            {
              DWORD2(v313) = v322;
              if ( (unsigned int)v322 > 0x40 )
                sub_C43780(&v313, &v321);
              else
                *(_QWORD *)&v313 = v321;
              DWORD2(v314) = v324;
              if ( v324 > 0x40 )
                sub_C43780(&v314, &v323);
              else
                *(_QWORD *)&v314 = v323;
              LOBYTE(v315) = 1;
            }
            sub_9D2150(&v321);
            v16 = v335;
            v20 = v308;
            goto LABEL_28;
          }
          v16 = v335;
          if ( v292 == 32 )
          {
            v16 = v335;
            v164 = v308;
            v20 = ++v308;
            v237 = *(_QWORD *)(v335 + 8 * v164);
            goto LABEL_28;
          }
        }
        else if ( (v336 & 1) != 0 )
        {
          v308 = 1;
          v280 = v311;
          v17 = sub_9CAD80(v5, *(_QWORD *)v335);
          v18 = &v313;
          v19 = 10;
          v16 = v335;
          src = (void *)v17;
          v13 = v280;
          while ( v19 )
          {
            *(_DWORD *)v18 = 0;
            v18 = (__int128 *)((char *)v18 + 4);
            --v19;
          }
        }
        else
        {
          v190 = &v313;
          v191 = 10;
          src = 0;
          while ( v191 )
          {
            *(_DWORD *)v190 = 0;
            v190 = (__int128 *)((char *)v190 + 4);
            --v191;
          }
        }
        LOBYTE(v237) = v13 == 20;
        v20 = v308;
LABEL_28:
        v328 = (__int64)&v330;
        v329 = 0x1000000000LL;
        v21 = v20;
        v246 = *(_QWORD *)(v16 + 8LL * v20);
        if ( v20 == (_DWORD)v336 )
          goto LABEL_388;
        v231 = v4;
        while ( 1 )
        {
          v308 = v20 + 1;
          if ( !sub_9CAD80(v5, *(_QWORD *)(v16 + 8 * v21)) )
            break;
          v23 = v308++;
          v24 = *(_QWORD *)(v335 + 8 * v23);
          v25 = (unsigned int)v329;
          v26 = (unsigned int)v329 + 1LL;
          if ( v26 > HIDWORD(v329) )
          {
            sub_C8D5F0(&v328, &v330, v26, 4);
            v25 = (unsigned int)v329;
          }
          *(_DWORD *)(v328 + 4 * v25) = v24;
          v21 = v308;
          v22 = v329 + 1;
          LODWORD(v329) = v329 + 1;
          v20 = v308;
          if ( v308 == (_DWORD)v336 )
          {
            v4 = v231;
            if ( !v22 )
            {
LABEL_388:
              BYTE1(v325) = 1;
              v171 = "Invalid gep with no operands";
              goto LABEL_281;
            }
            LODWORD(v172) = v246;
            v173 = sub_9CAD80(v5, (unsigned int)v246);
            if ( (unsigned int)*(unsigned __int8 *)(v173 + 8) - 17 <= 1
              && (v172 = (unsigned int)sub_9C2A90((__int64)v5, v246, 0), (v173 = sub_9CAD80(v5, v172)) == 0)
              || *(_BYTE *)(v173 + 8) != 14 )
            {
              BYTE1(v325) = 1;
              v171 = "GEP base operand must be pointer or vector of pointer";
              goto LABEL_281;
            }
            if ( !src )
            {
              src = (void *)sub_9CAE40(v5, v172);
              if ( !src )
              {
                BYTE1(v325) = 1;
                v171 = "Missing element type for old-style constant GEP";
                goto LABEL_281;
              }
            }
            v320 = 0;
            v174 = (const void *)v328;
            v236 = (unsigned int)v329;
            if ( (_BYTE)v315 )
            {
              LODWORD(v317) = DWORD2(v313);
              if ( DWORD2(v313) > 0x40 )
                sub_C43780(&v316, &v313);
              else
                v316 = v313;
              v319 = DWORD2(v314);
              if ( DWORD2(v314) > 0x40 )
                sub_C43780(&v318, &v314);
              else
                v318 = v314;
              v320 = 1;
            }
            LOBYTE(v321) = 34;
            HIDWORD(v321) = 0;
            BYTE1(v321) = v237;
            LOBYTE(v327) = 0;
            v322 = (unsigned __int64)src;
            if ( v320 )
            {
              v175 = v317;
              LOBYTE(v327) = 1;
              LODWORD(v317) = 0;
              v324 = v175;
              v323 = v316;
              v176 = v319;
              v319 = 0;
              v326 = v176;
              v325 = v318;
            }
            v177 = sub_9D1FB0(v5 + 81, v306, (__int16 *)&v321, v174, v236);
            v35 = v177;
            if ( (_BYTE)v327 )
            {
              v298 = v177;
              sub_9963D0((__int64)&v323);
              v35 = v298;
            }
            if ( v320 )
            {
              v297 = v35;
              sub_9963D0((__int64)&v316);
              v35 = v297;
            }
            if ( (__int64 *)v328 != &v330 )
            {
              v293 = v35;
              _libc_free(v328, v306);
              v35 = v293;
            }
            if ( (_BYTE)v315 )
            {
              v294 = v35;
              sub_9963D0((__int64)&v313);
              v35 = v294;
            }
LABEL_43:
            sub_A149E0(&v328, v5 + 93, v307, v35, v305);
            v36 = v328 & 0xFFFFFFFFFFFFFFFELL;
            if ( (v328 & 0xFFFFFFFFFFFFFFFELL) != 0 )
            {
              *v3 = 0;
              v8 = &v328;
              v328 = v36 | 1;
              sub_9C6670(v3, &v328);
              sub_9C66B0(&v328);
              goto LABEL_45;
            }
            ++v307;
            if ( (v312 & 2) != 0 )
              sub_9CE230(&v311);
            if ( (v312 & 1) != 0 && v311 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v311 + 8LL))(v311);
            if ( (v310 & 2) != 0 )
              goto LABEL_225;
            if ( (v310 & 1) != 0 && v309 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v309 + 8LL))(v309);
            goto LABEL_3;
          }
          v16 = v335;
        }
        BYTE1(v325) = 1;
        v171 = "Invalid getelementptr constexpr record";
LABEL_281:
        v8 = v5 + 1;
        v321 = (unsigned __int64)v171;
        LOBYTE(v325) = 3;
        sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v321);
        if ( (__int64 *)v328 != &v330 )
          _libc_free(v328, v8);
LABEL_283:
        if ( (_BYTE)v315 )
          sub_9963D0((__int64)&v313);
LABEL_45:
        sub_9CE2A0(&v311);
LABEL_12:
        if ( (v310 & 2) != 0 )
LABEL_225:
          sub_9CEF10(&v309);
        if ( (v310 & 1) != 0 && v309 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v309 + 8LL))(v309);
LABEL_14:
        if ( (_BYTE *)v335 != v337 )
          _libc_free(v335, v8);
        return v3;
      case 13:
        if ( (unsigned int)v336 > 2 )
        {
          LODWORD(v316) = *(_QWORD *)v335;
          HIDWORD(v316) = *(_QWORD *)(v335 + 8);
          v127 = *(_QWORD *)(v335 + 16);
          LOBYTE(v325) = 0;
          LODWORD(v317) = v127;
          v328 = 57;
          goto LABEL_85;
        }
        v333 = 1;
        v162 = "Invalid select constexpr record";
        goto LABEL_267;
      case 14:
        if ( (unsigned int)v336 <= 2 )
          goto LABEL_268;
        v82 = sub_9CAD80(v5, *(_QWORD *)v335);
        if ( !v82 || (unsigned int)*(unsigned __int8 *)(v82 + 8) - 17 > 1 )
          goto LABEL_268;
        v83 = v335;
        if ( (_DWORD)v336 == 4 )
        {
          if ( !sub_9CAD80(v5, *(_QWORD *)(v335 + 16)) )
          {
LABEL_268:
            v333 = 1;
            v162 = "Invalid extractelement constexpr record";
            goto LABEL_267;
          }
          v83 = v335;
          v84 = *(_DWORD *)(v335 + 24);
        }
        else
        {
          v84 = *(_DWORD *)(v335 + 16);
        }
        v85 = *(_QWORD *)(v83 + 8);
        v39 = v5 + 81;
        LOBYTE(v325) = 0;
        v40 = 2;
        v316 = __PAIR64__(v84, v85);
        v328 = 61;
        v329 = 0;
        v334 = 0;
        goto LABEL_51;
      case 15:
        if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 > 1 || (unsigned int)v336 <= 2uLL )
          goto LABEL_389;
        v64 = (_QWORD *)v335;
        if ( (unsigned int)v336 != 4 )
        {
          v65 = *(_DWORD *)(v335 + 16);
LABEL_90:
          LODWORD(v316) = *v64;
          v66 = v64[1];
          LODWORD(v317) = v65;
          HIDWORD(v316) = v66;
          LOBYTE(v325) = 0;
          v328 = 62;
LABEL_85:
          v329 = 0;
          v39 = v5 + 81;
          v334 = 0;
          v40 = 3;
          goto LABEL_51;
        }
        if ( sub_9CAD80(v5, *(_QWORD *)(v335 + 16)) )
        {
          v64 = (_QWORD *)v335;
          v65 = *(_DWORD *)(v335 + 24);
          goto LABEL_90;
        }
LABEL_389:
        v333 = 1;
        v162 = "Invalid insertelement constexpr record";
        goto LABEL_267;
      case 16:
        if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 > 1 || (unsigned int)v336 <= 2 )
          goto LABEL_373;
        LODWORD(v316) = *(_QWORD *)v335;
        HIDWORD(v316) = *(_QWORD *)(v335 + 8);
        v63 = *(_QWORD *)(v335 + 16);
        LOBYTE(v325) = 0;
        v328 = 63;
        LODWORD(v317) = v63;
        goto LABEL_85;
      case 17:
        if ( (unsigned int)v336 <= 3 )
        {
          v333 = 1;
          v162 = "Invalid cmp constexpt record";
        }
        else
        {
          v109 = sub_9CAD80(v5, *(_QWORD *)v335);
          v110 = v109;
          if ( v109 )
          {
            LODWORD(v316) = *(_QWORD *)(v335 + 8);
            HIDWORD(v316) = *(_QWORD *)(v335 + 16);
            v111 = *(_BYTE *)(v109 + 8);
            if ( (unsigned int)v111 - 17 <= 1 )
              v111 = *(_BYTE *)(**(_QWORD **)(v110 + 16) + 8LL);
            v112 = 54;
            if ( v111 > 3u && v111 != 5 )
              v112 = ((v111 & 0xFD) == 4) + 53;
            v113 = *(_QWORD *)(v335 + 24);
            LOBYTE(v325) = 0;
            LOBYTE(v328) = v112;
            v39 = v5 + 81;
            v40 = 2;
            BYTE1(v328) = v113;
            HIDWORD(v328) = 0;
            v329 = 0;
            LOBYTE(v334) = 0;
            goto LABEL_51;
          }
          v333 = 1;
          v162 = "Invalid cmp constexpr record";
        }
        goto LABEL_267;
      case 18:
        if ( (unsigned int)v336 <= 1 )
          goto LABEL_266;
        v100 = &v318;
        v317 = 0;
        v321 = (unsigned __int64)&v323;
        v316 = (unsigned __int64)&v318;
        LOBYTE(v318) = 0;
        v322 = 0;
        LOBYTE(v323) = 0;
        v101 = *(_QWORD *)(v335 + 8);
        v303 = *(_QWORD *)v335 & 1;
        v102 = (unsigned int)(v101 + 2);
        v217 = *(_QWORD *)v335 >> 1 != 0;
        v288 = v102;
        if ( (unsigned int)v102 >= (unsigned int)v336 )
          goto LABEL_358;
        v103 = v101 + 3;
        v216 = *(_QWORD *)(v335 + 8 * v102);
        v221 = v101 + 3 + v216;
        if ( v221 > (unsigned int)v336 )
          goto LABEL_358;
        if ( (_DWORD)v101 )
        {
          v104 = *(_BYTE *)(v335 + 16);
          v105 = 0;
          v106 = 3;
          v107 = 1;
          while ( 1 )
          {
            *(_BYTE *)(v316 + v105) = v104;
            v317 = v107;
            *(_BYTE *)(v316 + v107) = 0;
            if ( v288 == v106 )
              break;
            v105 = v317;
            v104 = *(_BYTE *)(v335 + 8LL * (unsigned int)v106);
            v107 = v317 + 1;
            if ( (unsigned __int64 *)v316 == v100 )
              v108 = 15;
            else
              v108 = v318;
            ++v106;
            if ( v108 < v107 )
            {
              v225 = v100;
              v229 = v317 + 1;
              v234 = v106;
              v240 = v104;
              v249 = v317;
              sub_2240BB0(&v316, v317, 0, 0, 1);
              v100 = v225;
              v107 = v229;
              v106 = v234;
              v104 = v240;
              v105 = v249;
            }
          }
        }
        if ( (_DWORD)v216 )
        {
          v252 = v4;
          v242 = v3;
          do
          {
            v147 = v322;
            v148 = 15;
            v149 = *(_QWORD *)(v335 + 8LL * v103);
            v150 = v321;
            v151 = v322 + 1;
            if ( (unsigned __int64 *)v321 != &v323 )
              v148 = v323;
            if ( v151 > v148 )
            {
              srce = *(void **)(v335 + 8LL * v103);
              sub_2240BB0(&v321, v322, 0, 0, 1);
              v150 = v321;
              LOBYTE(v149) = (_BYTE)srce;
            }
            *(_BYTE *)(v150 + v147) = v149;
            ++v103;
            v322 = v151;
            *(_BYTE *)(v321 + v147 + 1) = 0;
          }
          while ( v221 != v103 );
          v4 = v252;
          v3 = v242;
        }
        sub_A848E0(&v316);
        if ( !v302 )
          goto LABEL_387;
        v207 = 0;
        v206 = 0;
        goto LABEL_240;
      case 19:
        v114 = 0;
        if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 <= 1 )
          v114 = v306;
        v115 = sub_9CAD80(v5, *(_QWORD *)v335);
        if ( !v115 || (unsigned int)*(unsigned __int8 *)(v115 + 8) - 17 > 1 || (unsigned int)v336 <= 3 || !v114 )
        {
LABEL_373:
          v333 = 1;
          v162 = "Invalid shufflevector constexpr record";
          goto LABEL_267;
        }
        LODWORD(v316) = *(_QWORD *)(v335 + 8);
        HIDWORD(v316) = *(_QWORD *)(v335 + 16);
        v116 = *(_QWORD *)(v335 + 24);
        LOBYTE(v325) = 0;
        LODWORD(v317) = v116;
        v328 = 63;
        goto LABEL_85;
      case 21:
        if ( (unsigned int)v336 > 2 && sub_9CAD80(v5, *(_QWORD *)v335) )
        {
          LODWORD(v321) = *(_QWORD *)(v335 + 8);
          v77 = *(_QWORD *)(v335 + 16);
          LODWORD(v328) = 250;
          v329 = 0;
          HIDWORD(v328) = v77;
          LOBYTE(v334) = 0;
          v78 = sub_9D1FB0(v5 + 81, v306, (__int16 *)&v328, &v321, 1);
          v35 = v78;
          if ( (_BYTE)v334 )
          {
            v286 = v78;
            sub_9963D0((__int64)&v330);
            v35 = v286;
          }
          goto LABEL_43;
        }
        v333 = 1;
        v162 = "Invalid blockaddress record";
        goto LABEL_267;
      case 22:
        if ( !(_DWORD)v336 )
        {
          v333 = 1;
          v162 = "Invalid data record";
          goto LABEL_267;
        }
        v283 = *(_QWORD *)(v306 + 24);
        if ( (unsigned __int8)sub_BCAC40(v283, 8) )
        {
          v51 = (unsigned int)v336;
          v329 = 0;
          v284 = (__int64 *)v331;
          v52 = v335;
          v328 = (__int64)v331;
          v330 = 16;
          if ( (unsigned int)v336 > 0x10uLL )
          {
            srcj = (void *)v335;
            nh = (unsigned int)v336;
            sub_C8D290(&v328, v331, (unsigned int)v336, 1);
            v51 = nh;
            v52 = (__int64)srcj;
            v53 = (char *)(v328 + v329);
          }
          else
          {
            v53 = v331;
            if ( !(8LL * (unsigned int)v336) )
            {
LABEL_71:
              v55 = v329 + v51;
              v329 = v55;
              v56 = v5[54];
              if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 <= 1 )
              {
                v32 = v328;
                v35 = sub_AC99A0(v56, v328, v55);
                goto LABEL_107;
              }
              na = v55;
              srcb = (void *)v328;
              v188 = sub_BCD140(v56, 8);
              v189 = na;
LABEL_327:
              sub_BCD420(v188, v189);
              v32 = na;
              v35 = sub_AC9630(srcb, na);
              goto LABEL_107;
            }
          }
          v54 = 0;
          do
          {
            v53[v54] = *(_QWORD *)(v52 + 8 * v54);
            ++v54;
          }
          while ( v51 != v54 );
          goto LABEL_71;
        }
        if ( (unsigned __int8)sub_BCAC40(v283, 16) )
        {
          v165 = (unsigned int)v336;
          v329 = 0;
          v284 = (__int64 *)v331;
          v166 = v335;
          v328 = (__int64)v331;
          v330 = 16;
          if ( (unsigned int)v336 > 0x10uLL )
          {
            srck = (void *)v335;
            nj = (unsigned int)v336;
            sub_C8D290(&v328, v331, (unsigned int)v336, 2);
            v165 = nj;
            v166 = (__int64)srck;
            v167 = (char *)(v328 + 2 * v329);
          }
          else
          {
            v167 = v331;
            if ( !(8LL * (unsigned int)v336) )
            {
LABEL_278:
              v169 = v329 + v165;
              v329 = v169;
              v170 = v5[54];
              if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 <= 1 )
              {
                v32 = v328;
                v35 = sub_AC99E0(v170, v328);
                goto LABEL_107;
              }
              ni = v169;
              srcb = (void *)v328;
              v188 = sub_BCD140(v170, 16);
              v189 = ni;
              na = 2 * ni;
              goto LABEL_327;
            }
          }
          v168 = 0;
          do
          {
            *(_WORD *)&v167[v168] = *(_QWORD *)(v166 + 4 * v168);
            v168 += 2;
          }
          while ( v168 != 2 * v165 );
          goto LABEL_278;
        }
        if ( (unsigned __int8)sub_BCAC40(v283, 32) )
        {
          v328 = (__int64)&v330;
          v329 = 0x1000000000LL;
          sub_9C9520((__int64)&v328, v335, v335 + 8LL * (unsigned int)v336);
          if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 <= 1 )
          {
            v32 = v328;
            v35 = sub_AC9A10(v5[54], v328, (unsigned int)v329);
            goto LABEL_324;
          }
          v299 = (unsigned int)v329;
          srcc = (void *)v328;
          v201 = sub_BCD140(v5[54], 32);
          v202 = v299;
          v203 = v201;
          v204 = 4 * v299;
        }
        else
        {
          if ( !(unsigned __int8)sub_BCAC40(v283, 64) )
          {
            v196 = *(_BYTE *)(v283 + 8);
            if ( v196 < 2u )
            {
              nb = v283;
              v329 = 0;
              v330 = 16;
              v284 = (__int64 *)v331;
              v328 = (__int64)v331;
              sub_9CC180(&v328, v335, v335 + 8LL * (unsigned int)v336);
              v32 = v328;
              if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 > 1 )
                v35 = sub_AC9910(nb, v328, v329);
              else
                v35 = sub_AC9A90(nb, v328, v329);
              goto LABEL_107;
            }
            if ( v196 == 2 )
            {
              v328 = (__int64)&v330;
              v329 = 0x1000000000LL;
              sub_9C9520((__int64)&v328, v335, v335 + 8LL * (unsigned int)v336);
              v32 = v328;
              if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 > 1 )
                v35 = sub_AC9940(v283, v328, (unsigned int)v329);
              else
                v35 = sub_AC9AC0(v283, v328, (unsigned int)v329);
            }
            else
            {
              if ( v196 != 3 )
              {
                v333 = 1;
                v162 = "Invalid type for value";
                goto LABEL_267;
              }
              v328 = (__int64)&v330;
              v329 = 0x1000000000LL;
              sub_9CC210((__int64)&v328, (_BYTE *)v335, (_BYTE *)(v335 + 8LL * (unsigned int)v336));
              v32 = v328;
              if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 > 1 )
                v35 = sub_AC9970(v283, v328, (unsigned int)v329);
              else
                v35 = sub_AC9AF0(v283, v328, (unsigned int)v329);
            }
LABEL_324:
            v34 = v328;
            if ( (__int64 *)v328 == &v330 )
              goto LABEL_43;
            goto LABEL_108;
          }
          v328 = (__int64)&v330;
          v329 = 0x1000000000LL;
          sub_9CC210((__int64)&v328, (_BYTE *)v335, (_BYTE *)(v335 + 8LL * (unsigned int)v336));
          if ( (unsigned int)*(unsigned __int8 *)(v306 + 8) - 17 <= 1 )
          {
            v32 = v328;
            v35 = sub_AC9A50(v5[54], v328, (unsigned int)v329);
            goto LABEL_324;
          }
          v301 = (unsigned int)v329;
          srcc = (void *)v328;
          v205 = sub_BCD140(v5[54], 64);
          v202 = v301;
          v203 = v205;
          v204 = 8 * v301;
        }
        v300 = v204;
        sub_BCD420(v203, v202);
        v32 = v300;
        v35 = sub_AC9630(srcc, v300);
        goto LABEL_324;
      case 23:
        if ( (unsigned int)v336 <= 1 )
          goto LABEL_266;
        v42 = &v318;
        v317 = 0;
        v321 = (unsigned __int64)&v323;
        v316 = (unsigned __int64)&v318;
        LOBYTE(v318) = 0;
        v322 = 0;
        LOBYTE(v323) = 0;
        v303 = *(_QWORD *)v335 & 1;
        v214 = *(_QWORD *)v335 >> 2;
        v43 = *(_QWORD *)(v335 + 8);
        v217 = (*(_QWORD *)v335 & 2LL) != 0;
        v44 = (unsigned int)(v43 + 2);
        v282 = v44;
        if ( (unsigned int)v44 >= (unsigned int)v336 )
          goto LABEL_358;
        v45 = v43 + 3;
        v211 = *(_QWORD *)(v335 + 8 * v44);
        v219 = v43 + 3 + v211;
        if ( v219 > (unsigned int)v336 )
          goto LABEL_358;
        if ( (_DWORD)v43 )
        {
          v46 = *(_BYTE *)(v335 + 16);
          v47 = 0;
          v48 = 3;
          v49 = 1;
          while ( 1 )
          {
            *(_BYTE *)(v316 + v47) = v46;
            v317 = v49;
            *(_BYTE *)(v316 + v49) = 0;
            if ( v282 == v48 )
              break;
            v47 = v317;
            v46 = *(_BYTE *)(v335 + 8LL * (unsigned int)v48);
            v49 = v317 + 1;
            if ( (unsigned __int64 *)v316 == v42 )
              v50 = 15;
            else
              v50 = v318;
            ++v48;
            if ( v50 < v49 )
            {
              v223 = v42;
              v227 = v317 + 1;
              v232 = v48;
              v238 = v46;
              v247 = v317;
              sub_2240BB0(&v316, v317, 0, 0, 1);
              v42 = v223;
              v49 = v227;
              v48 = v232;
              v46 = v238;
              v47 = v247;
            }
          }
        }
        if ( (_DWORD)v211 )
        {
          v253 = v4;
          v243 = v3;
          do
          {
            v152 = v322;
            v153 = 15;
            v154 = *(_QWORD *)(v335 + 8LL * v45);
            v155 = v321;
            v156 = v322 + 1;
            if ( (unsigned __int64 *)v321 != &v323 )
              v153 = v323;
            if ( v156 > v153 )
            {
              srcg = *(void **)(v335 + 8LL * v45);
              sub_2240BB0(&v321, v322, 0, 0, 1);
              v155 = v321;
              LOBYTE(v154) = (_BYTE)srcg;
            }
            *(_BYTE *)(v155 + v152) = v154;
            ++v45;
            v322 = v156;
            *(_BYTE *)(v321 + v152 + 1) = 0;
          }
          while ( v219 != v45 );
          v4 = v253;
          v3 = v243;
        }
        sub_A848E0(&v316);
        if ( !v302 )
          goto LABEL_387;
        v207 = 0;
        goto LABEL_251;
      case 25:
        if ( (unsigned int)v336 > 1 )
        {
          v57 = v306;
          v79 = sub_9C3C60(*(_DWORD *)v335, v306);
          if ( v79 < 0 )
            goto LABEL_262;
          v81 = *(_QWORD *)(v80 + 8);
          LOBYTE(v325) = 0;
          LOBYTE(v328) = v79;
          LODWORD(v316) = v81;
          goto LABEL_50;
        }
        v333 = 1;
        v162 = "Invalid unary op constexpr record";
        goto LABEL_267;
      case 26:
        goto LABEL_42;
      case 27:
        if ( (unsigned int)v336 > 1 && sub_9CAD80(v5, *(_QWORD *)v335) )
        {
          v126 = *(_QWORD *)(v335 + 8);
          LOBYTE(v325) = 0;
          v328 = 251;
          LODWORD(v316) = v126;
          goto LABEL_137;
        }
        v333 = 1;
        v162 = "Invalid dso_local record";
        break;
      case 28:
        if ( (unsigned int)v336 <= 1 )
          goto LABEL_266;
        v117 = &v318;
        v317 = 0;
        v316 = (unsigned __int64)&v318;
        LOBYTE(v318) = 0;
        v321 = (unsigned __int64)&v323;
        v322 = 0;
        LOBYTE(v323) = 0;
        v303 = *(_QWORD *)v335 & 1;
        v217 = (*(_QWORD *)v335 & 2LL) != 0;
        v213 = (*(_QWORD *)v335 & 8LL) != 0;
        v118 = *(_QWORD *)(v335 + 8);
        LODWORD(v214) = (*(_QWORD *)v335 >> 2) & 1;
        v119 = (unsigned int)(v118 + 2);
        v289 = v119;
        if ( (unsigned int)v119 >= (unsigned int)v336
          || (v120 = v118 + 3, v210 = *(_QWORD *)(v335 + 8 * v119), v222 = v118 + 3 + v210, v222 > (unsigned int)v336) )
        {
LABEL_358:
          v333 = 1;
          v8 = v5 + 1;
          v328 = (__int64)"Invalid inlineasm record";
          v332 = 3;
          sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v328);
        }
        else
        {
          if ( (_DWORD)v118 )
          {
            v121 = *(_BYTE *)(v335 + 16);
            v122 = 0;
            v123 = 3;
            v124 = 1;
            while ( 1 )
            {
              *(_BYTE *)(v316 + v122) = v121;
              v317 = v124;
              *(_BYTE *)(v316 + v124) = 0;
              if ( v289 == v123 )
                break;
              v122 = v317;
              v121 = *(_BYTE *)(v335 + 8LL * (unsigned int)v123);
              v124 = v317 + 1;
              if ( (unsigned __int64 *)v316 == v117 )
                v125 = 15;
              else
                v125 = v318;
              ++v123;
              if ( v124 > v125 )
              {
                v226 = v117;
                v230 = v317 + 1;
                v235 = v123;
                v241 = v121;
                v250 = v317;
                sub_2240BB0(&v316, v317, 0, 0, 1);
                v117 = v226;
                v124 = v230;
                v123 = v235;
                v121 = v241;
                v122 = v250;
              }
            }
          }
          if ( (_DWORD)v210 )
          {
            v254 = v4;
            v244 = v3;
            do
            {
              v157 = v322;
              v158 = 15;
              v159 = *(_QWORD *)(v335 + 8LL * v120);
              v160 = v321;
              v161 = v322 + 1;
              if ( (unsigned __int64 *)v321 != &v323 )
                v158 = v323;
              if ( v161 > v158 )
              {
                srch = *(void **)(v335 + 8LL * v120);
                sub_2240BB0(&v321, v322, 0, 0, 1);
                v160 = v321;
                LOBYTE(v159) = (_BYTE)srch;
              }
              *(_BYTE *)(v160 + v157) = v159;
              ++v120;
              v322 = v161;
              *(_BYTE *)(v321 + v157 + 1) = 0;
            }
            while ( v222 != v120 );
            v4 = v254;
            v3 = v244;
          }
          sub_A848E0(&v316);
          if ( v302 )
          {
            v207 = v213;
LABEL_251:
            v206 = v214;
LABEL_240:
            srcf = (void *)sub_B41A60(v302, v316, v317, v321, v322, v303 & 1, v217, v206, v207);
            sub_2240A30(&v321);
            sub_2240A30(&v316);
            v35 = (__int64)srcf;
            goto LABEL_43;
          }
LABEL_387:
          v333 = 1;
          v8 = v5 + 1;
          v328 = (__int64)"Missing element type for old-style inlineasm";
          v332 = 3;
          sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v328);
        }
        sub_2240A30(&v321);
        sub_2240A30(&v316);
        goto LABEL_45;
      case 29:
        if ( (unsigned int)v336 > 1 && sub_9CAD80(v5, *(_QWORD *)v335) )
        {
          v98 = *(_QWORD *)(v335 + 8);
          LOBYTE(v325) = 0;
          v328 = 252;
          LODWORD(v316) = v98;
LABEL_137:
          v329 = 0;
          v39 = v5 + 81;
          v334 = 0;
          v40 = 1;
          goto LABEL_51;
        }
        v333 = 1;
        v162 = "Invalid no_cfi record";
        break;
      case 30:
        if ( (unsigned int)v336 <= 2
          || (v86 = sub_9CAD80(v5, *(_QWORD *)v335), v220 = v86, !v86)
          || *(_BYTE *)(v86 + 8) != 13 )
        {
LABEL_266:
          v333 = 1;
          v162 = "Invalid inlineasm record";
          goto LABEL_267;
        }
        v87 = &v318;
        v317 = 0;
        v316 = (unsigned __int64)&v318;
        LOBYTE(v318) = 0;
        v321 = (unsigned __int64)&v323;
        v322 = 0;
        LOBYTE(v323) = 0;
        v88 = *(_QWORD *)(v335 + 8);
        v218 = v88 & 1;
        v215 = (v88 & 2) != 0;
        v89 = v88 >> 2;
        v209 = (v88 & 8) != 0;
        v90 = *(_QWORD *)(v335 + 16);
        v212 = v89 & 1;
        v91 = (unsigned int)(v90 + 3);
        v287 = v91;
        if ( (unsigned int)v91 < (unsigned int)v336 )
        {
          v92 = v90 + 4;
          v208 = *(_QWORD *)(v335 + 8 * v91);
          v304 = v90 + 4 + v208;
          if ( v304 <= (unsigned int)v336 )
          {
            if ( (_DWORD)v90 )
            {
              v93 = *(_BYTE *)(v335 + 24);
              v94 = 0;
              v95 = 4;
              v96 = 1;
              while ( 1 )
              {
                *(_BYTE *)(v316 + v94) = v93;
                v317 = v96;
                *(_BYTE *)(v316 + v96) = 0;
                if ( v287 == v95 )
                  break;
                v94 = v317;
                v93 = *(_BYTE *)(v335 + 8LL * (unsigned int)v95);
                v96 = v317 + 1;
                if ( (unsigned __int64 *)v316 == v87 )
                  v97 = 15;
                else
                  v97 = v318;
                ++v95;
                if ( v96 > v97 )
                {
                  v233 = v95;
                  v224 = v87;
                  v228 = v92;
                  v239 = v93;
                  v248 = v317;
                  sub_2240BB0(&v316, v317, 0, 0, 1);
                  v87 = v224;
                  v92 = v228;
                  v95 = v233;
                  v93 = v239;
                  v94 = v248;
                }
              }
            }
            if ( (_DWORD)v208 )
            {
              v178 = v92;
              v255 = v4;
              v245 = v3;
              do
              {
                v179 = v322;
                v180 = 15;
                v181 = *(_QWORD *)(v335 + 8LL * v178);
                v182 = v321;
                v183 = v322 + 1;
                if ( (unsigned __int64 *)v321 != &v323 )
                  v180 = v323;
                if ( v183 > v180 )
                {
                  srci = *(void **)(v335 + 8LL * v178);
                  sub_2240BB0(&v321, v322, 0, 0, 1);
                  v182 = v321;
                  LOBYTE(v181) = (_BYTE)srci;
                }
                *(_BYTE *)(v182 + v179) = v181;
                ++v178;
                v322 = v183;
                *(_BYTE *)(v321 + v179 + 1) = 0;
              }
              while ( v304 != v178 );
              v4 = v255;
              v3 = v245;
            }
            sub_A848E0(&v316);
            ng = sub_B41A60(v220, v316, v317, v321, v322, v218 & 1, v215, v212, v209);
            sub_2240A30(&v321);
            sub_2240A30(&v316);
            v35 = ng;
            goto LABEL_43;
          }
        }
        v333 = 1;
        v8 = v5 + 1;
        v328 = (__int64)"Invalid inlineasm record";
        v332 = 3;
        sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v328);
        sub_2240A30(&v321);
        sub_2240A30(&v316);
        goto LABEL_45;
      case 33:
        if ( (unsigned int)v336 > 3 )
        {
          v39 = v5 + 81;
          v40 = 4;
          LODWORD(v316) = *(_QWORD *)v335;
          HIDWORD(v316) = *(_QWORD *)(v335 + 8);
          LODWORD(v317) = *(_QWORD *)(v335 + 16);
          v67 = *(_QWORD *)(v335 + 24);
          LOBYTE(v325) = 0;
          HIDWORD(v317) = v67;
          v328 = 249;
          v329 = 0;
          v334 = 0;
          goto LABEL_51;
        }
        v333 = 1;
        v162 = "Invalid ptrauth record";
        goto LABEL_267;
      default:
        v35 = sub_ACA8A0(v306);
        goto LABEL_43;
    }
    break;
  }
LABEL_267:
  v8 = v5 + 1;
  v328 = (__int64)v162;
  v332 = 3;
  sub_9C81F0(v3, (__int64)(v5 + 1), (__int64)&v328);
  goto LABEL_45;
}
