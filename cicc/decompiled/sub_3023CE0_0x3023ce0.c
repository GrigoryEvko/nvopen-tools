// Function: sub_3023CE0
// Address: 0x3023ce0
//
_BYTE *__fastcall sub_3023CE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // r12
  __m128i *v7; // rdx
  unsigned int v8; // ebx
  __m128i si128; // xmm0
  __int64 v10; // r14
  size_t v11; // rax
  char *v12; // rdi
  unsigned __int8 *v13; // rsi
  size_t v14; // rdx
  unsigned __int64 v15; // rax
  char *v16; // rdx
  unsigned __int64 v17; // rax
  char *v18; // rsi
  size_t v19; // rax
  char *v20; // rdi
  size_t v21; // rdx
  unsigned __int64 v22; // rax
  char *v23; // rdx
  unsigned __int64 v24; // rax
  void *v25; // rdx
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rax
  __int64 v30; // rax
  unsigned int v31; // ecx
  __int64 v32; // rdi
  _BYTE *v33; // rax
  __int64 v34; // r8
  _BYTE *v35; // rax
  _QWORD *v36; // rdx
  __int64 v37; // rdx
  size_t v38; // rdx
  unsigned __int8 *v39; // rsi
  __int64 v40; // r13
  __int64 v41; // r14
  int v42; // eax
  int v43; // r14d
  _BYTE *v44; // rax
  void *v45; // rdx
  _WORD *v46; // rdx
  char *v47; // rsi
  _BYTE *v48; // rax
  _BYTE *result; // rax
  __int64 v50; // rax
  _BYTE *v51; // rsi
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  unsigned __int8 *src; // [rsp+0h] [rbp-70h]
  char *srca; // [rsp+0h] [rbp-70h]
  char *srcb; // [rsp+0h] [rbp-70h]
  void *srcc; // [rsp+0h] [rbp-70h]
  __int64 v61; // [rsp+10h] [rbp-60h] BYREF
  int v62; // [rsp+18h] [rbp-58h]
  unsigned __int8 *v63; // [rsp+20h] [rbp-50h] BYREF
  __int64 v64; // [rsp+28h] [rbp-48h]
  char v65[64]; // [rsp+30h] [rbp-40h] BYREF

  v6 = a3;
  v7 = *(__m128i **)(a3 + 32);
  v8 = *(_DWORD *)(a4 + 336);
  if ( *(_QWORD *)(v6 + 24) - (_QWORD)v7 <= 0x40u )
  {
    v10 = sub_CB6200(v6, "//\n// Generated by NVIDIA NVVM Compiler\n//\n// Compiler Build ID: ", 0x41u);
  }
  else
  {
    si128 = _mm_load_si128((const __m128i *)&xmmword_44C2D80);
    v7[4].m128i_i8[0] = 32;
    v10 = v6;
    *v7 = si128;
    v7[1] = _mm_load_si128((const __m128i *)&xmmword_44C2D90);
    v7[2] = _mm_load_si128((const __m128i *)&xmmword_44C2DA0);
    v7[3] = _mm_load_si128((const __m128i *)&xmmword_44C2DB0);
    *(_QWORD *)(v6 + 32) += 65LL;
  }
  if ( !off_4C5D108 )
    goto LABEL_47;
  src = (unsigned __int8 *)off_4C5D108;
  v11 = strlen((const char *)off_4C5D108);
  v12 = *(char **)(v10 + 32);
  v13 = src;
  v14 = v11;
  v15 = *(_QWORD *)(v10 + 24) - (_QWORD)v12;
  if ( v14 > v15 )
  {
    v10 = sub_CB6200(v10, src, v14);
LABEL_47:
    v12 = *(char **)(v10 + 32);
    v15 = *(_QWORD *)(v10 + 24) - (_QWORD)v12;
    goto LABEL_48;
  }
  if ( v14 )
  {
    srca = (char *)v14;
    memcpy(v12, v13, v14);
    v16 = &srca[*(_QWORD *)(v10 + 32)];
    v17 = *(_QWORD *)(v10 + 24) - (_QWORD)v16;
    *(_QWORD *)(v10 + 32) = v16;
    v12 = v16;
    if ( v17 <= 3 )
      goto LABEL_7;
    goto LABEL_49;
  }
LABEL_48:
  if ( v15 <= 3 )
  {
LABEL_7:
    v10 = sub_CB6200(v10, "\n// ", 4u);
    v18 = (char *)off_4C5D100;
    if ( off_4C5D100 )
      goto LABEL_8;
LABEL_50:
    v20 = *(char **)(v10 + 32);
    v22 = *(_QWORD *)(v10 + 24) - (_QWORD)v20;
    goto LABEL_51;
  }
LABEL_49:
  *(_DWORD *)v12 = 539963146;
  *(_QWORD *)(v10 + 32) += 4LL;
  v18 = (char *)off_4C5D100;
  if ( !off_4C5D100 )
    goto LABEL_50;
LABEL_8:
  v19 = strlen(v18);
  v20 = *(char **)(v10 + 32);
  v21 = v19;
  v22 = *(_QWORD *)(v10 + 24) - (_QWORD)v20;
  if ( v21 > v22 )
  {
    v10 = sub_CB6200(v10, (unsigned __int8 *)v18, v21);
    goto LABEL_50;
  }
  if ( v21 )
  {
    srcb = (char *)v21;
    memcpy(v20, v18, v21);
    v23 = &srcb[*(_QWORD *)(v10 + 32)];
    v24 = *(_QWORD *)(v10 + 24) - (_QWORD)v23;
    *(_QWORD *)(v10 + 32) = v23;
    v20 = v23;
    if ( v24 <= 0xC )
      goto LABEL_11;
    goto LABEL_52;
  }
LABEL_51:
  if ( v22 <= 0xC )
  {
LABEL_11:
    v10 = sub_CB6200(v10, "\n// Based on ", 0xDu);
    v25 = *(void **)(v10 + 32);
    if ( *(_QWORD *)(v10 + 24) - (_QWORD)v25 > 0xAu )
      goto LABEL_12;
    goto LABEL_53;
  }
LABEL_52:
  qmemcpy(v20, "\n// Based on ", 13);
  v25 = (void *)(*(_QWORD *)(v10 + 32) + 13LL);
  v50 = *(_QWORD *)(v10 + 24);
  *(_QWORD *)(v10 + 32) = v25;
  if ( (unsigned __int64)(v50 - (_QWORD)v25) > 0xA )
  {
LABEL_12:
    qmemcpy(v25, "NVVM 20.0.0", 11);
    v26 = *(_QWORD *)(v10 + 32) + 11LL;
    v27 = *(_QWORD *)(v10 + 24);
    *(_QWORD *)(v10 + 32) = v26;
    if ( (unsigned __int64)(v27 - v26) > 4 )
      goto LABEL_13;
LABEL_54:
    v10 = sub_CB6200(v10, "\n//\n\n", 5u);
    v28 = *(_QWORD *)(v10 + 32);
    if ( (unsigned __int64)(*(_QWORD *)(v10 + 24) - v28) > 8 )
      goto LABEL_14;
    goto LABEL_55;
  }
LABEL_53:
  v10 = sub_CB6200(v10, "NVVM 20.0.0", 0xBu);
  v26 = *(_QWORD *)(v10 + 32);
  if ( (unsigned __int64)(*(_QWORD *)(v10 + 24) - v26) <= 4 )
    goto LABEL_54;
LABEL_13:
  *(_DWORD *)v26 = 170864394;
  *(_BYTE *)(v26 + 4) = 10;
  v28 = *(_QWORD *)(v10 + 32) + 5LL;
  v29 = *(_QWORD *)(v10 + 24);
  *(_QWORD *)(v10 + 32) = v28;
  if ( (unsigned __int64)(v29 - v28) > 8 )
  {
LABEL_14:
    *(_BYTE *)(v28 + 8) = 32;
    *(_QWORD *)v28 = 0x6E6F69737265762ELL;
    *(_QWORD *)(v10 + 32) += 9LL;
    goto LABEL_15;
  }
LABEL_55:
  v10 = sub_CB6200(v10, ".version ", 9u);
LABEL_15:
  v30 = sub_CB59D0(v10, v8 / 0xAuLL);
  v31 = v8;
  v32 = v30;
  v33 = *(_BYTE **)(v30 + 32);
  if ( *(_BYTE **)(v32 + 24) == v33 )
  {
    v52 = sub_CB6200(v32, (unsigned __int8 *)".", 1u);
    v31 = v8;
    v32 = v52;
  }
  else
  {
    *v33 = 46;
    ++*(_QWORD *)(v32 + 32);
  }
  v34 = sub_CB59D0(v32, v8 - 10 * (v31 / 0xA));
  v35 = *(_BYTE **)(v34 + 32);
  if ( *(_BYTE **)(v34 + 24) == v35 )
  {
    v53 = sub_CB6200(v34, (unsigned __int8 *)"\n", 1u);
    v36 = *(_QWORD **)(v53 + 32);
    v34 = v53;
  }
  else
  {
    *v35 = 10;
    v36 = (_QWORD *)(*(_QWORD *)(v34 + 32) + 1LL);
    *(_QWORD *)(v34 + 32) = v36;
  }
  if ( *(_QWORD *)(v34 + 24) - (_QWORD)v36 <= 7u )
  {
    v34 = sub_CB6200(v34, ".target ", 8u);
  }
  else
  {
    *v36 = 0x207465677261742ELL;
    *(_QWORD *)(v34 + 32) += 8LL;
  }
  v37 = *(_QWORD *)(a4 + 312);
  if ( v37 )
  {
    v51 = *(_BYTE **)(a4 + 304);
    srcc = (void *)v34;
    v63 = (unsigned __int8 *)v65;
    sub_3020560((__int64 *)&v63, v51, (__int64)&v51[v37]);
    v39 = v63;
    v38 = v64;
    v34 = (__int64)srcc;
  }
  else
  {
    v38 = 5;
    v63 = (unsigned __int8 *)v65;
    v39 = (unsigned __int8 *)v65;
    strcpy(v65, "sm_30");
    v64 = 5;
  }
  sub_CB6200(v34, v39, v38);
  if ( v63 != (unsigned __int8 *)v65 )
    j_j___libc_free_0((unsigned __int64)v63);
  v40 = *(_QWORD *)(a1 + 200);
  if ( !*(_DWORD *)(v40 + 1280) )
    sub_904010(v6, ", texmode_independent");
  v41 = sub_BA8DC0(a2, (__int64)"llvm.dbg.cu", 11);
  v42 = 0;
  if ( v41 )
    v42 = sub_B91A00(v41);
  LODWORD(v64) = v42;
  v63 = (unsigned __int8 *)v41;
  sub_BA95A0((__int64)&v63);
  v61 = v41;
  v62 = 0;
  sub_BA95A0((__int64)&v61);
  v43 = v64;
  LODWORD(v64) = v62;
  v63 = (unsigned __int8 *)v61;
  if ( v62 != v43 )
  {
    while ( (unsigned int)(*(_DWORD *)(sub_BA9580((__int64)&v63) + 32) - 1) > 1 )
    {
      LODWORD(v64) = v64 + 1;
      sub_BA95A0((__int64)&v63);
      if ( (_DWORD)v64 == v43 )
        goto LABEL_34;
    }
    sub_904010(v6, ", debug");
  }
LABEL_34:
  v44 = *(_BYTE **)(v6 + 32);
  if ( *(_BYTE **)(v6 + 24) == v44 )
  {
    v55 = sub_CB6200(v6, (unsigned __int8 *)"\n", 1u);
    v45 = *(void **)(v55 + 32);
    v6 = v55;
  }
  else
  {
    *v44 = 10;
    v45 = (void *)(*(_QWORD *)(v6 + 32) + 1LL);
    *(_QWORD *)(v6 + 32) = v45;
  }
  if ( *(_QWORD *)(v6 + 24) - (_QWORD)v45 <= 0xDu )
  {
    v54 = sub_CB6200(v6, ".address_size ", 0xEu);
    v46 = *(_WORD **)(v54 + 32);
    v6 = v54;
  }
  else
  {
    qmemcpy(v45, ".address_size ", 14);
    v46 = (_WORD *)(*(_QWORD *)(v6 + 32) + 14LL);
    *(_QWORD *)(v6 + 32) = v46;
  }
  v47 = "64";
  if ( !*(_BYTE *)(v40 + 1264) )
    v47 = "32";
  if ( *(_QWORD *)(v6 + 24) - (_QWORD)v46 > 1u )
  {
    *v46 = *(_WORD *)v47;
    v48 = (_BYTE *)(*(_QWORD *)(v6 + 32) + 2LL);
    *(_QWORD *)(v6 + 32) = v48;
  }
  else
  {
    v6 = sub_CB6200(v6, (unsigned __int8 *)v47, 2u);
    v48 = *(_BYTE **)(v6 + 32);
  }
  if ( v48 == *(_BYTE **)(v6 + 24) )
  {
    v6 = sub_CB6200(v6, (unsigned __int8 *)"\n", 1u);
    result = *(_BYTE **)(v6 + 32);
  }
  else
  {
    *v48 = 10;
    result = (_BYTE *)(*(_QWORD *)(v6 + 32) + 1LL);
    *(_QWORD *)(v6 + 32) = result;
  }
  if ( result == *(_BYTE **)(v6 + 24) )
    return (_BYTE *)sub_CB6200(v6, (unsigned __int8 *)"\n", 1u);
  *result = 10;
  ++*(_QWORD *)(v6 + 32);
  return result;
}
