// Function: sub_91DF90
// Address: 0x91df90
//
__int64 __fastcall sub_91DF90(__int64 *a1, const __m128i *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  const __m128i *v5; // r15
  __int64 v7; // r12
  unsigned __int64 v9; // rbx
  size_t v10; // r12
  size_t v11; // rbx
  __int64 v12; // rax
  unsigned __int64 v13; // r13
  char *v14; // r14
  size_t v15; // r12
  size_t v16; // r13
  __int64 v17; // rdi
  __int64 j; // rax
  unsigned __int8 v19; // bl
  __int64 v20; // rdx
  __int8 v21; // al
  __int64 v22; // r13
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r13
  __int64 v26; // rax
  char v27; // dl
  __int64 v28; // rcx
  unsigned __int64 v29; // r14
  char v30; // al
  __int64 v31; // rax
  char v32; // dl
  int v33; // eax
  unsigned __int64 v34; // rbx
  int v35; // r13d
  bool i; // r14
  __int64 v37; // rax
  __int64 v38; // rcx
  unsigned __int64 v39; // rax
  __int64 v40; // rax
  char v41; // r14
  __int64 v42; // r15
  _BYTE *v43; // rdi
  __int64 v44; // rax
  const char *v45; // rdx
  __int64 v46; // r13
  size_t v47; // rbx
  __int64 v48; // rax
  unsigned __int64 v49; // r13
  char v50; // bl
  int v51; // r13d
  unsigned __int64 v52; // r14
  __int64 v53; // rdi
  __int64 *v54; // r13
  __int64 v55; // r12
  __int64 v56; // rax
  char *k; // rbx
  __int64 v58; // r14
  __int64 v59; // rsi
  __int64 v60; // rdi
  __int64 v61; // rax
  __int64 v62; // rax
  char *v63; // rax
  size_t v64; // rcx
  char *v65; // r14
  __int64 v66; // rax
  __int64 v67; // rax
  __int64 v68; // rdi
  __int64 v69; // r14
  unsigned int v70; // r13d
  __int64 v71; // rax
  __int64 v72; // rax
  __int64 v73; // rcx
  __int64 v74; // r8
  __int64 v75; // r9
  int v76; // eax
  __int64 v77; // rdi
  int v78; // r12d
  int v79; // eax
  int v80; // ebx
  __int64 v81; // r8
  __int64 v82; // r9
  __int64 v83; // r12
  __int64 v84; // rcx
  __int64 v85; // rcx
  __int64 v86; // rsi
  __int64 v87; // r12
  __int64 v88; // rax
  __m128i *v89; // rsi
  __int64 v90; // rax
  __m128i *v91; // rsi
  __int64 v92; // r12
  __int64 v93; // rax
  __int64 v94; // rcx
  __int64 v95; // r13
  unsigned int v96; // ebx
  __int64 v97; // r12
  __int64 v98; // r13
  __int64 v99; // rdi
  __int64 v100; // rax
  _BYTE *v101; // rsi
  unsigned __int64 v102; // r13
  __int64 v103; // rcx
  __int64 v104; // rcx
  unsigned __int64 v105; // rbx
  char v106; // r14
  __int64 v107; // rbx
  __int64 v108; // r15
  __int64 v109; // rax
  __int64 v110; // r9
  unsigned __int64 v111; // r13
  _BOOL4 v112; // eax
  __int64 v113; // rax
  __int64 v114; // rsi
  __int64 v115; // rbx
  unsigned int v116; // eax
  __int64 v117; // rax
  __int64 v118; // rax
  size_t v119; // rbx
  __int64 v120; // rax
  unsigned __int64 v121; // r13
  __int64 v122; // r14
  __int64 v123; // rax
  size_t v124; // rbx
  _BYTE *v125; // r13
  __int64 v126; // rax
  unsigned int v127; // r15d
  __int64 v128; // rcx
  unsigned __int8 v129; // al
  __int64 v130; // r12
  unsigned __int64 v131; // r14
  unsigned __int64 v132; // rcx
  char *v133; // r8
  _BYTE *v134; // rdi
  _BYTE *v135; // rsi
  __int64 v136; // rdx
  unsigned int v137; // ebx
  __int64 v138; // rax
  __int64 m; // rax
  __int64 v140; // rax
  __int64 v141; // r12
  __int64 v142; // rdi
  __int64 v143; // rax
  _BYTE *v144; // rsi
  unsigned __int8 v145; // al
  __int64 v146; // rcx
  __int64 v147; // rax
  __int64 v148; // rbx
  __int64 v149; // rsi
  __int64 n; // rax
  unsigned __int64 v151; // r14
  __int64 ii; // rax
  unsigned int jj; // r12d
  __int64 v154; // rsi
  __int64 v155; // r8
  __int64 v156; // rdx
  __int64 v157; // rax
  unsigned __int64 kk; // rbx
  __int64 v159; // rsi
  __int64 v160; // rax
  __int64 v161; // r13
  __int64 v162; // rbx
  __int64 v163; // rax
  unsigned int v164; // ecx
  int v165; // ebx
  unsigned int v166; // r15d
  int v167; // r12d
  unsigned int v168; // r13d
  signed int v169; // eax
  unsigned int v170; // eax
  unsigned int v171; // edi
  unsigned __int64 v172; // rsi
  unsigned __int64 v173; // rdx
  bool v174; // zf
  unsigned __int64 v175; // rax
  __int64 v176; // rax
  unsigned int v177; // eax
  __int64 v178; // rax
  __int64 v179; // rax
  __int64 v180; // rax
  __int64 v181; // rax
  __int64 v182; // rax
  __int64 v183; // [rsp-8h] [rbp-128h]
  const __m128i *v184; // [rsp+8h] [rbp-118h]
  unsigned __int64 v185; // [rsp+10h] [rbp-110h]
  __int64 v186; // [rsp+10h] [rbp-110h]
  __int64 v187; // [rsp+18h] [rbp-108h]
  __int64 v188; // [rsp+18h] [rbp-108h]
  int v189; // [rsp+20h] [rbp-100h]
  __int64 v190; // [rsp+20h] [rbp-100h]
  __int64 v191; // [rsp+28h] [rbp-F8h]
  __int64 v192; // [rsp+28h] [rbp-F8h]
  __int64 v193; // [rsp+28h] [rbp-F8h]
  unsigned int v194; // [rsp+30h] [rbp-F0h]
  unsigned __int64 v195; // [rsp+30h] [rbp-F0h]
  const __m128i *v196; // [rsp+30h] [rbp-F0h]
  unsigned int v197; // [rsp+38h] [rbp-E8h]
  __int64 v198; // [rsp+38h] [rbp-E8h]
  __int64 v199; // [rsp+38h] [rbp-E8h]
  __int64 v200; // [rsp+40h] [rbp-E0h]
  __int64 v201; // [rsp+48h] [rbp-D8h]
  unsigned __int64 v202; // [rsp+48h] [rbp-D8h]
  char v203; // [rsp+48h] [rbp-D8h]
  unsigned int v204; // [rsp+48h] [rbp-D8h]
  double v205; // [rsp+50h] [rbp-D0h]
  float v206; // [rsp+50h] [rbp-D0h]
  bool v207; // [rsp+50h] [rbp-D0h]
  __int64 v208; // [rsp+50h] [rbp-D0h]
  unsigned __int64 v210; // [rsp+60h] [rbp-C0h] BYREF
  unsigned int v211; // [rsp+68h] [rbp-B8h]
  __int64 v212; // [rsp+70h] [rbp-B0h] BYREF
  unsigned int v213; // [rsp+78h] [rbp-A8h]
  __int64 v214; // [rsp+80h] [rbp-A0h] BYREF
  __int64 v215; // [rsp+88h] [rbp-98h]
  unsigned __int64 v216; // [rsp+90h] [rbp-90h] BYREF
  char *v217; // [rsp+98h] [rbp-88h]
  _BYTE *v218; // [rsp+A0h] [rbp-80h] BYREF
  unsigned int v219; // [rsp+A8h] [rbp-78h]
  char v220; // [rsp+B0h] [rbp-70h]
  __int64 v221; // [rsp+C0h] [rbp-60h] BYREF
  _BYTE *v222; // [rsp+C8h] [rbp-58h]
  _BYTE *v223; // [rsp+D0h] [rbp-50h] BYREF
  unsigned int v224; // [rsp+D8h] [rbp-48h]
  char v225; // [rsp+E0h] [rbp-40h]

  if ( !a2 )
    return 0;
  v4 = a2[9].m128i_i64[0];
  v5 = a2;
  if ( v4 && sub_6E9180(v4) )
    sub_91B8A0("constant expressions are not supported!", (const __m128i *)a2[4].m128i_i32, 1);
  switch ( a2[10].m128i_i8[13] )
  {
    case 1:
      v33 = sub_620E90((__int64)a2);
      v34 = a2[8].m128i_u64[0];
      v35 = v33;
      for ( i = v33 == 0; *(_BYTE *)(v34 + 140) == 12; v34 = *(_QWORD *)(v34 + 160) )
        ;
      if ( *(_QWORD *)(v34 + 128) != 16 )
      {
        BYTE4(v217) = v33 == 0;
        LODWORD(v217) = 64;
        v216 = 0;
        goto LABEL_44;
      }
      LODWORD(v217) = 128;
      sub_C43690(&v216, 0, 0);
      v62 = *(_QWORD *)(v34 + 128);
      BYTE4(v217) = i;
      if ( v62 != 16 )
      {
LABEL_44:
        if ( v35 )
          v37 = sub_620FA0((__int64)a2, &v221);
        else
          v37 = sub_620FD0((__int64)a2, &v221);
        if ( (unsigned int)v217 > 0x40 )
        {
          *(_QWORD *)v216 = v37;
          memset((void *)(v216 + 8), 0, 8 * (unsigned int)(((unsigned __int64)(unsigned int)v217 + 63) >> 6) - 8);
        }
        else
        {
          v38 = (unsigned int)-(int)v217;
          v39 = (0xFFFFFFFFFFFFFFFFLL >> -(char)v217) & v37;
          if ( !(_DWORD)v217 )
            v39 = 0;
          v216 = v39;
        }
        goto LABEL_50;
      }
      v63 = sub_622850(a2);
      v64 = 0;
      v65 = v63;
      if ( v63 )
        v64 = strlen(v63);
      sub_C47AB0(&v221, 128, v65, v64, 10);
      if ( (unsigned int)v217 > 0x40 && v216 )
        j_j___libc_free_0_0(v216);
      v216 = v221;
      LODWORD(v217) = (_DWORD)v222;
LABEL_50:
      v40 = sub_91A390(*a1 + 8, v34, 0, v38);
      v41 = *(_BYTE *)(v40 + 8);
      v42 = v40;
      if ( v41 == 14 || 8 * (unsigned int)*(_QWORD *)(v34 + 128) > 0x3F )
      {
        v7 = sub_ACCFD0(a1[3], &v216);
        if ( v41 == 14 )
        {
          v116 = sub_91B6E0();
          v117 = sub_BCCE00(a1[3], v116);
          v118 = sub_96F3F0(v7, v117, 0, *(_QWORD *)(*a1 + 352));
          v7 = sub_AD4C70(v118, v42, 0);
        }
      }
      else
      {
        v50 = BYTE4(v217);
        sub_C44740(&v221, &v216);
        v51 = (int)v222;
        v52 = v221;
        if ( (unsigned int)v217 > 0x40 && v216 )
          j_j___libc_free_0_0(v216);
        v216 = v52;
        LODWORD(v217) = v51;
        v53 = a1[3];
        BYTE4(v217) = v50;
        v7 = sub_ACCFD0(v53, &v216);
      }
      if ( (unsigned int)v217 > 0x40 )
      {
        v43 = (_BYTE *)v216;
        if ( v216 )
          goto LABEL_56;
      }
      return v7;
    case 2:
      v9 = qword_4F06B40[a2[10].m128i_i8[8] & 7];
      if ( a3 )
        v10 = v9 * sub_8D4490(a3);
      else
        v10 = a2[11].m128i_u64[0];
      if ( v9 != 4 )
      {
        if ( v9 <= 4 )
        {
          if ( v9 != 1 )
          {
            if ( v9 != 2 )
              return 0;
            v11 = 0;
            v12 = sub_2207820(v10);
            v13 = a2[11].m128i_u64[0];
            v14 = (char *)v12;
            if ( v13 )
            {
              do
              {
                *(_WORD *)&v14[v11] = sub_722AB0((unsigned __int8 *)(v11 + a2[11].m128i_i64[1]), 2);
                v11 += 2LL;
              }
              while ( v13 > v11 );
              if ( v10 <= v11 )
                goto LABEL_19;
              goto LABEL_18;
            }
            if ( v10 )
            {
              do
              {
LABEL_18:
                *(_WORD *)&v14[v11] = 0;
                v11 += 2LL;
              }
              while ( v10 > v11 );
LABEL_19:
              v15 = v10 >> 1;
              v16 = 2 * v15;
              v17 = sub_BCD140(a1[3], 16);
LABEL_72:
              sub_BCD420(v17, v15);
              v7 = sub_AC9630(v14, v16);
LABEL_73:
              j_j___libc_free_0_0(v14);
              return v7;
            }
            v59 = 16;
            v60 = a1[3];
            goto LABEL_97;
          }
          v122 = 0;
          v123 = sub_2207820(v10);
          v124 = a2[11].m128i_u64[0];
          v125 = (_BYTE *)v123;
          if ( v124 )
          {
            do
            {
              v125[v122] = sub_722AB0((unsigned __int8 *)(v122 + a2[11].m128i_i64[1]), 1);
              ++v122;
            }
            while ( v124 != v122 );
            if ( v10 <= v124 )
            {
              v182 = sub_BCD140(a1[3], 8);
              sub_BCD420(v182, v10);
              v7 = sub_AC9630(v125, v10);
LABEL_187:
              v43 = v125;
LABEL_56:
              j_j___libc_free_0_0(v43);
              return v7;
            }
          }
          else if ( !v10 )
          {
LABEL_186:
            v126 = sub_BCD140(a1[3], 8);
            sub_BCD420(v126, v10);
            v7 = sub_AC9630(v125, v10);
            if ( v125 )
              goto LABEL_187;
            return v7;
          }
          memset(&v125[v124], 0, v10 - v124);
          goto LABEL_186;
        }
        if ( v9 != 8 )
          return 0;
        v47 = 0;
        v48 = sub_2207820(v10);
        v49 = a2[11].m128i_u64[0];
        v14 = (char *)v48;
        if ( v49 )
        {
          do
          {
            *(_QWORD *)&v14[v47] = sub_722AB0((unsigned __int8 *)(v47 + a2[11].m128i_i64[1]), 8);
            v47 += 8LL;
          }
          while ( v49 > v47 );
          if ( v10 <= v47 )
            goto LABEL_71;
          goto LABEL_70;
        }
        if ( v10 )
        {
          do
          {
LABEL_70:
            *(_QWORD *)&v14[v47] = 0;
            v47 += 8LL;
          }
          while ( v10 > v47 );
LABEL_71:
          v15 = v10 >> 3;
          v16 = 8 * v15;
          v17 = sub_BCD140(a1[3], 64);
          goto LABEL_72;
        }
        v59 = 64;
        v60 = a1[3];
LABEL_97:
        v61 = sub_BCD140(v60, v59);
        sub_BCD420(v61, 0);
        v7 = sub_AC9630(v14, 0);
        if ( v14 )
          goto LABEL_73;
        return v7;
      }
      v119 = 0;
      v120 = sub_2207820(v10);
      v121 = a2[11].m128i_u64[0];
      v14 = (char *)v120;
      if ( v121 )
      {
        do
        {
          *(_DWORD *)&v14[v119] = sub_722AB0((unsigned __int8 *)(v119 + a2[11].m128i_i64[1]), 4);
          v119 += 4LL;
        }
        while ( v121 > v119 );
        if ( v10 <= v119 )
          goto LABEL_181;
      }
      else if ( !v10 )
      {
        v59 = 32;
        v60 = a1[3];
        goto LABEL_97;
      }
      do
      {
        *(_DWORD *)&v14[v119] = 0;
        v119 += 4LL;
      }
      while ( v10 > v119 );
LABEL_181:
      v15 = v10 >> 2;
      v16 = 4 * v15;
      v17 = sub_BCD140(a1[3], 32);
      goto LABEL_72;
    case 3:
      for ( j = a2[8].m128i_i64[0]; *(_BYTE *)(j + 140) == 12; j = *(_QWORD *)(j + 160) )
        ;
      v19 = *(_BYTE *)(j + 160);
      v214 = sub_709B30(v19, a2 + 11);
      v215 = v20;
      switch ( v19 )
      {
        case 2u:
          v54 = (__int64 *)&v216;
          LODWORD(v206) = sub_12F9960(&v214);
          v58 = sub_C33310();
          sub_C3B170(&v221, v206);
          sub_C407B0(&v216, &v221, v58);
          sub_C338F0(&v221);
          goto LABEL_89;
        case 4u:
          goto LABEL_64;
        case 6u:
        case 7u:
          goto LABEL_57;
        case 8u:
        case 0xDu:
          if ( dword_4D0470C )
          {
LABEL_57:
            if ( qword_4F04C50 )
            {
              v44 = *(_QWORD *)(qword_4F04C50 + 32LL);
              if ( v44 )
              {
                if ( (*(_BYTE *)(v44 + 198) & 0x10) != 0 )
                {
                  v45 = "long double";
                  if ( v19 != 6 )
                  {
                    v45 = "__float80";
                    if ( v19 != 7 )
                      v45 = "__float128";
                  }
                  sub_684B10(0xE51u, (const __m128i *)a2[4].m128i_i32, (__int64)v45);
                }
              }
            }
LABEL_64:
            v205 = COERCE_DOUBLE(sub_12F99A0(&v214));
            v46 = sub_C33320();
            sub_C3B1B0(&v221, v205);
            sub_C407B0(&v216, &v221, v46);
            sub_C338F0(&v221);
            v7 = sub_AC8EA0(a1[3], &v216);
            if ( v216 == sub_C33340() )
            {
              if ( v217 )
              {
                v56 = 24LL * *((_QWORD *)v217 - 1);
                for ( k = &v217[v56]; v217 != k; sub_91D830(k) )
                  k -= 24;
                j_j_j___libc_free_0_0(k - 8);
              }
            }
            else
            {
              sub_C338F0(&v216);
            }
          }
          else
          {
            v54 = &v221;
            sub_C438C0(&v216, 128, &v214, 2);
            v55 = sub_C33330();
            if ( v55 == sub_C33340() )
              sub_C3C640(&v221, v55, &v216);
            else
              sub_C3B160(&v221, v55, &v216);
            if ( (unsigned int)v217 > 0x40 && v216 )
              j_j___libc_free_0_0(v216);
LABEL_89:
            v7 = sub_AC8EA0(a1[3], v54);
            sub_91D830(v54);
          }
          break;
        default:
          sub_91B8A0("unsupported float variant!", (const __m128i *)a2[4].m128i_i32, 1);
      }
      return v7;
    case 6:
      v21 = a2[11].m128i_i8[0];
      if ( v21 == 1 )
      {
        v86 = a2[11].m128i_i64[1];
        if ( (*(_BYTE *)(v86 + 89) & 1) != 0 )
        {
          v7 = sub_9227D0(a1[1]);
          if ( *(_BYTE *)v7 > 0x15u )
            sub_91B8A0("failed to lookup function static variable", (const __m128i *)v5[4].m128i_i32, 1);
        }
        else
        {
          v7 = sub_916430((__int64 *)*a1, v86, 0);
        }
      }
      else if ( v21 == 2 )
      {
        v92 = a2[11].m128i_i64[1];
        if ( *(_BYTE *)(v92 + 173) != 2 )
          sub_91B8A0("taking address of non-string constant is not supported!", (_DWORD *)(v92 + 64), 1);
        v7 = sub_90A830((__int64 *)*a1, a2[11].m128i_i64[1], 0);
      }
      else
      {
        if ( v21 )
          sub_91B8A0("unsupported constant variant!", (const __m128i *)a2[4].m128i_i32, 1);
        v87 = a2[11].m128i_i64[1];
        if ( (*(_BYTE *)(v87 + 197) & 0x60) != 0 && *(_QWORD *)(v87 + 128) )
          v87 = *(_QWORD *)(v87 + 128);
        if ( dword_4D046EC )
        {
          v88 = a2[9].m128i_i64[0];
          v89 = (__m128i *)&a2[4];
          if ( v88 )
            v89 = (__m128i *)(v88 + 36);
          sub_91C360(v87, v89);
        }
        v90 = v5[9].m128i_i64[0];
        v91 = (__m128i *)&v5[4];
        if ( v90 )
          v91 = (__m128i *)(v90 + 36);
        sub_91C930(v87, v91);
        v7 = sub_917010(*a1, v87, 0);
      }
      v22 = v5[12].m128i_i64[0];
      if ( v22 )
      {
        sub_622920((unsigned __int8)byte_4F06A60[0], &v212, &v210);
        v66 = sub_BCCE00(a1[3], (unsigned int)(8 * v212));
        v67 = sub_AD64C0(v66, v22, 0);
        v68 = a1[3];
        v214 = v67;
        v69 = *(_QWORD *)(v7 + 8);
        v70 = *(_DWORD *)(v69 + 8);
        v71 = sub_BCB2B0(v68);
        v72 = sub_BCE760(v71, v70 >> 8);
        v76 = sub_AD4C90(v7, v72, 0, v73, v74, v75);
        v77 = a1[3];
        v220 = 0;
        v78 = v76;
        v79 = sub_BCB2B0(v77);
        v225 = 0;
        v80 = v79;
        if ( v220 )
        {
          LODWORD(v222) = (_DWORD)v217;
          if ( (unsigned int)v217 > 0x40 )
            sub_C43780(&v221, &v216);
          else
            v221 = v216;
          v224 = v219;
          if ( v219 > 0x40 )
            sub_C43780(&v223, &v218);
          else
            v223 = v218;
          v225 = 1;
        }
        v83 = sub_AD9FD0(v80, v78, (unsigned int)&v214, 1, 0, (unsigned int)&v221, 0);
        v84 = v183;
        if ( v225 )
        {
          v225 = 0;
          if ( v224 > 0x40 && v223 )
            j_j___libc_free_0_0(v223);
          if ( (unsigned int)v222 > 0x40 && v221 )
            j_j___libc_free_0_0(v221);
        }
        if ( v220 )
        {
          v220 = 0;
          if ( v219 > 0x40 && v218 )
            j_j___libc_free_0_0(v218);
          if ( (unsigned int)v217 > 0x40 && v216 )
            j_j___libc_free_0_0(v216);
        }
        v7 = sub_AD4C90(v83, v69, 0, v84, v81, v82);
      }
      v25 = sub_91A390(*a1 + 8, v5[8].m128i_u64[0], 0, v85);
      v26 = *(_QWORD *)(v7 + 8);
      if ( v25 == v26 )
        return v7;
      v27 = *(_BYTE *)(v25 + 8);
      v28 = *(unsigned __int8 *)(v26 + 8);
      if ( v27 == 14 )
      {
        if ( (_BYTE)v28 == 14 )
        {
          if ( *(_DWORD *)(v25 + 8) >> 8 == *(_DWORD *)(v26 + 8) >> 8 )
            return sub_AD4C90(v7, v25, 0, v28, v23, v24);
          else
            return sub_ADAFB0(v7, v25);
        }
LABEL_82:
        sub_91B8A0("unsupported cast from address constant!", (const __m128i *)v5[4].m128i_i32, 1);
      }
      if ( (_BYTE)v28 != 14 || v27 != 12 )
        goto LABEL_82;
      if ( *(_DWORD *)(v26 + 8) >> 8 )
      {
        v179 = sub_BCB2B0(a1[3]);
        v180 = sub_BCE760(v179, 0);
        v7 = sub_ADAFB0(v7, v180);
      }
      return sub_AD4C50(v7, v25, 0);
    case 0xA:
      v29 = a2[8].m128i_u64[0];
      v30 = *(_BYTE *)(v29 + 140);
      switch ( v30 )
      {
        case 12:
          v31 = a2[8].m128i_i64[0];
          do
          {
            v31 = *(_QWORD *)(v31 + 160);
            v32 = *(_BYTE *)(v31 + 140);
          }
          while ( v32 == 12 );
          if ( v32 != 10 )
          {
            if ( v32 != 11 )
            {
              if ( v32 != 8 )
                goto LABEL_39;
              v216 = 0;
              v217 = 0;
              v218 = 0;
              do
                v29 = *(_QWORD *)(v29 + 160);
              while ( *(_BYTE *)(v29 + 140) == 12 );
              goto LABEL_159;
            }
            v221 = 0;
            v222 = 0;
            v223 = 0;
            do
              v29 = *(_QWORD *)(v29 + 160);
            while ( *(_BYTE *)(v29 + 140) == 12 );
LABEL_169:
            v114 = a2[11].m128i_i64[0];
            if ( v114 )
            {
              if ( *(_BYTE *)(v114 + 173) != 13 )
              {
                v115 = *(_QWORD *)(v29 + 160);
                if ( v115 )
                {
                  while ( 1 )
                  {
                    if ( (*(_BYTE *)(v115 + 146) & 8) == 0 )
                    {
                      if ( (*(_BYTE *)(v115 + 144) & 4) == 0 )
                        goto LABEL_221;
                      if ( *(_QWORD *)(v115 + 8) )
                        break;
                    }
                    v115 = *(_QWORD *)(v115 + 112);
                    if ( !v115 )
                      goto LABEL_176;
                  }
LABEL_271:
                  sub_91B8A0("initialization of bit-field in union not supported!", (const __m128i *)v5[4].m128i_i32, 1);
                }
LABEL_176:
                sub_91B8A0("cannot find initialized union member!", (const __m128i *)v5[4].m128i_i32, 1);
              }
              v115 = *(_QWORD *)(v114 + 184);
              if ( !v115 )
                goto LABEL_176;
              if ( (*(_BYTE *)(v115 + 144) & 4) != 0 )
                goto LABEL_271;
              v114 = *(_QWORD *)(v114 + 120);
LABEL_221:
              v216 = sub_91DF90(a1, v114, *(_QWORD *)(v115 + 120));
              sub_91D6E0((__int64)&v221, &v216);
              for ( m = *(_QWORD *)(v115 + 120); *(_BYTE *)(m + 140) == 12; m = *(_QWORD *)(m + 160) )
                ;
              v140 = *(_QWORD *)(m + 128);
            }
            else
            {
              v140 = 0;
            }
            v141 = *(_QWORD *)(v29 + 128) - v140;
            if ( v141 )
            {
              v142 = sub_BCB2B0(a1[3]);
              if ( v141 != 1 )
                v142 = sub_BCD420(v142, v141);
              v143 = sub_AD6530(v142);
              v144 = v222;
              v216 = v143;
              if ( v222 == v223 )
              {
                sub_91DE00((__int64)&v221, v222, &v216);
              }
              else
              {
                if ( v222 )
                {
                  *(_QWORD *)v222 = v143;
                  v144 = v222;
                }
                v222 = v144 + 8;
              }
            }
            v145 = sub_91B7B0(v29);
            v130 = sub_AC34C0(v221, (__int64)&v222[-v221] >> 3, v145);
            v147 = sub_91A390(*a1 + 8, v29, 0, v146);
            v148 = v147;
            if ( *(_BYTE *)(v147 + 8) == 15 && (unsigned __int8)sub_BCBA70(v147, v130) )
              v130 = v148;
            goto LABEL_199;
          }
          v221 = 0;
          v222 = 0;
          v223 = 0;
          do
            v29 = *(_QWORD *)(v29 + 160);
          while ( *(_BYTE *)(v29 + 140) == 12 );
          break;
        case 10:
          v221 = 0;
          v222 = 0;
          v223 = 0;
          break;
        case 11:
          v221 = 0;
          v222 = 0;
          v223 = 0;
          goto LABEL_169;
        case 8:
          v216 = 0;
          v217 = 0;
          v218 = 0;
LABEL_159:
          v102 = sub_8D4050(v29);
          v192 = sub_91A390(*a1 + 8, v29, 0, v103);
          v208 = sub_91A390(*a1 + 8, v102, 0, v104);
          v195 = *(_QWORD *)(v29 + 176);
          if ( !v195 )
            goto LABEL_188;
          v105 = 0;
          v106 = 0;
          if ( !a2[11].m128i_i64[0] )
            goto LABEL_203;
          v202 = 0;
          v107 = a2[11].m128i_i64[0];
          v108 = v102;
          do
          {
            v110 = v107;
            v111 = 1;
            if ( *(_BYTE *)(v107 + 173) != 11
              || (v111 = *(_QWORD *)(v107 + 184),
                  v198 = *(_QWORD *)(v107 + 176),
                  v112 = sub_8D44E0(v198, v108),
                  v110 = v198,
                  v112) )
            {
              v109 = sub_91DF90(a1, v110, v108);
              v212 = v109;
            }
            else
            {
              v111 = 1;
              v113 = sub_91DF90(a1, v198, *(_QWORD *)(v198 + 128));
              v109 = sub_91D5C0(v113, v108);
              v212 = v109;
            }
            v106 |= *(_QWORD *)(v109 + 8) != v208;
            sub_91DB10((__int64)&v216, v217, v111, &v212);
            v107 = *(_QWORD *)(v107 + 120);
            v202 += v111;
          }
          while ( v107 );
          v105 = v202;
          if ( v195 > v202 )
          {
LABEL_203:
            v203 = v106;
            v131 = v105;
            do
            {
              ++v131;
              v221 = sub_AD6530(v208);
              sub_91D6E0((__int64)&v216, &v221);
            }
            while ( v195 > v131 );
            v106 = v203;
          }
          if ( v106 )
          {
            v132 = v216;
            v133 = v217;
            v221 = 0;
            v222 = 0;
            v223 = 0;
            if ( (char *)v216 == v217 )
            {
              v156 = 0;
              v155 = 0;
            }
            else
            {
              v134 = 0;
              v135 = 0;
              v136 = 0;
              v137 = 0;
              while ( 1 )
              {
                v138 = *(_QWORD *)(*(_QWORD *)(v132 + 8 * v136) + 8LL);
                v214 = v138;
                if ( v135 == v134 )
                {
                  sub_9183A0((__int64)&v221, v135, &v214);
                  v135 = v222;
                  v132 = v216;
                  v133 = v217;
                }
                else
                {
                  if ( v135 )
                  {
                    *(_QWORD *)v135 = v138;
                    v135 = v222;
                    v132 = v216;
                    v133 = v217;
                  }
                  v135 += 8;
                  v222 = v135;
                }
                v136 = ++v137;
                if ( v137 >= (unsigned __int64)((__int64)&v133[-v132] >> 3) )
                  break;
                v134 = v223;
              }
              v155 = v221;
              v156 = (__int64)&v135[-v221] >> 3;
            }
            v157 = sub_BD0B90(a1[3], v155, v156, 1);
            v7 = sub_AD24A0(v157, v216, (__int64)&v217[-v216] >> 3);
            if ( v221 )
              j_j___libc_free_0(v221, &v223[-v221]);
          }
          else
          {
LABEL_188:
            v7 = sub_AD1300(v192, v216, (__int64)&v217[-v216] >> 3);
          }
          if ( v216 )
            j_j___libc_free_0(v216, &v218[-v216]);
          return v7;
        default:
LABEL_39:
          sub_91B8A0("unsupported aggregate constant!", (const __m128i *)a2[4].m128i_i32, 1);
      }
      v93 = sub_91A390(*a1 + 8, v29, 0, a4);
      v94 = a2[11].m128i_i64[0];
      v200 = v93;
      v197 = *(_DWORD *)(v93 + 12);
      v207 = v197 != 0 && v94 == 0;
      if ( v207 )
      {
        v7 = sub_AC9350(v93);
        goto LABEL_200;
      }
      v95 = *(_QWORD *)(v29 + 160);
      if ( !v95 )
      {
        v96 = 0;
        if ( v197 )
          goto LABEL_192;
        goto LABEL_196;
      }
      v185 = v29;
      v96 = 0;
      v97 = a2[11].m128i_i64[0];
      v191 = *a1 + 8;
      v201 = a2[11].m128i_i64[1];
      break;
    case 0xE:
      return 0;
    default:
      sub_91B8A0("unsupported constant variant!", (const __m128i *)a2[4].m128i_i32, 1);
  }
  while ( 1 )
  {
    if ( (*(_BYTE *)(v95 + 146) & 8) == 0 )
    {
      if ( (*(_BYTE *)(v95 + 144) & 4) != 0 )
      {
        v207 = 1;
      }
      else
      {
        v194 = sub_917F80(v191, v95);
        if ( v96 >= v194 )
        {
          v194 = v96;
        }
        else
        {
          v187 = v95;
          v98 = 8LL * v96;
          do
          {
            v99 = *(_QWORD *)(*(_QWORD *)(v200 + 16) + v98);
            v98 += 8;
            v216 = sub_AD6530(v99);
            sub_91D6E0((__int64)&v221, &v216);
          }
          while ( 8 * (v96 + (unsigned __int64)(~v96 + v194) + 1) != v98 );
          v95 = v187;
        }
        v100 = sub_91DF90(a1, v97, *(_QWORD *)(v95 + 120));
        v214 = v100;
        if ( (*(_BYTE *)(v95 + 145) & 0x10) != 0 )
        {
          v149 = *(_QWORD *)(v100 + 8);
          for ( n = *(_QWORD *)(v95 + 120); *(_BYTE *)(n + 140) == 12; n = *(_QWORD *)(n + 160) )
            ;
          v151 = *(_QWORD *)(n + 128);
          for ( ii = *(_QWORD *)(v97 + 128); *(_BYTE *)(ii + 140) == 12; ii = *(_QWORD *)(ii + 160) )
            ;
          if ( v151 < *(_QWORD *)(ii + 128) )
          {
            v181 = sub_AE4AC0(*(_QWORD *)(*a1 + 352), v149);
            v189 = sub_AE1C80(v181, v151);
          }
          else
          {
            v189 = *(_DWORD *)(v149 + 12);
          }
          if ( v189 )
          {
            v188 = v97;
            for ( jj = 0; jj != v189; ++jj )
            {
              v154 = jj;
              v216 = sub_AD69F0(v214, v154);
              sub_91D6E0((__int64)&v221, &v216);
            }
            v97 = v188;
            v96 = v194 + v189;
          }
          else
          {
            v96 = v194;
          }
        }
        else
        {
          v101 = v222;
          if ( v222 == v223 )
          {
            sub_91DE00((__int64)&v221, v222, &v214);
          }
          else
          {
            if ( v222 )
            {
              *(_QWORD *)v222 = v100;
              v101 = v222;
            }
            v222 = v101 + 8;
          }
          v96 = v194 + 1;
        }
        if ( (*(_BYTE *)(v95 + 144) & 4) == 0 )
        {
LABEL_140:
          if ( v97 == v201 )
            goto LABEL_191;
          v97 = *(_QWORD *)(v97 + 120);
          goto LABEL_142;
        }
      }
      if ( *(_QWORD *)(v95 + 8) )
        goto LABEL_140;
    }
LABEL_142:
    v95 = *(_QWORD *)(v95 + 112);
    if ( !v95 )
    {
LABEL_191:
      v29 = v185;
      if ( v197 > v96 )
      {
LABEL_192:
        v196 = v5;
        v127 = v96;
        do
        {
          v128 = v127++;
          v216 = sub_AD6530(*(_QWORD *)(*(_QWORD *)(v200 + 16) + 8 * v128));
          sub_91D6E0((__int64)&v221, &v216);
        }
        while ( v197 > v127 );
        v5 = v196;
      }
      if ( v207 )
      {
        for ( kk = v5[8].m128i_u64[0]; *(_BYTE *)(kk + 140) == 12; kk = *(_QWORD *)(kk + 160) )
          ;
        v159 = sub_91A390(*a1 + 8, kk, 0, v94);
        if ( *(_BYTE *)(v159 + 8) != 15 )
          v159 = 0;
        v160 = sub_AE4AC0(*(_QWORD *)(*a1 + 352), v159);
        v161 = *(_QWORD *)(kk + 160);
        v186 = v160;
        v190 = v5[11].m128i_i64[1];
        v199 = v5[11].m128i_i64[0];
        if ( v161 )
        {
          v184 = v5;
          do
          {
            if ( (*(_BYTE *)(v161 + 146) & 8) == 0 )
            {
              if ( (*(_BYTE *)(v161 + 144) & 4) != 0 )
              {
                if ( *(_QWORD *)(v161 + 8) )
                {
                  v204 = sub_AE1C80(v186, *(_QWORD *)(v161 + 128));
                  v162 = *(_QWORD *)(*(_QWORD *)(v221 + 8LL * v204) + 8LL);
                  if ( v162 != sub_BCB2B0(a1[3]) )
                    sub_91B8A0("unexpected error while initializing bitfield!", (const __m128i *)v184[4].m128i_i32, 1);
                  v163 = sub_91DF90(a1, v199, 0);
                  if ( !v163 )
LABEL_383:
                    sub_91B8A0("bit-field constant must have a known value at compile time!", (_DWORD *)(v199 + 64), 1);
                  v164 = *(_DWORD *)(v163 + 32);
                  v211 = v164;
                  if ( v164 > 0x40 )
                  {
                    sub_C43780(&v210, v163 + 24);
                    v164 = v211;
                  }
                  else
                  {
                    v210 = *(_QWORD *)(v163 + 24);
                  }
                  v165 = *(unsigned __int8 *)(v161 + 137);
                  if ( v165 < v164 )
                  {
                    sub_C44740(&v216, &v210);
                    if ( v211 > 0x40 && v210 )
                      j_j___libc_free_0_0(v210);
                    v210 = v216;
                    v211 = (unsigned int)v217;
                    v165 = *(unsigned __int8 *)(v161 + 137);
                  }
                  v166 = v204;
                  if ( v165 )
                  {
                    v193 = v161;
                    while ( 1 )
                    {
                      v178 = *(_QWORD *)(v221 + 8LL * v166);
                      if ( !v178 )
                        goto LABEL_383;
                      v213 = *(_DWORD *)(v178 + 32);
                      if ( v213 > 0x40 )
                        sub_C43780(&v212, v178 + 24);
                      else
                        v212 = *(_QWORD *)(v178 + 24);
                      if ( v166 == v204 )
                      {
                        v168 = *(unsigned __int8 *)(v193 + 136);
                        v167 = 8 - v168;
                        if ( (int)(8 - v168) > v165 )
                          v167 = v165;
                      }
                      else
                      {
                        v167 = 8;
                        if ( v165 <= 8 )
                          v167 = v165;
                        v168 = 0;
                      }
                      v169 = v211;
                      LODWORD(v215) = v211;
                      if ( v211 > 0x40 )
                      {
                        sub_C43780(&v214, &v210);
                        v169 = v211;
                      }
                      else
                      {
                        v214 = v210;
                      }
                      if ( v169 > v167 )
                      {
                        sub_C44740(&v216, &v214);
                        if ( (unsigned int)v215 > 0x40 && v214 )
                          j_j___libc_free_0_0(v214);
                        v214 = v216;
                        v170 = (unsigned int)v217;
                        LODWORD(v215) = (_DWORD)v217;
                      }
                      else
                      {
                        v170 = v215;
                      }
                      if ( v170 <= 7 )
                      {
                        sub_C449B0(&v216, &v214, 8);
                        if ( (unsigned int)v215 > 0x40 && v214 )
                          j_j___libc_free_0_0(v214);
                        v214 = v216;
                        v170 = (unsigned int)v217;
                        LODWORD(v215) = (_DWORD)v217;
                      }
                      LODWORD(v217) = v170;
                      if ( v170 > 0x40 )
                      {
                        sub_C43780(&v216, &v214);
                        v170 = (unsigned int)v217;
                        if ( (unsigned int)v217 > 0x40 )
                        {
                          sub_C47690(&v216, v168);
                          v171 = v215;
                          goto LABEL_307;
                        }
                        v171 = v215;
                      }
                      else
                      {
                        v171 = v170;
                        v216 = v214;
                      }
                      v172 = 0;
                      if ( v168 != v170 )
                        v172 = v216 << v168;
                      v173 = v172 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v170);
                      v174 = v170 == 0;
                      v175 = 0;
                      if ( !v174 )
                        v175 = v173;
                      v216 = v175;
LABEL_307:
                      if ( v171 > 0x40 && v214 )
                        j_j___libc_free_0_0(v214);
                      v214 = v216;
                      LODWORD(v215) = (_DWORD)v217;
                      if ( v213 > 0x40 )
                        sub_C43BD0(&v212, &v214);
                      else
                        v212 |= v216;
                      v176 = sub_ACCFD0(a1[3], &v212);
                      *(_QWORD *)(v221 + 8LL * v166) = v176;
                      v177 = v211;
                      LODWORD(v217) = v211;
                      if ( v211 <= 0x40 )
                      {
                        v216 = v210;
LABEL_314:
                        if ( v177 == v167 )
                          v216 = 0;
                        else
                          v216 >>= v167;
                        goto LABEL_316;
                      }
                      sub_C43780(&v216, &v210);
                      v177 = (unsigned int)v217;
                      if ( (unsigned int)v217 <= 0x40 )
                        goto LABEL_314;
                      sub_C482E0(&v216, (unsigned int)v167);
LABEL_316:
                      if ( v211 > 0x40 && v210 )
                        j_j___libc_free_0_0(v210);
                      v165 -= v167;
                      v210 = v216;
                      v211 = (unsigned int)v217;
                      if ( (unsigned int)v215 > 0x40 && v214 )
                        j_j___libc_free_0_0(v214);
                      if ( v213 > 0x40 && v212 )
                        j_j___libc_free_0_0(v212);
                      ++v166;
                      if ( !v165 )
                      {
                        v161 = v193;
                        break;
                      }
                    }
                  }
                  if ( v199 == v190 )
                  {
                    if ( v211 > 0x40 && v210 )
                      j_j___libc_free_0_0(v210);
                    break;
                  }
                  v199 = *(_QWORD *)(v199 + 120);
                  if ( v211 > 0x40 && v210 )
                    j_j___libc_free_0_0(v210);
                }
              }
              else
              {
                if ( v199 == v190 )
                  break;
                v199 = *(_QWORD *)(v199 + 120);
              }
            }
            v161 = *(_QWORD *)(v161 + 112);
          }
          while ( v161 );
        }
      }
LABEL_196:
      if ( v222 != (_BYTE *)v221 )
      {
        v129 = sub_91B7B0(v29);
        v130 = sub_AC34C0(v221, (__int64)&v222[-v221] >> 3, v129);
        if ( (unsigned __int8)sub_BCBA70(v200, v130) )
          v130 = v200;
LABEL_199:
        v7 = sub_AD24A0(v130, v221, (__int64)&v222[-v221] >> 3);
        goto LABEL_200;
      }
      v7 = sub_AD24A0(v200, v221, 0);
LABEL_200:
      if ( v221 )
        j_j___libc_free_0(v221, &v223[-v221]);
      return v7;
    }
  }
}
