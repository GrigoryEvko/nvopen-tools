// Function: ctor_515_0
// Address: 0x55ed10
//
int ctor_515_0()
{
  __m128i *v0; // rax
  int v2; // [rsp+30h] [rbp-1E0h] BYREF
  int v3; // [rsp+34h] [rbp-1DCh] BYREF
  int *v4; // [rsp+38h] [rbp-1D8h] BYREF
  int *v5; // [rsp+40h] [rbp-1D0h] BYREF
  __int64 v6; // [rsp+48h] [rbp-1C8h]
  _BYTE v7[160]; // [rsp+50h] [rbp-1C0h] BYREF
  __m128i v8; // [rsp+F0h] [rbp-120h] BYREF
  __m128i v9; // [rsp+100h] [rbp-110h] BYREF
  __m128i v10; // [rsp+110h] [rbp-100h] BYREF
  __m128i v11; // [rsp+120h] [rbp-F0h] BYREF
  __m128i v12; // [rsp+130h] [rbp-E0h] BYREF
  __m128i v13; // [rsp+140h] [rbp-D0h] BYREF
  __m128i v14; // [rsp+150h] [rbp-C0h] BYREF
  __m128i v15; // [rsp+160h] [rbp-B0h] BYREF
  __m128i v16; // [rsp+170h] [rbp-A0h] BYREF
  __m128i v17; // [rsp+180h] [rbp-90h] BYREF
  __m128i v18; // [rsp+190h] [rbp-80h] BYREF
  __m128i v19; // [rsp+1A0h] [rbp-70h] BYREF
  __m128i v20; // [rsp+1B0h] [rbp-60h] BYREF
  __m128i v21; // [rsp+1C0h] [rbp-50h] BYREF
  __m128i v22; // [rsp+1D0h] [rbp-40h] BYREF

  v8.m128i_i64[0] = (__int64)"Enable vectorization of epilogue loops.";
  v8.m128i_i64[1] = 39;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 1;
  v5 = &v3;
  sub_23A19B0(&unk_500ED00, "enable-epilogue-vectorization", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500ED00, &qword_4A427C0);
  sub_D95050(&qword_500EC20, 0, 0);
  qword_500ECA8 = 0;
  qword_500ECB8 = 0;
  qword_500ECB0 = (__int64)&unk_49D9728;
  qword_500EC20 = (__int64)&unk_49DBF10;
  qword_500ECC0 = (__int64)&unk_49DC290;
  qword_500ECE0 = (__int64)nullsub_24;
  qword_500ECD8 = (__int64)sub_984050;
  sub_C53080(&qword_500EC20, "epilogue-vectorization-force-VF", 31);
  LODWORD(qword_500ECA8) = 1;
  BYTE4(qword_500ECB8) = 1;
  LODWORD(qword_500ECB8) = 1;
  qword_500EC50 = 135;
  byte_500EC2C = byte_500EC2C & 0x9F | 0x20;
  qword_500EC48 = (__int64)"When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the g"
                           "iven VF for all applicable epilogue loops.";
  sub_C53130(&qword_500EC20);
  __cxa_atexit(sub_984970, &qword_500EC20, &qword_4A427C0);
  sub_D95050(&qword_500EB40, 0, 0);
  qword_500EC00 = (__int64)nullsub_24;
  qword_500EBD0 = (__int64)&unk_49D9728;
  qword_500EB40 = (__int64)&unk_49DBF10;
  qword_500EBE0 = (__int64)&unk_49DC290;
  qword_500EBF8 = (__int64)sub_984050;
  qword_500EBC8 = 0;
  qword_500EBD8 = 0;
  sub_C53080(&qword_500EB40, "epilogue-vectorization-minimum-VF", 33);
  qword_500EB70 = 123;
  byte_500EB4C = byte_500EB4C & 0x9F | 0x20;
  qword_500EB68 = (__int64)"Only loops with vectorization factor equal to or larger than the specified value are consider"
                           "ed for epilogue vectorization.";
  sub_C53130(&qword_500EB40);
  __cxa_atexit(sub_984970, &qword_500EB40, &qword_4A427C0);
  v8.m128i_i64[1] = 131;
  v8.m128i_i64[0] = (__int64)"Loops with a constant trip count that is smaller than this value are vectorized only if no "
                             "scalar iteration overheads are incurred.";
  LODWORD(v4) = 1;
  v3 = 16;
  v5 = &v3;
  sub_2ABC1F0(&unk_500EA60, "vectorizer-min-trip-count", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500EA60, &qword_4A427C0);
  sub_D95050(&qword_500E980, 0, 0);
  qword_500EA40 = (__int64)nullsub_24;
  qword_500EA10 = (__int64)&unk_49D9728;
  qword_500E980 = (__int64)&unk_49DBF10;
  qword_500EA20 = (__int64)&unk_49DC290;
  qword_500EA38 = (__int64)sub_984050;
  qword_500EA08 = 0;
  qword_500EA18 = 0;
  sub_C53080(&qword_500E980, "vectorize-memory-check-threshold", 32);
  LODWORD(qword_500EA08) = 128;
  BYTE4(qword_500EA18) = 1;
  LODWORD(qword_500EA18) = 128;
  qword_500E9B0 = 51;
  byte_500E98C = byte_500E98C & 0x9F | 0x20;
  qword_500E9A8 = (__int64)"The maximum allowed number of runtime memory checks";
  sub_C53130(&qword_500E980);
  __cxa_atexit(sub_984970, &qword_500E980, &qword_4A427C0);
  v9.m128i_i64[1] = 15;
  v8.m128i_i64[0] = (__int64)&v9;
  v9.m128i_i64[0] = (__int64)"scalar-epilogue";
  v10.m128i_i64[1] = (__int64)"Don't tail-predicate loops, create scalar epilogue";
  v11.m128i_i64[1] = (__int64)"predicate-else-scalar-epilogue";
  v13.m128i_i64[0] = (__int64)"prefer tail-folding, create scalar epilogue if tail folding fails.";
  v14.m128i_i64[0] = (__int64)"predicate-dont-vectorize";
  v15.m128i_i64[1] = (__int64)"prefers tail-folding, don't attempt vectorization if tail-folding fails.";
  v8.m128i_i64[1] = 0x400000003LL;
  v4 = &v2;
  v5 = (int *)"Tail-folding and predication preferences over creating a scalar epilogue loop.";
  v10.m128i_i32[0] = 0;
  v11.m128i_i64[0] = 50;
  v12.m128i_i64[0] = 30;
  v12.m128i_i32[2] = 1;
  v13.m128i_i64[1] = 66;
  v14.m128i_i64[1] = 24;
  v15.m128i_i32[0] = 2;
  v16.m128i_i64[0] = 72;
  v6 = 78;
  v3 = 1;
  v2 = 0;
  sub_2AF6680(&unk_500E720, "prefer-predicate-over-epilogue", &v4, &v3, &v5, &v8);
  if ( (__m128i *)v8.m128i_i64[0] != &v9 )
    _libc_free(v8.m128i_i64[0], "prefer-predicate-over-epilogue");
  __cxa_atexit(sub_2AAA870, &unk_500E720, &qword_4A427C0);
  v8.m128i_i64[0] = (__int64)"none";
  v9.m128i_i64[1] = (__int64)"Disable tail folding";
  v10.m128i_i64[1] = (__int64)"data";
  v12.m128i_i64[0] = (__int64)"Create lane mask for data only, using active.lane.mask intrinsic";
  v13.m128i_i64[0] = (__int64)"data-without-lane-mask";
  v14.m128i_i64[1] = (__int64)"Create lane mask with compare/stepvector";
  v15.m128i_i64[1] = (__int64)"data-and-control";
  v17.m128i_i64[0] = (__int64)"Create lane mask using active.lane.mask intrinsic, and use it for both data and control flow";
  v18.m128i_i64[0] = (__int64)"data-and-control-without-rt-check";
  v19.m128i_i64[1] = (__int64)"Similar to data-and-control, but remove the runtime check";
  v20.m128i_i64[1] = (__int64)"data-with-evl";
  v22.m128i_i64[0] = (__int64)"Use predicated EVL instructions for tail folding. If EVL is unsupported, fallback to data-"
                              "without-lane-mask.";
  v5 = (int *)v7;
  v6 = 0x400000000LL;
  v8.m128i_i64[1] = 4;
  v9.m128i_i32[0] = 0;
  v10.m128i_i64[0] = 20;
  v11.m128i_i64[0] = 4;
  v11.m128i_i32[2] = 1;
  v12.m128i_i64[1] = 64;
  v13.m128i_i64[1] = 22;
  v14.m128i_i32[0] = 2;
  v15.m128i_i64[0] = 40;
  v16.m128i_i64[0] = 16;
  v16.m128i_i32[2] = 3;
  v17.m128i_i64[1] = 92;
  v18.m128i_i64[1] = 33;
  v19.m128i_i32[0] = 4;
  v20.m128i_i64[0] = 57;
  v21.m128i_i64[0] = 13;
  v21.m128i_i32[2] = 5;
  v22.m128i_i64[1] = 108;
  sub_C8D5F0(&v5, v7, 6, 40);
  v0 = (__m128i *)&v5[10 * (unsigned int)v6];
  *v0 = _mm_loadu_si128(&v8);
  v0[1] = _mm_loadu_si128(&v9);
  v0[2] = _mm_loadu_si128(&v10);
  v0[3] = _mm_loadu_si128(&v11);
  v0[4] = _mm_loadu_si128(&v12);
  v0[5] = _mm_loadu_si128(&v13);
  v0[6] = _mm_loadu_si128(&v14);
  v0[7] = _mm_loadu_si128(&v15);
  v0[8] = _mm_loadu_si128(&v16);
  v0[9] = _mm_loadu_si128(&v17);
  v0[10] = _mm_loadu_si128(&v18);
  v0[11] = _mm_loadu_si128(&v19);
  v0[12] = _mm_loadu_si128(&v20);
  v0[13] = _mm_loadu_si128(&v21);
  v0[14] = _mm_loadu_si128(&v22);
  LODWORD(v6) = v6 + 6;
  v3 = 0;
  v4 = &v3;
  v8.m128i_i64[0] = (__int64)"Force the tail folding style";
  v8.m128i_i64[1] = 28;
  sub_2AF6330(&unk_500E4C0, "force-tail-folding-style", &v8, &v4, &v5);
  if ( v5 != (int *)v7 )
    _libc_free(v5, "force-tail-folding-style");
  __cxa_atexit(sub_2AAA7E0, &unk_500E4C0, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Maximize bandwidth when selecting vectorization factor which will be determined by the smal"
                             "lest type in loop.";
  v8.m128i_i64[1] = 109;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_23A19B0(&unk_500E3E0, "vectorizer-maximize-bandwidth", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500E3E0, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Enable vectorization on interleaved memory accesses in a loop";
  v8.m128i_i64[1] = 61;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC310(&unk_500E300, "enable-interleaved-mem-accesses", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500E300, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Enable vectorization on masked interleaved memory accesses in a loop";
  v8.m128i_i64[1] = 68;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC420(&unk_500E220, "enable-masked-interleaved-mem-accesses", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500E220, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"A flag that overrides the target's number of scalar registers.";
  v8.m128i_i64[1] = 62;
  LODWORD(v4) = 1;
  v3 = 0;
  sub_2ABC530(&unk_500E140, "force-target-num-scalar-regs", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500E140, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"A flag that overrides the target's number of vector registers.";
  v8.m128i_i64[1] = 62;
  LODWORD(v4) = 1;
  v3 = 0;
  sub_2ABC530(&unk_500E060, "force-target-num-vector-regs", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500E060, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"A flag that overrides the target's max interleave factor for scalar loops.";
  v8.m128i_i64[1] = 74;
  LODWORD(v4) = 1;
  v3 = 0;
  sub_2ABC650(&unk_500DF80, "force-target-max-scalar-interleave", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500DF80, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"A flag that overrides the target's max interleave factor for vectorized loops.";
  v8.m128i_i64[1] = 78;
  LODWORD(v4) = 1;
  v3 = 0;
  sub_2ABC650(&unk_500DEA0, "force-target-max-vector-interleave", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500DEA0, &qword_4A427C0);
  sub_D95050(qword_500DDC0, 0, 0);
  qword_500DDC0[17] = 0;
  qword_500DDC0[18] = &unk_49D9728;
  qword_500DDC0[19] = 0;
  qword_500DDC0[0] = &unk_49DBF10;
  qword_500DDC0[20] = &unk_49DC290;
  qword_500DDC0[24] = nullsub_24;
  qword_500DDC0[23] = sub_984050;
  sub_C53080(qword_500DDC0, "force-target-instruction-cost", 29);
  LODWORD(qword_500DDC0[17]) = 0;
  BYTE4(qword_500DDC0[19]) = 1;
  qword_500DDC0[6] = 141;
  LODWORD(qword_500DDC0[19]) = 0;
  BYTE4(qword_500DDC0[1]) = BYTE4(qword_500DDC0[1]) & 0x9F | 0x20;
  qword_500DDC0[5] = "A flag that overrides the target's expected cost for an instruction to a single constant value. Mos"
                     "tly useful for getting consistent testing.";
  sub_C53130(qword_500DDC0);
  __cxa_atexit(sub_984970, qword_500DDC0, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Pretend that scalable vectors are supported, even if the target does not support them. This"
                             " flag should only be used for testing.";
  v8.m128i_i64[1] = 129;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC420(&unk_500DCE0, "force-target-supports-scalable-vectors", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500DCE0, &qword_4A427C0);
  sub_D95050(&qword_500DC00, 0, 0);
  qword_500DCC0 = (__int64)nullsub_24;
  qword_500DC90 = (__int64)&unk_49D9728;
  qword_500DC00 = (__int64)&unk_49DBF10;
  qword_500DCA0 = (__int64)&unk_49DC290;
  qword_500DCB8 = (__int64)sub_984050;
  qword_500DC88 = 0;
  qword_500DC98 = 0;
  sub_C53080(&qword_500DC00, "small-loop-cost", 15);
  LODWORD(qword_500DC88) = 20;
  BYTE4(qword_500DC98) = 1;
  LODWORD(qword_500DC98) = 20;
  qword_500DC30 = 65;
  byte_500DC0C = byte_500DC0C & 0x9F | 0x20;
  qword_500DC28 = (__int64)"The cost of a loop that is considered 'small' by the interleaver.";
  sub_C53130(&qword_500DC00);
  __cxa_atexit(sub_984970, &qword_500DC00, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Enable the use of the block frequency analysis to access PGO heuristics minimizing code gro"
                             "wth in cold regions and being more aggressive in hot regions.";
  v8.m128i_i64[1] = 152;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 1;
  sub_2ABC770(&unk_500DB20, "loop-vectorize-with-block-frequency", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500DB20, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Enable runtime interleaving until load/store ports are saturated";
  v8.m128i_i64[1] = 64;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 1;
  sub_2ABC770(&unk_500DA40, "enable-loadstore-runtime-interleave", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500DA40, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Max number of stores to be predicated behind an if.";
  v8.m128i_i64[1] = 51;
  LODWORD(v4) = 1;
  v3 = 1;
  sub_2ABC1F0(&unk_500D960, "vectorize-num-stores-pred", &v5, &v4, &v8);
  __cxa_atexit(sub_984970, &unk_500D960, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Count the induction variable only once when interleaving";
  v8.m128i_i64[1] = 56;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 1;
  sub_23A1AC0(&unk_500D880, "enable-ind-var-reg-heur", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500D880, &qword_4A427C0);
  sub_D95050(&qword_500D7A0, 0, 0);
  qword_500D828 = 0;
  qword_500D838 = 0;
  qword_500D860 = (__int64)nullsub_23;
  qword_500D830 = (__int64)&unk_49D9748;
  qword_500D858 = (__int64)sub_984030;
  qword_500D7A0 = (__int64)&unk_49DC090;
  qword_500D840 = (__int64)&unk_49DC1D0;
  sub_C53080(&qword_500D7A0, "enable-cond-stores-vec", 22);
  LOWORD(qword_500D838) = 257;
  qword_500D7C8 = (__int64)"Enable if predication of stores during vectorization.";
  LOBYTE(qword_500D828) = 1;
  qword_500D7D0 = 53;
  byte_500D7AC = byte_500D7AC & 0x9F | 0x20;
  sub_C53130(&qword_500D7A0);
  __cxa_atexit(sub_984900, &qword_500D7A0, &qword_4A427C0);
  sub_D95050(&qword_500D6C0, 0, 0);
  qword_500D748 = 0;
  qword_500D780 = (__int64)nullsub_24;
  qword_500D778 = (__int64)sub_984050;
  qword_500D750 = (__int64)&unk_49D9728;
  qword_500D6C0 = (__int64)&unk_49DBF10;
  qword_500D760 = (__int64)&unk_49DC290;
  qword_500D758 = 0;
  sub_C53080(&qword_500D6C0, "max-nested-scalar-reduction-interleave", 38);
  LODWORD(qword_500D748) = 2;
  BYTE4(qword_500D758) = 1;
  LODWORD(qword_500D758) = 2;
  qword_500D6F0 = 90;
  qword_500D6E8 = (__int64)"The maximum interleave count to use when interleaving a scalar reduction in a nested loop.";
  byte_500D6CC = byte_500D6CC & 0x9F | 0x20;
  sub_C53130(&qword_500D6C0);
  __cxa_atexit(sub_984970, &qword_500D6C0, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Prefer in-loop vector reductions, overriding the targets preference.";
  v8.m128i_i64[1] = 68;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC880(&unk_500D5E0, "prefer-inloop-reductions", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500D5E0, &qword_4A427C0);
  v8.m128i_i64[0] = (__int64)"Enable the vectorisation of loops with in-order (strict) FP reductions";
  v5 = &v3;
  v8.m128i_i64[1] = 70;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC880(&unk_500D500, "force-ordered-reductions", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500D500, &qword_4A427C0);
  sub_D95050(&qword_500D420, 0, 0);
  qword_500D4A8 = 0;
  qword_500D4B8 = 0;
  qword_500D4C0 = (__int64)&unk_49DC1D0;
  qword_500D4E0 = (__int64)nullsub_23;
  qword_500D4D8 = (__int64)sub_984030;
  qword_500D420 = (__int64)&unk_49DC090;
  qword_500D4B0 = (__int64)&unk_49D9748;
  sub_C53080(&qword_500D420, "prefer-predicated-reduction-select", 34);
  LOBYTE(qword_500D4A8) = 0;
  LOWORD(qword_500D4B8) = 256;
  qword_500D448 = (__int64)"Prefer predicating a reduction operation over an after loop select.";
  qword_500D450 = 67;
  byte_500D42C = byte_500D42C & 0x9F | 0x20;
  sub_C53130(&qword_500D420);
  __cxa_atexit(sub_984900, &qword_500D420, &qword_4A427C0);
  sub_D95050(qword_500D340, 0, 0);
  qword_500D340[0] = &unk_49DC090;
  qword_500D340[18] = &unk_49D9748;
  qword_500D340[20] = &unk_49DC1D0;
  qword_500D340[24] = nullsub_23;
  qword_500D340[23] = sub_984030;
  qword_500D340[17] = 0;
  qword_500D340[19] = 0;
  sub_C53080(qword_500D340, "enable-vplan-native-path", 24);
  qword_500D340[6] = 81;
  qword_500D340[5] = "Enable VPlan-native vectorization path with support for outer loop vectorization.";
  BYTE4(qword_500D340[1]) = BYTE4(qword_500D340[1]) & 0x9F | 0x20;
  sub_C53130(qword_500D340);
  __cxa_atexit(sub_984900, qword_500D340, &qword_4A427C0);
  sub_D95050(qword_500D260, 0, 0);
  qword_500D260[18] = &unk_49D9748;
  qword_500D260[0] = &unk_49DC090;
  qword_500D260[20] = &unk_49DC1D0;
  qword_500D260[24] = nullsub_23;
  qword_500D260[23] = sub_984030;
  qword_500D260[17] = 0;
  qword_500D260[19] = 0;
  sub_C53080(qword_500D260, "vplan-verify-each", 17);
  LOWORD(qword_500D260[19]) = 256;
  qword_500D260[5] = "Verfiy VPlans after VPlan transforms.";
  LOBYTE(qword_500D260[17]) = 0;
  qword_500D260[6] = 37;
  BYTE4(qword_500D260[1]) = BYTE4(qword_500D260[1]) & 0x9F | 0x20;
  sub_C53130(qword_500D260);
  __cxa_atexit(sub_984900, qword_500D260, &qword_4A427C0);
  v8.m128i_i64[0] = (__int64)"Build VPlan for every supported loop nest in the function and bail out right after the buil"
                             "d (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).";
  v5 = &v3;
  v8.m128i_i64[1] = 175;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_23A1AC0(&unk_500D180, "vplan-build-stress-test", &v5, &v4, &v8);
  __cxa_atexit(sub_984900, &unk_500D180, &qword_4A427C0);
  sub_D95050(qword_500D0A0, 0, 0);
  qword_500D0A0[0] = &unk_49DC090;
  qword_500D0A0[18] = &unk_49D9748;
  qword_500D0A0[20] = &unk_49DC1D0;
  qword_500D0A0[24] = nullsub_23;
  qword_500D0A0[23] = sub_984030;
  qword_500D0A0[17] = 0;
  qword_500D0A0[19] = 0;
  sub_C53080(qword_500D0A0, "interleave-loops", 16);
  LOWORD(qword_500D0A0[19]) = 257;
  qword_500D0A0[5] = "Enable loop interleaving in Loop vectorization passes";
  LOBYTE(qword_500D0A0[17]) = 1;
  qword_500D0A0[6] = 53;
  BYTE4(qword_500D0A0[1]) = BYTE4(qword_500D0A0[1]) & 0x9F | 0x20;
  sub_C53130(qword_500D0A0);
  __cxa_atexit(sub_984900, qword_500D0A0, &qword_4A427C0);
  sub_D95050(qword_500CFC0, 0, 0);
  qword_500CFC0[0] = &unk_49DC090;
  qword_500CFC0[18] = &unk_49D9748;
  qword_500CFC0[20] = &unk_49DC1D0;
  qword_500CFC0[24] = nullsub_23;
  qword_500CFC0[23] = sub_984030;
  qword_500CFC0[17] = 0;
  qword_500CFC0[19] = 0;
  sub_C53080(qword_500CFC0, "vectorize-loops", 15);
  LOWORD(qword_500CFC0[19]) = 257;
  qword_500CFC0[5] = "Run the Loop vectorization passes";
  LOBYTE(qword_500CFC0[17]) = 1;
  qword_500CFC0[6] = 33;
  BYTE4(qword_500CFC0[1]) = BYTE4(qword_500CFC0[1]) & 0x9F | 0x20;
  sub_C53130(qword_500CFC0);
  __cxa_atexit(sub_984900, qword_500CFC0, &qword_4A427C0);
  sub_D95050(&qword_500CEE0, 0, 0);
  qword_500CF68 = 0;
  qword_500CF78 = 0;
  qword_500CF70 = (__int64)&unk_49DC110;
  qword_500CEE0 = (__int64)&unk_49D97F0;
  qword_500CF80 = (__int64)&unk_49DC200;
  qword_500CFA0 = (__int64)nullsub_26;
  qword_500CF98 = (__int64)sub_9C26D0;
  sub_C53080(&qword_500CEE0, "force-widen-divrem-via-safe-divisor", 35);
  qword_500CF10 = 66;
  qword_500CF08 = (__int64)"Override cost based safe divisor widening for div/rem instructions";
  byte_500CEEC = byte_500CEEC & 0x9F | 0x20;
  sub_C53130(&qword_500CEE0);
  __cxa_atexit(sub_9C44F0, &qword_500CEE0, &qword_4A427C0);
  sub_D95050(&qword_500CE00, 0, 0);
  qword_500CE88 = 0;
  qword_500CE90 = (__int64)&unk_49D9748;
  qword_500CEA0 = (__int64)&unk_49DC1D0;
  qword_500CEC0 = (__int64)nullsub_23;
  qword_500CE00 = (__int64)&unk_49DC090;
  qword_500CEB8 = (__int64)sub_984030;
  qword_500CE98 = 0;
  sub_C53080(&qword_500CE00, "vectorizer-maximize-bandwidth-for-vector-calls", 46);
  LOWORD(qword_500CE98) = 257;
  LOBYTE(qword_500CE88) = 1;
  qword_500CE30 = 55;
  byte_500CE0C = byte_500CE0C & 0x9F | 0x20;
  qword_500CE28 = (__int64)"Try wider VFs if they enable the use of vector variants";
  sub_C53130(&qword_500CE00);
  __cxa_atexit(sub_984900, &qword_500CE00, &qword_4A427C0);
  v5 = &v3;
  v8.m128i_i64[0] = (__int64)"Enable vectorization of early exit loops with uncountable exits.";
  v8.m128i_i64[1] = 64;
  LODWORD(v4) = 1;
  LOBYTE(v3) = 0;
  sub_2ABC310(&unk_500CD20, "enable-early-exit-vectorization", &v5, &v4, &v8);
  return __cxa_atexit(sub_984900, &unk_500CD20, &qword_4A427C0);
}
