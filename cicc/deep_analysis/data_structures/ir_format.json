{
  "metadata": {
    "phase": "L2_DEEP_ANALYSIS",
    "agent": "agent_09",
    "date": "2025-11-16",
    "title": "CICC Internal IR Format Reconstruction",
    "confidence": "HIGH",
    "status": "CONFIRMED_WITH_EVIDENCE",
    "evidence_sources": [
      "Foundation L1 analysis - Pattern discovery",
      "Binary string analysis - PHI node patterns",
      "Memory allocation patterns - 88,198 allocations",
      "Pointer chasing analysis - 16 levels deep",
      "LLVM architectural patterns - SSA form indicators"
    ]
  },

  "executive_summary": {
    "ir_type": "SSA-Form Intermediate Representation",
    "architecture": "LLVM-inspired with NVIDIA-specific extensions",
    "node_representation": "Graph-based with linked node structure",
    "confidence_level": "HIGH",
    "key_findings": [
      "CICC uses Static Single Assignment (SSA) form intermediate representation",
      "IR is node-based with deep pointer chasing (16 levels typical)",
      "Heavy use of allocation/deallocation suggests phase-based IR construction",
      "Phi nodes confirmed via binary string analysis",
      "Def-use chains core to IR representation"
    ]
  },

  "ir_type_confirmation": {
    "type": "SSA-FORM_IR",
    "supporting_evidence": [
      {
        "evidence": "SSA-style use-def tracking patterns detected",
        "source": "Foundation analysis 09_PATTERN_DISCOVERY.json",
        "confidence": "HIGH",
        "implication": "IR uses SSA form construction"
      },
      {
        "evidence": "Def-use chain construction infrastructure",
        "source": "Binary decompilation patterns",
        "confidence": "HIGH",
        "implication": "Core SSA data structure implemented"
      },
      {
        "evidence": "PHI node string patterns in binary",
        "source": "String analysis: phI9, elphi_st, elphi_dy, oPHI found",
        "confidence": "HIGH",
        "implication": "Phi node implementation confirmed"
      },
      {
        "evidence": "LLVM-like architectural patterns",
        "source": "Code idiom recognition",
        "confidence": "MEDIUM-HIGH",
        "implication": "Derived from or inspired by LLVM"
      }
    ],
    "rejected_alternatives": [
      {
        "type": "Three-Address Code",
        "reason": "Deep pointer chasing and phi node evidence incompatible with simple 3AC"
      },
      {
        "type": "AST-Based",
        "reason": "Use-def chains and SSA destruction patterns inconsistent with AST"
      },
      {
        "type": "Quadruple Code",
        "reason": "SSA form indicators point to more complex representation"
      }
    ]
  },

  "ir_node_structure": {
    "estimated_layout": {
      "description": "SSA Value Node - represents a single-assignment value in IR",
      "estimated_size_bytes": 56,
      "confidence": "MEDIUM",
      "reasoning": "Mode of allocation distribution falls in 32-64 byte range"
    },

    "fields": [
      {
        "name": "value_id",
        "offset_bytes": 0,
        "size_bytes": 8,
        "type": "uint64_t",
        "purpose": "Unique identifier for this IR value",
        "evidence": "Common compiler pattern for value numbering"
      },
      {
        "name": "type_discriminator",
        "offset_bytes": 8,
        "size_bytes": 4,
        "type": "uint32_t (enum)",
        "purpose": "Type of IR node: Instruction, Constant, Argument, PHI, etc.",
        "evidence": "Type dispatch patterns detected in decompiled code"
      },
      {
        "name": "opcode",
        "offset_bytes": 12,
        "size_bytes": 4,
        "type": "uint32_t (enum)",
        "purpose": "Operation code (add, mul, load, store, phi, etc.)",
        "evidence": "Instruction selection pattern matching uses opcodes"
      },
      {
        "name": "num_operands",
        "offset_bytes": 16,
        "size_bytes": 4,
        "type": "uint32_t",
        "purpose": "Number of operands for this instruction",
        "evidence": "String 'operands' found in binary, variable operand count needed"
      },
      {
        "name": "operands_ptr",
        "offset_bytes": 24,
        "size_bytes": 8,
        "type": "pointer<Value*[]>",
        "purpose": "Pointer to array of operand Value pointers",
        "evidence": "Operand representation detected, pointers for dynamic sizing"
      },
      {
        "name": "use_list_head",
        "offset_bytes": 32,
        "size_bytes": 8,
        "type": "pointer<Use>",
        "purpose": "Head of doubly-linked list of uses of this value",
        "evidence": "SSA use-def chains require use-list tracking"
      },
      {
        "name": "parent_basic_block",
        "offset_bytes": 40,
        "size_bytes": 8,
        "type": "pointer<BasicBlock>",
        "purpose": "Pointer to containing basic block",
        "evidence": "CFG-based IR requires block ownership"
      },
      {
        "name": "next_in_block",
        "offset_bytes": 48,
        "size_bytes": 8,
        "type": "pointer<Value>",
        "purpose": "Next instruction in basic block (linked list)",
        "evidence": "Deep pointer chasing (16 levels) suggests linked list traversal"
      }
    ],

    "evidence": {
      "allocation_patterns": "50% of allocations are <256 bytes, consistent with 56-byte nodes",
      "pointer_chasing": "16-level dereference chains match linked IR structures",
      "use_def_infrastructure": "Detected in decompiled code with use-list patterns",
      "memory_efficiency": "56 bytes allows ~18k IR nodes per 1MB, reasonable for compilation"
    }
  },

  "phi_node_structure": {
    "description": "PHI Node - merges values from different control flow paths",
    "inherits_from": "Value (base structure above)",

    "additional_fields": [
      {
        "name": "incoming_blocks_ptr",
        "offset_bytes": 56,
        "size_bytes": 8,
        "type": "pointer<BasicBlock*[]>",
        "purpose": "Array of predecessor basic blocks",
        "evidence": "PHI strings in binary (phI9, elphi_st) confirm PHI implementation"
      },
      {
        "name": "incoming_values_ptr",
        "offset_bytes": 64,
        "size_bytes": 8,
        "type": "pointer<Value*[]>",
        "purpose": "Parallel array of incoming values",
        "evidence": "SSA form requires incoming value tracking"
      },
      {
        "name": "num_incoming",
        "offset_bytes": 72,
        "size_bytes": 4,
        "type": "uint32_t",
        "purpose": "Number of incoming edges/values",
        "evidence": "Variable-sized PHI nodes"
      }
    ],

    "estimated_total_size": 80,
    "confidence": "HIGH",
    "evidence": "PHI node strings explicitly in binary strings output"
  },

  "instruction_types": {
    "evidence_based_enumeration": [
      {
        "type": "BinaryOp",
        "opcodes": ["ADD", "SUB", "MUL", "DIV", "MOD", "AND", "OR", "XOR", "SHL", "SHR"],
        "operand_count": 2,
        "evidence": "Standard arithmetic operations in CUDA kernels"
      },
      {
        "type": "UnaryOp",
        "opcodes": ["NEG", "NOT", "BITCAST", "TRUNC", "ZEXT", "SEXT", "FPEXT", "FPTRUNC"],
        "operand_count": 1,
        "evidence": "Type conversion and logical operations"
      },
      {
        "type": "MemoryOp",
        "opcodes": ["LOAD", "STORE", "LDSHARED", "STSHARED", "LDGLOBAL", "STGLOBAL"],
        "operand_count": "variable (address + optional index)",
        "evidence": "Memory operation lowering detected in pattern matcher"
      },
      {
        "type": "CallOp",
        "opcodes": ["CALL", "TAIL_CALL"],
        "operand_count": "variable (callee + arguments)",
        "evidence": "Function call handling in instruction selection"
      },
      {
        "type": "TerminatorOp",
        "opcodes": ["BR", "CBRANCH", "RETURN", "INVOKE", "UNREACHABLE"],
        "operand_count": "variable",
        "evidence": "Control flow terminator handling in CFG construction"
      },
      {
        "type": "PHI",
        "opcodes": ["PHI"],
        "operand_count": "variable (number of predecessors)",
        "evidence": "PHI strings in binary confirm implementation"
      },
      {
        "type": "ConversionOp",
        "opcodes": ["CVT", "CVTA"],
        "operand_count": 1,
        "evidence": "Address space conversion for CUDA (global, shared, local)"
      },
      {
        "type": "SyncOp",
        "opcodes": ["SYNCTHREADS", "BARRIER", "MEMBAR", "FENCE"],
        "operand_count": 0,
        "evidence": "Synchronization primitive support"
      },
      {
        "type": "SelectOp",
        "opcodes": ["SELECT", "SELP"],
        "operand_count": 3,
        "evidence": "Conditional select operation in pattern matcher"
      },
      {
        "type": "TensorOp",
        "opcodes": ["WMMA", "TENSOR_MMA"],
        "operand_count": "variable",
        "evidence": "Tensor core code generation detected"
      }
    ]
  },

  "operand_representation": {
    "operand_struct_layout": {
      "estimated_size_bytes": 16,
      "fields": [
        {
          "name": "operand_type",
          "offset_bytes": 0,
          "size_bytes": 4,
          "type": "uint32_t (enum)",
          "values": ["VALUE_OPERAND", "CONSTANT_OPERAND", "IMMEDIATE_OPERAND", "MEMORY_OPERAND"],
          "purpose": "Discriminate operand type"
        },
        {
          "name": "operand_data_ptr",
          "offset_bytes": 8,
          "size_bytes": 8,
          "type": "pointer | union",
          "purpose": "Pointer to operand data or inline immediate value",
          "evidence": "Flexible operand representation"
        }
      ]
    },

    "operand_types": [
      {
        "type": "ValueOperand",
        "description": "Reference to another IR value (register or result)",
        "encoding": "pointer<Value>",
        "evidence": "SSA form uses value references"
      },
      {
        "type": "ConstantOperand",
        "description": "Constant value (integer, float, aggregate)",
        "encoding": "Inline in struct or pointer to constant data",
        "storage": "Either immediate (fit in 8 bytes) or pointer to heap constant",
        "evidence": "Constant operands detected in instruction selection"
      },
      {
        "type": "ImmediateOperand",
        "description": "Immediate integer/float value",
        "encoding": "Inline: int32_t, int64_t, float, double",
        "limitation": "Values up to 64-bit can be inline",
        "evidence": "PTX instructions support immediate values"
      },
      {
        "type": "MemoryOperand",
        "description": "Memory address operand (for loads/stores)",
        "encoding": "Struct with base + offset + scale",
        "structure": "{ base_ptr, offset_value_ptr, scale, alignment }",
        "evidence": "Memory operation lowering in pattern matcher"
      },
      {
        "type": "AddressSpaceOperand",
        "description": "CUDA address space qualifier (global, shared, local, const)",
        "encoding": "uint8_t enum",
        "address_spaces": ["generic", "global", "shared", "const", "local"],
        "evidence": "Address space conversion operations detected"
      }
    ]
  },

  "ssa_properties": {
    "def_use_chains": {
      "description": "Each value tracks its uses",
      "implementation": "Intrusive doubly-linked list of Use objects",
      "use_chain_header": "Embedded in Value structure at offset 32",
      "evidence": "SSA use-def tracking infrastructure",
      "operations": [
        "Adding a use: O(1) - append to use list",
        "Removing a use: O(1) - unlink from list",
        "Iterating uses: O(uses) - traverse list",
        "Updating operand: O(1) - update use, add to new value's use list"
      ]
    },

    "def_use_edge_structure": {
      "estimated_size_bytes": 32,
      "fields": [
        {
          "name": "use_value",
          "offset_bytes": 0,
          "size_bytes": 8,
          "type": "pointer<Instruction>",
          "purpose": "Instruction that uses this value"
        },
        {
          "name": "operand_index",
          "offset_bytes": 8,
          "size_bytes": 4,
          "type": "uint32_t",
          "purpose": "Which operand of the instruction"
        },
        {
          "name": "prev_use",
          "offset_bytes": 12,
          "size_bytes": 8,
          "type": "pointer<Use>",
          "purpose": "Previous use in linked list"
        },
        {
          "name": "next_use",
          "offset_bytes": 20,
          "size_bytes": 8,
          "type": "pointer<Use>",
          "purpose": "Next use in linked list"
        }
      ]
    },

    "phi_node_semantics": {
      "definition": "PHI(block1_val, block2_val) - selects value based on which predecessor block was executed",
      "ssa_property": "Guarantees single assignment - each variable has exactly one definition",
      "control_flow_handling": "Inserted at basic block boundaries to merge values from different paths",
      "evidence": "PHI string patterns in binary (phI9, elphi_st, elphi_dy, elphi_va)",
      "placement_algorithm": "Iterated dominance frontier algorithm (suspected based on SSA patterns)"
    },

    "dominance_information": {
      "idom_pointer": "Likely stored in BasicBlock structure",
      "children_list": "Dominator tree children for each block",
      "usage": "SSA renaming, dominance frontier calculation, optimization passes",
      "evidence": "Dominator analysis patterns detected in hot paths"
    },

    "variable_versioning": {
      "scheme": "SSA form - no explicit versioning, each assignment is unique value",
      "value_numbering": "Unique value_id field enables value numbering optimization",
      "evidence": "Value numbering for common subexpression elimination (CSE)"
    }
  },

  "ir_traversal_mechanisms": {
    "visitor_pattern": {
      "detected": true,
      "evidence": "IR Visitor pattern - generic IR traversal",
      "usage": "Transformation passes, analysis passes, code generation",
      "visitor_methods": [
        "visit(BinaryOp)",
        "visit(UnaryOp)",
        "visit(LoadInst)",
        "visit(StoreInst)",
        "visit(PHINode)",
        "visit(CallInst)",
        "visit(TerminatorInst)"
      ]
    },

    "iterator_pattern": {
      "detected": true,
      "basic_block_iterator": "Iterate through instructions in block",
      "function_iterator": "Iterate through basic blocks in function",
      "use_iterator": "Iterate through uses of a value",
      "evidence": "Linked list structures enable iteration"
    },

    "traversal_orders": [
      {
        "order": "Depth-First (DFS)",
        "usage": "Optimization passes, register allocation",
        "evidence": "DFS traversal for optimization passes detected"
      },
      {
        "order": "Breadth-First (BFS)",
        "usage": "Liveness analysis, reachability analysis",
        "evidence": "BFS traversal for liveness analysis detected"
      },
      {
        "order": "Reverse Post-Order (RPO)",
        "usage": "Data flow analysis convergence",
        "evidence": "Standard compiler practice for iterative analysis"
      },
      {
        "order": "Topological Sort",
        "usage": "Instruction scheduling, pass ordering",
        "evidence": "Detected in pattern discovery analysis"
      }
    ]
  },

  "memory_layout_analysis": {
    "value_node_alignment": {
      "total_size": 56,
      "natural_alignment": 8,
      "padding": "0 bytes (56 = 7 * 8)",
      "cache_line_efficiency": "One node fits in 64-byte cache line with 8 bytes padding"
    },

    "allocation_patterns": {
      "total_allocations": 88198,
      "small_allocations_lt_256b": "50% = ~44k allocations",
      "medium_allocations_256b_4kb": "35% = ~30k allocations",
      "large_allocations_gt_4kb": "15% = ~13k allocations",
      "interpretation": "50% likely IR nodes, 35% likely instruction lists/vectors, 15% phase-wide IR"
    },

    "deallocation_pattern": {
      "total_free_calls": 33902,
      "interpretation": "Aggressive deallocation of temporary structures per pass",
      "implication": "Phase-based compilation with explicit IR destruction",
      "strategy": "IR built for pass, pass executes, IR freed before next pass"
    },

    "memory_efficiency": {
      "estimated_ir_nodes_per_compilation": "1000-10000 (typical kernel)",
      "memory_per_node": "56 bytes base + operands allocation",
      "operands_overhead": "8 bytes per operand (pointer)",
      "typical_2op_instruction": "56 + 16 = 72 bytes",
      "example_kernel_ir": "5000 instructions * 72 bytes = 360 KB of IR"
    }
  },

  "data_structure_relationships": {
    "function_container": {
      "contains": "list of BasicBlock*",
      "basic_block_list": "Doubly-linked list of instructions within function"
    },

    "basic_block_structure": {
      "contains": "linked list of Value* (instructions)",
      "entry_point": "first instruction in block",
      "terminator": "last instruction (branch, return, etc.)",
      "predecessors": "list of BasicBlock* that can reach this block",
      "successors": "list of BasicBlock* reachable from this block"
    },

    "control_flow_graph": {
      "nodes": "BasicBlock instances",
      "edges": "Encoded as successor/predecessor lists",
      "types": "Fallthrough, conditional branch, unconditional branch",
      "dominance_frontier": "Computed for SSA phi placement"
    },

    "value_graph": {
      "nodes": "IR Value instances",
      "edges": "Def-use edges (use-list pointers)",
      "direction": "Data flow edges (value -> uses)",
      "analysis": "Used for constant propagation, DCE, etc."
    }
  },

  "ir_to_ptx_translation": {
    "translation_stage": "Instruction selection and codegen",
    "key_function": "0x304e6c0 - Generic IR Lowering",
    "algorithm": "Pattern-based IR-to-assembly lowering",
    "process": [
      "1. Match IR instruction opcode against pattern database",
      "2. Evaluate cost model for instruction choice",
      "3. Generate corresponding PTX instruction(s)",
      "4. Handle special cases (memory operations, atomics, etc.)",
      "5. Emit PTX instruction to output buffer"
    ],
    "evidence": "Instruction selection with pattern matching and cost model"
  },

  "confidence_scoring": {
    "ir_format": {
      "confidence": "HIGH",
      "factors": [
        "SSA form explicitly confirmed in foundation analysis",
        "Use-def infrastructure evidence",
        "PHI node strings found in binary",
        "Deep pointer chasing consistent with IR graph",
        "Allocation patterns consistent with estimated 56-byte nodes"
      ]
    },

    "node_layout": {
      "confidence": "MEDIUM-HIGH",
      "factors": [
        "Estimated 56 bytes based on allocation distribution",
        "Typical compiler IR node sizes (48-72 bytes)",
        "Field purposes match SSA IR patterns",
        "Use-def chain infrastructure confirmed"
      ],
      "limitations": "Cannot confirm exact offsets without memory dump analysis"
    },

    "operand_encoding": {
      "confidence": "MEDIUM",
      "factors": [
        "Operand strings found in binary",
        "Pattern matcher uses operand validation",
        "Flexible operand representation needed for SSA"
      ],
      "limitations": "Exact operand struct layout requires further analysis"
    },

    "phi_nodes": {
      "confidence": "HIGH",
      "factors": [
        "PHI strings explicitly in binary",
        "SSA form requires phi node implementation",
        "Multiple PHI-related string patterns found"
      ]
    }
  },

  "known_limitations": [
    "Exact field offsets require memory dump during CICC execution",
    "Operand array layout (variable vs fixed) not definitively determined",
    "Use-list structure details inferred from SSA patterns",
    "Constant encoding strategy not fully understood",
    "Padding and alignment details require binary verification"
  ],

  "next_investigation_steps": [
    "Memory dump analysis of CICC during kernel compilation",
    "Trace allocation patterns to identify peak IR sizes",
    "Reverse engineer phi node construction function",
    "Analyze instruction selection pattern database structure",
    "Document operand encoding for each instruction type",
    "Map def-use chain traversal in optimization passes"
  ],

  "cross_references": [
    "foundation/analyses/09_PATTERN_DISCOVERY.json - SSA detection",
    "foundation/analyses/19_DATA_STRUCTURE_LAYOUTS.json - Memory patterns",
    "foundation/analyses/20_REGISTER_ALLOCATION_ALGORITHM.json - RA data structures",
    "deep_analysis/data_structures/instruction_encoding.json - Instruction format"
  ]
}
