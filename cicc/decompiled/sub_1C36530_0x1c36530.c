// Function: sub_1C36530
// Address: 0x1c36530
//
__int64 __fastcall sub_1C36530(__int64 a1, __int64 *a2)
{
  const char *v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 *v5; // r14
  __int64 v7; // rax
  unsigned int v8; // r15d
  __int64 v9; // rax
  _QWORD *v10; // rbx
  __int64 v11; // rax
  __m128i *v12; // rdx
  __int64 v13; // rdi
  __m128i v14; // xmm0
  _BYTE *v15; // rax
  const char *v16; // rsi
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rax
  __m128i *v21; // rdx
  __int64 v22; // rdi
  __m128i v23; // xmm0
  __m128i v24; // xmm0
  _BYTE *v25; // rax
  __int64 v26; // rax
  __int64 v27; // r13
  __int64 v28; // rax
  __int64 v29; // r15
  __int64 v30; // rbx
  __int64 v31; // rdi
  __int64 v32; // rdx
  __int64 v33; // rdi
  __m128i *v34; // rdx
  _BYTE *v35; // rax
  __int64 v36; // rax
  __int64 v37; // rdi
  __int64 v38; // rdx
  __int64 v39; // rdi
  _WORD *v40; // rdx
  __int64 v41; // rdx
  char v42; // al
  __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 *v48; // rdx
  __int64 v49; // rax
  unsigned __int64 v50; // rbx
  __int64 v51; // rax
  __int64 v52; // rdx
  const char *v53; // rsi
  __int64 v54; // rdi
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rax
  __int64 v59; // rsi
  _QWORD *v60; // rdx
  const char *v61; // rsi
  __int64 v62; // rdi
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rax
  _QWORD *v66; // rdi
  unsigned __int64 v67; // rbx
  __int64 v68; // rax
  unsigned int v69; // edx
  __int64 v70; // rax
  __int64 v71; // rbx
  __int64 i; // r13
  __int64 v73; // rax
  __m128i *v74; // rdx
  __int64 v75; // rdi
  __m128i v76; // xmm0
  __int64 v77; // rdx
  __m128i v78; // xmm0
  __int64 v79; // rdi
  unsigned __int8 v80; // al
  __int64 v82; // rax
  __m128i *v83; // rdx
  __int64 v84; // rdi
  __m128i si128; // xmm0
  _BYTE *v86; // rax
  bool v87; // r13
  __int64 v88; // rdx
  _QWORD *v89; // rax
  unsigned int v90; // ebx
  unsigned int v91; // r13d
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  __m128i *v95; // rdx
  __int64 v96; // rdi
  __m128i v97; // xmm0
  _BYTE *v98; // rax
  __int64 v99; // rax
  __m128i *v100; // rdx
  __int64 v101; // rdi
  __m128i v102; // xmm0
  _BYTE *v103; // rax
  __int64 v104; // rdi
  char v105; // al
  unsigned __int64 v106; // rax
  __int64 v107; // rdx
  __int64 v108; // rax
  __int64 v109; // rax
  unsigned int v110; // ecx
  __int64 v111; // rax
  __m128i *v112; // rdx
  __int64 v113; // rdi
  __m128i v114; // xmm0
  const char *v115; // rsi
  __int64 v116; // rdi
  __int64 v117; // rax
  __int64 v118; // rax
  __int64 v119; // rax
  __int64 *v120; // rax
  unsigned __int64 v121; // rax
  __int64 v122; // rdx
  __int64 v123; // rax
  __int64 v124; // rax
  __int64 v125; // rcx
  unsigned int v126; // ebx
  char v127; // r8
  __int64 v128; // rbx
  __int64 v129; // rdx
  _QWORD *v130; // rax
  char v131; // bl
  int v132; // eax
  __int64 v133; // rax
  __int64 v134; // rax
  __int64 v135; // rax
  __int64 v136; // rax
  __int64 v137; // rdx
  _QWORD *v138; // rax
  __int64 v139; // rax
  __int64 v140; // rax
  __int64 v141; // rax
  __int64 v142; // rsi
  const char *v143; // rsi
  __int64 v144; // rdi
  __int64 v145; // rax
  __int64 *v146; // rax
  __int64 v147; // rax
  __int64 v148; // rax
  __int64 v149; // rdx
  _QWORD *v150; // rax
  int v151; // ebx
  unsigned int v152; // r13d
  __int64 v153; // rax
  __int64 v154; // rax
  __int64 v155; // rax
  __int64 v156; // rax
  __int64 v157; // rax
  __int64 v158; // rdx
  _QWORD *v159; // rax
  __int64 v160; // rax
  __int64 v161; // rax
  __int64 v162; // rdx
  _QWORD *v163; // rax
  int v164; // ebx
  __int64 v165; // rax
  __int64 v166; // rax
  __int64 v167; // rax
  __int64 v168; // rax
  __int64 v169; // rax
  __int64 v170; // rax
  __int64 v171; // rax
  __int64 v172; // rdi
  __int64 v173; // r13
  char *v174; // rax
  size_t v175; // rdx
  void *v176; // rdi
  size_t v177; // rbx
  __int64 v178; // rdx
  unsigned __int64 v179; // rax
  const char *v180; // rsi
  __int64 v181; // rdi
  __int64 v182; // rax
  __int64 v183; // rax
  __int64 v184; // rax
  __int64 v185; // rax
  __int64 v186; // rax
  __int64 v187; // rdx
  _QWORD *v188; // rax
  __int64 v189; // rax
  __int64 v190; // rax
  __int64 v191; // rax
  _QWORD *v192; // rbx
  __int64 v193; // rax
  __int64 v194; // rsi
  _QWORD *v195; // rdx
  __int64 v196; // rax
  __int64 v197; // rax
  __int64 v198; // rax
  __int64 v199; // rax
  __int64 v200; // rax
  __int64 v201; // r13
  __int64 v202; // rax
  __int64 v203; // rax
  __int64 v204; // rax
  __int64 v205; // rdx
  unsigned __int64 v206; // rbx
  __int64 v207; // rax
  __int64 v208; // rax
  __int64 v209; // rdx
  _QWORD *v210; // rax
  __int64 v211; // rax
  __int64 v212; // rax
  __int64 *v213; // rax
  __int64 v214; // rax
  __int64 v215; // rax
  __int64 v216; // rax
  unsigned __int8 *v217; // rdx
  __int64 v218; // rbx
  __int64 v219; // rax
  __int64 v220; // rax
  __int64 v221; // rax
  __int64 v222; // rax
  _QWORD *v223; // rbx
  __int64 v224; // rax
  __int64 v225; // rax
  __int64 v226; // rax
  __int64 v227; // rax
  int v228; // eax
  int v229; // eax
  __int64 v230; // rax
  __int64 v231; // rax
  __int64 v232; // rax
  __int64 v233; // rax
  __int64 v234; // rdx
  __int64 v235; // rsi
  _QWORD *v236; // rax
  int v237; // ebx
  __int64 v238; // rax
  __int64 v239; // rax
  __int64 v240; // r13
  __int64 v241; // rax
  __int64 v242; // rax
  __int64 v243; // rax
  __int64 v244; // rax
  __int64 v245; // rax
  int v246; // eax
  __int64 v247; // rax
  __int64 v248; // rax
  __int64 v249; // rax
  __int64 v250; // rax
  __int64 v251; // rdi
  char v252; // al
  __int64 v253; // rax
  __int64 v254; // rax
  __int64 v255; // rax
  int v256; // eax
  __int64 v257; // rax
  _QWORD *v258; // r13
  unsigned int v259; // ebx
  __int64 v260; // rax
  __int64 v261; // rax
  int v262; // eax
  __int64 v263; // rbx
  __int64 v264; // rax
  __int64 v265; // r13
  unsigned int v266; // edx
  __int64 v267; // rcx
  __int64 v268; // rcx
  char v269; // al
  __int64 v270; // rdi
  __int64 v271; // rdi
  char v272; // al
  __int64 v273; // rdi
  unsigned __int64 v274; // r13
  int v275; // eax
  __int64 v276; // rcx
  __int64 v277; // rdx
  __int64 v278; // rsi
  __int64 v279; // rax
  __int64 v280; // rax
  __int64 v281; // rax
  __int64 v282; // rax
  char v283; // al
  __int64 v284; // rdi
  _QWORD *v285; // rax
  _QWORD *v286; // rax
  const char *v287; // rsi
  __int64 v288; // rdi
  __int64 v289; // rax
  _QWORD *v290; // rax
  _QWORD *v291; // rax
  __int64 v292; // rax
  __int64 v293; // rax
  __int64 v294; // rax
  __int64 v295; // rsi
  __int64 v296; // rdx
  __int64 v297; // rbx
  __int64 v298; // r13
  __int64 v299; // rcx
  __int64 v300; // rax
  _QWORD *v301; // rax
  __int64 v302; // rax
  __int64 v303; // rax
  _QWORD *v304; // rax
  const char *v305; // rsi
  __int64 v306; // rdi
  __int64 v307; // rax
  char v308; // al
  const char *v309; // rsi
  __int64 v310; // rdi
  __int64 v311; // rax
  _QWORD *v312; // rax
  const char *v313; // rsi
  __int64 v314; // rdi
  __int64 v315; // rax
  char v316; // al
  __int64 v317; // rax
  __int64 v318; // rax
  int v319; // eax
  __int64 v320; // rdx
  _QWORD *v321; // rax
  unsigned __int8 v322; // bl
  unsigned __int8 v323; // al
  unsigned __int8 v324; // bl
  unsigned __int8 v325; // al
  __int64 v326; // rax
  __int64 v327; // rax
  int v328; // eax
  __int64 v329; // rax
  unsigned __int64 v330; // rbx
  char v331; // r13
  __int64 v332; // rax
  __int64 v333; // rax
  __int64 v334; // rax
  __int64 v335; // rax
  __int64 v336; // rax
  __int64 v337; // rax
  __int64 v338; // rdx
  __int64 v339; // rax
  __int64 v340; // r13
  __int64 v341; // rbx
  __int64 v342; // rax
  _QWORD *v343; // rax
  const char *v344; // rsi
  __int64 v345; // rdi
  __int64 v346; // rax
  char v347; // al
  __int64 v348; // rax
  __int64 v349; // rax
  int v350; // eax
  __int64 v351; // rax
  __int64 v352; // rax
  __int64 v353; // rax
  __int64 v354; // rdx
  _QWORD *v355; // rbx
  __int64 *v356; // rax
  __int64 v357; // r13
  int v358; // ebx
  __int64 v359; // rax
  __int64 v360; // rax
  __int64 v361; // rax
  __int64 v362; // rax
  __int64 v363; // rax
  __int64 v364; // rax
  __int64 v365; // rdx
  _QWORD *v366; // rax
  char v367; // bl
  __int64 v368; // rax
  __int64 v369; // rax
  __int64 v370; // rax
  __int64 v371; // rax
  __int64 v372; // rax
  __int64 v373; // rax
  __int64 v374; // rax
  __int64 v375; // rbx
  __int64 v377; // r14
  const char *v378; // rsi
  __int64 v379; // rdi
  __int64 v380; // rax
  __int64 v381; // rax
  __int64 v382; // rax
  __int64 v383; // rax
  __int64 v384; // rax
  __int64 v385; // rax
  __int64 v386; // rcx
  _QWORD *v387; // rdx
  __int64 v388; // rbx
  __int64 v389; // rax
  __int64 v390; // rax
  __int64 v391; // rax
  __int64 v392; // rax
  __int64 v393; // rax
  _QWORD *v394; // rdx
  unsigned __int64 v395; // rax
  __int64 v396; // rdx
  __int64 v397; // rax
  int v398; // ecx
  __int64 v399; // rax
  int v400; // ebx
  __int64 v401; // rax
  __int64 v402; // rax
  const char *v403; // rsi
  __int64 v404; // rdi
  __int64 v405; // rax
  __int64 v406; // rax
  __int64 v407; // rax
  __int64 v408; // rbx
  const char *v409; // rsi
  __int64 v410; // rdi
  __int64 v411; // rax
  __int64 v412; // rax
  __int64 v413; // rax
  __int64 v414; // rax
  __int64 v415; // rax
  __int64 v416; // rax
  __int64 v417; // rax
  __int64 v418; // rdx
  _QWORD *v419; // rax
  char v420; // bl
  __int64 v421; // rdx
  __int64 v422; // rdi
  int v423; // edx
  __int64 v424; // rax
  __int64 v425; // rax
  __int64 v426; // rax
  __int64 v427; // rax
  __int64 v428; // rax
  __int64 v429; // rax
  int v430; // eax
  __int64 v431; // rax
  __int64 v432; // rax
  const char *v433; // rsi
  __int64 v434; // rdi
  __int64 v435; // rax
  __int64 v436; // rdx
  __int64 *v437; // rax
  __int64 v438; // rdi
  __int64 v439; // rax
  __int64 v440; // rax
  __int64 v441; // rax
  __int64 v442; // rax
  __int64 v443; // rax
  _QWORD *v444; // rdx
  unsigned __int64 v445; // rax
  __int64 v446; // rdx
  __int64 v447; // rax
  __int64 v448; // rax
  __int64 v449; // rax
  _QWORD *v450; // rbx
  __int64 v451; // rax
  __int64 v452; // rax
  __int64 v453; // rax
  __int64 v454; // rax
  __int64 v455; // rax
  __int64 v456; // rax
  __int64 v457; // rax
  __int64 v458; // rax
  __int64 v459; // rax
  __int64 v460; // rax
  __int64 v461; // rax
  __int64 v462; // rax
  __int64 v463; // rax
  __int64 v464; // rax
  __int64 v465; // rax
  const char *v466; // rsi
  __int64 v467; // rdi
  __int64 v468; // rax
  __int64 v469; // rax
  __int64 v470; // rax
  __int64 v471; // rax
  __int64 v472; // rax
  __int64 v473; // rax
  __int64 v474; // rax
  __int64 v475; // rax
  __int64 v476; // rax
  __int64 v477; // rax
  __int64 v478; // rax
  __int64 v479; // rax
  __int64 v480; // rax
  __int64 *v481; // rax
  __int64 v482; // rdi
  __int64 v483; // rax
  __int64 v484; // rax
  __int64 v485; // rax
  __int64 v486; // rax
  __int64 v487; // rax
  __int64 v488; // rax
  __int64 v489; // rax
  __int64 v490; // rax
  __int64 v491; // rax
  __int64 v492; // rax
  __int64 v493; // rax
  __int64 v494; // rax
  __int64 v495; // rax
  __int64 v496; // rax
  __int64 v497; // rax
  __int64 v498; // rax
  __int64 v499; // rax
  __int64 v500; // rax
  __int64 v501; // rax
  __int64 v502; // rax
  __int64 *v503; // rax
  __int64 v504; // rdx
  _QWORD *v505; // rax
  unsigned int v506; // ebx
  __int64 v507; // rax
  __int64 v508; // rax
  __int64 v509; // rax
  __int64 v510; // rax
  const char *v511; // rsi
  __int64 v512; // rdi
  __int64 v513; // rax
  const char *v514; // rsi
  __int64 v515; // rdi
  __int64 v516; // rax
  __int64 v517; // rax
  __int64 v518; // rax
  __int64 v519; // rax
  __int64 v520; // rax
  __int64 v521; // rax
  __int64 v522; // rax
  __int64 v523; // rax
  __int64 v524; // rax
  __int64 v525; // rax
  __int64 v526; // rax
  __int64 v527; // rax
  __int64 v528; // rax
  __int64 v529; // rax
  __int64 v530; // rax
  __int64 v531; // rax
  __int64 v532; // rax
  __int64 v533; // rax
  __int64 v534; // rax
  __int64 v535; // rax
  __int64 v536; // rax
  __int64 v537; // rdx
  _QWORD *v538; // rax
  __int16 v539; // r13d^2
  unsigned __int16 v540; // bx
  char v541; // al
  __int64 v542; // rax
  __int64 v543; // rax
  __int64 v544; // rax
  __int64 v545; // rax
  int v546; // eax
  __int64 v547; // r13
  int v548; // r15d
  _QWORD *v549; // rax
  __int64 v550; // rax
  __int64 v551; // rax
  __int64 v552; // rax
  __int64 v553; // rax
  __int64 v554; // rax
  __int64 v555; // rax
  __int64 v556; // rbx
  __int64 v557; // rax
  __int64 v558; // rax
  __int64 v559; // rax
  __int64 v560; // rax
  __int64 v561; // rax
  __int64 v562; // rax
  __int64 v563; // rax
  const char *v564; // rsi
  __int64 v565; // rdi
  __int64 v566; // rax
  __int64 v567; // rax
  __int64 v568; // rax
  __int64 v569; // rax
  __int64 v570; // rax
  __int64 v571; // rax
  __int64 v572; // rax
  __int64 v573; // rax
  __int64 v574; // rax
  __int64 v575; // rax
  __int64 v576; // rax
  __int64 v577; // rax
  __int64 v578; // rax
  __int64 v579; // rax
  __int64 v580; // rax
  __int64 v581; // rax
  __int64 v582; // rax
  __int64 v583; // rax
  __int64 v584; // rax
  __int64 v585; // rax
  __int64 v586; // rax
  __int64 v587; // rax
  __int64 v588; // rax
  __int64 v589; // rax
  __int64 v590; // rax
  __int64 v591; // rax
  __int64 v592; // rax
  __int64 v593; // rax
  __int64 v594; // rax
  int v595; // eax
  __int64 v596; // rbx
  __int64 v597; // rax
  __int64 v598; // rax
  __int64 v599; // rdx
  _QWORD *v600; // rax
  unsigned int v601; // edx
  _QWORD *v602; // rax
  __int64 v603; // rax
  __int64 v604; // rax
  __int64 v605; // rax
  _QWORD *v606; // rbx
  __int64 v607; // rdx
  _QWORD *v608; // rax
  const char *v609; // rsi
  __int64 v610; // rdi
  __int64 v611; // rax
  __int64 v612; // rax
  __int64 v613; // rax
  __int64 v614; // rax
  __int64 v615; // rax
  _QWORD *v616; // rbx
  __int64 v617; // rax
  __int64 v618; // rax
  __int64 v619; // rax
  __int64 v620; // rax
  __int64 v621; // rax
  const char *v622; // rsi
  __int64 v623; // rdi
  __int64 v624; // rax
  __int64 v625; // rax
  __int64 v626; // rax
  __int64 v627; // rax
  __int64 v628; // rax
  __int64 v629; // rax
  __int64 v630; // rax
  __int64 v631; // rax
  __int64 v632; // rax
  __int64 v633; // rax
  __int64 v634; // rax
  __int64 v635; // rax
  __int64 v636; // rax
  __int64 v637; // rax
  __int64 v638; // rax
  __int64 v639; // rax
  __int64 v640; // rax
  __int64 v641; // rax
  __int64 v642; // rax
  __int64 v643; // rax
  __int64 v644; // rax
  __int64 v645; // rax
  __int64 v646; // rax
  int v647; // [rsp+Ch] [rbp-74h]
  unsigned __int64 v648; // [rsp+10h] [rbp-70h]
  int v649; // [rsp+18h] [rbp-68h]
  __int64 ***v650; // [rsp+20h] [rbp-60h]
  char v651; // [rsp+20h] [rbp-60h]
  unsigned int v652; // [rsp+20h] [rbp-60h]
  __int64 v653; // [rsp+28h] [rbp-58h]
  __int64 v654; // [rsp+28h] [rbp-58h]
  int v655; // [rsp+28h] [rbp-58h]
  __int64 v656; // [rsp+30h] [rbp-50h]
  __int64 v657; // [rsp+30h] [rbp-50h]
  int v658; // [rsp+30h] [rbp-50h]
  char v659; // [rsp+30h] [rbp-50h]
  char v660; // [rsp+30h] [rbp-50h]
  __int64 v661; // [rsp+38h] [rbp-48h]
  __int64 v662; // [rsp+38h] [rbp-48h]
  unsigned __int64 v663; // [rsp+38h] [rbp-48h]
  __int16 v664; // [rsp+3Ah] [rbp-46h]
  __int64 v665; // [rsp+44h] [rbp-3Ch]
  int v666; // [rsp+4Ch] [rbp-34h]

  v5 = a2;
  v7 = *(a2 - 3);
  if ( *(_DWORD *)(*(_QWORD *)v7 + 8LL) >> 8 )
  {
    v82 = sub_1C321C0(a1, (__int64)a2, 0);
    v83 = *(__m128i **)(v82 + 24);
    v84 = v82;
    if ( *(_QWORD *)(v82 + 16) - (_QWORD)v83 <= 0x30u )
    {
      v84 = sub_16E7EE0(v82, "Function pointers should always use addrspace(0).", 0x31u);
      v86 = *(_BYTE **)(v84 + 24);
    }
    else
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_42D0B70);
      v83[3].m128i_i8[0] = 46;
      *v83 = si128;
      v83[1] = _mm_load_si128((const __m128i *)&xmmword_42D0B80);
      v83[2] = _mm_load_si128((const __m128i *)&xmmword_42D0B90);
      v86 = (_BYTE *)(*(_QWORD *)(v82 + 24) + 49LL);
      *(_QWORD *)(v84 + 24) = v86;
    }
    if ( *(_BYTE **)(v84 + 16) == v86 )
    {
      sub_16E7EE0(v84, "\n", 1u);
    }
    else
    {
      *v86 = 10;
      ++*(_QWORD *)(v84 + 24);
    }
    sub_1C31880(a1);
    v7 = *(a2 - 3);
  }
  if ( *(_BYTE *)(v7 + 16) || (*(_BYTE *)(v7 + 33) & 0x20) == 0 )
  {
    v69 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
    if ( !v69 )
      goto LABEL_33;
    v70 = v69;
    if ( *(_BYTE *)(a2[3 * (v69 - 1 - (unsigned __int64)v69)] + 16) != 20 || v69 == 1 )
      goto LABEL_33;
    v71 = v69 - 2;
    for ( i = 0; ; ++i )
    {
      v79 = *(_QWORD *)a2[3 * (i - v70)];
      v80 = *(_BYTE *)(v79 + 8);
      if ( v80 == 11 )
      {
        v110 = sub_1643030(v79) - 8;
        if ( v110 > 0x38 || ((1LL << v110) & 0x100000001000101LL) == 0 )
        {
          v111 = sub_1C321C0(a1, (__int64)a2, 0);
          v112 = *(__m128i **)(v111 + 24);
          v113 = v111;
          if ( *(_QWORD *)(v111 + 16) - (_QWORD)v112 <= 0x27u )
          {
            v113 = sub_16E7EE0(v111, "Invalid type in inline assembly, must be", 0x28u);
          }
          else
          {
            v114 = _mm_load_si128((const __m128i *)&xmmword_42D0C20);
            v112[2].m128i_i64[0] = 0x6562207473756D20LL;
            *v112 = v114;
            v112[1] = _mm_load_si128((const __m128i *)&xmmword_42D0C30);
            *(_QWORD *)(v111 + 24) += 40LL;
          }
          sub_1263B40(v113, " i8, i16, i32, i64, float, or double\n");
          goto LABEL_128;
        }
      }
      else
      {
        if ( v80 <= 0xBu )
        {
          if ( (unsigned __int8)(v80 - 2) <= 1u )
            goto LABEL_129;
LABEL_124:
          v73 = sub_1C321C0(a1, (__int64)a2, 0);
          v74 = *(__m128i **)(v73 + 24);
          v75 = v73;
          if ( *(_QWORD *)(v73 + 16) - (_QWORD)v74 <= 0x28u )
          {
            v119 = sub_16E7EE0(v73, "Invalid type in inline assembly, must be ", 0x29u);
            v77 = *(_QWORD *)(v119 + 24);
            v75 = v119;
          }
          else
          {
            v76 = _mm_load_si128((const __m128i *)&xmmword_42D0C20);
            v74[2].m128i_i8[8] = 32;
            v74[2].m128i_i64[0] = 0x6562207473756D20LL;
            *v74 = v76;
            v74[1] = _mm_load_si128((const __m128i *)&xmmword_42D0C30);
            v77 = *(_QWORD *)(v73 + 24) + 41LL;
            *(_QWORD *)(v73 + 24) = v77;
          }
          if ( (unsigned __int64)(*(_QWORD *)(v75 + 16) - v77) <= 0x23 )
          {
            sub_16E7EE0(v75, "i8, i16, i32, i64, float, or double\n", 0x24u);
          }
          else
          {
            v78 = _mm_load_si128((const __m128i *)&xmmword_42D0C40);
            *(_DWORD *)(v77 + 32) = 174419042;
            *(__m128i *)v77 = v78;
            *(__m128i *)(v77 + 16) = _mm_load_si128((const __m128i *)&xmmword_42D0C50);
            *(_QWORD *)(v75 + 24) += 36LL;
          }
LABEL_128:
          sub_1C31880(a1);
          goto LABEL_129;
        }
        if ( v80 != 15 )
          goto LABEL_124;
      }
LABEL_129:
      if ( i == v71 )
        goto LABEL_33;
      v70 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
    }
  }
  v8 = *(_DWORD *)(v7 + 36);
  if ( v8 > 0x1004 )
  {
    if ( v8 == 4994 )
    {
      v187 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v187 + 16) == 13 )
      {
        v188 = *(_QWORD **)(v187 + 24);
        if ( *(_DWORD *)(v187 + 32) > 0x40u )
          v188 = (_QWORD *)*v188;
        if ( (_DWORD)v188 )
        {
          v189 = sub_1C321C0(a1, (__int64)a2, 0);
          v190 = sub_1263B40(v189, "syncwarp mode not a valid value");
          sub_1263B40(v190, "\n");
          sub_1C31880(a1);
        }
      }
      else
      {
        v462 = sub_1C321C0(a1, (__int64)a2, 0);
        v463 = sub_1263B40(v462, "the mode parameter must be constant");
        sub_1263B40(v463, "\n");
        sub_1C31880(a1);
      }
      goto LABEL_9;
    }
    if ( v8 > 0x1382 )
    {
      if ( v8 <= 0x1492 )
      {
        if ( v8 <= 0x146F )
        {
          if ( v8 == 4996 )
          {
            v41 = *(_QWORD *)a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
            v42 = *(_BYTE *)(v41 + 8);
            if ( v42 == 16 )
              v42 = *(_BYTE *)(**(_QWORD **)(v41 + 16) + 8LL);
            if ( (unsigned __int8)(v42 - 1) > 1u )
            {
              v43 = sub_1C321C0(a1, (__int64)a2, 0);
              v44 = sub_1263B40(v43, "arg0 must be either half (vector) or float (vector)");
              sub_1263B40(v44, "\n");
              sub_1C31880(a1);
            }
          }
          goto LABEL_9;
        }
        switch ( v8 )
        {
          case 0x1470u:
            v216 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
            if ( *(_BYTE *)(v216 + 16) != 19 || (v217 = *(unsigned __int8 **)(v216 + 24), (unsigned int)*v217 - 1 > 1) )
            {
              v218 = 0;
              v412 = sub_1C321C0(a1, (__int64)a2, 0);
              v413 = sub_1263B40(
                       v412,
                       "Op0 of nvvm.texsurf.handle must be a metadata wrapper around a tex/surf GlobalVariable (e.g. meta"
                       "data i64 addrspace(1)* @tex )");
              sub_1263B40(v413, "\n");
              sub_1C31880(a1);
              goto LABEL_367;
            }
            v218 = *((_QWORD *)v217 + 17);
            if ( *(_BYTE *)(v218 + 16) == 3 )
            {
              if ( (unsigned __int8)sub_1C2E830(*((_QWORD *)v217 + 17)) || (unsigned __int8)sub_1C2E860(v218) )
              {
LABEL_367:
                v219 = a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
                if ( !v219 )
LABEL_827:
                  BUG();
                if ( *(_BYTE *)(v219 + 16) != 3 || v218 != v219 )
                {
                  v220 = sub_1C321C0(a1, (__int64)a2, 0);
                  v221 = sub_1263B40(v220, "Op1 must be the same tex/surf GV from Op0");
                  sub_1263B40(v221, "\n");
                  sub_1C31880(a1);
                }
                goto LABEL_9;
              }
            }
            else
            {
              v218 = 0;
            }
            v587 = sub_1C321C0(a1, (__int64)a2, 0);
            v588 = sub_1263B40(
                     v587,
                     "Op0 of nvvm.texsurf.handle must be a metadata wrapper around a tex/surf GlobalVariable (e.g. metada"
                     "ta i64 addrspace(1)* @tex )");
            sub_1263B40(v588, "\n");
            sub_1C31880(a1);
            goto LABEL_367;
          case 0x148Bu:
LABEL_352:
            if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) != 13 )
            {
              v207 = sub_1C321C0(a1, (__int64)a2, 0);
              v208 = sub_1263B40(v207, "the task_id parameter must be constant");
              sub_1263B40(v208, "\n");
              sub_1C31880(a1);
            }
            goto LABEL_9;
          case 0x1490u:
          case 0x1492u:
            v178 = a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
            if ( *(_BYTE *)(v178 + 16) == 13 )
            {
              v179 = *(_QWORD *)(v178 + 24);
              if ( *(_DWORD *)(v178 + 32) > 0x40u )
                v179 = *(_QWORD *)v179;
              if ( (v179 & 0xFFFFFFFFFFFF000FLL) == 0 )
              {
LABEL_294:
                if ( v8 == 5266 )
                {
                  v487 = *(_QWORD *)v5[3 * (2LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))];
                  if ( *(_DWORD *)(v487 + 32) != 2 || !sub_1642F90(**(_QWORD **)(v487 + 16), 64) )
                  {
                    v488 = sub_1C321C0(a1, (__int64)v5, 0);
                    v489 = sub_1263B40(v488, "Non-supported store type");
                    sub_1263B40(v489, "\n");
                    sub_1C31880(a1);
                  }
                }
                else if ( v8 == 5264 )
                {
                  if ( *(_DWORD *)(*v5 + 32) != 2 || !sub_1642F90(**(_QWORD **)(*v5 + 16), 64) )
                  {
                    v183 = sub_1C321C0(a1, (__int64)v5, 0);
                    v184 = sub_1263B40(v183, "Non-supported load type");
                    sub_1263B40(v184, "\n");
                    sub_1C31880(a1);
                  }
                  if ( *(_BYTE *)(v5[3 * (2LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))] + 16) != 13 )
                  {
                    v185 = sub_1C321C0(a1, (__int64)v5, 0);
                    v186 = sub_1263B40(v185, "'close' argument must be constant");
                    sub_1263B40(v186, "\n");
                    sub_1C31880(a1);
                  }
                }
                goto LABEL_9;
              }
              v180 = "Offset must be aligned 16 bytes";
              v181 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            else
            {
              v180 = "Offset must be constant";
              v181 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            v182 = sub_1263B40(v181, v180);
            sub_1263B40(v182, "\n");
            sub_1C31880(a1);
            goto LABEL_294;
          case 0x1491u:
            if ( *(_BYTE *)(a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))] + 16) != 13 )
            {
              v211 = sub_1C321C0(a1, (__int64)a2, 0);
              v212 = sub_1263B40(v211, "'is_dual' argument must be constant.");
              sub_1263B40(v212, "\n");
              sub_1C31880(a1);
            }
            goto LABEL_9;
          default:
            goto LABEL_9;
        }
      }
      if ( v8 != 5625 )
      {
        if ( v8 > 0x15F9 )
        {
          if ( v8 != 5628 )
            goto LABEL_9;
          if ( !sub_1642F90(*(_QWORD *)a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))], 32) )
          {
            v483 = sub_1C321C0(a1, (__int64)a2, 0);
            v484 = sub_1263B40(v483, "Data type must be i32");
            sub_1263B40(v484, "\n");
            sub_1C31880(a1);
          }
          if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) == 13 )
            goto LABEL_9;
          goto LABEL_68;
        }
        if ( v8 == 5620 )
        {
          v129 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
          if ( *(_BYTE *)(v129 + 16) == 13 )
          {
            v130 = *(_QWORD **)(v129 + 24);
            if ( *(_DWORD *)(v129 + 32) > 0x40u )
              v130 = (_QWORD *)*v130;
            v131 = (char)v130;
            v132 = (unsigned __int8)v130 & 6;
            if ( v132 && (_BYTE)v132 != 6 )
            {
              v133 = sub_1C321C0(a1, (__int64)a2, 0);
              v134 = sub_1263B40(v133, "Only writes to MAP or ATTR are supported");
              sub_1263B40(v134, "\n");
              sub_1C31880(a1);
            }
            if ( (v131 & 1) != 0 )
            {
              v135 = sub_1C321C0(a1, (__int64)a2, 0);
              v136 = sub_1263B40(v135, "Cannot write to input ISBE");
              sub_1263B40(v136, "\n");
              sub_1C31880(a1);
            }
          }
          else
          {
LABEL_382:
            v226 = sub_1C321C0(a1, (__int64)a2, 0);
            v227 = sub_1263B40(v226, "Mode operand must be constant");
            sub_1263B40(v227, "\n");
            sub_1C31880(a1);
          }
          goto LABEL_9;
        }
        if ( v8 != 5624 )
          goto LABEL_9;
        v58 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v59 = a2[-3 * v58];
        if ( *(_BYTE *)(v59 + 16) == 13 )
        {
          v60 = *(_QWORD **)(v59 + 24);
          if ( *(_DWORD *)(v59 + 32) > 0x40u )
            v60 = (_QWORD *)*v60;
          if ( (unsigned __int64)v60 <= 7 )
            goto LABEL_412;
          v61 = "op0 not between 0 and 7\n";
          v62 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        else
        {
          v61 = "op0 of intrinsic not constant\n";
          v62 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        v250 = sub_1263B40(v62, v61);
        sub_1263B40(v250, "\n");
        sub_1C31880(a1);
        v58 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
LABEL_412:
        v251 = *(_QWORD *)v5[3 * (1 - v58)];
        v252 = *(_BYTE *)(v251 + 8);
        if ( v252 == 16 )
        {
          v251 = **(_QWORD **)(v251 + 16);
          v252 = *(_BYTE *)(v251 + 8);
        }
        if ( v252 != 2 && !sub_1642F90(v251, 32) )
        {
          v253 = sub_1C321C0(a1, (__int64)v5, 0);
          v254 = sub_1263B40(v253, "op1 of intrinsic not containing f32 or i32 element\n");
          sub_1263B40(v254, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      }
      v141 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
      v142 = a2[-3 * v141];
      if ( *(_BYTE *)(v142 + 16) == 13 )
      {
        v444 = *(_QWORD **)(v142 + 24);
        if ( *(_DWORD *)(v142 + 32) > 0x40u )
          v444 = (_QWORD *)*v444;
        if ( (unsigned __int64)v444 <= 7 )
          goto LABEL_247;
        v143 = "op0 not between 0 and 7\n";
        v144 = sub_1C321C0(a1, (__int64)v5, 0);
      }
      else
      {
        v143 = "op0 of intrinsic not constant\n";
        v144 = sub_1C321C0(a1, (__int64)v5, 0);
      }
      v145 = sub_1263B40(v144, v143);
      sub_1263B40(v145, "\n");
      sub_1C31880(a1);
      v141 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
LABEL_247:
      v146 = (__int64 *)v5[3 * (2 - v141)];
      if ( *(_BYTE *)(*v146 + 8) != 2 && !sub_1642F90(*v146, 32) )
      {
        v147 = sub_1C321C0(a1, (__int64)v5, 0);
        v148 = sub_1263B40(v147, "op2 of intrinsic not f32 or i32\n");
        sub_1263B40(v148, "\n");
        sub_1C31880(a1);
      }
      goto LABEL_9;
    }
    if ( v8 <= 0x10B5 )
    {
      if ( v8 > 0x1084 )
      {
        switch ( v8 )
        {
          case 0x1085u:
            if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) != 13 )
            {
              v232 = sub_1C321C0(a1, (__int64)a2, 0);
              v233 = sub_1263B40(v232, "the mask parameter must be constant");
              sub_1263B40(v233, "\n");
              sub_1C31880(a1);
            }
            break;
          case 0x108Au:
          case 0x108Bu:
          case 0x108Cu:
          case 0x108Du:
          case 0x108Fu:
          case 0x1090u:
          case 0x1091u:
          case 0x1093u:
            sub_1263B40(*(_QWORD *)(a1 + 24), "Error: ");
            sub_1263B40(
              *(_QWORD *)(a1 + 24),
              "nvvm address space conversion intrinsics are not supported.  Please use addrspacecast instruction for addr"
              "ess space conversions");
            sub_1C31880(a1);
            break;
          case 0x10B3u:
            v228 = *(_DWORD *)(a1 + 8);
            if ( v228 && v228 <= 899 )
            {
              v573 = sub_1C321C0(a1, (__int64)a2, 0);
              v574 = sub_1263B40(v573, "this intrinsic is only supported for Hopper+");
              sub_1263B40(v574, "\n");
              sub_1C31880(a1);
            }
            if ( *(_BYTE *)(*a2 + 8) != 11 || (v229 = sub_1643030(*a2), v229 != 1) && v229 != 32 )
            {
              v230 = sub_1C321C0(a1, (__int64)a2, 0);
              v231 = sub_1263B40(v230, "return type must be i1 or i32");
              sub_1263B40(v231, "\n");
              sub_1C31880(a1);
            }
            break;
          case 0x10B5u:
            if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) != 13 )
              goto LABEL_382;
            break;
          default:
            goto LABEL_9;
        }
        goto LABEL_9;
      }
      if ( v8 != 4173 )
        goto LABEL_9;
      v47 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
      v48 = (__int64 *)a2[3 * (1 - v47)];
      v661 = *v48;
      if ( *(_BYTE *)(*v48 + 8) == 16 )
        v661 = **(_QWORD **)(*v48 + 16);
      v49 = a2[-3 * v47];
      if ( *(_BYTE *)(v49 + 16) != 13 )
      {
        v433 = "arg0 of intrinsic not constant";
        v434 = sub_1C321C0(a1, (__int64)v5, 0);
        goto LABEL_704;
      }
      v50 = *(_QWORD *)(v49 + 24);
      if ( *(_DWORD *)(v49 + 32) > 0x40u )
        v50 = *(_QWORD *)v50;
      if ( (v50 & 0xFFC00000C0000000LL) != 0 )
      {
        v577 = sub_1C321C0(a1, (__int64)a2, 0);
        v578 = sub_1263B40(v577, "Reserved bits-used");
        sub_1263B40(v578, "\n");
        sub_1C31880(a1);
      }
      HIDWORD(v665) = 0;
      v666 = 0;
      switch ( BYTE4(v50) )
      {
        case 1:
          v666 = 8;
          v665 = 0x400000008LL;
          goto LABEL_907;
        case 2:
          v666 = 8;
          v665 = 0x1000000008LL;
          goto LABEL_907;
        case 3:
          v666 = 8;
          v665 = 0x2000000008LL;
          goto LABEL_907;
        case 4:
          v666 = 8;
          v665 = 0x4000000008LL;
          goto LABEL_907;
        case 5:
          v666 = 8;
          v665 = 0x8000000008LL;
          goto LABEL_907;
        case 6:
          v666 = 32;
          v665 = 0x1000000008LL;
          goto LABEL_907;
        case 0x10:
          v666 = 8;
          v665 = 0x400000010LL;
          goto LABEL_907;
        case 0x11:
          v666 = 8;
          v665 = 0x800000010LL;
          goto LABEL_907;
        case 0x12:
          v666 = 8;
          v665 = 0x1000000010LL;
          goto LABEL_907;
        case 0x13:
          v666 = 8;
          v665 = 0x2000000010LL;
          goto LABEL_907;
        case 0x14:
          v666 = 8;
          v665 = 0x4000000010LL;
          goto LABEL_907;
        case 0x15:
          v666 = 8;
          v665 = 0x8000000010LL;
          goto LABEL_907;
        case 0x16:
          v666 = 8;
          v665 = 0x10000000010LL;
          goto LABEL_907;
        case 0x17:
          v666 = 16;
          v665 = 0x1000000010LL;
          goto LABEL_907;
        case 0x18:
          v666 = 8;
          v665 = 0x1000000020LL;
          goto LABEL_907;
        case 0x19:
          v666 = 16;
          v665 = 0x800000010LL;
LABEL_907:
          v655 = HIDWORD(v665);
          v658 = v665;
          v649 = v666 * v665;
          break;
        default:
          v655 = 0;
          v658 = 0;
          v649 = 0;
          v370 = sub_1C321C0(a1, (__int64)a2, 0);
          v371 = sub_1263B40(v370, "Invalid MMA MNK");
          sub_1263B40(v371, "\n");
          sub_1C31880(a1);
          break;
      }
      v372 = (unsigned int)BYTE1(v50) - 1;
      if ( (unsigned int)v372 > 0xC || (v652 = dword_42D04A0[v372]) == 0 )
      {
        v373 = sub_1C321C0(a1, (__int64)a2, 0);
        v374 = sub_1263B40(v373, "Invalid MMA AType");
        sub_1263B40(v374, "\n");
        sub_1C31880(a1);
        v652 = 0;
      }
      v648 = v50;
      v647 = BYTE1(v50);
      v375 = 1;
      v377 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
      while ( 1 )
      {
        if ( (v652 * v655 * v658) >> 5 != (unsigned int)sub_1643030(*(_QWORD *)a2[3 * (v375 - v377)]) )
        {
          v378 = "Invalid MMA FragBSize";
          v379 = sub_1C321C0(a1, (__int64)a2, 0);
          if ( v375 == 1 )
            v378 = "Invalid MMA FragASize";
          v380 = sub_1263B40(v379, v378);
          sub_1263B40(v380, "\n");
          sub_1C31880(a1);
          v377 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        }
        if ( v375 == 2 )
          break;
        v375 = 2;
        v658 = HIDWORD(v665);
        v655 = v666;
      }
      v421 = v377;
      v5 = a2;
      v422 = *(_QWORD *)a2[3 * (3 - v421)];
      if ( v647 != 6 )
        goto LABEL_684;
      v541 = *(_BYTE *)(v422 + 8);
      if ( v541 == 16 )
        v541 = *(_BYTE *)(**(_QWORD **)(v422 + 16) + 8LL);
      v423 = 16;
      if ( v541 != 11 )
      {
LABEL_684:
        v423 = 16;
        if ( BYTE5(v648) != 6 )
          v423 = sub_16431D0(v422);
      }
      if ( (unsigned int)(v423 * v649) >> 5 != (unsigned int)sub_1643030(v422) )
      {
        v424 = sub_1C321C0(a1, (__int64)a2, 0);
        v425 = sub_1263B40(v424, "Invalid MMA FragCSize");
        sub_1263B40(v425, "\n");
        sub_1C31880(a1);
      }
      if ( v652 > 0x20 || !sub_1642F90(v661, 32) )
      {
        if ( v647 == 8 )
        {
          if ( *(_BYTE *)(v661 + 8) == 2 )
          {
            if ( (v648 & 7) != 0 )
              goto LABEL_695;
LABEL_779:
            v430 = (unsigned __int8)v648 >> 4;
            goto LABEL_780;
          }
        }
        else if ( v647 == 9 && *(_BYTE *)(v661 + 8) == 3 )
        {
LABEL_777:
          if ( (v648 & 7) == 0 || (v648 & 7) > 4 )
            goto LABEL_695;
          goto LABEL_779;
        }
        v426 = sub_1C321C0(a1, (__int64)a2, 0);
        v427 = sub_1263B40(v426, "Invalid fragA type");
        sub_1263B40(v427, "\n");
        sub_1C31880(a1);
      }
      if ( v647 != 9 )
      {
        if ( (v648 & 7) == 0 )
        {
LABEL_696:
          v430 = (unsigned __int8)v648 >> 4;
          if ( v647 != 1 )
          {
LABEL_781:
            if ( !v430 )
            {
LABEL_700:
              if ( v647 != BYTE2(v648) )
              {
                if ( (unsigned int)(v647 - 4) > 1 )
                {
                  if ( (unsigned int)(v647 - 2) <= 1 && (unsigned int)BYTE2(v648) - 2 <= 1 )
                    goto LABEL_705;
                  goto LABEL_703;
                }
                if ( (unsigned int)BYTE2(v648) - 4 > 1 )
                {
LABEL_703:
                  v433 = "Mismatched MMA A B Type";
                  v434 = sub_1C321C0(a1, (__int64)a2, 0);
LABEL_704:
                  v435 = sub_1263B40(v434, v433);
                  sub_1263B40(v435, "\n");
                  sub_1C31880(a1);
                }
              }
LABEL_705:
              v436 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
              v437 = (__int64 *)v5[3 * (2 - v436)];
              v438 = *v437;
              if ( *(_BYTE *)(*v437 + 8) == 16 )
                v438 = **(_QWORD **)(v438 + 16);
              v439 = *(_QWORD *)v5[3 * (3 - v436)];
              if ( *(_BYTE *)(v439 + 8) == 16 )
                v439 = **(_QWORD **)(v439 + 16);
              if ( v438 != v661 || v439 != v438 && (*(_BYTE *)(v439 + 8) != 2 || !sub_1642F90(v438, 32)) )
              {
                v440 = sub_1C321C0(a1, (__int64)v5, 0);
                v441 = sub_1263B40(v440, "Mismatched fragA, fragB and fragC element type");
                sub_1263B40(v441, "\n");
                sub_1C31880(a1);
              }
              goto LABEL_9;
            }
LABEL_699:
            v431 = sub_1C321C0(a1, (__int64)a2, 0);
            v432 = sub_1263B40(v431, "Invalid MMA Opcode");
            sub_1263B40(v432, "\n");
            sub_1C31880(a1);
            goto LABEL_700;
          }
          if ( (unsigned __int8)v648 >> 4 )
          {
            if ( (unsigned __int8)((unsigned __int8)v648 >> 4) <= 2u )
            {
              if ( BYTE2(v648) == 1 )
                goto LABEL_705;
              goto LABEL_703;
            }
            goto LABEL_699;
          }
LABEL_780:
          if ( v647 == 1 )
            goto LABEL_699;
          goto LABEL_781;
        }
LABEL_695:
        v428 = sub_1C321C0(a1, (__int64)a2, 0);
        v429 = sub_1263B40(v428, "Invalid MMA Rounding Mode");
        sub_1263B40(v429, "\n");
        sub_1C31880(a1);
        goto LABEL_696;
      }
      goto LABEL_777;
    }
    if ( v8 == 4385 )
    {
      v137 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v137 + 16) == 13 )
      {
        v138 = *(_QWORD **)(v137 + 24);
        if ( *(_DWORD *)(v137 + 32) > 0x40u )
          v138 = (_QWORD *)*v138;
        if ( v138 != (_QWORD *)0xFFFFFFFFLL )
        {
          v139 = sub_1C321C0(a1, (__int64)a2, 0);
          v140 = sub_1263B40(v139, "Mask must be 0xFFFFFFFF");
          sub_1263B40(v140, "\n");
          sub_1C31880(a1);
        }
      }
      else
      {
        v464 = sub_1C321C0(a1, (__int64)a2, 0);
        v465 = sub_1263B40(v464, "Mask must be a constant integer");
        sub_1263B40(v465, "\n");
        sub_1C31880(a1);
      }
      goto LABEL_9;
    }
    if ( v8 <= 0x1121 )
    {
      if ( v8 != 4349 )
        goto LABEL_9;
      if ( !sub_1642F90(*a2, 32) )
      {
        v485 = sub_1C321C0(a1, (__int64)a2, 0);
        v486 = sub_1263B40(v485, "Data type must be i32");
        sub_1263B40(v486, "\n");
        sub_1C31880(a1);
      }
      if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) == 13 )
        goto LABEL_9;
LABEL_68:
      v45 = sub_1C321C0(a1, (__int64)a2, 0);
      v46 = sub_1263B40(v45, "Index must be constant");
      sub_1263B40(v46, "\n");
      sub_1C31880(a1);
      goto LABEL_9;
    }
    if ( v8 != 4494 )
    {
      if ( v8 > 0x118E )
      {
        if ( v8 - 4504 > 7 )
          goto LABEL_9;
LABEL_86:
        v51 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v52 = *(_QWORD *)a2[-3 * v51];
        if ( *(_BYTE *)(v52 + 8) == 15 )
        {
          if ( ((*(_DWORD *)(v52 + 8) >> 8) & 0xFFFFFFFD) == 1 )
          {
LABEL_89:
            if ( *(_BYTE *)(v5[3 * (2 - v51)] + 16) != 13 )
            {
              v56 = sub_1C321C0(a1, (__int64)v5, 0);
              v57 = sub_1263B40(v56, "arg2 not constant");
              sub_1263B40(v57, "\n");
              sub_1C31880(a1);
            }
            goto LABEL_9;
          }
          v53 = "arg0 invalid addrspace";
          v54 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        else
        {
          v53 = "arg0 of intrinsic not pointer";
          v54 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        v55 = sub_1263B40(v54, v53);
        sub_1263B40(v55, "\n");
        sub_1C31880(a1);
        v51 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        goto LABEL_89;
      }
      if ( v8 == 4412 )
      {
LABEL_107:
        if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 8LL) - 1) > 1u )
        {
          v63 = sub_1C321C0(a1, (__int64)a2, 0);
          v64 = sub_1263B40(v63, "arg0 must be either half or float");
          sub_1263B40(v64, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      }
      if ( v8 != 4492 )
        goto LABEL_9;
    }
LABEL_110:
    v65 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v65 + 16) == 13 )
    {
      v66 = *(_QWORD **)(v65 + 24);
      if ( *(_DWORD *)(v65 + 32) > 0x40u )
        v66 = (_QWORD *)*v66;
      v67 = sub_1C278B0((__int64)v66);
      if ( (v67 & 0x400) != 0 )
      {
        v561 = sub_1C321C0(a1, (__int64)a2, 1u);
        sub_1263B40(v561, "Bit 10 of mode argument is reserved and should be unset.\n");
      }
      if ( v8 != 4057 )
        goto LABEL_116;
      if ( ((v67 >> 16) & 0xF0) != 0 )
      {
        v556 = *a2;
        if ( *(_BYTE *)(*a2 + 8) != 16
          || *(_QWORD *)(v556 + 32) != 8
          || !sub_1642F90(*(_QWORD *)(v556 + 24), 32) && *(_BYTE *)(*(_QWORD *)(v556 + 24) + 8LL) != 2 )
        {
          v557 = sub_1C321C0(a1, (__int64)a2, 0);
          v558 = sub_1263B40(v557, "COP2 is supported for v8i32 and v8f32 only");
          sub_1263B40(v558, "\n");
          sub_1C31880(a1);
        }
      }
    }
    else
    {
      v255 = sub_1C321C0(a1, (__int64)a2, 0);
      sub_1263B40(v255, "Flag argument must be an immediate.\n");
      sub_1C31880(a1);
    }
    if ( v8 == 4057 )
    {
LABEL_117:
      if ( *(_BYTE *)(a2[3 * ((v8 != 4057) + 2LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))] + 16) != 9 )
      {
        v68 = sub_1C321C0(a1, (__int64)a2, 1u);
        sub_1263B40(v68, "Desc parameter is deprecated and should be undef.\n");
      }
      goto LABEL_9;
    }
LABEL_116:
    if ( v8 != 4492 )
      goto LABEL_9;
    goto LABEL_117;
  }
  if ( v8 > 0xF7D )
  {
    switch ( v8 )
    {
      case 0xF7Eu:
      case 0xF7Fu:
      case 0xF80u:
      case 0xF81u:
      case 0xF8Cu:
      case 0xF8Du:
      case 0xF8Eu:
      case 0xF8Fu:
      case 0xF96u:
      case 0xF97u:
      case 0xF98u:
      case 0xF99u:
        v158 = a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
        if ( !v158 )
          goto LABEL_827;
        if ( *(_BYTE *)(v158 + 16) != 13 )
          goto LABEL_268;
        v159 = *(_QWORD **)(v158 + 24);
        if ( *(_DWORD *)(v158 + 32) > 0x40u )
          v159 = (_QWORD *)*v159;
        if ( v159 )
        {
LABEL_268:
          v160 = sub_1C321C0(a1, (__int64)a2, 0);
          v161 = sub_1263B40(v160, "satf operand must be a constant zero");
          sub_1263B40(v161, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xF84u:
      case 0xF85u:
      case 0xF86u:
      case 0xF87u:
        v209 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v209 + 16) == 13 )
        {
          v210 = *(_QWORD **)(v209 + 24);
          if ( *(_DWORD *)(v209 + 32) > 0x40u )
            v210 = (_QWORD *)*v210;
          if ( (_DWORD)v210 )
          {
LABEL_571:
            v336 = sub_1C321C0(a1, (__int64)a2, 0);
            v337 = sub_1263B40(v336, "reserved flag bits used");
            sub_1263B40(v337, "\n");
            sub_1C31880(a1);
          }
        }
        else
        {
          v453 = sub_1C321C0(a1, (__int64)a2, 0);
          v454 = sub_1263B40(v453, "arg0 of intrinsic not constant");
          sub_1263B40(v454, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xFCBu:
      case 0xFCFu:
        if ( *(_BYTE *)(a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)] + 16) != 13 )
        {
          v249 = sub_1C321C0(a1, (__int64)a2, 0);
          sub_1263B40(v249, "Flag argument must be an immediate.\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xFD5u:
        v350 = *(_DWORD *)(a1 + 8);
        if ( v350 && v350 <= 899 )
        {
          v351 = sub_1C321C0(a1, (__int64)a2, 0);
          v352 = sub_1263B40(v351, "this intrinsic is only supported for Hopper+");
          sub_1263B40(v352, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xFD9u:
      case 0xFDBu:
        goto LABEL_110;
      case 0xFF6u:
        v353 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v354 = a2[-3 * v353];
        if ( *(_BYTE *)(v354 + 16) == 13 )
        {
          v355 = *(_QWORD **)(v354 + 24);
          if ( *(_DWORD *)(v354 + 32) > 0x40u )
            v355 = (_QWORD *)*v355;
          if ( ((unsigned int)v355 & 0xFFFFFFF0) != 0 )
          {
            v535 = sub_1C321C0(a1, (__int64)a2, 0);
            v536 = sub_1263B40(v535, "reserved flag bits used");
            sub_1263B40(v536, "\n");
            sub_1C31880(a1);
            v353 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
          }
          v356 = (__int64 *)a2[3 * (1 - v353)];
          v357 = *v356;
          v358 = (unsigned __int8)v355 & 3;
          if ( v358 )
          {
            if ( (_BYTE)v358 != 1 )
            {
              v359 = sub_1C321C0(a1, (__int64)a2, 0);
              v360 = sub_1263B40(v359, "Invalid constant load kind");
              sub_1263B40(v360, "\n");
              sub_1C31880(a1);
            }
            if ( !sub_1642F90(v357, 64) )
            {
              v361 = sub_1C321C0(a1, (__int64)a2, 0);
              v362 = sub_1263B40(v361, "Bindless bank must be i64");
              sub_1263B40(v362, "\n");
              sub_1C31880(a1);
            }
          }
          else if ( !sub_1642F90(*v356, 32) )
          {
            v579 = sub_1C321C0(a1, (__int64)a2, 0);
            v580 = sub_1263B40(v579, "Bound bank must be i32");
            sub_1263B40(v580, "\n");
            sub_1C31880(a1);
          }
        }
        else
        {
LABEL_746:
          v469 = sub_1C321C0(a1, (__int64)a2, 0);
          v470 = sub_1263B40(v469, "op0 of intrinsic not constant");
          sub_1263B40(v470, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xFF7u:
      case 0xFF8u:
      case 0xFF9u:
      case 0xFFAu:
      case 0xFFBu:
      case 0xFFCu:
      case 0xFFDu:
      case 0xFFEu:
        goto LABEL_86;
      case 0xFFFu:
      case 0x1000u:
      case 0x1001u:
        v222 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v222 + 16) == 13 )
        {
          v223 = *(_QWORD **)(v222 + 24);
          if ( *(_DWORD *)(v222 + 32) > 0x40u )
            v223 = (_QWORD *)*v223;
          if ( ((unsigned int)v223 & 0xFFFFFFE0) != 0 )
          {
            v575 = sub_1C321C0(a1, (__int64)a2, 0);
            v576 = sub_1263B40(v575, "reserved flag bits used");
            sub_1263B40(v576, "\n");
            sub_1C31880(a1);
          }
          if ( ((unsigned __int8)v223 & 0x1E) != 0 && ((unsigned __int8)v223 & 1) != 0 )
          {
            v585 = sub_1C321C0(a1, (__int64)a2, 0);
            v586 = sub_1263B40(v585, "ColMajor is not supported for this size");
            sub_1263B40(v586, "\n");
            sub_1C31880(a1);
          }
          if ( (((unsigned int)v223 >> 1) & 0xF) > 4 )
          {
            v224 = sub_1C321C0(a1, (__int64)a2, 0);
            v225 = sub_1263B40(v224, "Invalid size");
            sub_1263B40(v225, "\n");
            sub_1C31880(a1);
          }
        }
        else
        {
          v455 = sub_1C321C0(a1, (__int64)a2, 0);
          v456 = sub_1263B40(v455, "arg0 of intrinsic not constant");
          sub_1263B40(v456, "\n");
          sub_1C31880(a1);
          v457 = *(_QWORD *)a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
          if ( *(_BYTE *)(v457 + 8) == 15 )
          {
            if ( *(_DWORD *)(v457 + 8) >> 8 != 3 )
            {
              v517 = sub_1C321C0(a1, (__int64)a2, 0);
              v518 = sub_1263B40(v517, "arg1 invalid addrspace");
              sub_1263B40(v518, "\n");
              sub_1C31880(a1);
            }
          }
          else
          {
            v458 = sub_1C321C0(a1, (__int64)a2, 0);
            v459 = sub_1263B40(v458, "arg0 of intrinsic not pointer");
            sub_1263B40(v459, "\n");
            sub_1C31880(a1);
          }
        }
        goto LABEL_9;
      case 0x1002u:
        v365 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v365 + 16) == 13 )
        {
          v366 = *(_QWORD **)(v365 + 24);
          if ( *(_DWORD *)(v365 + 32) > 0x40u )
            v366 = (_QWORD *)*v366;
          v367 = (char)v366;
          if ( (unsigned int)v366 >> 16 )
          {
            v581 = sub_1C321C0(a1, (__int64)a2, 0);
            v582 = sub_1263B40(v581, "reserved flag bits used");
            sub_1263B40(v582, "\n");
            sub_1C31880(a1);
          }
          if ( (v367 & 7u) <= 2 )
          {
LABEL_614:
            if ( *(_DWORD *)(*(_QWORD *)v5[3 * (1LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))] + 8LL) >> 8 != 1 )
            {
              v368 = sub_1C321C0(a1, (__int64)v5, 0);
              v369 = sub_1263B40(v368, "pointer address space not global");
              sub_1263B40(v369, "\n");
              sub_1C31880(a1);
            }
            goto LABEL_9;
          }
          v466 = "invalid load bounds check type";
          v467 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        else
        {
          v466 = "op0 of intrinsic not constant";
          v467 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        v468 = sub_1263B40(v467, v466);
        sub_1263B40(v468, "\n");
        sub_1C31880(a1);
        goto LABEL_614;
      case 0x1004u:
        if ( *(_BYTE *)(a2[3 * (3LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))] + 16) != 13 )
        {
          v363 = sub_1C321C0(a1, (__int64)a2, 0);
          v364 = sub_1263B40(v363, "fourth argument must be a constant integer");
          sub_1263B40(v364, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      default:
        goto LABEL_9;
    }
  }
  if ( v8 > 0xD3 )
  {
    switch ( v8 )
    {
      case 0xE55u:
      case 0xE56u:
      case 0xE57u:
      case 0xE58u:
      case 0xE5Bu:
      case 0xE5Cu:
      case 0xE5Du:
      case 0xE5Eu:
        v162 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        v163 = *(_QWORD **)(v162 + 24);
        if ( *(_DWORD *)(v162 + 32) > 0x40u )
          v163 = (_QWORD *)*v163;
        v164 = (int)v163;
        if ( BYTE2(v163) != 14 )
        {
          v165 = sub_1C321C0(a1, (__int64)a2, 0);
          v166 = sub_1263B40(v165, "the opcode of atomic_cas must be CAS");
          sub_1263B40(v166, "\n");
          sub_1C31880(a1);
        }
        if ( (v164 & 0x1000000) != 0 )
        {
          v167 = *(_QWORD *)a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
          if ( *(_BYTE *)(v167 + 8) == 16 )
            v167 = **(_QWORD **)(v167 + 16);
          if ( *(_DWORD *)(v167 + 8) > 0x1FFu )
          {
            v168 = sub_1C321C0(a1, (__int64)a2, 0);
            v169 = sub_1263B40(v168, "Global ordering on atomics is only allowed on generic/global pointers");
            sub_1263B40(v169, "\n");
            sub_1C31880(a1);
          }
        }
        goto LABEL_9;
      case 0xE5Fu:
      case 0xE60u:
        v234 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v235 = a2[-3 * v234];
        v236 = *(_QWORD **)(v235 + 24);
        if ( *(_DWORD *)(v235 + 32) > 0x40u )
          v236 = (_QWORD *)*v236;
        v237 = (int)v236;
        if ( (unsigned __int8)(BYTE2(v236) - 15) > 1u )
        {
          v238 = sub_1C321C0(a1, (__int64)v5, 0);
          v239 = sub_1263B40(v238, "the opcode of atomic_cast must be CAST or CAST_SPIN");
          sub_1263B40(v239, "\n");
          sub_1C31880(a1);
          v234 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        }
        v240 = **(_QWORD **)(*(_QWORD *)v5[3 * (1 - v234)] + 16LL);
        if ( !sub_1642F90(v240, 32) && !sub_1642F90(v240, 64) )
        {
          v493 = sub_1C321C0(a1, (__int64)v5, 0);
          v494 = sub_1263B40(v493, "atomic.cast only overloads on i32 and i64");
          sub_1263B40(v494, "\n");
          sub_1C31880(a1);
        }
        v241 = *(_QWORD *)v5[3 * (1LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))];
        if ( *(_BYTE *)(v241 + 8) == 16 )
          v241 = **(_QWORD **)(v241 + 16);
        if ( *(_DWORD *)(v241 + 8) >> 8 != 3 )
        {
          v242 = sub_1C321C0(a1, (__int64)v5, 0);
          v243 = sub_1263B40(v242, "atomic.cast is only allowed on shared pointers");
          sub_1263B40(v243, "\n");
          sub_1C31880(a1);
        }
        if ( (v237 & 0x1000000) != 0 )
        {
          v244 = sub_1C321C0(a1, (__int64)v5, 0);
          v245 = sub_1263B40(v244, "atomic.cast works on shared memory, so cannot be ordered");
          sub_1263B40(v245, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xE71u:
      case 0xE72u:
      case 0xE73u:
      case 0xE74u:
      case 0xE75u:
      case 0xE76u:
      case 0xE7Bu:
      case 0xE7Cu:
      case 0xE7Du:
      case 0xE7Eu:
      case 0xE7Fu:
      case 0xE80u:
        v149 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        v150 = *(_QWORD **)(v149 + 24);
        if ( *(_DWORD *)(v149 + 32) > 0x40u )
          v150 = (_QWORD *)*v150;
        v151 = (int)v150;
        v152 = (unsigned int)v150 >> 16;
        if ( (unsigned __int8)(BYTE2(v150) - 14) <= 2u )
        {
          v490 = sub_1C321C0(a1, (__int64)a2, 0);
          v491 = sub_1263B40(v490, "the opcode of atomic_rmw must not be CAS, CAST or CAST_SPIN");
          sub_1263B40(v491, "\n");
          sub_1C31880(a1);
        }
        if ( (v151 & 0x1000000) != 0 )
        {
          v153 = *(_QWORD *)a2[3 * (1LL - (*((_DWORD *)a2 + 5) & 0xFFFFFFF))];
          if ( *(_BYTE *)(v153 + 8) == 16 )
            v153 = **(_QWORD **)(v153 + 16);
          if ( *(_DWORD *)(v153 + 8) > 0x1FFu )
          {
            v154 = sub_1C321C0(a1, (__int64)a2, 0);
            v155 = sub_1263B40(v154, "Global ordering on atomics is only allowed on generic/global pointers");
            sub_1263B40(v155, "\n");
            sub_1C31880(a1);
          }
        }
        if ( (v8 == 3710 || v8 == 3700) && (_BYTE)v152 )
        {
          v156 = sub_1C321C0(a1, (__int64)a2, 0);
          v157 = sub_1263B40(v156, "only atomic EXCH allowed for 128b atomic rmw");
          sub_1263B40(v157, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xE79u:
      case 0xE7Au:
      case 0xE81u:
      case 0xE82u:
        v193 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v194 = a2[-3 * v193];
        v195 = *(_QWORD **)(v194 + 24);
        if ( *(_DWORD *)(v194 + 32) > 0x40u )
          v195 = (_QWORD *)*v195;
        if ( BYTE2(v195) != 11 )
        {
          v196 = sub_1C321C0(a1, (__int64)v5, 0);
          v197 = sub_1263B40(v196, "the opcode of atomic_rmw_v2f32 and atomic_rmw_v4f32 must be FADD");
          sub_1263B40(v197, "\n");
          sub_1C31880(a1);
          v193 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        }
        v198 = *(_QWORD *)v5[3 * (1 - v193)];
        if ( *(_BYTE *)(v198 + 8) == 16 )
          v198 = **(_QWORD **)(v198 + 16);
        if ( *(_DWORD *)(v198 + 8) > 0x1FFu )
        {
          v199 = sub_1C321C0(a1, (__int64)v5, 0);
          v200 = sub_1263B40(v199, "Vector atomics are only allowed on generic/global pointers");
          sub_1263B40(v200, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xEAFu:
      case 0xEB1u:
      case 0xEB2u:
      case 0xEB3u:
        v191 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v191 + 16) != 13 )
          goto LABEL_746;
        v192 = *(_QWORD **)(v191 + 24);
        if ( *(_DWORD *)(v191 + 32) > 0x40u )
          v192 = (_QWORD *)*v192;
        if ( ((unsigned __int8)v192 & 0xFu) > 4 )
        {
          v562 = sub_1C321C0(a1, (__int64)a2, 0);
          v563 = sub_1263B40(v562, "invalid cache type");
          sub_1263B40(v563, "\n");
          sub_1C31880(a1);
        }
        if ( v8 == 3759 )
        {
          if ( ((unsigned __int8)v192 & 0xF0) == 0 )
            goto LABEL_313;
        }
        else if ( (char)v192 >= 0 )
        {
          goto LABEL_313;
        }
        v544 = sub_1C321C0(a1, (__int64)a2, 0);
        v545 = sub_1263B40(v544, "invalid cache op");
        sub_1263B40(v545, "\n");
        sub_1C31880(a1);
LABEL_313:
        if ( ((unsigned int)v192 & 0xFFFF8000) != 0 )
          goto LABEL_571;
        goto LABEL_9;
      case 0xEB7u:
        v319 = *(_DWORD *)(a1 + 8);
        if ( v319 && v319 <= 899 )
        {
          v533 = sub_1C321C0(a1, (__int64)a2, 0);
          v534 = sub_1263B40(v533, "this intrinsic is only supported for Hopper+");
          sub_1263B40(v534, "\n");
          sub_1C31880(a1);
        }
        v320 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v320 + 16) != 13 )
        {
          v2 = "argument must be a constant integer";
          v3 = sub_1C321C0(a1, (__int64)v5, 0);
          goto LABEL_944;
        }
        v321 = *(_QWORD **)(v320 + 24);
        if ( *(_DWORD *)(v320 + 32) > 0x40u )
          v321 = (_QWORD *)*v321;
        v322 = (unsigned __int8)v321;
        if ( ((unsigned int)v321 & 0xFFFFFF00) != 0 )
        {
          v479 = sub_1C321C0(a1, (__int64)a2, 0);
          v480 = sub_1263B40(v479, "reserved bits should not be set");
          sub_1263B40(v480, "\n");
          sub_1C31880(a1);
        }
        v323 = v322;
        v324 = v322 >> 4;
        v325 = v323 & 0xF;
        if ( v325 > 1u )
        {
          v475 = sub_1C321C0(a1, (__int64)a2, 0);
          v476 = sub_1263B40(v475, "unsupported operation mode");
          sub_1263B40(v476, "\n");
          sub_1C31880(a1);
          if ( v324 <= 1u )
            goto LABEL_9;
        }
        else if ( v324 <= 1u )
        {
          if ( (v324 & v325 & 1) != 0 )
          {
            v326 = sub_1C321C0(a1, (__int64)a2, 0);
            v327 = sub_1263B40(v326, "relaxed memory ordering is not allowed on 'wait' operation");
            sub_1263B40(v327, "\n");
            sub_1C31880(a1);
          }
          goto LABEL_9;
        }
        v477 = sub_1C321C0(a1, (__int64)a2, 0);
        v478 = sub_1263B40(v477, "unsupported memory ordering");
        sub_1263B40(v478, "\n");
        sub_1C31880(a1);
        goto LABEL_9;
      case 0xEB9u:
      case 0xEBAu:
        v246 = *(_DWORD *)(a1 + 8);
        if ( v246 && v246 <= 899 )
        {
          v569 = sub_1C321C0(a1, (__int64)a2, 0);
          v570 = sub_1263B40(v569, "this intrinsic is only supported for Hopper+");
          sub_1263B40(v570, "\n");
          sub_1C31880(a1);
        }
        if ( (unsigned int)sub_1643030(*(_QWORD *)a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)]) <= 0x3F )
        {
          v247 = sub_1C321C0(a1, (__int64)a2, 0);
          v248 = sub_1263B40(v247, "this intrinsic is only supported when pointer size is >= 64 bits");
          sub_1263B40(v248, "\n");
          sub_1C31880(a1);
        }
        goto LABEL_9;
      case 0xEC6u:
        v263 = *a2;
        v264 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v265 = a2[-3 * v264];
        v266 = 0;
        if ( *(_BYTE *)(v265 + 16) != 13 )
          v265 = 0;
        v650 = (__int64 ***)a2[3 * (4 - v264)];
        v267 = a2[3 * (6 - v264)];
        if ( *(_BYTE *)(v267 + 16) != 13 )
          v267 = 0;
        v653 = v267;
        v268 = a2[3 * (7 - v264)];
        if ( *(_BYTE *)(v268 + 16) != 13 )
          v268 = 0;
        v656 = v268;
        v662 = *(_QWORD *)a2[3 * (1 - v264)];
        v269 = *(_BYTE *)(v263 + 8);
        if ( *(_BYTE *)(v662 + 8) == 16 )
        {
          v270 = **(_QWORD **)(v662 + 16);
          if ( v269 == 16 )
          {
            if ( *(_BYTE *)(v270 + 8) == 1 || sub_1642F90(v270, 8) )
              goto LABEL_450;
          }
          else
          {
            if ( *(_BYTE *)(v270 + 8) == 1 )
              goto LABEL_830;
            v263 = 0;
            if ( sub_1642F90(v270, 8) )
              goto LABEL_830;
          }
          v271 = v662;
          if ( *(_BYTE *)(v662 + 8) == 16 )
            v271 = **(_QWORD **)(v662 + 16);
          if ( !sub_1642F90(v271, 32) )
          {
            v617 = sub_1C321C0(a1, (__int64)a2, 0);
            v618 = sub_1263B40(v617, "inputVec must be i8/i32/f16 vector type");
            sub_1263B40(v618, "\n");
            sub_1C31880(a1);
          }
        }
        else
        {
          if ( v269 != 16 )
            v263 = 0;
          v460 = sub_1C321C0(a1, (__int64)a2, 0);
          v461 = sub_1263B40(v460, "inputVec must be a vector type");
          sub_1263B40(v461, "\n");
          sub_1C31880(a1);
          v662 = 0;
        }
        if ( v263 )
        {
LABEL_450:
          v272 = *(_BYTE *)(v263 + 8);
          v273 = v263;
          if ( v272 == 16 )
          {
            v273 = **(_QWORD **)(v263 + 16);
            v272 = *(_BYTE *)(v273 + 8);
          }
          if ( v272 != 1 && !sub_1642F90(v273, 32) )
          {
            v583 = sub_1C321C0(a1, (__int64)a2, 0);
            v584 = sub_1263B40(v583, "result must be f16/i32 vector type");
            sub_1263B40(v584, "\n");
            sub_1C31880(a1);
          }
LABEL_455:
          if ( !v265 )
          {
            v564 = "flags must be constant";
            v565 = sub_1C321C0(a1, (__int64)v5, 0);
            goto LABEL_845;
          }
          if ( *(_DWORD *)(v265 + 32) <= 0x40u )
            v274 = *(_QWORD *)(v265 + 24);
          else
            v274 = **(_QWORD **)(v265 + 24);
          if ( (v274 & 0xFFFFFF8000000000LL) != 0 )
          {
            v497 = sub_1C321C0(a1, (__int64)a2, 0);
            v498 = sub_1263B40(v497, "reserved flag bits used");
            sub_1263B40(v498, "\n");
            sub_1C31880(a1);
          }
          v275 = v274 & 0xE0000000;
          LOBYTE(v266) = (_BYTE)v274 == 4;
          v276 = v274 & 0x1FE0000000LL;
          LOBYTE(v275) = (_BYTE)v274 == 1;
          v277 = v275 | v266;
          v278 = BYTE1(v274) == 1;
          if ( ((unsigned __int8)(v278 | (BYTE1(v274) == 4)) & (unsigned __int8)v277) == 0
            || (LOBYTE(v277) = v276 == 1610612736 || v276 == 3221225472LL, !(_BYTE)v277) )
          {
            if ( (v274 & 0x1FE000FFFFLL) != 0 )
            {
              v279 = sub_1C321C0(a1, (__int64)v5, 0);
              v280 = sub_1263B40(v279, "Combination of Input, Matrix, Result not supported");
              v278 = (__int64)"\n";
              sub_1263B40(v280, "\n");
              sub_1C31880(a1);
            }
          }
          if ( v650 != (__int64 ***)sub_15A06D0(*v650, v278, v277, v276) && BYTE2(v274) != (unsigned __int8)(v274 >> 29) )
          {
            v281 = sub_1C321C0(a1, (__int64)v5, 0);
            v282 = sub_1263B40(v281, "Bias interpretation must match result interpretation");
            sub_1263B40(v282, "\n");
            sub_1C31880(a1);
          }
          if ( !v263 )
            goto LABEL_474;
          v283 = *(_BYTE *)(v263 + 8);
          if ( (v274 & 0x1FE0000000LL) != 0 )
          {
            if ( v283 != 16 )
              goto LABEL_471;
            v503 = *(__int64 **)(v263 + 16);
          }
          else
          {
            if ( v283 != 16 )
            {
              if ( v283 != 1 )
              {
LABEL_471:
                v284 = v263;
                goto LABEL_472;
              }
LABEL_474:
              if ( (BYTE3(v274) & 0xFu) > 2 )
              {
                v501 = sub_1C321C0(a1, (__int64)v5, 0);
                v502 = sub_1263B40(v501, "MatrixLayout not a supported value");
                sub_1263B40(v502, "\n");
                sub_1C31880(a1);
              }
              if ( (v274 & 0x10000000) == 0 || !BYTE1(v274) )
              {
LABEL_478:
                if ( v653 )
                {
                  v285 = *(_QWORD **)(v653 + 24);
                  if ( *(_DWORD *)(v653 + 32) > 0x40u )
                    v285 = (_QWORD *)*v285;
                  if ( !v285 )
                  {
                    v499 = sub_1C321C0(a1, (__int64)v5, 0);
                    v500 = sub_1263B40(v499, "N must be greater than zero");
                    sub_1263B40(v500, "\n");
                    sub_1C31880(a1);
                  }
                  if ( !v263 )
                    goto LABEL_489;
                  v286 = *(_QWORD **)(v653 + 24);
                  if ( *(_DWORD *)(v653 + 32) > 0x40u )
                    v286 = (_QWORD *)*v286;
                  if ( *(_QWORD **)(v263 + 32) == v286 )
                    goto LABEL_489;
                  v287 = "N must be the number of components in the result type";
                  v288 = sub_1C321C0(a1, (__int64)v5, 0);
                }
                else
                {
                  v287 = "N must be constant";
                  v288 = sub_1C321C0(a1, (__int64)v5, 0);
                }
                v289 = sub_1263B40(v288, v287);
                sub_1263B40(v289, "\n");
                sub_1C31880(a1);
LABEL_489:
                if ( v656 )
                {
                  v290 = *(_QWORD **)(v656 + 24);
                  if ( *(_DWORD *)(v656 + 32) > 0x40u )
                    v290 = (_QWORD *)*v290;
                  if ( !v290 )
                  {
                    v495 = sub_1C321C0(a1, (__int64)v5, 0);
                    v496 = sub_1263B40(v495, "K must be greater than zero");
                    sub_1263B40(v496, "\n");
                    sub_1C31880(a1);
                  }
                  if ( v662 )
                  {
                    v291 = *(_QWORD **)(v656 + 24);
                    if ( *(_DWORD *)(v656 + 32) > 0x40u )
                      v291 = (_QWORD *)*v291;
                    if ( *(_QWORD **)(v662 + 32) != v291 )
                    {
                      v292 = sub_1C321C0(a1, (__int64)v5, 0);
                      v293 = sub_1263B40(v292, "K must be the number of components in the input vector type");
                      sub_1263B40(v293, "\n");
                      sub_1C31880(a1);
                    }
                  }
                }
                else
                {
                  v559 = sub_1C321C0(a1, (__int64)v5, 0);
                  v560 = sub_1263B40(v559, "K must be constant");
                  sub_1263B40(v560, "\n");
                  sub_1C31880(a1);
                }
                goto LABEL_9;
              }
              v564 = "Transpose not a supported value";
              v565 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_845:
              v566 = sub_1263B40(v565, v564);
              sub_1263B40(v566, "\n");
              sub_1C31880(a1);
              goto LABEL_478;
            }
            v503 = *(__int64 **)(v263 + 16);
            if ( *(_BYTE *)(*v503 + 8) == 1 )
              goto LABEL_474;
          }
          v284 = *v503;
LABEL_472:
          if ( !sub_1642F90(v284, 32) )
          {
            v567 = sub_1C321C0(a1, (__int64)v5, 0);
            v568 = sub_1263B40(v567, "ResultTy must match ResultInterpretation");
            sub_1263B40(v568, "\n");
            sub_1C31880(a1);
          }
          goto LABEL_474;
        }
LABEL_830:
        v263 = 0;
        v552 = sub_1C321C0(a1, (__int64)a2, 0);
        v553 = sub_1263B40(v552, "result must be a vector type");
        sub_1263B40(v553, "\n");
        sub_1C31880(a1);
        goto LABEL_455;
      case 0xEC7u:
        v294 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v295 = 0;
        v296 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v296 + 16) != 13 )
          v296 = 0;
        v297 = *(_QWORD *)v5[3 * (4 - v294)];
        v298 = *(_QWORD *)v5[3 * (3 - v294)];
        if ( *(_BYTE *)(v298 + 8) != 16 )
          v298 = 0;
        if ( *(_BYTE *)(v297 + 8) != 16 )
          v297 = 0;
        v299 = v5[3 * (6 - v294)];
        if ( *(_BYTE *)(v299 + 16) != 13 )
          v299 = 0;
        v300 = v5[3 * (7 - v294)];
        v654 = v299;
        if ( *(_BYTE *)(v300 + 16) == 13 )
          v295 = v300;
        v657 = v295;
        if ( v296 )
        {
          v301 = *(_QWORD **)(v296 + 24);
          if ( *(_DWORD *)(v296 + 32) > 0x40u )
            v301 = (_QWORD *)*v301;
          v663 = (unsigned __int64)v301;
          v651 = (char)v301;
          if ( ((unsigned __int8)v301 & 0xF0) != 0 )
          {
            v509 = sub_1C321C0(a1, (__int64)v5, 0);
            v510 = sub_1263B40(v509, "reserved flag bits used");
            sub_1263B40(v510, "\n");
            sub_1C31880(a1);
          }
          if ( (v663 & 0xFFFFFFFFFFFF0000LL) != 0 )
          {
            v507 = sub_1C321C0(a1, (__int64)v5, 0);
            v508 = sub_1263B40(v507, "reserved2 flag bits used");
            sub_1263B40(v508, "\n");
            sub_1C31880(a1);
          }
          if ( (v651 & 0xF) != 3 )
          {
            v302 = sub_1C321C0(a1, (__int64)v5, 0);
            v303 = sub_1263B40(v302, "MatrixLayout must be TrainingOptimal");
            sub_1263B40(v303, "\n");
            sub_1C31880(a1);
          }
          if ( (v663 & 0xFF00) == 0 )
          {
LABEL_519:
            if ( !v298 )
            {
              v309 = "V1 must be a vector";
              v310 = sub_1C321C0(a1, (__int64)v5, 0);
              goto LABEL_530;
            }
            if ( v654 )
            {
              v304 = *(_QWORD **)(v654 + 24);
              if ( *(_DWORD *)(v654 + 32) > 0x40u )
                v304 = (_QWORD *)*v304;
              if ( *(_QWORD **)(v298 + 32) == v304 )
                goto LABEL_526;
              v305 = "M must equal the number of components in V1";
              v306 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            else
            {
              v305 = "M must be constant";
              v306 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            v307 = sub_1263B40(v306, v305);
            sub_1263B40(v307, "\n");
            sub_1C31880(a1);
LABEL_526:
            v308 = *(_BYTE *)(v298 + 8);
            if ( v308 == 16 )
              v308 = *(_BYTE *)(**(_QWORD **)(v298 + 16) + 8LL);
            if ( v308 == 1 )
            {
LABEL_531:
              if ( !v297 )
              {
                v571 = sub_1C321C0(a1, (__int64)v5, 0);
                v572 = sub_1263B40(v571, "V2 must be a vector");
                sub_1263B40(v572, "\n");
                sub_1C31880(a1);
                goto LABEL_9;
              }
              if ( v657 )
              {
                v312 = *(_QWORD **)(v657 + 24);
                if ( *(_DWORD *)(v657 + 32) > 0x40u )
                  v312 = (_QWORD *)*v312;
                if ( *(_QWORD **)(v297 + 32) == v312 )
                  goto LABEL_538;
                v313 = "N must equal the number of components in V2";
                v314 = sub_1C321C0(a1, (__int64)v5, 0);
              }
              else
              {
                v313 = "N must be constant";
                v314 = sub_1C321C0(a1, (__int64)v5, 0);
              }
              v315 = sub_1263B40(v314, v313);
              sub_1263B40(v315, "\n");
              sub_1C31880(a1);
LABEL_538:
              v316 = *(_BYTE *)(v297 + 8);
              if ( v316 == 16 )
                v316 = *(_BYTE *)(**(_QWORD **)(v297 + 16) + 8LL);
              if ( v316 != 1 )
              {
                v317 = sub_1C321C0(a1, (__int64)v5, 0);
                v318 = sub_1263B40(v317, "Element type must be f16");
                sub_1263B40(v318, "\n");
                sub_1C31880(a1);
              }
              goto LABEL_9;
            }
            v309 = "Element type must be f16";
            v310 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_530:
            v311 = sub_1263B40(v310, v309);
            sub_1263B40(v311, "\n");
            sub_1C31880(a1);
            goto LABEL_531;
          }
          v511 = "MatrixInterpretation must be Float16";
          v512 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        else
        {
          v511 = "flags must be constant";
          v512 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        v513 = sub_1263B40(v512, v511);
        sub_1263B40(v513, "\n");
        sub_1C31880(a1);
        goto LABEL_519;
      case 0xEC8u:
        v338 = *((_DWORD *)a2 + 5) & 0xFFFFFFF;
        v339 = a2[-3 * v338];
        if ( *(_BYTE *)(v339 + 16) != 13 )
          v339 = 0;
        v340 = *(_QWORD *)a2[3 * (3 - v338)];
        if ( *(_BYTE *)(v340 + 8) != 16 )
          v340 = 0;
        v341 = a2[3 * (4 - v338)];
        if ( *(_BYTE *)(v341 + 16) != 13 )
          v341 = 0;
        if ( v339 )
        {
          if ( *(_DWORD *)(v339 + 32) <= 0x40u )
            v342 = *(_QWORD *)(v339 + 24);
          else
            v342 = **(_QWORD **)(v339 + 24);
          if ( !v342 )
          {
LABEL_582:
            if ( !v340 )
            {
              v529 = sub_1C321C0(a1, (__int64)v5, 0);
              v530 = sub_1263B40(v529, "V must be a vector");
              sub_1263B40(v530, "\n");
              sub_1C31880(a1);
              goto LABEL_9;
            }
            if ( v341 )
            {
              v343 = *(_QWORD **)(v341 + 24);
              if ( *(_DWORD *)(v341 + 32) > 0x40u )
                v343 = (_QWORD *)*v343;
              if ( *(_QWORD **)(v340 + 32) == v343 )
                goto LABEL_589;
              v344 = "N must equal the number of components in V";
              v345 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            else
            {
              v344 = "N must be constant";
              v345 = sub_1C321C0(a1, (__int64)v5, 0);
            }
            v346 = sub_1263B40(v345, v344);
            sub_1263B40(v346, "\n");
            sub_1C31880(a1);
LABEL_589:
            v347 = *(_BYTE *)(v340 + 8);
            if ( v347 == 16 )
              v347 = *(_BYTE *)(**(_QWORD **)(v340 + 16) + 8LL);
            if ( (unsigned __int8)(v347 - 1) > 1u )
            {
              v348 = sub_1C321C0(a1, (__int64)v5, 0);
              v349 = sub_1263B40(v348, "Element type must be f16 or f32");
              sub_1263B40(v349, "\n");
              sub_1C31880(a1);
            }
            goto LABEL_9;
          }
          v514 = "reserved flag bits used";
          v515 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        else
        {
          v514 = "flags must be constant";
          v515 = sub_1C321C0(a1, (__int64)v5, 0);
        }
        v516 = sub_1263B40(v515, v514);
        sub_1263B40(v516, "\n");
        sub_1C31880(a1);
        goto LABEL_582;
      case 0xECAu:
        goto LABEL_107;
      case 0xEE4u:
        v256 = *(_DWORD *)(a1 + 8);
        if ( v256 && v256 <= 719 )
        {
          v554 = sub_1C321C0(a1, (__int64)a2, 0);
          v555 = sub_1263B40(v554, "this instrinsic is only supported for Volta (sm_72)+");
          sub_1263B40(v555, "\n");
          sub_1C31880(a1);
        }
        v257 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v257 + 16) != 13 )
          goto LABEL_746;
        v258 = *(_QWORD **)(v257 + 24);
        if ( *(_DWORD *)(v257 + 32) > 0x40u )
          v258 = (_QWORD *)*v258;
        v259 = ((unsigned int)v258 >> 1) & 7;
        if ( ((unsigned __int8)v258 & 0xE) == 0 || (unsigned __int8)v259 > 4u )
        {
          v260 = sub_1C321C0(a1, (__int64)a2, 0);
          v261 = sub_1263B40(v260, "conversion type not a valid value");
          sub_1263B40(v261, "\n");
          sub_1C31880(a1);
        }
        if ( (unsigned __int8)v259 > 2u )
        {
          v262 = *(_DWORD *)(a1 + 8);
          if ( v262 )
          {
            if ( v262 <= 749 )
            {
              v613 = sub_1C321C0(a1, (__int64)a2, 0);
              v614 = sub_1263B40(v613, "conversion type only supported for Turing (sm_75)+");
              sub_1263B40(v614, "\n");
              sub_1C31880(a1);
            }
          }
        }
        if ( ((unsigned int)v258 & 0xFFFFFFF0) != 0 )
          goto LABEL_571;
        goto LABEL_9;
      case 0xEE5u:
        v328 = *(_DWORD *)(a1 + 8);
        if ( v328 && v328 <= 889 )
        {
          v542 = sub_1C321C0(a1, (__int64)a2, 0);
          v543 = sub_1263B40(v542, "this instrinsic is only supported for Ada (sm_89)+");
          sub_1263B40(v543, "\n");
          sub_1C31880(a1);
        }
        v329 = a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(v329 + 16) != 13 )
          goto LABEL_746;
        v330 = *(_QWORD *)(v329 + 24);
        if ( *(_DWORD *)(v329 + 32) > 0x40u )
          v330 = *(_QWORD *)v330;
        v331 = v330 & 0xF;
        if ( (v330 & 0xF) > 0xC || !v331 )
        {
          v332 = sub_1C321C0(a1, (__int64)a2, 0);
          v333 = sub_1263B40(v332, "Invalid dst type");
          sub_1263B40(v333, "\n");
          sub_1C31880(a1);
        }
        if ( (unsigned __int8)v330 > 0xCFu )
        {
          v531 = sub_1C321C0(a1, (__int64)a2, 0);
          v532 = sub_1263B40(v531, "Invalid src type");
          sub_1263B40(v532, "\n");
          sub_1C31880(a1);
        }
        if ( v331 == (unsigned __int8)v330 >> 4 )
        {
          v593 = sub_1C321C0(a1, (__int64)a2, 0);
          v594 = sub_1263B40(v593, "Src and dst type must be different types");
          sub_1263B40(v594, "\n");
          sub_1C31880(a1);
        }
        if ( (v330 & 0xE) == 2 && (v330 & 0xE0) == 0x20 )
        {
          v334 = sub_1C321C0(a1, (__int64)a2, 0);
          v335 = sub_1263B40(v334, "Src and dst type must be different bit widths");
          sub_1263B40(v335, "\n");
          sub_1C31880(a1);
        }
        if ( (v330 & 0xFFFFFFFFFFFE0000LL) != 0 )
          goto LABEL_571;
        goto LABEL_9;
      case 0xF00u:
        goto LABEL_352;
      default:
        goto LABEL_9;
    }
  }
  if ( v8 > 1 )
  {
    switch ( v8 )
    {
      case 2u:
      case 0x2Eu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x34u:
      case 0x6Du:
      case 0x8Cu:
      case 0x90u:
      case 0xBBu:
      case 0xBCu:
      case 0xC7u:
      case 0xC8u:
      case 0xCEu:
        goto LABEL_282;
      case 0x1Eu:
      case 0x36u:
      case 0x37u:
      case 0x60u:
      case 0x7Au:
      case 0x7Bu:
      case 0x7Cu:
      case 0x91u:
      case 0x92u:
      case 0x93u:
      case 0x94u:
      case 0xB9u:
      case 0xC2u:
        if ( *(_DWORD *)a1 == 1 )
          goto LABEL_280;
        goto LABEL_282;
      case 0x65u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0xBAu:
      case 0xC9u:
      case 0xCAu:
        if ( *(_DWORD *)a1 != 1 )
          goto LABEL_282;
        if ( v8 - 201 > 1 )
        {
LABEL_280:
          if ( v8 != 96 && v8 != 148 )
          {
LABEL_282:
            v170 = sub_1C321C0(a1, (__int64)a2, 0);
            v171 = sub_1263B40(v170, "Unsupported intrinsic: ");
            v172 = *(a2 - 3);
            v173 = v171;
            if ( *(_BYTE *)(v172 + 16) )
              v172 = 0;
            v174 = (char *)sub_1649960(v172);
            v176 = *(void **)(v173 + 24);
            v177 = v175;
            if ( v175 > *(_QWORD *)(v173 + 16) - (_QWORD)v176 )
            {
              v173 = sub_16E7EE0(v173, v174, v175);
            }
            else if ( v175 )
            {
              memcpy(v176, v174, v175);
              *(_QWORD *)(v173 + 24) += v177;
            }
            sub_1263B40(v173, "\n");
            sub_1C31880(a1);
          }
        }
        break;
      case 0xBDu:
      case 0xC3u:
      case 0xC6u:
      case 0xD1u:
      case 0xD2u:
      case 0xD3u:
        v213 = (__int64 *)a2[-3 * (*((_DWORD *)a2 + 5) & 0xFFFFFFF)];
        if ( *(_BYTE *)(*v213 + 8) == 11 )
        {
          v445 = (unsigned int)sub_1643030(*v213) - 16;
          if ( (unsigned int)v445 > 0x30 || (v446 = 0x1000000010001LL, !_bittest64(&v446, v445)) )
          {
            v447 = sub_1C321C0(a1, (__int64)a2, 0);
            v448 = sub_1263B40(v447, "Invalid type for arithmetic overflow intrinsic,");
            sub_1263B40(v448, " need i16, i32, or i64\n");
            sub_1C31880(a1);
          }
        }
        else
        {
          v214 = sub_1C321C0(a1, (__int64)a2, 0);
          v215 = sub_1263B40(v214, "arithmetic overflow operand 0 not an integer?");
          sub_1263B40(v215, "\n");
          sub_1C31880(a1);
        }
        break;
      default:
        break;
    }
  }
LABEL_9:
  if ( (unsigned __int8)sub_1C303A0(v8) && *(int *)(a1 + 8) <= 1199 )
  {
    v99 = sub_1C321C0(a1, (__int64)v5, 0);
    v100 = *(__m128i **)(v99 + 24);
    v101 = v99;
    if ( *(_QWORD *)(v99 + 16) - (_QWORD)v100 <= 0x4Bu )
    {
      v101 = sub_16E7EE0(v99, ".offset.bindless intrinsics are not supported on pre-Blackwell architectures", 0x4Cu);
      v103 = *(_BYTE **)(v101 + 24);
    }
    else
    {
      v102 = _mm_load_si128((const __m128i *)&xmmword_42D0BA0);
      qmemcpy(&v100[4], "rchitectures", 12);
      *v100 = v102;
      v100[1] = _mm_load_si128((const __m128i *)&xmmword_42D0BB0);
      v100[2] = _mm_load_si128((const __m128i *)&xmmword_42D0BC0);
      v100[3] = _mm_load_si128((const __m128i *)&xmmword_42D0BD0);
      v103 = (_BYTE *)(*(_QWORD *)(v99 + 24) + 76LL);
      *(_QWORD *)(v101 + 24) = v103;
    }
    if ( v103 == *(_BYTE **)(v101 + 16) )
    {
      sub_16E7EE0(v101, "\n", 1u);
    }
    else
    {
      *v103 = 10;
      ++*(_QWORD *)(v101 + 24);
    }
    sub_1C31880(a1);
  }
  if ( sub_1C302E0(v8) )
  {
    v9 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v9 + 16) != 13 )
    {
      v94 = sub_1C321C0(a1, (__int64)v5, 0);
      v95 = *(__m128i **)(v94 + 24);
      v96 = v94;
      if ( *(_QWORD *)(v94 + 16) - (_QWORD)v95 <= 0x1Cu )
      {
        v96 = sub_16E7EE0(v94, "op0 of intrinsic not constant", 0x1Du);
        v98 = *(_BYTE **)(v96 + 24);
      }
      else
      {
        v97 = _mm_load_si128((const __m128i *)&xmmword_42D0BE0);
        qmemcpy(&v95[1], " not constant", 13);
        *v95 = v97;
        v98 = (_BYTE *)(*(_QWORD *)(v94 + 24) + 29LL);
        *(_QWORD *)(v96 + 24) = v98;
      }
      if ( v98 == *(_BYTE **)(v96 + 16) )
      {
        sub_16E7EE0(v96, "\n", 1u);
      }
      else
      {
        *v98 = 10;
        ++*(_QWORD *)(v96 + 24);
      }
      goto LABEL_25;
    }
    v10 = *(_QWORD **)(v9 + 24);
    if ( *(_DWORD *)(v9 + 32) > 0x40u )
      v10 = (_QWORD *)*v10;
    if ( ((unsigned __int8)v10 & 7) == 0 || ((unsigned __int8)v10 & 7u) > 4 )
    {
      v11 = sub_1C321C0(a1, (__int64)v5, 0);
      v12 = *(__m128i **)(v11 + 24);
      v13 = v11;
      if ( *(_QWORD *)(v11 + 16) - (_QWORD)v12 <= 0x1Eu )
      {
        v13 = sub_16E7EE0(v11, "rounding mode not a valid value", 0x1Fu);
        v15 = *(_BYTE **)(v13 + 24);
      }
      else
      {
        v14 = _mm_load_si128((const __m128i *)&xmmword_42D0BF0);
        qmemcpy(&v12[1], "t a valid value", 15);
        *v12 = v14;
        v15 = (_BYTE *)(*(_QWORD *)(v11 + 24) + 31LL);
        *(_QWORD *)(v13 + 24) = v15;
      }
      if ( v15 == *(_BYTE **)(v13 + 16) )
      {
        sub_16E7EE0(v13, "\n", 1u);
      }
      else
      {
        *v15 = 10;
        ++*(_QWORD *)(v13 + 24);
      }
      sub_1C31880(a1);
    }
    if ( ((unsigned int)v10 & 0xFFFFFC00) != 0 )
      goto LABEL_23;
LABEL_26:
    if ( (v8 & 0xFFFFFFFD) == 0x85 )
    {
      v19 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(*(_QWORD *)v19 + 8LL) != 15 )
      {
        v20 = sub_1C321C0(a1, (__int64)v5, 0);
        v21 = *(__m128i **)(v20 + 24);
        v22 = v20;
        if ( *(_QWORD *)(v20 + 16) - (_QWORD)v21 <= 0x26u )
        {
          v22 = sub_16E7EE0(v20, "memmove/memcpy operand 0 not a pointer?", 0x27u);
          v25 = *(_BYTE **)(v22 + 24);
        }
        else
        {
          v23 = _mm_load_si128((const __m128i *)&xmmword_42D0C00);
          v21[2].m128i_i32[0] = 1953393007;
          v21[2].m128i_i16[2] = 29285;
          *v21 = v23;
          v24 = _mm_load_si128((const __m128i *)&xmmword_42D0C10);
          v21[2].m128i_i8[6] = 63;
          v21[1] = v24;
          v25 = (_BYTE *)(*(_QWORD *)(v20 + 24) + 39LL);
          *(_QWORD *)(v22 + 24) = v25;
        }
        if ( v25 == *(_BYTE **)(v22 + 16) )
        {
          sub_16E7EE0(v22, "\n", 1u);
        }
        else
        {
          *v25 = 10;
          ++*(_QWORD *)(v22 + 24);
        }
        sub_1C31880(a1);
        goto LABEL_33;
      }
      if ( *(_BYTE *)(*(_QWORD *)v5[3 * (1LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))] + 8LL) == 15 )
      {
        if ( *(_DWORD *)(*(_QWORD *)v19 + 8LL) >> 8 != 4 )
          goto LABEL_33;
        v115 = "memmove/memcpy cannot target constant address space";
        v116 = sub_1C321C0(a1, (__int64)v5, 0);
      }
      else
      {
        v115 = "memmove/memcpy operand 1 not a pointer?";
        v116 = sub_1C321C0(a1, (__int64)v5, 0);
      }
LABEL_185:
      v117 = sub_1263B40(v116, v115);
      sub_1263B40(v117, "\n");
      sub_1C31880(a1);
      goto LABEL_33;
    }
    goto LABEL_169;
  }
  v87 = sub_1C30390(v8);
  if ( v87 )
  {
    v88 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v88 + 16) == 13 )
    {
      v89 = *(_QWORD **)(v88 + 24);
      if ( *(_DWORD *)(v88 + 32) > 0x40u )
        v89 = (_QWORD *)*v89;
      v90 = (unsigned int)v89;
      v91 = (unsigned int)v89;
      if ( ((unsigned __int8)v89 & 0x1C) == 0 || (((unsigned int)v89 >> 2) & 7) > 4 )
      {
        v92 = sub_1C321C0(a1, (__int64)v5, 0);
        v93 = sub_1263B40(v92, "rounding mode not a valid value");
        sub_1263B40(v93, "\n");
        sub_1C31880(a1);
      }
      if ( ((v91 >> 7) & 7) > 2 )
      {
        v383 = sub_1C321C0(a1, (__int64)v5, 0);
        v384 = sub_1263B40(v383, "src subword mode not a valid value");
        sub_1263B40(v384, "\n");
        sub_1C31880(a1);
      }
      if ( ((v91 >> 10) & 7) > 2 )
      {
        v381 = sub_1C321C0(a1, (__int64)v5, 0);
        v382 = sub_1263B40(v381, "dest subword mode not a valid value");
        sub_1263B40(v382, "\n");
        sub_1C31880(a1);
      }
      if ( !HIBYTE(v90) )
        goto LABEL_26;
      goto LABEL_23;
    }
LABEL_195:
    v16 = "op0 of intrinsic not constant";
    v17 = sub_1C321C0(a1, (__int64)v5, 0);
    goto LABEL_24;
  }
  if ( !sub_1C30440(v8) )
  {
    if ( sub_1C30480(v8) )
    {
      v205 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v205 + 16) != 13 )
        goto LABEL_195;
      v206 = *(_QWORD *)(v205 + 24);
      if ( *(_DWORD *)(v205 + 32) > 0x40u )
        v206 = **(_QWORD **)(v205 + 24);
      if ( (v206 & 0xF) > 8 )
      {
        v527 = sub_1C321C0(a1, (__int64)v5, 0);
        v528 = sub_1263B40(v527, "dimensionality not a valid value");
        sub_1263B40(v528, "\n");
        sub_1C31880(a1);
      }
      if ( (v206 & 0x30) == 0x30 )
      {
        v591 = sub_1C321C0(a1, (__int64)v5, 0);
        v592 = sub_1263B40(v591, "border mode not a valid value");
        sub_1263B40(v592, "\n");
        sub_1C31880(a1);
      }
      if ( (v206 & 0x180) == 0x180 )
      {
        v589 = sub_1C321C0(a1, (__int64)v5, 0);
        v590 = sub_1263B40(v589, "address mode not a valid value");
        sub_1263B40(v590, "\n");
        sub_1C31880(a1);
      }
      if ( ((v206 >> 20) & 7) > 2 )
      {
        v525 = sub_1C321C0(a1, (__int64)v5, 0);
        v526 = sub_1263B40(v525, "address mode not a valid value");
        sub_1263B40(v526, "\n");
        sub_1C31880(a1);
      }
      if ( ((v206 >> 31) & 0xF) > 2 )
      {
        v523 = sub_1C321C0(a1, (__int64)v5, 0);
        v524 = sub_1263B40(v523, "scope not a valid value");
        sub_1263B40(v524, "\n");
        sub_1C31880(a1);
      }
      if ( ((v206 >> 27) & 0xF) > 6 )
      {
        v521 = sub_1C321C0(a1, (__int64)v5, 0);
        v522 = sub_1263B40(v521, "semantic mode not a valid value");
        sub_1263B40(v522, "\n");
        sub_1C31880(a1);
      }
      if ( (v206 & 0xC000000000LL) != 0 )
      {
        v519 = sub_1C321C0(a1, (__int64)v5, 0);
        v520 = sub_1263B40(v519, "query mode is not a valid value");
        sub_1263B40(v520, "\n");
        sub_1C31880(a1);
      }
      if ( (v206 & 0xFFFFE00000000000LL) == 0 )
        goto LABEL_26;
LABEL_23:
      v16 = "reserved flag bits used";
      v17 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_24:
      v18 = sub_1263B40(v17, v16);
      sub_1263B40(v18, "\n");
LABEL_25:
      sub_1C31880(a1);
      goto LABEL_26;
    }
    if ( sub_1C304C0(v8) )
    {
      v449 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v449 + 16) != 13 )
        goto LABEL_195;
      v450 = *(_QWORD **)(v449 + 24);
      if ( *(_DWORD *)(v449 + 32) > 0x40u )
        v450 = (_QWORD *)*v450;
      if ( ((unsigned __int8)v450 & 0xFu) > 8 )
      {
        v627 = sub_1C321C0(a1, (__int64)v5, 0);
        v628 = sub_1263B40(v627, "dimensionality not a valid value");
        sub_1263B40(v628, "\n");
        sub_1C31880(a1);
      }
      if ( (unsigned __int8)v450 > 0x8Fu )
      {
        v625 = sub_1C321C0(a1, (__int64)v5, 0);
        v626 = sub_1263B40(v625, "query mode not a valid value");
        sub_1263B40(v626, "\n");
        sub_1C31880(a1);
      }
      if ( (((unsigned int)v450 >> 9) & 7) > 2 )
      {
        v619 = sub_1C321C0(a1, (__int64)v5, 0);
        v620 = sub_1263B40(v619, "Binding Mode is not a valid value");
        sub_1263B40(v620, "\n");
        sub_1C31880(a1);
      }
      if ( ((unsigned int)v450 & 0xFFFFE000) == 0 )
        goto LABEL_26;
      goto LABEL_23;
    }
    if ( sub_1C302A0(v8) )
    {
      v537 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v537 + 16) != 13 )
        goto LABEL_195;
      v538 = *(_QWORD **)(v537 + 24);
      if ( *(_DWORD *)(v537 + 32) > 0x40u )
        v538 = (_QWORD *)*v538;
      v539 = WORD1(v538);
      v540 = (unsigned __int16)v538;
      if ( ((unsigned __int8)v538 & 0xFu) > 6 )
      {
        v637 = sub_1C321C0(a1, (__int64)v5, 0);
        v638 = sub_1263B40(v637, "ordering mode not a valid value");
        sub_1263B40(v638, "\n");
        sub_1C31880(a1);
      }
      if ( (unsigned __int8)v540 > 0x2Fu )
      {
        v635 = sub_1C321C0(a1, (__int64)v5, 0);
        v636 = sub_1263B40(v635, "scope mode not a valid value");
        sub_1263B40(v636, "\n");
        sub_1C31880(a1);
      }
      if ( (unsigned __int8)(v540 >> 12) > 6u )
      {
        v633 = sub_1C321C0(a1, (__int64)v5, 0);
        v634 = sub_1263B40(v633, "Cache operation hint not a valid value");
        sub_1263B40(v634, "\n");
        sub_1C31880(a1);
      }
      if ( (unsigned __int8)v539 > 0x10u || (_BYTE)v539 == 4 )
      {
        v631 = sub_1C321C0(a1, (__int64)v5, 0);
        v632 = sub_1263B40(v631, "operation mode not a valid value");
        sub_1263B40(v632, "\n");
        sub_1C31880(a1);
      }
      if ( (v539 & 0xF800u) == 0 )
        goto LABEL_26;
      goto LABEL_23;
    }
    if ( v8 != 3957 )
    {
      if ( v8 != 4085 && v8 != 4503 )
      {
        if ( v8 != 4271 && v8 != 5616 )
          goto LABEL_26;
        v595 = *((_DWORD *)v5 + 5);
        v596 = v5[-3 * (v595 & 0xFFFFFFF)];
        if ( *(_BYTE *)(v596 + 16) != 13 )
        {
          v596 = 0;
          v597 = sub_1C321C0(a1, (__int64)v5, 0);
          v598 = sub_1263B40(v597, "Mode operand is not constant");
          sub_1263B40(v598, "\n");
          sub_1C31880(a1);
          v595 = *((_DWORD *)v5 + 5);
        }
        v599 = v5[3 * (1LL - (v595 & 0xFFFFFFF))];
        if ( *(_BYTE *)(v599 + 16) != 13 )
        {
          v2 = "Attribute is not constant";
          v3 = sub_1C321C0(a1, (__int64)v5, 0);
          goto LABEL_944;
        }
        v600 = *(_QWORD **)(v599 + 24);
        if ( *(_DWORD *)(v599 + 32) > 0x40u )
          v600 = (_QWORD *)*v600;
        if ( (unsigned int)v600 > 0x45 )
        {
          v645 = sub_1C321C0(a1, (__int64)v5, 0);
          v646 = sub_1263B40(v645, "Attribute out of range");
          sub_1263B40(v646, "\n");
          sub_1C31880(a1);
        }
        v601 = *(_DWORD *)(v596 + 32);
        v602 = *(_QWORD **)(v596 + 24);
        if ( v8 == 4271 )
        {
          if ( v601 > 0x40 )
            v602 = (_QWORD *)*v602;
          if ( ((unsigned int)v602 & 0xFFFFFFF0) != 0 )
          {
            v643 = sub_1C321C0(a1, (__int64)v5, 0);
            v644 = sub_1263B40(v643, "reserved flag bits used");
            sub_1263B40(v644, "\n");
            sub_1C31880(a1);
          }
          goto LABEL_171;
        }
        if ( v601 > 0x40 )
          v602 = (_QWORD *)*v602;
        if ( !(_DWORD)v602 )
          goto LABEL_26;
        goto LABEL_23;
      }
      v615 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v615 + 16) == 13 )
      {
        v616 = *(_QWORD **)(v615 + 24);
        if ( *(_DWORD *)(v615 + 32) > 0x40u )
          v616 = (_QWORD *)*v616;
        if ( (WORD1(v616) & 0xFFF0) != 0 )
        {
          v629 = sub_1C321C0(a1, (__int64)v5, 0);
          v630 = sub_1263B40(v629, "reserved flag bits used");
          sub_1263B40(v630, "\n");
          sub_1C31880(a1);
        }
        if ( v8 == 4085 )
          goto LABEL_171;
        if ( ((unsigned __int8)v616 & 1) == 0 )
          goto LABEL_26;
        v16 = "Use Texture Domain flag not allowed on stores";
        v17 = sub_1C321C0(a1, (__int64)v5, 0);
        goto LABEL_24;
      }
      goto LABEL_195;
    }
    v605 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v605 + 16) != 13 )
    {
      v609 = "op0 of intrinsic not constant";
      v610 = sub_1C321C0(a1, (__int64)v5, 0);
      goto LABEL_893;
    }
    v606 = *(_QWORD **)(v605 + 24);
    if ( *(_DWORD *)(v605 + 32) > 0x40u )
      v606 = (_QWORD *)*v606;
    if ( ((unsigned __int8)v606 & 3) == 3 )
    {
      v641 = sub_1C321C0(a1, (__int64)v5, 0);
      v642 = sub_1263B40(v641, "geometry out mode not a valid value");
      sub_1263B40(v642, "\n");
      sub_1C31880(a1);
    }
    if ( ((unsigned int)v606 & 0xFFFFFFFC) != 0 )
    {
      v639 = sub_1C321C0(a1, (__int64)v5, 0);
      v640 = sub_1263B40(v639, "reserved flag bits used");
      sub_1263B40(v640, "\n");
      sub_1C31880(a1);
    }
    if ( ((unsigned __int8)v606 & 3) == 1 )
    {
      v607 = v5[3 * (1LL - (*((_DWORD *)v5 + 5) & 0xFFFFFFF))];
      if ( *(_BYTE *)(v607 + 16) != 13 )
      {
        v609 = "op1 of GeometryOut intrinsic must be constant when CUT mode";
        v610 = sub_1C321C0(a1, (__int64)v5, 0);
        goto LABEL_893;
      }
      v608 = *(_QWORD **)(v607 + 24);
      if ( *(_DWORD *)(v607 + 32) > 0x40u )
        v608 = (_QWORD *)*v608;
      if ( v608 )
      {
        v609 = "op1 of GeometryOut intrinsic must be 0 when CUT mode";
        v610 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_893:
        v611 = sub_1263B40(v610, v609);
        sub_1263B40(v611, "\n");
        sub_1C31880(a1);
      }
    }
LABEL_224:
    if ( v8 - 4355 > 1 )
    {
      if ( v8 - 3755 > 1 )
      {
        if ( v8 == 4495 )
        {
          v621 = *(_QWORD *)v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
          if ( *(_BYTE *)(v621 + 8) == 16 )
            v621 = **(_QWORD **)(v621 + 16);
          if ( *(_DWORD *)(v621 + 8) >> 8 != 5 )
          {
            v115 = "llvm.nvvm.stackrestore is only supported with local address space pointers";
            v116 = sub_1C321C0(a1, (__int64)v5, 0);
            goto LABEL_185;
          }
        }
        else
        {
          if ( v8 != 4496 )
          {
            if ( v8 != 3785 || *(_BYTE *)(v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)] + 16) == 13 )
              goto LABEL_33;
            v115 = "llvm.nvvm.coro.create.suspend must have exactly one argument, which must be a constant integer";
            v116 = sub_1C321C0(a1, (__int64)v5, 0);
            goto LABEL_185;
          }
          v612 = *v5;
          if ( *(_BYTE *)(*v5 + 8) == 16 )
            v612 = **(_QWORD **)(v612 + 16);
          if ( *(_DWORD *)(v612 + 8) >> 8 != 5 )
          {
            v115 = "llvm.nvvm.stacksave is only supported with local address space pointers";
            v116 = sub_1C321C0(a1, (__int64)v5, 0);
            goto LABEL_185;
          }
        }
        goto LABEL_33;
      }
      v546 = *(_DWORD *)(a1 + 8);
      if ( !v546 )
        goto LABEL_819;
      if ( v8 == 3755 )
      {
        if ( v546 > 699 )
          goto LABEL_819;
        v622 = "llvm.nvvm.branch.if.all.convergent is not supported on pre-Volta Architectures";
        v623 = sub_1C321C0(a1, (__int64)v5, 0);
      }
      else
      {
        if ( v546 > 799 )
        {
LABEL_819:
          v547 = v5[1];
          if ( !v547 )
            goto LABEL_826;
          v548 = 0;
          do
          {
            v549 = sub_1648700(v547);
            v547 = *(_QWORD *)(v547 + 8);
            if ( *((_BYTE *)v549 + 16) != 26 )
              v549 = 0;
            ++v548;
          }
          while ( v547 );
          if ( !v549 || v548 != 1 )
          {
LABEL_826:
            v115 = "result of llvm.nvvm.branch.if.convergent and llvm.nvvm.branch.if.all.convergent can only be used by e"
                   "xactly one branch instruction";
            v116 = sub_1C321C0(a1, (__int64)v5, 0);
            goto LABEL_185;
          }
          goto LABEL_33;
        }
        v622 = "llvm.nvvm.branch.if.convergent is not supported on pre-Ampere Architectures";
        v623 = sub_1C321C0(a1, (__int64)v5, 0);
      }
      v624 = sub_1263B40(v623, v622);
      sub_1263B40(v624, "\n");
      sub_1C31880(a1);
      goto LABEL_819;
    }
    v504 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v504 + 16) == 13 )
    {
      v505 = *(_QWORD **)(v504 + 24);
      if ( *(_DWORD *)(v504 + 32) > 0x40u )
        v505 = (_QWORD *)*v505;
      v506 = (unsigned int)v505;
      if ( ((unsigned int)v505 & 0xFFFFFFF0) != 0 )
      {
        v603 = sub_1C321C0(a1, (__int64)v5, 0);
        v604 = sub_1263B40(v603, "reserved bits used");
        sub_1263B40(v604, "\n");
        sub_1C31880(a1);
      }
      if ( ((v506 >> 1) & 7) > 5 )
      {
        v115 = "Invalid subop mode";
        v116 = sub_1C321C0(a1, (__int64)v5, 0);
        goto LABEL_185;
      }
      goto LABEL_33;
    }
    goto LABEL_946;
  }
  v124 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
  if ( *(_BYTE *)(v124 + 16) != 13 )
  {
    v403 = "op0 of intrinsic not constant";
    v404 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_660:
    v405 = sub_1263B40(v404, v403);
    sub_1263B40(v405, "\n");
    sub_1C31880(a1);
    goto LABEL_213;
  }
  v125 = *(_QWORD *)(v124 + 24);
  if ( *(_DWORD *)(v124 + 32) > 0x40u )
    v125 = **(_QWORD **)(v124 + 24);
  v664 = WORD1(v125);
  v126 = v125;
  if ( ((unsigned __int8)v125 & 0xFu) > 8 )
  {
    v659 = v125;
    v416 = sub_1C321C0(a1, (__int64)v5, 0);
    v417 = sub_1263B40(v416, "dimensionality not a valid value");
    sub_1263B40(v417, "\n");
    sub_1C31880(a1);
    LOBYTE(v125) = v659;
  }
  v127 = v125;
  if ( (v125 & 0xF) == 6 )
  {
    v660 = v125;
    v471 = sub_1C321C0(a1, (__int64)v5, 0);
    v472 = sub_1263B40(v471, "dimensionality not a valid value");
    sub_1263B40(v472, "\n");
    sub_1C31880(a1);
    v127 = v660;
  }
  if ( (v127 & 0x30) == 0x30 )
  {
    v473 = sub_1C321C0(a1, (__int64)v5, 0);
    v474 = sub_1263B40(v473, "LOD Adjust mode not a valid value");
    sub_1263B40(v474, "\n");
    sub_1C31880(a1);
  }
  if ( ((v126 >> 10) & 7) > 2 )
  {
    v414 = sub_1C321C0(a1, (__int64)v5, 0);
    v415 = sub_1263B40(v414, "Binding Mode is not a valid value");
    sub_1263B40(v415, "\n");
    sub_1C31880(a1);
  }
  if ( (v664 & 0xFFE0) != 0 )
  {
    v403 = "reserved flag bits used";
    v404 = sub_1C321C0(a1, (__int64)v5, 0);
    goto LABEL_660;
  }
LABEL_213:
  if ( v8 - 5144 <= 1 )
    goto LABEL_170;
  v128 = *v5;
  if ( *(_BYTE *)(*v5 + 8) == 13 )
  {
    if ( *(_DWORD *)(v128 + 12) == 2 )
    {
      v481 = *(__int64 **)(v128 + 16);
      v482 = v481[1];
      v128 = *v481;
      if ( *(_BYTE *)(v482 + 8) == 11 && (unsigned int)sub_1643030(v482) == 1 )
        goto LABEL_215;
      v409 = "type not i1";
      v410 = sub_1C321C0(a1, (__int64)v5, 0);
    }
    else
    {
      v409 = "not struct of 2 elements";
      v410 = sub_1C321C0(a1, (__int64)v5, 0);
    }
    v411 = sub_1263B40(v410, v409);
    sub_1263B40(v411, "\n");
    sub_1C31880(a1);
  }
LABEL_215:
  if ( *(int *)(a1 + 8) > 1199 )
    v87 = !sub_1C30470(v8);
  if ( *(_BYTE *)(v128 + 8) != 16 )
  {
    v16 = "type not a vector";
    v17 = sub_1C321C0(a1, (__int64)v5, 0);
    goto LABEL_24;
  }
  if ( *(_QWORD *)(v128 + 32) != 4 )
  {
    v406 = sub_1C321C0(a1, (__int64)v5, 0);
    v407 = sub_1263B40(v406, "type not v4");
    sub_1263B40(v407, "\n");
    sub_1C31880(a1);
  }
  v408 = *(_QWORD *)(v128 + 24);
  if ( (unsigned __int8)(*(_BYTE *)(v408 + 8) - 1) <= 1u || sub_1642F90(v408, 32) || sub_1642F90(v408, 16) && v87 )
    goto LABEL_26;
  if ( v8 - 5146 > 3 || !sub_1642F90(v408, 64) )
  {
    v16 = "texture element type not legal";
    v17 = sub_1C321C0(a1, (__int64)v5, 0);
    goto LABEL_24;
  }
LABEL_169:
  if ( v8 == 137 )
  {
    v118 = *(_QWORD *)v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(v118 + 8) == 15 )
    {
      if ( *(_DWORD *)(v118 + 8) >> 8 != 4 )
        goto LABEL_33;
      v115 = "memset cannot point to constant address space";
      v116 = sub_1C321C0(a1, (__int64)v5, 0);
    }
    else
    {
      v115 = "memset operand 0 not a pointer?";
      v116 = sub_1C321C0(a1, (__int64)v5, 0);
    }
    goto LABEL_185;
  }
LABEL_170:
  if ( v8 == 6 )
  {
    v120 = (__int64 *)v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    if ( *(_BYTE *)(*v120 + 8) != 11 )
    {
      v115 = "bswap operand 0 not an integer?";
      v116 = sub_1C321C0(a1, (__int64)v5, 0);
      goto LABEL_185;
    }
    v121 = (unsigned int)sub_1643030(*v120) - 16;
    if ( (unsigned int)v121 > 0x30 || (v122 = 0x1000000010001LL, !_bittest64(&v122, v121)) )
    {
      v123 = sub_1C321C0(a1, (__int64)v5, 0);
      sub_1263B40(v123, "Invalid type for bswap, need i16, i32, or i64\n");
      sub_1C31880(a1);
    }
    goto LABEL_33;
  }
LABEL_171:
  if ( v8 - 31 <= 2 )
  {
    v104 = *(_QWORD *)v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
    v105 = *(_BYTE *)(v104 + 8);
    if ( v105 == 16 )
    {
      v104 = *(_QWORD *)(v104 + 24);
      v105 = *(_BYTE *)(v104 + 8);
    }
    if ( v105 != 11
      || (v106 = (unsigned int)sub_1643030(v104) - 8, (unsigned int)v106 > 0x38)
      || (v107 = 0x100000001000101LL, !_bittest64(&v107, v106)) )
    {
      v108 = sub_1C321C0(a1, (__int64)v5, 0);
      v109 = sub_1263B40(v108, "Invalid type for ctpop/ctlz/cttz, need i8, i16, i32, ");
      sub_1263B40(v109, "i64, or vector of these\n");
      sub_1C31880(a1);
    }
    goto LABEL_33;
  }
  switch ( v8 )
  {
    case 0xF77u:
      v201 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      v202 = *(_QWORD *)v201;
      if ( *(_BYTE *)(*(_QWORD *)v201 + 8LL) == 16 )
        v202 = **(_QWORD **)(v202 + 16);
      if ( *(_DWORD *)(v202 + 8) >> 8 != 4 )
      {
        v203 = sub_1C321C0(a1, (__int64)v5, 0);
        v204 = sub_1263B40(v203, "Operand must be in constant address space");
        sub_1263B40(v204, "\n");
        sub_1C31880(a1);
      }
      if ( *(_BYTE *)(sub_1649C60(v201) + 16) != 3 )
      {
        v115 = "Operand must be a global variable or a bitcast from a global variable";
        v116 = sub_1C321C0(a1, (__int64)v5, 0);
        goto LABEL_185;
      }
      goto LABEL_33;
    case 0x1043u:
    case 0x1046u:
      v385 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
      v386 = v5[-3 * v385];
      if ( *(_BYTE *)(v386 + 16) == 13 )
      {
        v387 = *(_QWORD **)(v386 + 24);
        if ( *(_DWORD *)(v386 + 32) > 0x40u )
          v387 = (_QWORD *)*v387;
        if ( ((unsigned int)v387 & 0xFFFFFFFE) != 0 )
        {
          v442 = sub_1C321C0(a1, (__int64)v5, 0);
          v443 = sub_1263B40(v442, "reserved bits used");
          sub_1263B40(v443, "\n");
          sub_1C31880(a1);
          v385 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        }
        v388 = v5[3 * (3 - v385)];
        if ( *(_BYTE *)(v388 + 16) != 13 )
        {
          v388 = 0;
          v389 = sub_1C321C0(a1, (__int64)v5, 0);
          v390 = sub_1263B40(v389, "Byte size is not constant");
          sub_1263B40(v390, "\n");
          sub_1C31880(a1);
          v385 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        }
        v391 = v5[3 * (4 - v385)];
        if ( *(_BYTE *)(v391 + 16) != 13 )
        {
          v392 = sub_1C321C0(a1, (__int64)v5, 0);
          v393 = sub_1263B40(v392, "Source size is not constant");
          sub_1263B40(v393, "\n");
          sub_1C31880(a1);
          v391 = 0;
        }
        v394 = *(_QWORD **)(v388 + 24);
        if ( *(_DWORD *)(v388 + 32) > 0x40u )
          v394 = (_QWORD *)*v394;
        if ( *(_DWORD *)(v391 + 32) <= 0x40u )
          v395 = *(_QWORD *)(v391 + 24);
        else
          v395 = **(_QWORD **)(v391 + 24);
        if ( v395 <= (unsigned __int64)v394 )
        {
          v451 = sub_1C321C0(a1, (__int64)v5, 0);
          v452 = sub_1263B40(v451, "Byte size must be less than or equal to source size");
          sub_1263B40(v452, "\n");
          sub_1C31880(a1);
        }
        v396 = *((_DWORD *)v5 + 5) & 0xFFFFFFF;
        v397 = *(_QWORD *)v5[3 * (1 - v396)];
        if ( *(_BYTE *)(v397 + 8) == 16 )
          v397 = **(_QWORD **)(v397 + 16);
        v398 = *(_DWORD *)(v397 + 8) >> 8;
        v399 = *(_QWORD *)v5[3 * (2 - v396)];
        if ( *(_BYTE *)(v399 + 8) == 16 )
          v399 = **(_QWORD **)(v399 + 16);
        v400 = *(_DWORD *)(v399 + 8) >> 8;
        if ( v398 != 3 )
        {
          v401 = sub_1C321C0(a1, (__int64)v5, 0);
          v402 = sub_1263B40(v401, "Destination must be in shared memory space");
          sub_1263B40(v402, "\n");
          sub_1C31880(a1);
        }
        if ( v400 != 1 )
        {
          v115 = "Source must be in global memory space";
          v116 = sub_1C321C0(a1, (__int64)v5, 0);
          goto LABEL_185;
        }
        goto LABEL_33;
      }
LABEL_946:
      v2 = "Mode operand is not constant";
      v3 = sub_1C321C0(a1, (__int64)v5, 0);
LABEL_944:
      v4 = sub_1263B40(v3, v2);
      sub_1263B40(v4, "\n");
      sub_1C31880(a1);
      BUG();
    case 0x1045u:
      v418 = v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
      if ( *(_BYTE *)(v418 + 16) == 13 )
      {
        v419 = *(_QWORD **)(v418 + 24);
        if ( *(_DWORD *)(v418 + 32) > 0x40u )
          v419 = (_QWORD *)*v419;
        v420 = (char)v419;
        if ( ((unsigned int)v419 & 0xFFFFFFF0) != 0 )
        {
          v550 = sub_1C321C0(a1, (__int64)v5, 0);
          v551 = sub_1263B40(v550, "reserved bits used");
          sub_1263B40(v551, "\n");
          sub_1C31880(a1);
        }
        if ( (v420 & 0xFu) > 2 )
        {
          v115 = "Invalid wait mode";
          v116 = sub_1C321C0(a1, (__int64)v5, 0);
          goto LABEL_185;
        }
        goto LABEL_33;
      }
      goto LABEL_946;
  }
  if ( v8 != 4164 )
    goto LABEL_224;
  v492 = *(_QWORD *)v5[-3 * (*((_DWORD *)v5 + 5) & 0xFFFFFFF)];
  if ( *(_BYTE *)(v492 + 8) == 16 )
    v492 = **(_QWORD **)(v492 + 16);
  if ( *(_DWORD *)(v492 + 8) >> 8 != 3 )
  {
    v115 = "Barrier pointer must be in shared memory space";
    v116 = sub_1C321C0(a1, (__int64)v5, 0);
    goto LABEL_185;
  }
LABEL_33:
  if ( v5[6] || *((__int16 *)v5 + 9) < 0 )
  {
    v26 = sub_1625940((__int64)v5, "callalign", 9u);
    v27 = v26;
    if ( v26 )
    {
      v28 = *(unsigned int *)(v26 + 8);
      if ( (int)v28 > 0 )
      {
        v29 = v28;
        v30 = 0;
        while ( 1 )
        {
          v36 = *(_QWORD *)(v27 + 8 * (v30 - v28));
          if ( *(_BYTE *)v36 != 1 || *(_BYTE *)(*(_QWORD *)(v36 + 136) + 16LL) != 13 )
          {
            v37 = *(_QWORD *)(a1 + 24);
            v38 = *(_QWORD *)(v37 + 24);
            if ( (unsigned __int64)(*(_QWORD *)(v37 + 16) - v38) <= 6 )
            {
              sub_16E7EE0(v37, "Error: ", 7u);
            }
            else
            {
              *(_DWORD *)v38 = 1869771333;
              *(_WORD *)(v38 + 4) = 14962;
              *(_BYTE *)(v38 + 6) = 32;
              *(_QWORD *)(v37 + 24) += 7LL;
            }
            v39 = *(_QWORD *)(a1 + 24);
            v40 = *(_WORD **)(v39 + 24);
            if ( *(_QWORD *)(v39 + 16) - (_QWORD)v40 > 1u )
            {
              *v40 = 8250;
              *(_QWORD *)(v39 + 24) += 2LL;
            }
            else
            {
              sub_16E7EE0(v39, ": ", 2u);
            }
            sub_1556280((unsigned __int8 *)v27, *(_QWORD *)(a1 + 24), 0);
            v31 = *(_QWORD *)(a1 + 24);
            v32 = *(_QWORD *)(v31 + 24);
            if ( (unsigned __int64)(*(_QWORD *)(v31 + 16) - v32) <= 2 )
            {
              sub_16E7EE0(v31, "\n  ", 3u);
            }
            else
            {
              *(_BYTE *)(v32 + 2) = 32;
              *(_WORD *)v32 = 8202;
              *(_QWORD *)(v31 + 24) += 3LL;
            }
            v33 = *(_QWORD *)(a1 + 24);
            v34 = *(__m128i **)(v33 + 24);
            if ( *(_QWORD *)(v33 + 16) - (_QWORD)v34 <= 0x2Fu )
            {
              v33 = sub_16E7EE0(v33, "callalign metadata operands not integer literals", 0x30u);
              v35 = *(_BYTE **)(v33 + 24);
            }
            else
            {
              *v34 = _mm_load_si128((const __m128i *)&xmmword_42D0C60);
              v34[1] = _mm_load_si128((const __m128i *)&xmmword_42D0C70);
              v34[2] = _mm_load_si128((const __m128i *)&xmmword_42D0C80);
              v35 = (_BYTE *)(*(_QWORD *)(v33 + 24) + 48LL);
              *(_QWORD *)(v33 + 24) = v35;
            }
            if ( v35 == *(_BYTE **)(v33 + 16) )
            {
              sub_16E7EE0(v33, "\n", 1u);
            }
            else
            {
              *v35 = 10;
              ++*(_QWORD *)(v33 + 24);
            }
            sub_1C31880(a1);
          }
          if ( ++v30 == v29 )
            break;
          v28 = *(unsigned int *)(v27 + 8);
        }
      }
    }
  }
  return sub_1C34B00(a1, (__int64)v5);
}
