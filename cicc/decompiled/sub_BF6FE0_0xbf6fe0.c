// Function: sub_BF6FE0
// Address: 0xbf6fe0
//
void __fastcall sub_BF6FE0(__int64 a1, __int64 a2)
{
  __int64 v2; // r15
  __int64 v4; // r14
  char v5; // si
  __int64 v6; // rax
  __int64 v7; // rdx
  const char *v8; // rax
  char v9; // al
  __int64 i; // rbx
  __int64 v11; // r12
  __int64 v12; // r11
  __int64 v14; // r12
  __int64 v15; // r15
  unsigned int v16; // esi
  __int64 v17; // rax
  __int64 *v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rdi
  int v21; // edx
  unsigned __int8 v22; // r9
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // r9
  __int64 v26; // rbx
  int v27; // eax
  __int64 v28; // rdi
  __int64 v29; // rax
  __int64 v30; // rbx
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r12
  __int64 v35; // rbx
  unsigned __int8 v36; // dl
  __int64 v37; // rax
  __int64 v38; // rdx
  int v39; // eax
  int v40; // edx
  __int64 v41; // rax
  __int64 v42; // rdx
  __int64 v43; // rax
  __int64 v44; // r15
  __int64 v45; // r14
  __int64 v46; // r12
  _BYTE *v47; // rax
  bool v48; // zf
  __int64 v49; // rax
  __int64 v50; // rcx
  __int64 v51; // rdx
  __int64 v52; // rsi
  char *v53; // rbx
  char **v54; // rax
  char **v55; // rsi
  __int64 v56; // rdx
  __int64 v57; // r9
  _BYTE *v58; // rax
  const char *v59; // rdx
  unsigned __int8 v60; // cl
  __int64 v61; // r12
  const char *v62; // rdx
  __int64 v63; // rax
  __int64 v65; // rdx
  __int64 v66; // rdx
  const char *v67; // rdx
  const char *v68; // rsi
  const char *v69; // rsi
  const char *v70; // rax
  unsigned __int8 v71; // cl
  __int64 v72; // rdx
  __int64 v73; // rsi
  _QWORD **v74; // rsi
  _QWORD **v75; // rax
  _QWORD *v76; // rcx
  __int64 v77; // r14
  _BYTE *v78; // rax
  __int64 v79; // rdi
  _BYTE *v80; // rax
  __int64 v81; // rax
  int v82; // edx
  __int64 v83; // rax
  __int64 v84; // rbx
  unsigned __int64 v85; // rax
  const char *v86; // rdx
  __int64 v87; // rax
  __int64 v88; // rdx
  unsigned __int8 v89; // cl
  const char *v90; // rsi
  unsigned __int8 v91; // cl
  __int64 v92; // r14
  _BYTE *v93; // rax
  __int64 v94; // rdi
  _BYTE *v95; // rax
  __int64 v96; // rbx
  char *v97; // rbx
  unsigned __int8 v98; // al
  __int64 v99; // rax
  __int64 v100; // rdx
  const char **v101; // rbx
  _BYTE *v102; // rdi
  const char **v103; // r14
  __int64 v104; // rbx
  const char *v105; // r14
  _BYTE *v106; // rax
  __int64 v107; // rax
  __int64 v108; // rdx
  unsigned __int8 v109; // cl
  char **v110; // rcx
  char **v111; // rdi
  char *v112; // rsi
  char v113; // al
  unsigned __int8 v114; // al
  char *v115; // rax
  __int64 v116; // rdx
  __int64 v117; // rdx
  char *v118; // rsi
  __int64 m; // rdx
  signed __int64 v120; // rdx
  const char *v121; // rax
  __int64 v122; // r14
  _BYTE *v123; // rax
  const char *v124; // rsi
  int v125; // eax
  __int64 v126; // rcx
  _BYTE *v127; // rdi
  __int64 v128; // rdx
  __int64 v129; // rbx
  unsigned int v130; // ebx
  int v131; // r14d
  const char *v132; // rax
  const char *v133; // rdx
  __int64 v134; // rax
  _BYTE *v135; // r14
  unsigned __int8 *v136; // rdi
  int v137; // edx
  __int64 v138; // r14
  __int64 v139; // rbx
  __int64 v140; // rsi
  bool v141; // dl
  bool v142; // al
  __int64 v143; // r14
  _BYTE *v144; // rax
  __int64 v145; // rdi
  _BYTE *v146; // rax
  unsigned __int8 v147; // cl
  const char **v148; // r12
  const char **v149; // rbx
  const char *v150; // rax
  unsigned __int8 v151; // dl
  const char **v152; // rax
  const char *v153; // rdx
  const char *v154; // rsi
  unsigned int j; // edx
  unsigned int v156; // ecx
  const char *v157; // rax
  const char *v158; // rdi
  unsigned __int8 v159; // al
  __int64 v160; // rax
  __int64 v161; // rax
  __int64 v162; // r12
  const char *v163; // r15
  __int64 k; // rbx
  __int64 v165; // r14
  const char *v166; // rbx
  __int64 v167; // r8
  _BYTE *v168; // rax
  __int64 v169; // rax
  __int64 v170; // rsi
  unsigned __int64 v171; // rsi
  __int64 *v172; // r12
  const char *v173; // r15
  __int64 v174; // rbx
  __int64 v175; // r14
  __int64 v176; // rdi
  __int64 v177; // rdi
  _BYTE *v178; // rax
  const char *v179; // rax
  unsigned __int8 v180; // si
  _QWORD *v181; // rax
  _QWORD *v182; // r8
  _QWORD *v183; // rsi
  __int64 v184; // rax
  __int64 v185; // rdi
  _BYTE *v186; // rax
  const char *v187; // rbx
  __int64 v188; // rdi
  _BYTE *v189; // rax
  const char *v190; // rax
  __int64 v191; // r14
  _BYTE *v192; // rax
  __int64 v193; // r14
  _BYTE *v194; // rax
  __int64 v195; // rdi
  _BYTE *v196; // rax
  __int64 v197; // r14
  _BYTE *v198; // rax
  int v199; // edx
  unsigned __int16 v200; // si
  __int64 v201; // [rsp+8h] [rbp-E8h]
  __int64 v202; // [rsp+8h] [rbp-E8h]
  __int64 v203; // [rsp+10h] [rbp-E0h]
  __int64 v204; // [rsp+18h] [rbp-D8h]
  __int64 v205; // [rsp+18h] [rbp-D8h]
  __int64 *v206; // [rsp+20h] [rbp-D0h]
  __int64 v207; // [rsp+20h] [rbp-D0h]
  __int64 v208; // [rsp+20h] [rbp-D0h]
  int v209; // [rsp+28h] [rbp-C8h]
  __int64 v210; // [rsp+28h] [rbp-C8h]
  const char **v211; // [rsp+28h] [rbp-C8h]
  __int64 v212; // [rsp+28h] [rbp-C8h]
  __int64 v213; // [rsp+28h] [rbp-C8h]
  const char *v214[2]; // [rsp+30h] [rbp-C0h] BYREF
  const char *v215; // [rsp+40h] [rbp-B0h] BYREF
  __int64 v216; // [rsp+48h] [rbp-A8h]
  char v217; // [rsp+50h] [rbp-A0h]
  char v218; // [rsp+60h] [rbp-90h]
  char v219; // [rsp+61h] [rbp-8Fh]
  __m128i v220; // [rsp+70h] [rbp-80h] BYREF
  _BYTE v221[16]; // [rsp+80h] [rbp-70h] BYREF
  char v222; // [rsp+90h] [rbp-60h]
  char v223; // [rsp+91h] [rbp-5Fh]

  v2 = a1;
  v4 = *(_QWORD *)(a2 + 40);
  if ( !v4 )
  {
    v215 = (const char *)a2;
    v8 = "Instruction not embedded in basic block!";
    v223 = 1;
    goto LABEL_23;
  }
  v5 = *(_BYTE *)a2;
  if ( v5 != 84 )
  {
    v6 = *(_QWORD *)(a2 + 16);
    if ( v6 )
    {
      while ( 1 )
      {
        if ( *(_QWORD *)(v6 + 24) == a2 )
        {
          v7 = (unsigned int)(*(_DWORD *)(v4 + 44) + 1);
          if ( (unsigned int)v7 < *(_DWORD *)(a1 + 192) )
          {
            if ( *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v7) )
              break;
          }
        }
        v6 = *(_QWORD *)(v6 + 8);
        if ( !v6 )
          goto LABEL_10;
      }
      v215 = (const char *)a2;
      v8 = "Only PHI nodes may reference their own value!";
      v223 = 1;
      goto LABEL_23;
    }
  }
LABEL_10:
  v9 = *(_BYTE *)(*(_QWORD *)(a2 + 8) + 8LL);
  if ( v9 != 7 )
  {
    if ( v9 != 13 )
    {
      if ( v5 != 34 && v5 != 85 && v9 == 9 )
      {
        v215 = (const char *)a2;
        v8 = "Invalid use of metadata!";
        v223 = 1;
        goto LABEL_23;
      }
      goto LABEL_14;
    }
    v215 = (const char *)a2;
    v8 = "Instruction returns a non-scalar type!";
    v223 = 1;
LABEL_23:
    v220.m128i_i64[0] = (__int64)v8;
    v222 = 3;
    sub_BE0C10((_BYTE *)v2, (__int64)&v220, (_BYTE **)&v215);
    return;
  }
  if ( (*(_BYTE *)(a2 + 7) & 0x10) != 0 )
  {
    v215 = (const char *)a2;
    v8 = "Instruction has a name, but provides a void value!";
    v223 = 1;
    goto LABEL_23;
  }
LABEL_14:
  for ( i = *(_QWORD *)(a2 + 16); i; i = *(_QWORD *)(i + 8) )
  {
    v11 = *(_QWORD *)(i + 24);
    if ( *(_BYTE *)v11 <= 0x1Cu )
    {
      v223 = 1;
      v220.m128i_i64[0] = (__int64)"Use of instruction is not an instruction!";
      v222 = 3;
      sub_BDBF70((__int64 *)a1, (__int64)&v220);
      if ( *(_QWORD *)a1 && *(_QWORD *)i )
        sub_BDBD80(a1, *(_BYTE **)i);
      return;
    }
    if ( !*(_QWORD *)(v11 + 40) )
    {
      v223 = 1;
      v220.m128i_i64[0] = (__int64)"Instruction referencing instruction not embedded in a basic block!";
      v222 = 3;
      sub_BDBF70((__int64 *)a1, (__int64)&v220);
      if ( *(_QWORD *)a1 )
      {
        sub_BDBD80(a1, (_BYTE *)a2);
        sub_BDBD80(a1, (_BYTE *)v11);
      }
      return;
    }
  }
  v12 = 0;
  if ( (unsigned __int8)(v5 - 34) <= 0x33u && ((0x8000000000041uLL >> (v5 - 34)) & 1) != 0 )
    v12 = a2;
  v209 = *(_DWORD *)(a2 + 4) & 0x7FFFFFF;
  if ( !v209 )
    goto LABEL_51;
  v204 = v4;
  v206 = (__int64 *)(v12 - 32);
  v14 = 0;
  v15 = v12;
  v203 = a1 + 288;
  do
  {
    v16 = v14;
    if ( (*(_BYTE *)(a2 + 7) & 0x40) != 0 )
      v17 = *(_QWORD *)(a2 - 8);
    else
      v17 = a2 - 32LL * (*(_DWORD *)(a2 + 4) & 0x7FFFFFF);
    v18 = (__int64 *)(32 * v14 + v17);
    v19 = *v18;
    if ( !*v18 )
    {
      v223 = 1;
      v2 = a1;
      v8 = "Instruction has null operand!";
      v215 = (const char *)a2;
      goto LABEL_23;
    }
    v20 = *(_QWORD *)(v19 + 8);
    v21 = *(unsigned __int8 *)(v20 + 8);
    if ( v21 == 13 || v21 == 7 )
    {
      v223 = 1;
      v2 = a1;
      v8 = "Instruction operands must be first-class values!";
      v215 = (const char *)a2;
      goto LABEL_23;
    }
    v22 = *(_BYTE *)v19;
    if ( *(_BYTE *)v19 )
    {
      if ( v22 == 23 )
      {
        if ( *(_QWORD *)(v204 + 72) != *(_QWORD *)(v19 + 72) )
        {
          v223 = 1;
          v2 = a1;
          v8 = "Referring to a basic block in another function!";
          v215 = (const char *)a2;
          goto LABEL_23;
        }
      }
      else if ( v22 == 22 )
      {
        if ( *(_QWORD *)(v204 + 72) != *(_QWORD *)(v19 + 24) )
        {
          v223 = 1;
          v2 = a1;
          v8 = "Referring to an argument in another function!";
          v215 = (const char *)a2;
          goto LABEL_23;
        }
      }
      else if ( (unsigned __int8)(v22 - 1) > 2u )
      {
        if ( v22 <= 0x1Cu )
        {
          switch ( v22 )
          {
            case 0x19u:
              if ( !v15 || v18 != v206 )
              {
                v223 = 1;
                v2 = a1;
                v8 = "Cannot take the address of an inline asm!";
                v215 = (const char *)a2;
                goto LABEL_23;
              }
              break;
            case 8u:
              goto LABEL_131;
            case 5u:
              if ( (unsigned int)(v21 - 17) <= 1 )
                v20 = **(_QWORD **)(v20 + 16);
              if ( *(_BYTE *)(v20 + 8) == 14 )
LABEL_131:
                sub_BDC820(a1, v19);
              break;
          }
        }
        else
        {
          v49 = sub_B43CB0(v19);
          v50 = 32 * v14;
          if ( *(_QWORD *)(v204 + 72) != v49 )
          {
            v223 = 1;
            v2 = a1;
            v8 = "Referring to an instruction in another function!";
            v215 = (const char *)a2;
            goto LABEL_23;
          }
          v51 = *(unsigned __int8 *)(a2 + 7);
          if ( (v51 & 0x40) != 0 )
            v52 = *(_QWORD *)(a2 - 8);
          else
            v52 = a2 - 32LL * (*(_DWORD *)(a2 + 4) & 0x7FFFFFF);
          v53 = *(char **)(v52 + 32 * v14);
          if ( *v53 != 34 || *((_QWORD *)v53 - 12) != *((_QWORD *)v53 - 8) )
          {
            if ( *(_BYTE *)a2 == 84 )
              goto LABEL_114;
            if ( !*(_BYTE *)(a1 + 316) )
            {
              if ( sub_C8CA60(v203, *(_QWORD *)(v52 + 32 * v14), v51, 32 * v14) )
                goto LABEL_49;
              LOBYTE(v51) = *(_BYTE *)(a2 + 7);
              v50 = 32 * v14;
LABEL_114:
              if ( (v51 & 0x40) != 0 )
                v56 = *(_QWORD *)(a2 - 8);
              else
                v56 = a2 - 32LL * (*(_DWORD *)(a2 + 4) & 0x7FFFFFF);
              if ( !(unsigned __int8)sub_B19F20(a1 + 160, v53, v50 + v56) )
              {
                v57 = *(_QWORD *)a1;
                v223 = 1;
                v220.m128i_i64[0] = (__int64)"Instruction does not dominate all uses!";
                v222 = 3;
                if ( v57 )
                {
                  v202 = v57;
                  sub_CA0E80(&v220, v57);
                  v58 = *(_BYTE **)(v202 + 32);
                  if ( (unsigned __int64)v58 >= *(_QWORD *)(v202 + 24) )
                  {
                    sub_CB5D20(v202, 10);
                  }
                  else
                  {
                    *(_QWORD *)(v202 + 32) = v58 + 1;
                    *v58 = 10;
                  }
                }
                v48 = *(_QWORD *)a1 == 0;
                *(_BYTE *)(a1 + 152) = 1;
                if ( !v48 )
                {
                  sub_BDBD80(a1, v53);
                  sub_BDBD80(a1, (_BYTE *)a2);
                }
              }
              goto LABEL_49;
            }
            v54 = *(char ***)(a1 + 296);
            v55 = &v54[*(unsigned int *)(a1 + 308)];
            if ( v54 == v55 )
              goto LABEL_114;
            while ( v53 != *v54 )
            {
              if ( v55 == ++v54 )
                goto LABEL_114;
            }
          }
        }
      }
      else
      {
        v201 = *(_QWORD *)(v19 + 40);
        v43 = *(_QWORD *)(a1 + 8);
        if ( v43 != v201 )
        {
          v44 = a1;
          v45 = *(_QWORD *)a1;
          v46 = v43;
          v223 = 1;
          v222 = 3;
          v220.m128i_i64[0] = (__int64)"Referencing global in another module!";
          if ( v45 )
          {
            sub_CA0E80(&v220, v45);
            v47 = *(_BYTE **)(v45 + 32);
            if ( (unsigned __int64)v47 >= *(_QWORD *)(v45 + 24) )
            {
              sub_CB5D20(v45, 10);
            }
            else
            {
              *(_QWORD *)(v45 + 32) = v47 + 1;
              *v47 = 10;
            }
          }
          v48 = *(_QWORD *)v44 == 0;
          *(_BYTE *)(v44 + 152) = 1;
          if ( !v48 )
          {
            sub_BDBD80(v44, (_BYTE *)a2);
            sub_BD9A50(*(_QWORD *)v44, v46);
            sub_BDBD80(v44, (_BYTE *)v19);
            sub_BD9A50(*(_QWORD *)v44, v201);
          }
          return;
        }
      }
    }
    else
    {
      if ( (*(_BYTE *)(v19 + 33) & 0x20) != 0 )
      {
        if ( !v15 )
          goto LABEL_42;
        if ( v18 == v206 )
          goto LABEL_80;
        if ( !(unsigned int)sub_A172A0(v15) )
          goto LABEL_42;
        if ( *(char *)(v15 + 7) >= 0 )
          goto LABEL_127;
        if ( *(_DWORD *)(sub_BD2BC0(v15) + 8) > (unsigned int)v14 )
          goto LABEL_42;
        if ( *(char *)(v15 + 7) >= 0 )
LABEL_486:
          BUG();
        v37 = sub_BD2BC0(v15);
        if ( *(_DWORD *)(v37 + v38 - 4) <= (unsigned int)v14
          || (v16 = v14, *(_DWORD *)(*(_QWORD *)sub_B49810(v15, v14) + 8LL) != 6) )
        {
LABEL_42:
          v223 = 1;
          v2 = a1;
          v8 = "Cannot take the address of an intrinsic!";
          v215 = (const char *)a2;
          goto LABEL_23;
        }
        if ( (*(_BYTE *)(v19 + 33) & 0x20) != 0 )
        {
LABEL_80:
          if ( *(_BYTE *)a2 != 85 )
          {
            v39 = *(_DWORD *)(v19 + 36);
            v40 = v39 - 316;
            LOBYTE(v40) = (unsigned int)(v39 - 316) > 3;
            if ( (unsigned int)(v39 - 36) > 0x25 )
            {
              if ( (unsigned int)(v39 - 151) <= 0x14 )
                v40 &= ~(0x100061uLL >> ((unsigned __int8)v39 + 105));
            }
            else
            {
              v40 &= ~(unsigned int)(0x2000100027uLL >> ((unsigned __int8)v39 - 36));
            }
            if ( v39 != 14249 && v39 != 14230 && (_BYTE)v40 )
            {
              if ( *(char *)(v15 + 7) >= 0 )
                goto LABEL_88;
              v41 = sub_BD2BC0(v15);
              if ( *(char *)(v15 + 7) >= 0 )
              {
                v2 = a1;
                if ( (unsigned int)((v41 + v42) >> 4) )
LABEL_127:
                  BUG();
                goto LABEL_89;
              }
              if ( !(unsigned int)((v41 + v42 - sub_BD2BC0(v15)) >> 4) )
                goto LABEL_88;
              if ( *(char *)(v15 + 7) >= 0 )
                goto LABEL_127;
              if ( *(_DWORD *)(sub_BD2BC0(v15) + 8) > v16 )
                goto LABEL_88;
              if ( *(char *)(v15 + 7) >= 0 )
                goto LABEL_486;
              v23 = sub_BD2BC0(v15);
              if ( *(_DWORD *)(v23 + v24 - 4) <= v16 || *(_DWORD *)(*(_QWORD *)sub_B49810(v15, v16) + 8LL) != 6 )
              {
LABEL_88:
                v2 = a1;
LABEL_89:
                v215 = (const char *)a2;
                v8 = "Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume, coro_destroy,"
                     " clang.arc.attachedcall or wasm.(re)throw";
                v223 = 1;
                goto LABEL_23;
              }
            }
          }
        }
      }
      v25 = *(_QWORD *)(a1 + 8);
      if ( v25 != *(_QWORD *)(v19 + 40) )
      {
        v61 = *(_QWORD *)(v19 + 40);
        v223 = 1;
        v210 = v25;
        v220.m128i_i64[0] = (__int64)"Referencing function in another module!";
        v222 = 3;
        sub_BDBF70((__int64 *)a1, (__int64)&v220);
        if ( *(_QWORD *)a1 )
        {
          sub_BDBD80(a1, (_BYTE *)a2);
          sub_BD9A50(*(_QWORD *)a1, v210);
          sub_BDBD80(a1, (_BYTE *)v19);
          sub_BD9A50(*(_QWORD *)a1, v61);
        }
        return;
      }
    }
LABEL_49:
    ++v14;
  }
  while ( v209 != (_DWORD)v14 );
  v2 = a1;
LABEL_51:
  v26 = sub_BDB7A0(a2, 3);
  if ( v26 )
  {
    if ( !(unsigned __int8)sub_BDB700(*(_QWORD *)(a2 + 8)) )
    {
      v215 = (const char *)a2;
      v8 = "fpmath requires a floating point result!";
      v223 = 1;
      goto LABEL_23;
    }
    if ( (*(_BYTE *)(v26 - 16) & 2) != 0 )
      v27 = *(_DWORD *)(v26 - 24);
    else
      v27 = (*(_WORD *)(v26 - 16) >> 6) & 0xF;
    if ( v27 != 1 )
    {
      v215 = (const char *)a2;
      v8 = "fpmath takes one operand!";
      v223 = 1;
      goto LABEL_23;
    }
    v28 = v26 - 16;
    v29 = *(_QWORD *)sub_A17150((_BYTE *)(v26 - 16));
    if ( !v29 || *(_BYTE *)v29 != 1 || (v30 = *(_QWORD *)(v29 + 136), *(_BYTE *)v30 != 18) )
    {
      v215 = (const char *)a2;
      v8 = "invalid fpmath accuracy!";
      v223 = 1;
      goto LABEL_23;
    }
    v34 = sub_C33310(v28, 3);
    if ( v34 != *(_QWORD *)(v30 + 24) )
    {
      v215 = (const char *)a2;
      v8 = "fpmath accuracy must have float type";
      v223 = 1;
      goto LABEL_23;
    }
    v35 = v34 == sub_C33340(v28, 3, v31, v32, v33) ? *(_QWORD *)(v30 + 32) : v30 + 24;
    v36 = *(_BYTE *)(v35 + 20) & 7;
    if ( v36 <= 1u || v36 == 3 || (*(_BYTE *)(v35 + 20) & 8) != 0 )
    {
      v215 = (const char *)a2;
      v8 = "fpmath accuracy not a positive number!";
      v223 = 1;
      goto LABEL_23;
    }
  }
  v59 = (const char *)sub_BDB7A0(a2, 4);
  if ( v59 )
  {
    v60 = *(_BYTE *)a2 - 34;
    if ( v60 > 0x33u || ((0x8000008000001uLL >> v60) & 1) == 0 )
    {
      v215 = (const char *)a2;
      v8 = "Ranges are only for loads, calls and invokes!";
      v223 = 1;
      goto LABEL_23;
    }
    sub_BE8600((__int64 *)v2, (_BYTE *)a2, v59, *(_QWORD *)(a2 + 8), 0);
  }
  v62 = (const char *)sub_BDB7A0(a2, 41);
  if ( v62 )
  {
    if ( ((*(_BYTE *)a2 - 61) & 0xFA) != 0 && *(_BYTE *)a2 != 85 )
    {
      v215 = (const char *)a2;
      v8 = "noalias.addrspace are only for memory operations!";
      v223 = 1;
      goto LABEL_23;
    }
    sub_BE8600((__int64 *)v2, (_BYTE *)a2, v62, *(_QWORD *)(a2 + 8), 2);
  }
  if ( sub_BDB7A0(a2, 16) && (unsigned __int8)(*(_BYTE *)a2 - 61) > 1u )
  {
    v215 = (const char *)a2;
    v8 = "invariant.group metadata is only for loads and stores";
    v223 = 1;
    goto LABEL_23;
  }
  v63 = sub_BDB7A0(a2, 11);
  if ( v63 )
  {
    if ( *(_BYTE *)(*(_QWORD *)(a2 + 8) + 8LL) != 14 )
    {
      v215 = (const char *)a2;
      v8 = "nonnull applies only to pointer types";
      v223 = 1;
      goto LABEL_23;
    }
    if ( *(_BYTE *)a2 != 61 )
    {
      v215 = (const char *)a2;
      v8 = "nonnull applies only to load instructions, use attributes for calls or invokes";
      v223 = 1;
      goto LABEL_23;
    }
    if ( (*(_BYTE *)(v63 - 16) & 2) != 0 ? *(_DWORD *)(v63 - 24) : (*(_WORD *)(v63 - 16) >> 6) & 0xF )
    {
      v215 = (const char *)a2;
      v8 = "nonnull metadata must be empty";
      v223 = 1;
      goto LABEL_23;
    }
  }
  v65 = sub_BDB7A0(a2, 12);
  if ( v65 )
    sub_BE0D10((_BYTE *)v2, a2, v65);
  v66 = sub_BDB7A0(a2, 13);
  if ( v66 )
    sub_BE0D10((_BYTE *)v2, a2, v66);
  v67 = (const char *)sub_BDB7A0(a2, 1);
  if ( v67 )
    sub_BF6420((__int64 **)(v2 + 2000), (_BYTE *)a2, v67);
  v68 = (const char *)sub_BDB7A0(a2, 8);
  if ( v68 )
    sub_BECBF0((_BYTE *)v2, v68);
  v69 = (const char *)sub_BDB7A0(a2, 7);
  if ( v69 )
    sub_BECBF0((_BYTE *)v2, v69);
  v70 = (const char *)sub_BDB7A0(a2, 25);
  if ( v70 )
  {
    v215 = v70;
    v71 = *(v70 - 16);
    if ( (v71 & 2) != 0 )
    {
      if ( *((_DWORD *)v70 - 6) || (BYTE1(*(_QWORD *)v70) & 0x7F) != 1 )
      {
        v72 = *((_QWORD *)v70 - 4);
        v73 = *((unsigned int *)v70 - 6);
LABEL_164:
        v74 = (_QWORD **)(v72 + 8 * v73);
        v75 = (_QWORD **)v72;
        while ( v74 != v75 )
        {
          v76 = *v75;
          if ( (unsigned __int8)(*(_BYTE *)*v75 - 5) > 0x1Fu )
          {
            v77 = *(_QWORD *)v2;
            v223 = 1;
            v220.m128i_i64[0] = (__int64)"Access scope list must consist of MDNodes";
            v222 = 3;
            if ( v77 )
            {
              sub_CA0E80(&v220, v77);
              v78 = *(_BYTE **)(v77 + 32);
              if ( (unsigned __int64)v78 >= *(_QWORD *)(v77 + 24) )
              {
                sub_CB5D20(v77, 10);
              }
              else
              {
                *(_QWORD *)(v77 + 32) = v78 + 1;
                *v78 = 10;
              }
              v77 = *(_QWORD *)v2;
            }
            *(_BYTE *)(v2 + 152) = 1;
            if ( v77 && v215 )
            {
              sub_A62C00(v215, v77, v2 + 16, *(_QWORD *)(v2 + 8));
              v79 = *(_QWORD *)v2;
              v80 = *(_BYTE **)(*(_QWORD *)v2 + 32LL);
              if ( (unsigned __int64)v80 >= *(_QWORD *)(*(_QWORD *)v2 + 24LL) )
              {
                sub_CB5D20(v79, 10);
              }
              else
              {
                *(_QWORD *)(v79 + 32) = v80 + 1;
                *v80 = 10;
              }
            }
            break;
          }
          if ( (*(_BYTE *)(v76 - 2) & 2) != 0 )
            v199 = *((_DWORD *)v76 - 6);
          else
            v199 = (*((_WORD *)v76 - 8) >> 6) & 0xF;
          if ( !v199 )
          {
            ++v75;
            if ( (BYTE1(*v76) & 0x7F) == 1 )
              continue;
          }
          v223 = 1;
          v222 = 3;
          v220.m128i_i64[0] = (__int64)"Access scope list contains invalid access scope";
          sub_BE1BE0((_BYTE *)v2, (__int64)&v220, &v215);
          break;
        }
      }
    }
    else
    {
      v200 = *((_WORD *)v70 - 8);
      if ( (v200 & 0x3C0) != 0 || (BYTE1(*(_QWORD *)v70) & 0x7F) != 1 )
      {
        v73 = (v200 >> 6) & 0xF;
        v72 = (__int64)&v70[-8 * ((v71 >> 2) & 0xF) - 16];
        goto LABEL_164;
      }
    }
  }
  v81 = sub_BDB7A0(a2, 17);
  if ( v81 )
  {
    if ( *(_BYTE *)(*(_QWORD *)(a2 + 8) + 8LL) != 14 )
    {
      v215 = (const char *)a2;
      v8 = "align applies only to pointer types";
      v223 = 1;
      goto LABEL_23;
    }
    if ( *(_BYTE *)a2 != 61 )
    {
      v215 = (const char *)a2;
      v8 = "align applies only to load instructions, use attributes for calls or invokes";
      v223 = 1;
      goto LABEL_23;
    }
    if ( (*(_BYTE *)(v81 - 16) & 2) != 0 )
      v82 = *(_DWORD *)(v81 - 24);
    else
      v82 = (*(_WORD *)(v81 - 16) >> 6) & 0xF;
    if ( v82 != 1 )
    {
      v215 = (const char *)a2;
      v8 = "align takes one operand!";
      v223 = 1;
      goto LABEL_23;
    }
    v83 = *(_QWORD *)sub_A17150((_BYTE *)(v81 - 16));
    if ( *(_BYTE *)v83 != 1
      || (v84 = *(_QWORD *)(v83 + 136), *(_BYTE *)v84 != 17)
      || !sub_BCAC40(*(_QWORD *)(v84 + 8), 64) )
    {
      v215 = (const char *)a2;
      v8 = "align metadata value must be an i64!";
      v223 = 1;
      goto LABEL_23;
    }
    v85 = *(_QWORD *)(v84 + 24);
    if ( *(_DWORD *)(v84 + 32) > 0x40u )
      v85 = *(_QWORD *)v85;
    if ( !v85 || (v85 & (v85 - 1)) != 0 )
    {
      v215 = (const char *)a2;
      v8 = "align metadata value must be a power of 2!";
      v223 = 1;
      goto LABEL_23;
    }
    if ( v85 > 0x100000000LL )
    {
      v215 = (const char *)a2;
      v8 = "alignment is larger that implementation defined limit";
      v223 = 1;
      goto LABEL_23;
    }
  }
  v86 = (const char *)sub_BDB7A0(a2, 2);
  if ( v86 )
    sub_BED100((_BYTE *)v2, (char *)a2, v86);
  v87 = sub_BDB7A0(a2, 34);
  v88 = v87;
  if ( !v87 )
    goto LABEL_194;
  v214[0] = (const char *)v87;
  v89 = *(_BYTE *)a2 - 34;
  if ( v89 > 0x33u || ((0x8000000000041uLL >> v89) & 1) == 0 )
  {
    v223 = 1;
    v215 = (const char *)a2;
    v220.m128i_i64[0] = (__int64)"!memprof metadata should only exist on calls";
    v222 = 3;
    sub_BE0C10((_BYTE *)v2, (__int64)&v220, (_BYTE **)&v215);
    goto LABEL_194;
  }
  v147 = *(_BYTE *)(v87 - 16);
  if ( (v147 & 2) != 0 )
  {
    v87 = *(unsigned int *)(v87 - 24);
    if ( (_DWORD)v87 )
    {
      v148 = *(const char ***)(v88 - 32);
      goto LABEL_322;
    }
LABEL_412:
    v223 = 1;
    v220.m128i_i64[0] = (__int64)"!memprof annotations should have at least 1 metadata operand (MemInfoBlock)";
    v222 = 3;
    sub_BECB10((_BYTE *)v2, (__int64)&v220, v214);
    goto LABEL_194;
  }
  LOBYTE(v87) = (*(_WORD *)(v87 - 16) >> 6) & 0xF;
  if ( !(_BYTE)v87 )
    goto LABEL_412;
  v87 = (unsigned __int8)v87;
  v148 = (const char **)(v88 - 8LL * ((v147 >> 2) & 0xF) - 16);
LABEL_322:
  v149 = &v148[v87];
LABEL_323:
  if ( v149 == v148 )
    goto LABEL_194;
  v150 = *v148;
  if ( (unsigned __int8)(**v148 - 5) > 0x1Fu )
  {
    v215 = 0;
    BUG();
  }
  v215 = *v148;
  v151 = *(v150 - 16);
  if ( (v151 & 2) != 0 )
  {
    if ( *((_DWORD *)v150 - 6) <= 1u )
      goto LABEL_411;
    v152 = (const char **)*((_QWORD *)v150 - 4);
    v153 = *v152;
    if ( !*v152 )
    {
LABEL_410:
      v223 = 1;
      v179 = "!memprof MemInfoBlock first operand should not be null";
      goto LABEL_377;
    }
    goto LABEL_328;
  }
  if ( ((*((_WORD *)v150 - 8) >> 6) & 0xFu) > 1 )
  {
    v152 = (const char **)&v150[-16 - 8LL * ((v151 >> 2) & 0xF)];
    v153 = *v152;
    if ( !*v152 )
      goto LABEL_410;
LABEL_328:
    if ( (unsigned __int8)(*v153 - 5) > 0x1Fu )
    {
      v143 = *(_QWORD *)v2;
      v223 = 1;
      v220.m128i_i64[0] = (__int64)"!memprof MemInfoBlock first operand should be an MDNode";
      v222 = 3;
      if ( v143 )
      {
        sub_CA0E80(&v220, v143);
        v144 = *(_BYTE **)(v143 + 32);
        if ( (unsigned __int64)v144 >= *(_QWORD *)(v143 + 24) )
        {
          sub_CB5D20(v143, 10);
        }
        else
        {
          *(_QWORD *)(v143 + 32) = v144 + 1;
          *v144 = 10;
        }
        v143 = *(_QWORD *)v2;
      }
      *(_BYTE *)(v2 + 152) = 1;
      if ( v143 && v215 )
      {
        sub_A62C00(v215, v143, v2 + 16, *(_QWORD *)(v2 + 8));
        v145 = *(_QWORD *)v2;
        v146 = *(_BYTE **)(*(_QWORD *)v2 + 32LL);
        if ( (unsigned __int64)v146 >= *(_QWORD *)(*(_QWORD *)v2 + 24LL) )
        {
          sub_CB5D20(v145, 10);
        }
        else
        {
          *(_QWORD *)(v145 + 32) = v146 + 1;
          *v146 = 10;
        }
      }
      goto LABEL_194;
    }
    v154 = *v152;
    if ( (unsigned __int8)(**v152 - 5) >= 0x20u )
      v154 = 0;
    sub_BDA750(v2, v154);
    for ( j = 1; ; ++j )
    {
      v159 = *(v215 - 16);
      if ( (v159 & 2) != 0 )
      {
        v156 = *((_DWORD *)v215 - 6);
        if ( v156 <= j )
          goto LABEL_378;
        v157 = (const char *)*((_QWORD *)v215 - 4);
      }
      else
      {
        v156 = (*((_WORD *)v215 - 8) >> 6) & 0xF;
        if ( v156 <= j )
        {
LABEL_378:
          ++v148;
          goto LABEL_323;
        }
        v157 = &v215[-16 - 8LL * ((v159 >> 2) & 0xF)];
      }
      v158 = &v157[8 * j];
      if ( **(_BYTE **)v158 )
        break;
    }
    if ( j <= 1 )
    {
      v223 = 1;
      v179 = "!memprof MemInfoBlock second operand should be an MDString";
      goto LABEL_377;
    }
    while ( 2 )
    {
      if ( j >= v156 )
        goto LABEL_378;
      v178 = *(_BYTE **)v158;
      if ( (unsigned __int8)(**(_BYTE **)v158 - 5) > 0x1Fu )
      {
        v223 = 1;
        v179 = "Not all !memprof MemInfoBlock operands 2 to N are MDNode";
        goto LABEL_377;
      }
      v180 = *(v178 - 16);
      if ( (v180 & 2) != 0 )
      {
        if ( *((_DWORD *)v178 - 6) != 2 )
          goto LABEL_391;
        v181 = (_QWORD *)*((_QWORD *)v178 - 4);
      }
      else
      {
        if ( ((*((_WORD *)v178 - 8) >> 6) & 0xF) != 2 )
        {
LABEL_391:
          v223 = 1;
          v179 = "Not all !memprof MemInfoBlock operands 2 to N are MDNode with 2 operands";
          goto LABEL_377;
        }
        v181 = &v178[-16 - 8LL * ((v180 >> 2) & 0xF)];
      }
      v182 = v181 + 2;
      if ( *(_BYTE *)*v181 == 1 && **(_BYTE **)(*v181 + 136LL) == 17 )
      {
        v183 = v181 + 1;
        v184 = v181[1];
        if ( *(_BYTE *)v184 == 1 && **(_BYTE **)(v184 + 136) == 17 )
        {
LABEL_386:
          ++j;
          v158 += 8;
          continue;
        }
        v181 = v183;
      }
      break;
    }
    if ( v182 != v181 )
    {
      v223 = 1;
      v179 = "Not all !memprof MemInfoBlock operands 2 to N are MDNode with ConstantInt operands";
      goto LABEL_377;
    }
    goto LABEL_386;
  }
LABEL_411:
  v223 = 1;
  v179 = "Each !memprof MemInfoBlock should have at least 2 operands";
LABEL_377:
  v220.m128i_i64[0] = (__int64)v179;
  v222 = 3;
  sub_BECB10((_BYTE *)v2, (__int64)&v220, &v215);
LABEL_194:
  v90 = (const char *)sub_BDB7A0(a2, 35);
  if ( v90 )
  {
    v91 = *(_BYTE *)a2 - 34;
    if ( v91 <= 0x33u && ((0x8000000000041uLL >> v91) & 1) != 0 )
    {
      sub_BDA750(v2, v90);
      goto LABEL_204;
    }
    v92 = *(_QWORD *)v2;
    v223 = 1;
    v220.m128i_i64[0] = (__int64)"!callsite metadata should only exist on calls";
    v222 = 3;
    if ( v92 )
    {
      sub_CA0E80(&v220, v92);
      v93 = *(_BYTE **)(v92 + 32);
      if ( (unsigned __int64)v93 >= *(_QWORD *)(v92 + 24) )
      {
        sub_CB5D20(v92, 10);
      }
      else
      {
        *(_QWORD *)(v92 + 32) = v93 + 1;
        *v93 = 10;
      }
      v92 = *(_QWORD *)v2;
    }
    *(_BYTE *)(v2 + 152) = 1;
    if ( v92 )
    {
      if ( *(_BYTE *)a2 <= 0x1Cu )
      {
        sub_A5C020((_BYTE *)a2, v92, 1, v2 + 16);
        v94 = *(_QWORD *)v2;
        v95 = *(_BYTE **)(*(_QWORD *)v2 + 32LL);
        if ( (unsigned __int64)v95 < *(_QWORD *)(*(_QWORD *)v2 + 24LL) )
          goto LABEL_203;
      }
      else
      {
        sub_A693B0(a2, (_BYTE *)v92, v2 + 16, 0);
        v94 = *(_QWORD *)v2;
        v95 = *(_BYTE **)(*(_QWORD *)v2 + 32LL);
        if ( (unsigned __int64)v95 < *(_QWORD *)(*(_QWORD *)v2 + 24LL) )
        {
LABEL_203:
          *(_QWORD *)(v94 + 32) = v95 + 1;
          *v95 = 10;
          goto LABEL_204;
        }
      }
      sub_CB5D20(v94, 10);
    }
  }
LABEL_204:
  v96 = sub_BDB7A0(a2, 38);
  if ( v96 )
  {
    if ( (*(_BYTE *)a2 & 0xFD) == 0x3C
      || *(_BYTE *)a2 == 85
      && (v160 = *(_QWORD *)(a2 - 32)) != 0
      && !*(_BYTE *)v160
      && *(_QWORD *)(v160 + 24) == *(_QWORD *)(a2 + 80)
      && (*(_BYTE *)(v160 + 33) & 0x20) != 0
      && (unsigned int)(*(_DWORD *)(v160 + 36) - 238) <= 7
      && ((1LL << (*(_BYTE *)(v160 + 36) + 18)) & 0xAD) != 0 )
    {
      v161 = sub_B9F8A0(*(__int64 **)(v2 + 144), (_BYTE *)v96);
      if ( v161 )
      {
        v162 = v2;
        v163 = (const char *)v96;
        for ( k = *(_QWORD *)(v161 + 16); ; k = *(_QWORD *)(k + 8) )
        {
          if ( !k )
          {
            v96 = (__int64)v163;
            v2 = v162;
            goto LABEL_362;
          }
          v165 = *(_QWORD *)(k + 24);
          if ( *(_BYTE *)v165 != 85 )
            break;
          v169 = *(_QWORD *)(v165 - 32);
          if ( !v169
            || *(_BYTE *)v169
            || *(_QWORD *)(v169 + 24) != *(_QWORD *)(v165 + 80)
            || (*(_BYTE *)(v169 + 33) & 0x20) == 0
            || *(_DWORD *)(v169 + 36) != 68 )
          {
            break;
          }
          v207 = sub_B43CB0(*(_QWORD *)(k + 24));
          if ( v207 != sub_B43CB0(a2) )
          {
            v2 = v162;
            v223 = 1;
            v220.m128i_i64[0] = (__int64)"dbg.assign not in same function as inst";
            v222 = 3;
            sub_BDD6D0((__int64 *)v162, (__int64)&v220);
            if ( *(_QWORD *)v162 )
            {
              sub_BDBD80(v162, (_BYTE *)v165);
              sub_BDBD80(v162, (_BYTE *)a2);
            }
            goto LABEL_209;
          }
        }
        v166 = v163;
        v2 = v162;
        v223 = 1;
        v167 = *(_QWORD *)v162;
        v220.m128i_i64[0] = (__int64)"!DIAssignID should only be used by llvm.dbg.assign intrinsics";
        v222 = 3;
        if ( v167 )
        {
          v213 = v167;
          sub_CA0E80(&v220, v167);
          v168 = *(_BYTE **)(v213 + 32);
          if ( (unsigned __int64)v168 >= *(_QWORD *)(v213 + 24) )
          {
            sub_CB5D20(v213, 10);
          }
          else
          {
            *(_QWORD *)(v213 + 32) = v168 + 1;
            *v168 = 10;
          }
        }
        *(_BYTE *)(v162 + 152) |= *(_BYTE *)(v162 + 154);
        v48 = *(_QWORD *)v162 == 0;
        *(_BYTE *)(v162 + 153) = 1;
        if ( !v48 )
        {
          sub_BD9900((__int64 *)v162, v166);
          sub_BDBD80(v162, (_BYTE *)v165);
        }
      }
      else
      {
LABEL_362:
        v170 = *(_QWORD *)(v96 + 8);
        if ( (v170 & 4) != 0 )
          v171 = v170 & 0xFFFFFFFFFFFFFFF8LL;
        else
          v171 = 0;
        sub_B967C0(&v220, (__m128i *)v171);
        v172 = (__int64 *)v2;
        v173 = (const char *)v96;
        v174 = v220.m128i_i64[0];
        v208 = v220.m128i_i64[0] + 8LL * v220.m128i_u32[2];
        while ( 1 )
        {
          if ( v208 == v174 )
          {
            v177 = v220.m128i_i64[0];
            v2 = (__int64)v172;
            if ( (_BYTE *)v220.m128i_i64[0] == v221 )
              goto LABEL_209;
            goto LABEL_399;
          }
          v175 = *(_QWORD *)v174;
          if ( *(_BYTE *)(*(_QWORD *)v174 + 64LL) != 2 )
            break;
          v176 = *(_QWORD *)v174;
          v174 += 8;
          v205 = sub_B141A0(v176);
          if ( v205 != sub_B43CB0(a2) )
          {
            v2 = (__int64)v172;
            v219 = 1;
            v215 = "DVRAssign not in same function as inst";
            v218 = 3;
            sub_BDD6D0(v172, (__int64)&v215);
            v171 = *v172;
            if ( *v172 )
            {
              sub_B123F0(v175, v171, (__int64)(v172 + 2), 0);
              v185 = *v172;
              v186 = *(_BYTE **)(*v172 + 32);
              if ( (unsigned __int64)v186 >= *(_QWORD *)(*v172 + 24) )
              {
                sub_CB5D20(v185, 10);
              }
              else
              {
                *(_QWORD *)(v185 + 32) = v186 + 1;
                *v186 = 10;
              }
              v171 = a2;
              sub_BDBD80((__int64)v172, (_BYTE *)a2);
            }
            goto LABEL_398;
          }
        }
        v187 = v173;
        v2 = (__int64)v172;
        v219 = 1;
        v171 = (unsigned __int64)&v215;
        v215 = "!DIAssignID should only be used by Assign DVRs.";
        v218 = 3;
        sub_BDD6D0(v172, (__int64)&v215);
        if ( *v172 )
        {
          sub_BD9900(v172, v187);
          v171 = *v172;
          sub_B123F0(v175, *v172, (__int64)(v172 + 2), 0);
          v188 = *v172;
          v189 = *(_BYTE **)(*v172 + 32);
          if ( (unsigned __int64)v189 >= *(_QWORD *)(*v172 + 24) )
          {
            v171 = 10;
            sub_CB5D20(v188, 10);
          }
          else
          {
            *(_QWORD *)(v188 + 32) = v189 + 1;
            *v189 = 10;
          }
        }
LABEL_398:
        v177 = v220.m128i_i64[0];
        if ( (_BYTE *)v220.m128i_i64[0] == v221 )
          goto LABEL_209;
LABEL_399:
        _libc_free(v177, v171);
      }
    }
    else
    {
      v223 = 1;
      v220.m128i_i64[0] = (__int64)"!DIAssignID attached to unexpected instruction kind";
      v222 = 3;
      sub_BDD6D0((__int64 *)v2, (__int64)&v220);
      if ( *(_QWORD *)v2 )
      {
        sub_BDBD80(v2, (_BYTE *)a2);
        sub_BD9900((__int64 *)v2, (const char *)v96);
      }
    }
  }
LABEL_209:
  v97 = (char *)sub_BDB7A0(a2, 40);
  if ( v97 )
  {
    if ( (unsigned __int8)sub_B8D5C0((unsigned __int8 *)a2) )
    {
      if ( !sub_B8D4C0(v97) )
      {
        if ( *v97 == 5 )
        {
          v98 = *(v97 - 16);
          if ( (v98 & 2) != 0 )
          {
            v99 = *((_QWORD *)v97 - 4);
            v100 = *((unsigned int *)v97 - 6);
          }
          else
          {
            v100 = (*((_WORD *)v97 - 8) >> 6) & 0xF;
            v99 = (__int64)&v97[-8 * ((v98 >> 2) & 0xF) - 16];
          }
          v101 = (const char **)v99;
          v211 = (const char **)(v99 + 8 * v100);
          while ( 1 )
          {
            v103 = v101;
            if ( v211 == v101 )
              break;
            v102 = *v101++;
            if ( !sub_B8D4C0(v102) )
            {
              v104 = *(_QWORD *)v2;
              v105 = *v103;
              v223 = 1;
              v220.m128i_i64[0] = (__int64)"!mmra metadata tuple operand is not an MMRA tag";
              v222 = 3;
              if ( v104 )
              {
                sub_CA0E80(&v220, v104);
                v106 = *(_BYTE **)(v104 + 32);
                if ( (unsigned __int64)v106 >= *(_QWORD *)(v104 + 24) )
                {
                  sub_CB5D20(v104, 10);
                }
                else
                {
                  *(_QWORD *)(v104 + 32) = v106 + 1;
                  *v106 = 10;
                }
              }
              v48 = *(_QWORD *)v2 == 0;
              *(_BYTE *)(v2 + 152) = 1;
              if ( !v48 )
              {
                sub_BDBD80(v2, (_BYTE *)a2);
                if ( v105 )
                  sub_BD9900((__int64 *)v2, v105);
              }
              break;
            }
          }
        }
        else
        {
          v197 = *(_QWORD *)v2;
          v223 = 1;
          v220.m128i_i64[0] = (__int64)"!mmra expected to be a metadata tuple";
          v222 = 3;
          if ( v197 )
          {
            sub_CA0E80(&v220, v197);
            v198 = *(_BYTE **)(v197 + 32);
            if ( (unsigned __int64)v198 >= *(_QWORD *)(v197 + 24) )
            {
              sub_CB5D20(v197, 10);
            }
            else
            {
              *(_QWORD *)(v197 + 32) = v198 + 1;
              *v198 = 10;
            }
          }
          v48 = *(_QWORD *)v2 == 0;
          *(_BYTE *)(v2 + 152) = 1;
          if ( !v48 )
          {
            sub_BDBD80(v2, (_BYTE *)a2);
            sub_BD9900((__int64 *)v2, v97);
          }
        }
      }
    }
    else
    {
      v193 = *(_QWORD *)v2;
      v223 = 1;
      v220.m128i_i64[0] = (__int64)"!mmra metadata attached to unexpected instruction kind";
      v222 = 3;
      if ( v193 )
      {
        sub_CA0E80(&v220, v193);
        v194 = *(_BYTE **)(v193 + 32);
        if ( (unsigned __int64)v194 >= *(_QWORD *)(v193 + 24) )
        {
          sub_CB5D20(v193, 10);
        }
        else
        {
          *(_QWORD *)(v193 + 32) = v194 + 1;
          *v194 = 10;
        }
      }
      v48 = *(_QWORD *)v2 == 0;
      *(_BYTE *)(v2 + 152) = 1;
      if ( !v48 )
      {
        sub_BDBD80(v2, (_BYTE *)a2);
        sub_A62C00(v97, *(_QWORD *)v2, v2 + 16, *(_QWORD *)(v2 + 8));
        v195 = *(_QWORD *)v2;
        v196 = *(_BYTE **)(*(_QWORD *)v2 + 32LL);
        if ( (unsigned __int64)v196 >= *(_QWORD *)(*(_QWORD *)v2 + 24LL) )
        {
          sub_CB5D20(v195, 10);
        }
        else
        {
          *(_QWORD *)(v195 + 32) = v196 + 1;
          *v196 = 10;
        }
      }
    }
  }
  v107 = sub_BDB7A0(a2, 30);
  v108 = v107;
  if ( !v107 )
    goto LABEL_261;
  if ( *(_BYTE *)v107 != 5 )
  {
    v223 = 1;
    v121 = "annotation must be a tuple";
    goto LABEL_257;
  }
  v109 = *(_BYTE *)(v107 - 16);
  if ( (v109 & 2) == 0 )
  {
    LOBYTE(v107) = (*(_WORD *)(v107 - 16) >> 6) & 0xF;
    if ( !(_BYTE)v107 )
      goto LABEL_415;
    v107 = (unsigned __int8)v107;
    v110 = (char **)(v108 - 8LL * ((v109 >> 2) & 0xF) - 16);
LABEL_234:
    v111 = &v110[v107];
    while ( 1 )
    {
      if ( v111 == v110 )
        goto LABEL_261;
      v112 = *v110;
      v113 = **v110;
      if ( v113 != 5 )
      {
        if ( v113 )
          goto LABEL_256;
        goto LABEL_236;
      }
      v114 = *(v112 - 16);
      if ( (v114 & 2) != 0 )
      {
        v115 = (char *)*((_QWORD *)v112 - 4);
        v116 = *((unsigned int *)v112 - 6);
      }
      else
      {
        v116 = (*((_WORD *)v112 - 8) >> 6) & 0xF;
        v115 = &v112[-8 * ((v114 >> 2) & 0xF) - 16];
      }
      v117 = 8 * v116;
      v118 = &v115[v117];
      for ( m = v117 >> 5; m; --m )
      {
        if ( **(_BYTE **)v115 )
          goto LABEL_255;
        if ( **((_BYTE **)v115 + 1) )
        {
          v115 += 8;
          goto LABEL_255;
        }
        if ( **((_BYTE **)v115 + 2) )
        {
          v115 += 16;
          goto LABEL_255;
        }
        if ( **((_BYTE **)v115 + 3) )
        {
          v115 += 24;
          goto LABEL_255;
        }
        v115 += 32;
      }
      v120 = v118 - v115;
      if ( v118 - v115 != 16 )
      {
        if ( v120 != 24 )
        {
          if ( v120 != 8 )
            goto LABEL_236;
          goto LABEL_251;
        }
        if ( **(_BYTE **)v115 )
          goto LABEL_255;
        v115 += 8;
      }
      if ( **(_BYTE **)v115 )
        goto LABEL_255;
      v115 += 8;
LABEL_251:
      if ( !**(_BYTE **)v115 )
        goto LABEL_236;
LABEL_255:
      if ( v118 != v115 )
      {
LABEL_256:
        v223 = 1;
        v121 = "operands must be a string or a tuple of strings";
        goto LABEL_257;
      }
LABEL_236:
      ++v110;
    }
  }
  v107 = *(unsigned int *)(v107 - 24);
  if ( (_DWORD)v107 )
  {
    v110 = *(char ***)(v108 - 32);
    goto LABEL_234;
  }
LABEL_415:
  v223 = 1;
  v121 = "annotation must have at least one operand";
LABEL_257:
  v122 = *(_QWORD *)v2;
  v220.m128i_i64[0] = (__int64)v121;
  v222 = 3;
  if ( v122 )
  {
    sub_CA0E80(&v220, v122);
    v123 = *(_BYTE **)(v122 + 32);
    if ( (unsigned __int64)v123 >= *(_QWORD *)(v122 + 24) )
    {
      sub_CB5D20(v122, 10);
    }
    else
    {
      *(_QWORD *)(v122 + 32) = v123 + 1;
      *v123 = 10;
    }
  }
  *(_BYTE *)(v2 + 152) = 1;
LABEL_261:
  v124 = *(const char **)(a2 + 48);
  v214[0] = v124;
  if ( v124 )
  {
    if ( *v124 != 6 )
    {
      v223 = 1;
      v215 = (const char *)a2;
      v220.m128i_i64[0] = (__int64)"invalid !dbg metadata attachment";
      v222 = 3;
      sub_BEF7C0((__int64 *)v2, (__int64)&v220, (_BYTE **)&v215, v214);
      return;
    }
    sub_BE3890(v2, (__int64)v124, 1u);
  }
  if ( sub_BDBCD0(a2) )
  {
    v125 = *(_DWORD *)(a2 + 4);
    v126 = v125 & 0x7FFFFFF;
    v127 = *(_BYTE **)(*(_QWORD *)(a2 + 32 * (1 - v126)) + 24LL);
    v212 = (__int64)v127;
    if ( v127 && *v127 != 26 )
      v212 = 0;
    v128 = *(_QWORD *)(a2 + 32 * (2 - v126));
    v129 = *(_QWORD *)(v128 + 24);
    if ( v129 && *(_BYTE *)v129 == 7 && v212 )
    {
      if ( sub_AF4230(*(_QWORD *)(v128 + 24)) )
      {
        sub_AF47B0((__int64)&v215, *(unsigned __int64 **)(v129 + 16), *(unsigned __int64 **)(v129 + 24));
        if ( v217 )
        {
          if ( (*(_BYTE *)(v212 + 24) & 0x40) == 0 )
          {
            v130 = (unsigned int)v215;
            v131 = v216;
            v132 = (const char *)sub_AF3FE0(v212);
            v214[1] = v133;
            v214[0] = v132;
            if ( (_BYTE)v133 )
            {
              if ( v214[0] < (const char *)(v130 + v131) )
              {
                v223 = 1;
                v190 = "fragment is larger than or outside of variable";
              }
              else
              {
                if ( v214[0] != (const char *)v130 )
                  goto LABEL_286;
                v223 = 1;
                v190 = "fragment covers entire variable";
              }
              v191 = *(_QWORD *)v2;
              v220.m128i_i64[0] = (__int64)v190;
              v222 = 3;
              if ( v191 )
              {
                sub_CA0E80(&v220, v191);
                v192 = *(_BYTE **)(v191 + 32);
                if ( (unsigned __int64)v192 >= *(_QWORD *)(v191 + 24) )
                {
                  sub_CB5D20(v191, 10);
                }
                else
                {
                  *(_QWORD *)(v191 + 32) = v192 + 1;
                  *v192 = 10;
                }
              }
              *(_BYTE *)(v2 + 152) |= *(_BYTE *)(v2 + 154);
              v48 = *(_QWORD *)v2 == 0;
              *(_BYTE *)(v2 + 153) = 1;
              if ( !v48 )
              {
                sub_BDBD80(v2, (_BYTE *)a2);
                sub_BD9900((__int64 *)v2, (const char *)v212);
              }
            }
          }
        }
      }
LABEL_286:
      v125 = *(_DWORD *)(a2 + 4);
    }
    v134 = *(_QWORD *)(a2 + 32 * (2LL - (v125 & 0x7FFFFFF)));
    v135 = *(_BYTE **)(v134 + 24);
    if ( v135 )
    {
      if ( *v135 == 7 && sub_AF4230(*(_QWORD *)(v134 + 24)) )
      {
        if ( (unsigned int)**(unsigned __int8 **)(*(_QWORD *)(a2 - 32LL * (*(_DWORD *)(a2 + 4) & 0x7FFFFFF)) + 24LL) - 1 > 1
          || (v136 = (unsigned __int8 *)sub_B58EB0(a2, 0), v137 = *v136, (unsigned int)(v137 - 12) > 1)
          && ((_BYTE)v137 != 22 || !(unsigned __int8)sub_B2D670((__int64)v136, 73)) )
        {
          if ( sub_AF46F0((__int64)v135) )
          {
            v223 = 1;
            v220.m128i_i64[0] = (__int64)"Entry values are only allowed in MIR unless they target a swiftasync Argument";
            v222 = 3;
            sub_BDD6D0((__int64 *)v2, (__int64)&v220);
            if ( *(_QWORD *)v2 )
              sub_BDBD80(v2, (_BYTE *)a2);
          }
        }
      }
    }
  }
  v220.m128i_i64[0] = (__int64)v221;
  v48 = *(_QWORD *)(a2 + 48) == 0;
  v220.m128i_i64[1] = 0x400000000LL;
  if ( !v48 || (*(_BYTE *)(a2 + 7) & 0x20) != 0 )
    sub_B9AA80(a2, (__int64)&v220);
  v138 = v220.m128i_i64[0];
  v139 = v220.m128i_i64[0] + 16LL * v220.m128i_u32[2];
  while ( v138 != v139 )
  {
    v140 = *(_QWORD *)(v138 + 8);
    v141 = *(_DWORD *)v138 == 0;
    v142 = *(_DWORD *)v138 == 18;
    v138 += 16;
    sub_BE3890(v2, v140, v142 || v141);
  }
  sub_BED950((__int64)&v215, v2 + 288, a2);
  if ( (_BYTE *)v220.m128i_i64[0] != v221 )
    _libc_free(v220.m128i_i64[0], v2 + 288);
}
