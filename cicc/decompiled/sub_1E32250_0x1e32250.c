// Function: sub_1E32250
// Address: 0x1e32250
//
void __fastcall sub_1E32250(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        char a5,
        char a6,
        char a7,
        unsigned int a8,
        __int64 a9,
        __int64 a10)
{
  __int64 v11; // r13
  int v14; // r9d
  __int64 v15; // rsi
  _BYTE *v16; // r12
  char **v17; // rdi
  __int64 v18; // rdx
  void (__fastcall *v19)(_BYTE *, _BYTE *, __int64); // rax
  char *v20; // rdx
  unsigned int v21; // r12d
  unsigned __int64 v22; // rax
  __int64 v23; // rdi
  _BYTE *v24; // rax
  _QWORD *v25; // rdx
  _BYTE *v26; // rdi
  unsigned int v27; // r14d
  int v28; // ebx
  __int64 v29; // r9
  __int64 v30; // rdi
  __int64 v31; // rax
  _QWORD *v32; // rdx
  void *v33; // rdx
  __int64 v34; // rcx
  _WORD *v35; // rdx
  void *v36; // rdx
  __int64 v37; // r8
  __int64 v38; // r14
  __int64 v39; // rsi
  __int64 v40; // rdx
  __int64 v41; // rcx
  int v42; // r12d
  _BYTE *v43; // rax
  const char *v44; // r14
  size_t v45; // r12
  _BYTE *v46; // rax
  _WORD *v47; // rdx
  __m128i *v48; // rdx
  __int64 v49; // rcx
  unsigned __int64 v50; // rax
  __int64 v51; // rcx
  __int64 v52; // rcx
  _DWORD *v53; // r8
  _DWORD *v54; // r15
  _QWORD *v55; // rdx
  __int64 v56; // r15
  int v57; // r12d
  unsigned int v58; // ebx
  char v59; // dl
  int v60; // eax
  _WORD *v61; // rdx
  char v62; // al
  int v63; // r12d
  char *v64; // rsi
  size_t v65; // rdx
  _QWORD *v66; // rax
  unsigned __int8 v67; // al
  bool v68; // dl
  char v69; // al
  _QWORD *v70; // r8
  unsigned __int64 v71; // rcx
  int v72; // edx
  unsigned __int64 v73; // rsi
  unsigned __int64 v74; // rax
  __int64 v75; // r8
  __int64 v76; // rdx
  __int64 v77; // rax
  size_t v78; // rax
  char *v79; // rsi
  void *v80; // rdi
  _BYTE *v81; // rax
  _BYTE *v82; // rdx
  _BYTE *v83; // rax
  int v84; // r14d
  char *v85; // r12
  size_t v86; // rdx
  __int64 v87; // rax
  size_t v88; // rax
  char *v89; // rax
  size_t v90; // rdx
  _BYTE *v91; // rdi
  char *v92; // rsi
  unsigned __int64 v93; // rax
  size_t v94; // r12
  __int64 v95; // rdx
  __int64 v96; // rdi
  __int64 v97; // rcx
  void *v98; // rdx
  __int64 v99; // rax
  __int64 v100; // rax
  __int64 v101; // rax
  __int64 (*v102)(); // rax
  int v103; // ebx
  __int64 v104; // rdi
  __int64 (*v105)(); // rax
  _BYTE *v106; // rdi
  char *v107; // rsi
  size_t v108; // r12
  __int64 v109; // rax
  __int64 v110; // r8
  unsigned __int64 v111; // rax
  __int64 v112; // rsi
  __int64 v113; // rsi
  __int64 v114; // rsi
  _WORD *v115; // rdx
  __m128i v116; // xmm0
  __int64 v117; // rsi
  __int64 v118; // rsi
  __int64 v119; // rax
  __int64 v120; // r14
  char v121; // al
  __int64 v122; // rax
  __m128i si128; // xmm0
  __int64 v124; // rsi
  _WORD *v125; // rdx
  _BYTE *v126; // rax
  __int64 v127; // rax
  __int64 v128; // rdx
  __int64 v129; // rsi
  __int64 v130; // rcx
  __int64 v131; // rdx
  __int64 v132; // rsi
  __int64 v133; // rdx
  size_t v134; // rax
  size_t v135; // rdx
  _DWORD *v136; // rdx
  void *v137; // rdx
  __int64 v138; // rax
  __int64 v139; // rax
  __int64 v140; // rax
  __int64 v141; // rdx
  __int64 v142; // rax
  __int64 v143; // rax
  _BYTE *v144; // rax
  __int64 v145; // rdx
  void *v146; // rdx
  void *v147; // rdx
  __int64 v148; // rax
  __int64 v149; // rdx
  __int64 v150; // rdx
  __int64 v151; // rdx
  __int64 v152; // rdx
  unsigned int v153; // ecx
  __int64 v154; // rsi
  const char *v155; // rax
  size_t v156; // rdx
  __int64 v157; // rdi
  _BYTE *v158; // rax
  __int64 v159; // rdx
  __int64 v160; // rdi
  __int64 v161; // rax
  unsigned __int64 v162; // rdi
  char *v163; // rax
  char *v164; // rsi
  unsigned int v165; // eax
  unsigned int v166; // eax
  unsigned int v167; // ecx
  __int64 v168; // r8
  void *v169; // rdx
  __int64 v170; // rdi
  __int64 v171; // rdi
  _BYTE *v172; // rax
  __int64 v173; // rax
  char v174; // al
  __int64 v175; // rax
  _WORD *v176; // rdx
  __int64 v177; // [rsp+8h] [rbp-128h]
  char *src; // [rsp+10h] [rbp-120h]
  size_t srca; // [rsp+10h] [rbp-120h]
  __int64 v180; // [rsp+18h] [rbp-118h]
  __int64 v181; // [rsp+18h] [rbp-118h]
  int v182; // [rsp+18h] [rbp-118h]
  __int16 v183; // [rsp+18h] [rbp-118h]
  unsigned int v185; // [rsp+20h] [rbp-110h]
  __int64 v186; // [rsp+20h] [rbp-110h]
  __int64 v187; // [rsp+20h] [rbp-110h]
  const char *v188; // [rsp+20h] [rbp-110h]
  __int64 v189; // [rsp+20h] [rbp-110h]
  __int64 v190; // [rsp+20h] [rbp-110h]
  __int64 v191; // [rsp+28h] [rbp-108h] BYREF
  _BYTE v192[16]; // [rsp+30h] [rbp-100h] BYREF
  void (__fastcall *v193)(_BYTE *, _BYTE *, __int64); // [rsp+40h] [rbp-F0h]
  void (__fastcall *v194)(_BYTE *, __int64); // [rsp+48h] [rbp-E8h]
  _BYTE v195[16]; // [rsp+50h] [rbp-E0h] BYREF
  void (__fastcall *v196)(_BYTE *, _BYTE *, __int64); // [rsp+60h] [rbp-D0h]
  void (__fastcall *v197)(_BYTE *, __int64); // [rsp+68h] [rbp-C8h]
  _QWORD v198[2]; // [rsp+70h] [rbp-C0h] BYREF
  void (__fastcall *v199)(_BYTE *, _BYTE *, __int64); // [rsp+80h] [rbp-B0h]
  void (__fastcall *v200)(_QWORD *, __int64); // [rsp+88h] [rbp-A8h]
  _BYTE v201[16]; // [rsp+90h] [rbp-A0h] BYREF
  void (__fastcall *v202)(_BYTE *, _BYTE *, __int64); // [rsp+A0h] [rbp-90h]
  void (__fastcall *v203)(_BYTE *, __int64); // [rsp+A8h] [rbp-88h]
  _BYTE v204[16]; // [rsp+B0h] [rbp-80h] BYREF
  void (__fastcall *v205)(_BYTE *, _BYTE *, __int64); // [rsp+C0h] [rbp-70h]
  void (__fastcall *v206)(_BYTE *, __int64); // [rsp+C8h] [rbp-68h]
  char *v207; // [rsp+D0h] [rbp-60h] BYREF
  const char *v208; // [rsp+D8h] [rbp-58h]
  _QWORD v209[10]; // [rsp+E0h] [rbp-50h] BYREF

  v11 = a2;
  v191 = a4;
  sub_1E318F0(a2, a1);
  switch ( *(_BYTE *)a1 )
  {
    case 0:
      v62 = *(_BYTE *)(a1 + 3);
      v63 = *(_DWORD *)(a1 + 8);
      if ( (v62 & 0x20) != 0 )
      {
        v64 = "implicit ";
        if ( (v62 & 0x10) != 0 )
          v64 = "implicit-def ";
        v65 = strlen(v64);
        v66 = *(_QWORD **)(v11 + 24);
        if ( v65 > *(_QWORD *)(v11 + 16) - (_QWORD)v66 )
          goto LABEL_89;
        *v66 = *(_QWORD *)v64;
        *(_QWORD *)((char *)v66 + (unsigned int)v65 - 8) = *(_QWORD *)&v64[(unsigned int)v65 - 8];
        v162 = (unsigned __int64)(v66 + 1) & 0xFFFFFFFFFFFFFFF8LL;
        v163 = (char *)v66 - v162;
        v164 = (char *)(v64 - v163);
        v165 = (v65 + (_DWORD)v163) & 0xFFFFFFF8;
        if ( v165 >= 8 )
        {
          v166 = v165 & 0xFFFFFFF8;
          v167 = 0;
          do
          {
            v168 = v167;
            v167 += 8;
            *(_QWORD *)(v162 + v168) = *(_QWORD *)&v164[v168];
          }
          while ( v167 < v166 );
        }
        *(_QWORD *)(v11 + 24) += v65;
      }
      else if ( a5 && (v62 & 0x10) != 0 )
      {
        v136 = *(_DWORD **)(a2 + 24);
        if ( *(_QWORD *)(a2 + 16) - (_QWORD)v136 <= 3u )
        {
          v65 = 4;
          v64 = "def ";
LABEL_89:
          sub_16E7EE0(v11, v64, v65);
          goto LABEL_90;
        }
        *v136 = 543581540;
        *(_QWORD *)(a2 + 24) += 4LL;
      }
LABEL_90:
      if ( (*(_BYTE *)(a1 + 4) & 2) != 0 )
      {
        v152 = *(_QWORD *)(v11 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v11 + 16) - v152) <= 8 )
        {
          sub_16E7EE0(v11, "internal ", 9u);
        }
        else
        {
          *(_BYTE *)(v152 + 8) = 32;
          *(_QWORD *)v152 = 0x6C616E7265746E69LL;
          *(_QWORD *)(v11 + 24) += 9LL;
        }
      }
      v67 = *(_BYTE *)(a1 + 3);
      v68 = (v67 & 0x40) != 0;
      if ( (v68 & (v67 >> 4)) != 0 )
      {
        v151 = *(_QWORD *)(v11 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v11 + 16) - v151) <= 4 )
        {
          sub_16E7EE0(v11, "dead ", 5u);
        }
        else
        {
          *(_DWORD *)v151 = 1684104548;
          *(_BYTE *)(v151 + 4) = 32;
          *(_QWORD *)(v11 + 24) += 5LL;
        }
        v67 = *(_BYTE *)(a1 + 3);
        v68 = (v67 & 0x40) != 0;
      }
      if ( (v68 & ((v67 >> 4) ^ 1) & 1) != 0 )
      {
        v150 = *(_QWORD *)(v11 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v11 + 16) - v150) <= 6 )
        {
          sub_16E7EE0(v11, "killed ", 7u);
        }
        else
        {
          *(_DWORD *)v150 = 1819044203;
          *(_WORD *)(v150 + 4) = 25701;
          *(_BYTE *)(v150 + 6) = 32;
          *(_QWORD *)(v11 + 24) += 7LL;
        }
      }
      v69 = *(_BYTE *)(a1 + 4);
      if ( (v69 & 1) != 0 )
      {
        v149 = *(_QWORD *)(v11 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v11 + 16) - v149) <= 5 )
        {
          sub_16E7EE0(v11, "undef ", 6u);
        }
        else
        {
          *(_DWORD *)v149 = 1701080693;
          *(_WORD *)(v149 + 4) = 8294;
          *(_QWORD *)(v11 + 24) += 6LL;
        }
        v69 = *(_BYTE *)(a1 + 4);
      }
      if ( (v69 & 4) != 0 )
      {
        v147 = *(void **)(v11 + 24);
        if ( *(_QWORD *)(v11 + 16) - (_QWORD)v147 <= 0xDu )
        {
          sub_16E7EE0(v11, "early-clobber ", 0xEu);
        }
        else
        {
          qmemcpy(v147, "early-clobber ", 14);
          *(_QWORD *)(v11 + 24) += 14LL;
        }
        v69 = *(_BYTE *)(a1 + 4);
      }
      if ( (v69 & 8) != 0 )
      {
        v146 = *(void **)(v11 + 24);
        if ( *(_QWORD *)(v11 + 16) - (_QWORD)v146 <= 9u )
        {
          sub_16E7EE0(v11, "debug-use ", 0xAu);
        }
        else
        {
          qmemcpy(v146, "debug-use ", 10);
          *(_QWORD *)(v11 + 24) += 10LL;
        }
      }
      if ( *(int *)(a1 + 8) > 0 && (unsigned __int8)sub_1E31310(a1) )
      {
        v137 = *(void **)(v11 + 24);
        if ( *(_QWORD *)(v11 + 16) - (_QWORD)v137 <= 9u )
        {
          sub_16E7EE0(v11, "renamable ", 0xAu);
        }
        else
        {
          qmemcpy(v137, "renamable ", 10);
          *(_QWORD *)(v11 + 24) += 10LL;
        }
      }
      v70 = 0;
      if ( v63 < 0 )
      {
        v70 = *(_QWORD **)(a1 + 16);
        if ( v70 )
        {
          v70 = (_QWORD *)v70[3];
          if ( v70 )
          {
            v70 = (_QWORD *)v70[7];
            if ( v70 )
              v70 = (_QWORD *)v70[5];
          }
        }
      }
      v15 = (unsigned int)v63;
      sub_1F4AA00(v192, (unsigned int)v63, a9, 0, v70);
      v17 = (char **)v192;
      if ( !v193 )
        goto LABEL_374;
      v194(v192, v11);
      if ( v193 )
        v193(v192, v192, 3);
      v71 = *(_DWORD *)a1 >> 8;
      LOWORD(v71) = v71 & 0xFFF;
      v72 = (*(_DWORD *)a1 >> 8) & 0xFFF;
      if ( v72 )
      {
        v73 = *(_QWORD *)(v11 + 16);
        v74 = *(_QWORD *)(v11 + 24);
        if ( a9 )
        {
          if ( v73 <= v74 )
          {
            v182 = (*(_DWORD *)a1 >> 8) & 0xFFF;
            v161 = sub_16E7DE0(v11, 46);
            v72 = v182;
            v75 = v161;
          }
          else
          {
            v71 = v74 + 1;
            v75 = v11;
            *(_QWORD *)(v11 + 24) = v74 + 1;
            *(_BYTE *)v74 = 46;
          }
          v76 = (unsigned int)(v72 - 1);
          v181 = v75;
          v77 = *(_QWORD *)(a9 + 240);
          if ( *(_QWORD *)(v77 + 8 * v76) )
          {
            src = *(char **)(v77 + 8 * v76);
            v78 = strlen(src);
            v79 = src;
            v80 = *(void **)(v181 + 24);
            if ( v78 > *(_QWORD *)(v181 + 16) - (_QWORD)v80 )
            {
              sub_16E7EE0(v181, src, v78);
            }
            else if ( v78 )
            {
              srca = v78;
              memcpy(v80, v79, v78);
              *(_QWORD *)(v181 + 24) += srca;
            }
          }
        }
        else
        {
          if ( v73 - v74 <= 6 )
          {
            v183 = v71;
            v173 = sub_16E7EE0(v11, ".subreg", 7u);
            LOWORD(v71) = v183;
            v160 = v173;
          }
          else
          {
            *(_DWORD *)v74 = 1651864366;
            v160 = v11;
            *(_WORD *)(v74 + 4) = 25970;
            *(_BYTE *)(v74 + 6) = 103;
            *(_QWORD *)(v11 + 24) += 7LL;
          }
          sub_16E7A90(v160, (unsigned __int16)v71);
        }
      }
      if ( v63 < 0 )
      {
        v138 = *(_QWORD *)(a1 + 16);
        if ( v138 )
        {
          v139 = *(_QWORD *)(v138 + 24);
          if ( v139 )
          {
            v140 = *(_QWORD *)(v139 + 56);
            if ( v140 )
            {
              v141 = *(_QWORD *)(v140 + 40);
              if ( a5 != 1
                || a6
                || (v142 = *(_QWORD *)(*(_QWORD *)(v141 + 24) + 16LL * (v63 & 0x7FFFFFFF) + 8)) == 0
                || (*(_BYTE *)(v142 + 3) & 0x10) == 0
                && ((v143 = *(_QWORD *)(v142 + 32)) == 0 || (*(_BYTE *)(v143 + 3) & 0x10) == 0) )
              {
                v144 = *(_BYTE **)(v11 + 24);
                if ( (unsigned __int64)v144 >= *(_QWORD *)(v11 + 16) )
                {
                  v190 = v141;
                  sub_16E7DE0(v11, 58);
                  v141 = v190;
                }
                else
                {
                  *(_QWORD *)(v11 + 24) = v144 + 1;
                  *v144 = 58;
                }
                v15 = (unsigned int)v63;
                v17 = (char **)v195;
                sub_1F4AA90(v195, (unsigned int)v63, v141, a9);
                if ( !v196 )
LABEL_374:
                  sub_4263D6(v17, v15, v18);
                v197(v195, v11);
                if ( v196 )
                  v196(v195, v195, 3);
              }
            }
          }
        }
      }
      if ( a7 && (*(_WORD *)(a1 + 2) & 0xFF0) != 0 && (*(_BYTE *)(a1 + 3) & 0x10) == 0 )
      {
        v169 = *(void **)(v11 + 24);
        if ( *(_QWORD *)(v11 + 16) - (_QWORD)v169 <= 9u )
        {
          v170 = sub_16E7EE0(v11, "(tied-def ", 0xAu);
        }
        else
        {
          v170 = v11;
          qmemcpy(v169, "(tied-def ", 10);
          *(_QWORD *)(v11 + 24) += 10LL;
        }
        v171 = sub_16E7A90(v170, a8);
        v172 = *(_BYTE **)(v171 + 24);
        if ( *(_BYTE **)(v171 + 16) == v172 )
        {
          sub_16E7EE0(v171, ")", 1u);
        }
        else
        {
          *v172 = 41;
          ++*(_QWORD *)(v171 + 24);
        }
      }
      if ( (v191 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
      {
        v81 = *(_BYTE **)(v11 + 24);
        if ( (unsigned __int64)v81 >= *(_QWORD *)(v11 + 16) )
        {
          v11 = sub_16E7DE0(v11, 40);
        }
        else
        {
          v82 = v81 + 1;
          *(_QWORD *)(v11 + 24) = v81 + 1;
          *v81 = 40;
        }
        sub_39462E0(&v191, v11, v82, v71);
        v83 = *(_BYTE **)(v11 + 24);
        if ( (unsigned __int64)v83 >= *(_QWORD *)(v11 + 16) )
        {
LABEL_227:
          sub_16E7DE0(v11, 41);
        }
        else
        {
          *(_QWORD *)(v11 + 24) = v83 + 1;
          *v83 = 41;
        }
      }
      return;
    case 1:
      sub_16E7AB0(a2, *(_QWORD *)(a1 + 24));
      return;
    case 2:
    case 3:
      sub_1553920(*(__int64 **)(a1 + 24), a2, 1, a3);
      return;
    case 4:
      v15 = *(_QWORD *)(a1 + 24);
      v16 = v198;
      v17 = (char **)v198;
      sub_1DD5B60(v198, v15);
      if ( !v199 )
        goto LABEL_374;
      v200(v198, v11);
      v19 = v199;
      if ( v199 )
        goto LABEL_8;
      return;
    case 5:
      v97 = *(_QWORD *)(a1 + 16);
      if ( v97 )
      {
        v97 = *(_QWORD *)(v97 + 24);
        if ( v97 )
        {
          v97 = *(_QWORD *)(v97 + 56);
          if ( v97 )
            v97 = *(_QWORD *)(v97 + 56);
        }
      }
      sub_1E32090(a2, *(_DWORD *)(a1 + 24), 0, v97);
      return;
    case 6:
      v95 = *(_QWORD *)(a2 + 24);
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) - v95) <= 6 )
      {
        v96 = sub_16E7EE0(a2, "%const.", 7u);
      }
      else
      {
        *(_DWORD *)v95 = 1852793637;
        v96 = a2;
        *(_WORD *)(v95 + 4) = 29811;
        *(_BYTE *)(v95 + 6) = 46;
        *(_QWORD *)(a2 + 24) += 7LL;
      }
      sub_16E7AB0(v96, *(int *)(a1 + 24));
      goto LABEL_3;
    case 7:
      v98 = *(void **)(a2 + 24);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v98 <= 0xCu )
      {
        sub_16E7EE0(a2, "target-index(", 0xDu);
      }
      else
      {
        qmemcpy(v98, "target-index(", 13);
        *(_QWORD *)(a2 + 24) += 13LL;
      }
      v99 = *(_QWORD *)(a1 + 16);
      if ( !v99 )
        goto LABEL_144;
      v100 = *(_QWORD *)(v99 + 24);
      if ( !v100 )
        goto LABEL_144;
      v101 = *(_QWORD *)(v100 + 56);
      if ( !v101 )
        goto LABEL_144;
      v102 = *(__int64 (**)())(**(_QWORD **)(v101 + 16) + 40LL);
      if ( v102 == sub_1D00B00 )
        BUG();
      v103 = *(_DWORD *)(a1 + 24);
      v104 = v102();
      v105 = *(__int64 (**)())(*(_QWORD *)v104 + 968LL);
      if ( v105 == sub_1E308D0 )
        goto LABEL_144;
      v127 = ((__int64 (__fastcall *)(__int64))v105)(v104);
      v129 = 16 * v128;
      v130 = v127 + 16 * v128;
      v131 = (16 * v128) >> 6;
      v132 = v129 >> 4;
      if ( v131 <= 0 )
        goto LABEL_327;
      v133 = v127 + (v131 << 6);
      do
      {
        if ( v103 == *(_DWORD *)v127 )
          goto LABEL_215;
        if ( v103 == *(_DWORD *)(v127 + 16) )
        {
          v127 += 16;
          goto LABEL_215;
        }
        if ( v103 == *(_DWORD *)(v127 + 32) )
        {
          v127 += 32;
          goto LABEL_215;
        }
        if ( v103 == *(_DWORD *)(v127 + 48) )
        {
          v127 += 48;
          goto LABEL_215;
        }
        v127 += 64;
      }
      while ( v133 != v127 );
      v132 = (v130 - v127) >> 4;
LABEL_327:
      if ( v132 == 2 )
      {
LABEL_328:
        if ( v103 != *(_DWORD *)v127 )
        {
          v127 += 16;
          goto LABEL_330;
        }
      }
      else
      {
        if ( v132 != 3 )
        {
          if ( v132 == 1 )
          {
LABEL_330:
            if ( v103 == *(_DWORD *)v127 )
              goto LABEL_215;
          }
          goto LABEL_144;
        }
        if ( v103 != *(_DWORD *)v127 )
        {
          v127 += 16;
          goto LABEL_328;
        }
      }
LABEL_215:
      if ( v130 != v127 && *(_QWORD *)(v127 + 8) )
      {
        v188 = *(const char **)(v127 + 8);
        v134 = strlen(v188);
        v106 = *(_BYTE **)(v11 + 24);
        v107 = (char *)v188;
        v135 = v134;
        v108 = v134;
        v111 = *(_QWORD *)(v11 + 16);
        if ( v135 <= v111 - (unsigned __int64)v106 )
        {
          if ( !v135 )
          {
            v110 = v11;
            goto LABEL_146;
          }
LABEL_285:
          memcpy(v106, v107, v108);
          v111 = *(_QWORD *)(v11 + 16);
          v110 = v11;
          v106 = (_BYTE *)(v108 + *(_QWORD *)(v11 + 24));
          *(_QWORD *)(v11 + 24) = v106;
LABEL_146:
          if ( (unsigned __int64)v106 >= v111 )
          {
            sub_16E7DE0(v110, 41);
          }
          else
          {
            *(_QWORD *)(v110 + 24) = v106 + 1;
            *v106 = 41;
          }
LABEL_3:
          sub_1E32140(v11, *(unsigned int *)(a1 + 8) | (unsigned __int64)((__int64)*(int *)(a1 + 32) << 32));
          return;
        }
LABEL_145:
        v109 = sub_16E7EE0(v11, v107, v108);
        v106 = *(_BYTE **)(v109 + 24);
        v110 = v109;
        v111 = *(_QWORD *)(v109 + 16);
        goto LABEL_146;
      }
LABEL_144:
      v106 = *(_BYTE **)(v11 + 24);
      v107 = "<unknown>";
      v108 = 9;
      if ( *(_QWORD *)(v11 + 16) - (_QWORD)v106 > 8u )
        goto LABEL_285;
      goto LABEL_145;
    case 8:
      v15 = *(unsigned int *)(a1 + 24);
      v16 = v201;
      v17 = (char **)v201;
      sub_1E0A8D0((__int64)v201, v15);
      if ( !v202 )
        goto LABEL_374;
      v203(v201, v11);
      v19 = v202;
      if ( !v202 )
        return;
LABEL_8:
      v19(v16, v16, 3);
      return;
    case 9:
      v44 = *(const char **)(a1 + 24);
      v45 = 0;
      if ( v44 )
        v45 = strlen(*(const char **)(a1 + 24));
      v46 = *(_BYTE **)(a2 + 24);
      if ( (unsigned __int64)v46 >= *(_QWORD *)(a2 + 16) )
      {
        sub_16E7DE0(a2, 38);
      }
      else
      {
        *(_QWORD *)(a2 + 24) = v46 + 1;
        *v46 = 38;
      }
      if ( v45 )
      {
        sub_154B650(a2, v44, v45);
      }
      else
      {
        v47 = *(_WORD **)(a2 + 24);
        if ( *(_QWORD *)(a2 + 16) - (_QWORD)v47 <= 1u )
        {
          sub_16E7EE0(a2, "\"\"", 2u);
        }
        else
        {
          *v47 = 8738;
          *(_QWORD *)(a2 + 24) += 2LL;
        }
      }
      goto LABEL_3;
    case 0xA:
      sub_1553920(*(__int64 **)(a1 + 24), a2, 0, a3);
      goto LABEL_3;
    case 0xB:
      v33 = *(void **)(a2 + 24);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v33 <= 0xCu )
      {
        sub_16E7EE0(a2, "blockaddress(", 0xDu);
      }
      else
      {
        qmemcpy(v33, "blockaddress(", 13);
        *(_QWORD *)(a2 + 24) += 13LL;
      }
      sub_1553920(*(__int64 **)(*(_QWORD *)(a1 + 24) - 48LL), a2, 0, a3);
      v35 = *(_WORD **)(a2 + 24);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v35 <= 1u )
      {
        sub_16E7EE0(a2, ", ", 2u);
        v36 = *(void **)(a2 + 24);
      }
      else
      {
        *v35 = 8236;
        v36 = (void *)(*(_QWORD *)(a2 + 24) + 2LL);
        *(_QWORD *)(a2 + 24) = v36;
      }
      v37 = *(_QWORD *)(*(_QWORD *)(a1 + 24) - 24LL);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v36 <= 9u )
      {
        v189 = *(_QWORD *)(*(_QWORD *)(a1 + 24) - 24LL);
        sub_16E7EE0(a2, "%ir-block.", 0xAu);
        v37 = v189;
      }
      else
      {
        qmemcpy(v36, "%ir-block.", 10);
        *(_QWORD *)(a2 + 24) += 10LL;
      }
      if ( (*(_BYTE *)(v37 + 23) & 0x20) != 0 )
      {
        v155 = sub_1649960(v37);
        sub_154B650(a2, v155, v156);
        v43 = *(_BYTE **)(a2 + 24);
      }
      else
      {
        v38 = *(_QWORD *)(v37 + 56);
        if ( v38 )
        {
          if ( v38 == *(_QWORD *)(a3 + 24) )
          {
            v42 = sub_154F480(a3, v37, (__int64)v36, v34);
            goto LABEL_53;
          }
          v39 = *(_QWORD *)(v38 + 40);
          v186 = v37;
          if ( v39 )
          {
            sub_154BA10((__int64)&v207, v39, 0);
            sub_154C150((__int64)&v207, v38);
            v42 = sub_154F480((__int64)&v207, v186, v40, v41);
            sub_154BA40((__int64 *)&v207);
LABEL_53:
            sub_1E32200(v11, v42);
            v43 = *(_BYTE **)(v11 + 24);
            goto LABEL_54;
          }
        }
        v145 = *(_QWORD *)(v11 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(v11 + 16) - v145) <= 8 )
        {
          sub_16E7EE0(v11, "<unknown>", 9u);
          v43 = *(_BYTE **)(v11 + 24);
        }
        else
        {
          *(_BYTE *)(v145 + 8) = 62;
          *(_QWORD *)v145 = 0x6E776F6E6B6E753CLL;
          v43 = (_BYTE *)(*(_QWORD *)(v11 + 24) + 9LL);
          *(_QWORD *)(v11 + 24) = v43;
        }
      }
LABEL_54:
      if ( *(_QWORD *)(v11 + 16) <= (unsigned __int64)v43 )
      {
        sub_16E7DE0(v11, 41);
      }
      else
      {
        *(_QWORD *)(v11 + 24) = v43 + 1;
        *v43 = 41;
      }
      goto LABEL_3;
    case 0xC:
      v25 = *(_QWORD **)(a2 + 24);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v25 <= 7u )
      {
        sub_16E7EE0(a2, "<regmask", 8u);
        v26 = *(_BYTE **)(a2 + 24);
      }
      else
      {
        *v25 = 0x6B73616D6765723CLL;
        v26 = (_BYTE *)(*(_QWORD *)(a2 + 24) + 8LL);
        *(_QWORD *)(a2 + 24) = v26;
      }
      if ( a9 )
      {
        if ( *(_DWORD *)(a9 + 16) )
        {
          v185 = 0;
          v27 = 0;
          v28 = 0;
          do
          {
            if ( (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 4LL * (v27 >> 5)) & (1 << v27)) != 0 )
            {
              if ( dword_4FC6AC0 < 0 || dword_4FC6AC0 >= v185 )
              {
                if ( v26 == *(_BYTE **)(v11 + 16) )
                {
                  v29 = sub_16E7EE0(v11, " ", 1u);
                }
                else
                {
                  *v26 = 32;
                  v29 = v11;
                  ++*(_QWORD *)(v11 + 24);
                }
                v15 = v27;
                v17 = (char **)v204;
                v180 = v29;
                sub_1F4AA00(v204, v27, a9, 0, 0);
                if ( !v205 )
                  goto LABEL_374;
                v206(v204, v180);
                if ( v205 )
                  v205(v204, v204, 3);
                ++v185;
                v26 = *(_BYTE **)(v11 + 24);
              }
              ++v28;
            }
            ++v27;
          }
          while ( v27 < *(_DWORD *)(a9 + 16) );
          if ( v28 != v185 )
          {
            if ( *(_QWORD *)(v11 + 16) - (_QWORD)v26 <= 4u )
            {
              v30 = sub_16E7EE0(v11, " and ", 5u);
            }
            else
            {
              *(_DWORD *)v26 = 1684955424;
              v26[4] = 32;
              v30 = v11;
              *(_QWORD *)(v11 + 24) += 5LL;
            }
            v31 = sub_16E7A90(v30, v28 - v185);
            v32 = *(_QWORD **)(v31 + 24);
            if ( *(_QWORD *)(v31 + 16) - (_QWORD)v32 <= 7u )
            {
              sub_16E7EE0(v31, " more...", 8u);
            }
            else
            {
              *v32 = 0x2E2E2E65726F6D20LL;
              *(_QWORD *)(v31 + 24) += 8LL;
            }
            goto LABEL_39;
          }
        }
      }
      else
      {
        if ( *(_QWORD *)(a2 + 16) - (_QWORD)v26 <= 3u )
        {
          sub_16E7EE0(a2, " ...", 4u);
LABEL_39:
          v26 = *(_BYTE **)(v11 + 24);
          goto LABEL_40;
        }
        *(_DWORD *)v26 = 774778400;
        v26 = (_BYTE *)(*(_QWORD *)(a2 + 24) + 4LL);
        *(_QWORD *)(a2 + 24) = v26;
      }
LABEL_40:
      if ( *(_BYTE **)(v11 + 16) == v26 )
      {
        sub_16E7EE0(v11, ">", 1u);
      }
      else
      {
        *v26 = 62;
        ++*(_QWORD *)(v11 + 24);
      }
      return;
    case 0xD:
      v55 = *(_QWORD **)(a2 + 24);
      v56 = *(_QWORD *)(a1 + 24);
      if ( *(_QWORD *)(a2 + 16) - (_QWORD)v55 <= 7u )
      {
        sub_16E7EE0(a2, "liveout(", 8u);
      }
      else
      {
        *v55 = 0x2874756F6576696CLL;
        *(_QWORD *)(a2 + 24) += 8LL;
      }
      if ( a9 )
      {
        v57 = *(_DWORD *)(a9 + 16);
        if ( v57 )
        {
          v58 = 0;
          v59 = 0;
          do
          {
            v60 = *(_DWORD *)(v56 + 4LL * (v58 >> 5));
            if ( _bittest(&v60, v58) )
            {
              if ( v59 )
              {
                v61 = *(_WORD **)(v11 + 24);
                if ( *(_QWORD *)(v11 + 16) - (_QWORD)v61 <= 1u )
                {
                  sub_16E7EE0(v11, ", ", 2u);
                }
                else
                {
                  *v61 = 8236;
                  *(_QWORD *)(v11 + 24) += 2LL;
                }
              }
              v15 = v58;
              v17 = &v207;
              sub_1F4AA00(&v207, v58, a9, 0, 0);
              if ( !v209[0] )
                goto LABEL_374;
              ((void (__fastcall *)(char **, __int64))v209[1])(&v207, v11);
              if ( v209[0] )
                ((void (__fastcall *)(char **, char **, __int64))v209[0])(&v207, &v207, 3);
              v59 = 1;
            }
            ++v58;
          }
          while ( v58 != v57 );
        }
        v126 = *(_BYTE **)(v11 + 24);
      }
      else
      {
        v159 = *(_QWORD *)(a2 + 24);
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) - v159) <= 8 )
        {
          sub_16E7EE0(a2, "<unknown>", 9u);
          v126 = *(_BYTE **)(a2 + 24);
        }
        else
        {
          *(_BYTE *)(v159 + 8) = 62;
          *(_QWORD *)v159 = 0x6E776F6E6B6E753CLL;
          v126 = (_BYTE *)(*(_QWORD *)(a2 + 24) + 9LL);
          *(_QWORD *)(a2 + 24) = v126;
        }
      }
      if ( *(_BYTE **)(v11 + 16) == v126 )
      {
        sub_16E7EE0(v11, ")", 1u);
      }
      else
      {
        *v126 = 41;
        ++*(_QWORD *)(v11 + 24);
      }
      return;
    case 0xE:
      sub_1556260(*(unsigned __int8 **)(a1 + 24), a2, a3, 0);
      return;
    case 0xF:
      sub_1E31EA0(a2, *(_QWORD *)(a1 + 24));
      return;
    case 0x10:
      v48 = *(__m128i **)(a2 + 24);
      v49 = *(_QWORD *)(a1 + 16);
      v50 = *(_QWORD *)(a2 + 16) - (_QWORD)v48;
      if ( v49 && (v51 = *(_QWORD *)(v49 + 24)) != 0 && (v52 = *(_QWORD *)(v51 + 56)) != 0 )
      {
        v53 = (_DWORD *)(*(_QWORD *)(v52 + 384) + 48LL * *(unsigned int *)(a1 + 24));
        v54 = v53;
        switch ( *v53 )
        {
          case 0:
            if ( v50 <= 0xA )
            {
              sub_16E7EE0(a2, "same_value ", 0xBu);
            }
            else
            {
              qmemcpy(v48, "same_value ", 0xBu);
              *(_QWORD *)(a2 + 24) += 11LL;
            }
            goto LABEL_152;
          case 1:
            if ( v50 <= 0xE )
            {
              sub_16E7EE0(a2, "remember_state ", 0xFu);
            }
            else
            {
              qmemcpy(v48, "remember_state ", 0xFu);
              *(_QWORD *)(a2 + 24) += 15LL;
            }
            goto LABEL_157;
          case 2:
            if ( v50 <= 0xD )
            {
              sub_16E7EE0(a2, "restore_state ", 0xEu);
            }
            else
            {
              qmemcpy(v48, "restore_state ", 0xEu);
              *(_QWORD *)(a2 + 24) += 14LL;
            }
            goto LABEL_157;
          case 3:
            if ( v50 <= 6 )
            {
              sub_16E7EE0(a2, "offset ", 7u);
            }
            else
            {
              qmemcpy(v48, "offset ", 7u);
              *(_QWORD *)(a2 + 24) += 7LL;
            }
            goto LABEL_190;
          case 4:
            if ( v50 <= 0x10 )
            {
              sub_16E7EE0(a2, "def_cfa_register ", 0x11u);
            }
            else
            {
              si128 = _mm_load_si128((const __m128i *)&xmmword_42EB9A0);
              v48[1].m128i_i8[0] = 32;
              *v48 = si128;
              *(_QWORD *)(a2 + 24) += 17LL;
            }
            goto LABEL_152;
          case 5:
            if ( v50 <= 0xE )
            {
              sub_16E7EE0(a2, "def_cfa_offset ", 0xFu);
            }
            else
            {
              qmemcpy(v48, "def_cfa_offset ", 0xFu);
              *(_QWORD *)(a2 + 24) += 15LL;
            }
            goto LABEL_170;
          case 6:
            if ( v50 <= 7 )
            {
              sub_16E7EE0(a2, "def_cfa ", 8u);
            }
            else
            {
              v48->m128i_i64[0] = 0x206166635F666564LL;
              *(_QWORD *)(a2 + 24) += 8LL;
            }
            goto LABEL_190;
          case 7:
            if ( v50 <= 0xA )
            {
              sub_16E7EE0(a2, "rel_offset ", 0xBu);
            }
            else
            {
              qmemcpy(v48, "rel_offset ", 0xBu);
              *(_QWORD *)(a2 + 24) += 11LL;
            }
LABEL_190:
            v124 = *((_QWORD *)v54 + 1);
            if ( v124 )
              sub_1E31EA0(v11, v124);
            sub_1E30990(v54[4], v11, a9);
            v125 = *(_WORD **)(v11 + 24);
            if ( *(_QWORD *)(v11 + 16) - (_QWORD)v125 <= 1u )
            {
              v11 = sub_16E7EE0(v11, ", ", 2u);
            }
            else
            {
              *v125 = 8236;
              *(_QWORD *)(v11 + 24) += 2LL;
            }
            goto LABEL_172;
          case 8:
            if ( v50 <= 0x11 )
            {
              sub_16E7EE0(a2, "adjust_cfa_offset ", 0x12u);
            }
            else
            {
              v116 = _mm_load_si128((const __m128i *)&xmmword_42EB9B0);
              v48[1].m128i_i16[0] = 8308;
              *v48 = v116;
              *(_QWORD *)(a2 + 24) += 18LL;
            }
LABEL_170:
            v117 = *((_QWORD *)v54 + 1);
            if ( v117 )
              sub_1E31EA0(v11, v117);
LABEL_172:
            sub_16E7AB0(v11, (int)v54[5]);
            return;
          case 9:
            if ( v50 <= 6 )
            {
              sub_16E7EE0(a2, "escape ", 7u);
            }
            else
            {
              qmemcpy(v48, "escape ", 7u);
              *(_QWORD *)(a2 + 24) += 7LL;
            }
            v118 = *((_QWORD *)v54 + 1);
            if ( v118 )
              sub_1E31EA0(v11, v118);
            v119 = *((_QWORD *)v54 + 4) - *((_QWORD *)v54 + 3);
            v177 = v119;
            if ( v119 )
            {
              v187 = v119 - 1;
              if ( v119 != 1 )
              {
                v120 = 0;
                do
                {
                  v121 = *(_BYTE *)(*((_QWORD *)v54 + 3) + v120);
                  v208 = "0x%02x";
                  v207 = (char *)&unk_49EF3B0;
                  LOBYTE(v209[0]) = v121;
                  v122 = sub_16E8450(v11, (__int64)&v207, (__int64)v48, (__int64)&unk_49EF3B0, (int)v53, v14);
                  v48 = *(__m128i **)(v122 + 24);
                  if ( *(_QWORD *)(v122 + 16) - (_QWORD)v48 > 1u )
                  {
                    LODWORD(v53) = 8236;
                    v48->m128i_i16[0] = 8236;
                    *(_QWORD *)(v122 + 24) += 2LL;
                  }
                  else
                  {
                    sub_16E7EE0(v122, ", ", 2u);
                  }
                  ++v120;
                }
                while ( v187 != v120 );
              }
              v174 = *(_BYTE *)(*((_QWORD *)v54 + 3) + v177 - 1);
              v208 = "0x%02x";
              LOBYTE(v209[0]) = v174;
              v207 = (char *)&unk_49EF3B0;
              v175 = sub_16E8450(v11, (__int64)&v207, (__int64)&unk_49EF3B0, v177, (int)v53, v14);
              v176 = *(_WORD **)(v175 + 24);
              if ( *(_QWORD *)(v175 + 16) - (_QWORD)v176 <= 1u )
              {
                sub_16E7EE0(v175, ", ", 2u);
              }
              else
              {
                *v176 = 8236;
                *(_QWORD *)(v175 + 24) += 2LL;
              }
            }
            return;
          case 0xA:
            if ( v50 <= 7 )
            {
              sub_16E7EE0(a2, "restore ", 8u);
            }
            else
            {
              v48->m128i_i64[0] = 0x2065726F74736572LL;
              *(_QWORD *)(a2 + 24) += 8LL;
            }
            goto LABEL_152;
          case 0xB:
            if ( v50 <= 9 )
            {
              sub_16E7EE0(a2, "undefined ", 0xAu);
            }
            else
            {
              qmemcpy(v48, "undefined ", 10);
              *(_QWORD *)(a2 + 24) += 10LL;
            }
LABEL_152:
            v112 = *((_QWORD *)v54 + 1);
            if ( v112 )
              sub_1E31EA0(v11, v112);
            sub_1E30990(v54[4], v11, a9);
            break;
          case 0xC:
            if ( v50 <= 8 )
            {
              sub_16E7EE0(a2, "register ", 9u);
            }
            else
            {
              v48->m128i_i8[8] = 32;
              v48->m128i_i64[0] = 0x7265747369676572LL;
              *(_QWORD *)(a2 + 24) += 9LL;
            }
            v114 = *((_QWORD *)v54 + 1);
            if ( v114 )
              sub_1E31EA0(v11, v114);
            sub_1E30990(v54[4], v11, a9);
            v115 = *(_WORD **)(v11 + 24);
            if ( *(_QWORD *)(v11 + 16) - (_QWORD)v115 <= 1u )
            {
              sub_16E7EE0(v11, ", ", 2u);
            }
            else
            {
              *v115 = 8236;
              *(_QWORD *)(v11 + 24) += 2LL;
            }
            sub_1E30990(v54[5], v11, a9);
            break;
          case 0xD:
            if ( v50 <= 0xB )
            {
              sub_16E7EE0(a2, "window_save ", 0xCu);
            }
            else
            {
              qmemcpy(v48, "window_save ", 12);
              *(_QWORD *)(a2 + 24) += 12LL;
            }
LABEL_157:
            v113 = *((_QWORD *)v54 + 1);
            if ( v113 )
              sub_1E31EA0(v11, v113);
            break;
          default:
            if ( v50 <= 0x1D )
            {
              sub_16E7EE0(a2, "<unserializable cfi directive>", 0x1Eu);
            }
            else
            {
              qmemcpy(v48, "<unserializable cfi directive>", 0x1Eu);
              *(_QWORD *)(a2 + 24) += 30LL;
            }
            break;
        }
      }
      else if ( v50 <= 0xE )
      {
        sub_16E7EE0(a2, "<cfi directive>", 0xFu);
      }
      else
      {
        qmemcpy(v48, "<cfi directive>", 15);
        *(_QWORD *)(a2 + 24) += 15LL;
      }
      return;
    case 0x11:
      v20 = *(char **)(a2 + 24);
      v21 = *(_DWORD *)(a1 + 24);
      v22 = *(_QWORD *)(a2 + 16) - (_QWORD)v20;
      if ( v21 <= 0x1DC9 )
      {
        if ( v22 <= 0xA )
        {
          v11 = sub_16E7EE0(a2, "intrinsic(@", 0xBu);
        }
        else
        {
          qmemcpy(v20, "intrinsic(@", 11);
          *(_QWORD *)(a2 + 24) += 11LL;
        }
        sub_15E1070((__int64 *)&v207, v21, 0, 0);
      }
      else
      {
        if ( !a10 )
        {
          if ( v22 <= 9 )
          {
            v11 = sub_16E7EE0(a2, "intrinsic(", 0xAu);
          }
          else
          {
            qmemcpy(v20, "intrinsic(", 10);
            *(_QWORD *)(a2 + 24) += 10LL;
          }
          v157 = sub_16E7A90(v11, v21);
          v158 = *(_BYTE **)(v157 + 24);
          if ( (unsigned __int64)v158 >= *(_QWORD *)(v157 + 16) )
          {
            sub_16E7DE0(v157, 41);
          }
          else
          {
            *(_QWORD *)(v157 + 24) = v158 + 1;
            *v158 = 41;
          }
          return;
        }
        if ( v22 <= 0xA )
        {
          v11 = sub_16E7EE0(a2, "intrinsic(@", 0xBu);
        }
        else
        {
          qmemcpy(v20, "intrinsic(@", 11);
          *(_QWORD *)(a2 + 24) += 11LL;
        }
        (*(void (__fastcall **)(char **, __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a10 + 16LL))(
          &v207,
          a10,
          v21,
          0,
          0);
      }
      v23 = sub_16E7EE0(v11, v207, (size_t)v208);
      v24 = *(_BYTE **)(v23 + 24);
      if ( (unsigned __int64)v24 >= *(_QWORD *)(v23 + 16) )
      {
        sub_16E7DE0(v23, 41);
      }
      else
      {
        *(_QWORD *)(v23 + 24) = v24 + 1;
        *v24 = 41;
      }
      if ( v207 != (char *)v209 )
        j_j___libc_free_0(v207, v209[0] + 1LL);
      return;
    case 0x12:
      v84 = *(_DWORD *)(a1 + 24);
      v85 = "int";
      if ( (unsigned int)(v84 - 32) >= 0xA )
        v85 = "float";
      v86 = strlen(v85);
      v87 = *(_QWORD *)(a2 + 24);
      if ( v86 <= *(_QWORD *)(a2 + 16) - v87 )
      {
        if ( (_DWORD)v86 )
        {
          v153 = 0;
          do
          {
            v154 = v153++;
            *(_BYTE *)(v87 + v154) = v85[v154];
          }
          while ( v153 < (unsigned int)v86 );
          v87 = *(_QWORD *)(v11 + 24);
        }
        v88 = v86 + v87;
        *(_QWORD *)(v11 + 24) = v88;
      }
      else
      {
        v11 = sub_16E7EE0(a2, v85, v86);
        v88 = *(_QWORD *)(v11 + 24);
      }
      if ( *(_QWORD *)(v11 + 16) - v88 <= 4 )
      {
        v11 = sub_16E7EE0(v11, "pred(", 5u);
      }
      else
      {
        *(_DWORD *)v88 = 1684370032;
        *(_BYTE *)(v88 + 4) = 40;
        *(_QWORD *)(v11 + 24) += 5LL;
      }
      v89 = sub_15FF290(v84);
      v91 = *(_BYTE **)(v11 + 24);
      v92 = v89;
      v93 = *(_QWORD *)(v11 + 16);
      v94 = v90;
      if ( v90 > v93 - (unsigned __int64)v91 )
      {
        v148 = sub_16E7EE0(v11, v92, v90);
        v91 = *(_BYTE **)(v148 + 24);
        v11 = v148;
        v93 = *(_QWORD *)(v148 + 16);
      }
      else if ( v90 )
      {
        memcpy(v91, v92, v90);
        v93 = *(_QWORD *)(v11 + 16);
        v91 = (_BYTE *)(v94 + *(_QWORD *)(v11 + 24));
        *(_QWORD *)(v11 + 24) = v91;
      }
      if ( v93 <= (unsigned __int64)v91 )
        goto LABEL_227;
      *(_QWORD *)(v11 + 24) = v91 + 1;
      *v91 = 41;
      return;
    default:
      return;
  }
}
