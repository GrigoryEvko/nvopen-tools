// Function: sub_BE3890
// Address: 0xbe3890
//
void __fastcall sub_BE3890(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r14
  const char *v5; // r13
  __int64 *v8; // rax
  __int64 v9; // rcx
  __int64 *i; // rdx
  char v11; // dl
  _QWORD *v12; // rax
  __int64 v13; // r13
  _BYTE *v14; // rax
  __int64 v15; // rsi
  __int64 v16; // rdi
  _BYTE *v17; // rax
  unsigned __int8 v18; // dl
  bool v19; // al
  __int64 *v20; // r14
  __int64 v21; // rax
  __int64 v22; // rcx
  unsigned __int64 v23; // rax
  __int64 v24; // rsi
  __int64 v25; // rcx
  unsigned __int8 **v26; // r13
  int v27; // eax
  __int64 v28; // rsi
  const char *v29; // rax
  __int64 v30; // r13
  _BYTE *v31; // rax
  __int64 v32; // rsi
  char v33; // al
  __int64 v34; // rdi
  _BYTE *v35; // rax
  __int64 v36; // r13
  _BYTE *v37; // rax
  __int64 v38; // rax
  char v39; // dl
  unsigned __int8 *v40; // r8
  unsigned __int64 v41; // rcx
  __int64 v42; // rsi
  __int64 v43; // r13
  _BYTE *v44; // rax
  const char *v45; // r8
  __int64 v46; // rax
  __int64 v47; // r13
  _BYTE *v48; // rax
  __int64 v49; // rsi
  char v50; // al
  _BYTE *v51; // rax
  __int64 v52; // rax
  unsigned __int64 v53; // rdx
  __int64 v54; // rcx
  const char **v55; // rcx
  const char *v56; // r14
  unsigned __int64 v57; // rsi
  __int64 v58; // rdi
  char v59; // cl
  __int64 v60; // r13
  _BYTE *v61; // rax
  __int64 v62; // rax
  char v63; // dl
  int v64; // ecx
  const char **v65; // rcx
  unsigned __int8 v66; // cl
  const char **v67; // rcx
  __int64 v68; // rdi
  const char **v69; // rdi
  const char *v70; // r13
  __int64 v71; // r14
  _BYTE *v72; // rax
  __int64 v73; // rax
  char v74; // dl
  const char **v75; // rax
  unsigned __int64 v76; // rdx
  __int64 v77; // rcx
  __int64 v78; // r14
  _BYTE *v79; // rax
  bool v80; // zf
  __int64 v81; // r13
  unsigned __int8 v82; // al
  __int64 v83; // rdx
  unsigned __int64 v84; // rax
  __int64 v85; // rdx
  __int64 v86; // r13
  _BYTE *v87; // rax
  __int64 v88; // rax
  char v89; // dl
  unsigned __int8 v90; // al
  __int64 v91; // rsi
  const char **v92; // rdx
  unsigned __int64 v93; // rax
  __int64 v94; // rcx
  unsigned __int8 v95; // dl
  const char **v96; // rsi
  __int64 v97; // r13
  const char *v98; // r14
  _BYTE *v99; // rax
  __int64 v100; // rdi
  __int64 v101; // rdx
  __int64 v102; // rdi
  _QWORD *v103; // rdx
  const char **v104; // r13
  __int64 v105; // r13
  _BYTE *v106; // rax
  __int64 v107; // rax
  __int64 v108; // rdx
  __int64 v109; // r13
  int v110; // edx
  __int64 v111; // rdx
  const char *v112; // rax
  unsigned __int8 v113; // al
  __int64 v114; // rdx
  __int64 v115; // rdi
  __int64 v116; // rdx
  __int64 v117; // r13
  _BYTE *v118; // rax
  unsigned __int8 v119; // al
  const char **v120; // rdx
  __int64 v121; // r13
  _BYTE *v122; // rax
  __int64 v123; // rax
  char v124; // dl
  __int64 v125; // rsi
  unsigned __int64 v126; // rcx
  __int64 v127; // rdi
  __int64 v128; // r13
  _BYTE *v129; // rax
  __int64 v130; // rsi
  char v131; // al
  _BYTE *v132; // rax
  __int64 v133; // r13
  _BYTE *v134; // rax
  __int64 v135; // rsi
  char v136; // al
  _BYTE *v137; // rax
  __int64 v138; // rsi
  __int64 v139; // rcx
  unsigned __int64 v140; // rax
  __int64 v141; // rsi
  __int64 v142; // r14
  _BYTE *v143; // rax
  __int64 v144; // r13
  _BYTE *v145; // rax
  __int64 v146; // rsi
  char v147; // al
  _BYTE *v148; // rax
  __int64 v149; // r13
  _BYTE *v150; // rax
  __int64 v151; // rsi
  char v152; // al
  _BYTE *v153; // rax
  _QWORD *v154; // rcx
  __int64 v155; // r13
  _BYTE *v156; // rax
  __int64 v157; // rax
  char v158; // dl
  __int64 v159; // r13
  _BYTE *v160; // rax
  __int64 v161; // rax
  char v162; // dl
  __int64 v163; // r13
  _BYTE *v164; // rax
  __int64 v165; // rax
  char v166; // dl
  char v167; // al
  char v168; // al
  char v169; // al
  __int64 v170; // r13
  _BYTE *v171; // rax
  __int64 v172; // r13
  _BYTE *v173; // rax
  char v174; // al
  _BYTE *v175; // rax
  __int64 v176; // r13
  _BYTE *v177; // rax
  __int64 v178; // rax
  char v179; // dl
  char v180; // al
  char v181; // al
  char v182; // al
  char v183; // al
  char v184; // al
  _BYTE *v185; // rax
  __int64 v186; // rdi
  __int64 v187; // rdx
  const char *v188; // rax
  _BYTE *v189; // rax
  const char **v190; // rax
  __int64 v191; // rdx
  const char **v192; // rcx
  const char **v193; // rdx
  __int16 v194; // ax
  const char *v195; // r14
  char v196; // al
  char v197; // al
  char v198; // al
  char v199; // al
  char v200; // al
  char v201; // al
  char *v202; // r14
  __int64 v203; // rdx
  char v204; // al
  const char *v205; // rax
  _BYTE *v206; // rax
  _BYTE *v207; // rax
  __int64 v208; // rdx
  _BYTE *j; // rsi
  char v210; // cl
  __int64 v211; // rdx
  const char *v212; // rax
  _BYTE *v213; // rax
  const char **v214; // rax
  __int64 v215; // rdx
  const char **v216; // rcx
  const char *v217; // rdx
  const char *v218; // rax
  _BYTE *v219; // rax
  const char **v220; // rax
  __int64 v221; // rdx
  const char **v222; // rcx
  const char *v223; // rdx
  const char *v224; // rax
  _BYTE *v225; // rax
  const char **v226; // rax
  __int64 v227; // rdx
  const char **v228; // rcx
  const char *v229; // rdx
  const char **v230; // [rsp+0h] [rbp-90h]
  const char *v231; // [rsp+8h] [rbp-88h]
  unsigned __int8 *v232; // [rsp+8h] [rbp-88h]
  const char *v233; // [rsp+8h] [rbp-88h]
  __int64 v234; // [rsp+8h] [rbp-88h]
  const char *v235; // [rsp+8h] [rbp-88h]
  const char **v236; // [rsp+8h] [rbp-88h]
  __int64 v237; // [rsp+8h] [rbp-88h]
  const char *v238; // [rsp+18h] [rbp-78h] BYREF
  const char *v239; // [rsp+20h] [rbp-70h] BYREF
  const char *v240; // [rsp+28h] [rbp-68h] BYREF
  _QWORD v241[4]; // [rsp+30h] [rbp-60h] BYREF
  char v242; // [rsp+50h] [rbp-40h]
  char v243; // [rsp+51h] [rbp-3Fh]

  v5 = (const char *)a2;
  if ( !*(_BYTE *)(a1 + 476) )
    goto LABEL_8;
  v8 = *(__int64 **)(a1 + 456);
  v9 = *(unsigned int *)(a1 + 468);
  for ( i = &v8[v9]; i != v8; ++v8 )
  {
    if ( a2 == *v8 )
      return;
  }
  if ( (unsigned int)v9 < *(_DWORD *)(a1 + 464) )
  {
    *(_DWORD *)(a1 + 468) = v9 + 1;
    *i = a2;
    ++*(_QWORD *)(a1 + 448);
  }
  else
  {
LABEL_8:
    sub_C8CC70(a1 + 448, a2);
    if ( !v11 )
      return;
  }
  v12 = (_QWORD *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8LL);
  if ( (*(_QWORD *)(a2 + 8) & 4) != 0 )
    v12 = (_QWORD *)*v12;
  if ( *(_QWORD **)(a1 + 144) == v12 )
  {
    switch ( *(_BYTE *)a2 )
    {
      case 5:
        goto LABEL_20;
      case 6:
        sub_BDD730(a1, (const char *)a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 7:
        if ( !sub_AF4230(a2) )
        {
          v243 = 1;
          v241[0] = "invalid expression";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 8:
        sub_BDDFD0(a1, (const char *)a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 9:
        if ( !(unsigned __int16)sub_AF2710(a2) )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 0xA:
        sub_BDF0A0((_BYTE *)a1, (const char *)a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0xB:
        if ( (unsigned __int16)sub_AF18C0(a2) != 40 )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 0xC:
        if ( (unsigned __int16)sub_AF18C0(a2) != 36
          && (unsigned __int16)sub_AF18C0(a2) != 59
          && (unsigned __int16)sub_AF18C0(a2) != 18 )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 0xD:
        sub_BE1DB0((__int64 *)a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0xE:
        sub_BE2390(a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0xF:
        sub_BDB000((_BYTE *)a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x10:
        if ( (unsigned __int16)sub_AF18C0(a2) != 41 )
        {
          v30 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v30 )
          {
            sub_CA0E80(v241, v30);
            v31 = *(_BYTE **)(v30 + 32);
            if ( (unsigned __int64)v31 >= *(_QWORD *)(v30 + 24) )
            {
              sub_CB5D20(v30, 10);
            }
            else
            {
              *(_QWORD *)(v30 + 32) = v31 + 1;
              *v31 = 10;
            }
            v32 = *(_QWORD *)a1;
            v33 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v33;
            if ( v32 )
            {
              sub_A62C00((const char *)a2, v32, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v35 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v35 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
                goto LABEL_416;
              *(_QWORD *)(v34 + 32) = v35 + 1;
              *v35 = 10;
            }
          }
          else
          {
            v169 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v169;
          }
          goto LABEL_20;
        }
        if ( !*(_BYTE *)(a2 + 32) )
          goto LABEL_20;
        v107 = sub_B91420(*(_QWORD *)(a2 + 24));
        v109 = v108;
        v110 = *(_DWORD *)(a2 + 16);
        if ( v110 > 3 )
        {
          v243 = 1;
          v112 = "invalid checksum kind";
          goto LABEL_230;
        }
        v111 = (unsigned int)(v110 - 1);
        if ( (unsigned int)v111 <= 2 )
          v3 = *(_QWORD *)&asc_3F63FE0[8 * v111];
        if ( v3 != v109 )
        {
          v243 = 1;
          v112 = "invalid checksum length";
          goto LABEL_230;
        }
        if ( !v109 )
          goto LABEL_20;
        v202 = (char *)v107;
        v203 = v109;
        while ( 1 )
        {
          v237 = v203;
          if ( !(unsigned __int8)sub_BD8D80((__int64 (__fastcall *)(_QWORD))sub_BD8D40, *v202) )
            break;
          ++v202;
          v203 = v237 - 1;
          if ( v237 == 1 )
            goto LABEL_20;
        }
        if ( v109 - v237 != -1 )
        {
          v243 = 1;
          v112 = "invalid checksum";
LABEL_230:
          v241[0] = v112;
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
          goto LABEL_477;
        }
        goto LABEL_20;
      case 0x11:
        if ( (*(_BYTE *)(a2 + 1) & 0x7F) != 1 )
        {
          v36 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "compile units must be distinct";
          v242 = 3;
          if ( !v36 )
          {
            v168 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v168;
            goto LABEL_20;
          }
          sub_CA0E80(v241, v36);
          v37 = *(_BYTE **)(v36 + 32);
          if ( (unsigned __int64)v37 >= *(_QWORD *)(v36 + 24) )
          {
            sub_CB5D20(v36, 10);
          }
          else
          {
            *(_QWORD *)(v36 + 32) = v37 + 1;
            *v37 = 10;
          }
          v38 = *(_QWORD *)a1;
          v39 = *(_BYTE *)(a1 + 154);
          *(_BYTE *)(a1 + 153) = 1;
          *(_BYTE *)(a1 + 152) |= v39;
          if ( !v38 )
            goto LABEL_20;
          goto LABEL_477;
        }
        if ( (unsigned __int16)sub_AF18C0(a2) != 17 )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
          goto LABEL_477;
        }
        if ( *(_BYTE *)a2 == 16 )
        {
          v186 = *(_QWORD *)sub_A17150((_BYTE *)(a2 - 16));
          if ( !v186 )
            goto LABEL_434;
        }
        else
        {
          v119 = *(_BYTE *)(a2 - 16);
          if ( (v119 & 2) != 0 )
            v120 = *(const char ***)(a2 - 32);
          else
            v120 = (const char **)(a2 - 16 - 8LL * ((v119 >> 2) & 0xF));
          v235 = *v120;
          if ( !*v120 || *v235 != 16 )
          {
            v121 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "invalid file";
            v242 = 3;
            if ( v121 )
            {
              sub_CA0E80(v241, v121);
              v122 = *(_BYTE **)(v121 + 32);
              if ( (unsigned __int64)v122 >= *(_QWORD *)(v121 + 24) )
              {
                sub_CB5D20(v121, 10);
              }
              else
              {
                *(_QWORD *)(v121 + 32) = v122 + 1;
                *v122 = 10;
              }
              v123 = *(_QWORD *)a1;
              v124 = *(_BYTE *)(a1 + 154);
              *(_BYTE *)(a1 + 153) = 1;
              *(_BYTE *)(a1 + 152) |= v124;
              if ( v123 )
              {
                sub_BD9900((__int64 *)a1, (const char *)a2);
                if ( v235 )
                  sub_BD9900((__int64 *)a1, v235);
              }
            }
            else
            {
              v198 = *(_BYTE *)(a1 + 154);
              *(_BYTE *)(a1 + 153) = 1;
              *(_BYTE *)(a1 + 152) |= v198;
            }
            goto LABEL_20;
          }
          v185 = sub_A17150((_BYTE *)(a2 - 16));
          v186 = *(_QWORD *)sub_A17150((_BYTE *)(*(_QWORD *)v185 - 16LL));
          if ( !v186 )
            goto LABEL_475;
        }
        sub_B91420(v186);
        if ( v187 )
        {
          if ( *(_DWORD *)(a2 + 32) <= 3u )
          {
            v188 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 4);
            v239 = v188;
            if ( !v188 )
            {
LABEL_439:
              v205 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 5);
              v238 = v205;
              if ( v205 )
              {
                if ( *v205 != 5 )
                {
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid retained type list";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v238);
                  goto LABEL_20;
                }
                v206 = sub_A17150((_BYTE *)(a2 - 16));
                v207 = sub_A17150((_BYTE *)(*((_QWORD *)v206 + 5) - 16LL));
                for ( j = &v207[8 * v208]; j != v207; v207 += 8 )
                {
                  v211 = *(_QWORD *)v207;
                  v239 = (const char *)v211;
                  if ( v211 )
                  {
                    v210 = *(_BYTE *)v211;
                    if ( *(_BYTE *)v211 <= 0x24u && ((1LL << v210) & 0x140000F000LL) != 0 )
                      continue;
                    if ( v210 == 18 && (*(_BYTE *)(v211 + 36) & 8) == 0 )
                      continue;
                  }
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid retained type";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v239);
                  goto LABEL_20;
                }
              }
              v212 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 6);
              v238 = v212;
              if ( v212 )
              {
                if ( *v212 != 5 )
                {
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid global variable list";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v238);
                  goto LABEL_20;
                }
                v213 = sub_A17150((_BYTE *)(a2 - 16));
                v214 = (const char **)sub_A17150((_BYTE *)(*((_QWORD *)v213 + 6) - 16LL));
                v216 = &v214[v215];
                while ( v216 != v214 )
                {
                  v217 = *v214;
                  v239 = v217;
                  if ( v217 )
                  {
                    ++v214;
                    if ( *v217 == 8 )
                      continue;
                  }
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid global variable ref";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v239);
                  goto LABEL_20;
                }
              }
              v218 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 7);
              v238 = v218;
              if ( v218 )
              {
                if ( *v218 != 5 )
                {
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid imported entity list";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v238);
                  goto LABEL_20;
                }
                v219 = sub_A17150((_BYTE *)(a2 - 16));
                v220 = (const char **)sub_A17150((_BYTE *)(*((_QWORD *)v219 + 7) - 16LL));
                v222 = &v220[v221];
                while ( v220 != v222 )
                {
                  v223 = *v220;
                  v239 = v223;
                  if ( v223 )
                  {
                    ++v220;
                    if ( *v223 == 29 )
                      continue;
                  }
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid imported entity ref";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v239);
                  goto LABEL_20;
                }
              }
              v224 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 8);
              v238 = v224;
              if ( v224 )
              {
                if ( *v224 != 5 )
                {
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid macro list";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v238);
                  goto LABEL_20;
                }
                v225 = sub_A17150((_BYTE *)(a2 - 16));
                v226 = (const char **)sub_A17150((_BYTE *)(*((_QWORD *)v225 + 8) - 16LL));
                v228 = &v226[v227];
                while ( v226 != v228 )
                {
                  v229 = *v226;
                  v239 = v229;
                  if ( v229 )
                  {
                    ++v226;
                    if ( (unsigned int)*(unsigned __int8 *)v229 - 31 <= 1 )
                      continue;
                  }
                  v240 = (const char *)a2;
                  v243 = 1;
                  v241[0] = "invalid macro ref";
                  v242 = 3;
                  sub_BE2A60(a1, (__int64)v241, &v240, &v239);
                  goto LABEL_20;
                }
              }
              sub_BE1AF0((__int64)v241, a1 + 768, a2);
              v18 = *(_BYTE *)(a2 - 16);
              v19 = (v18 & 2) != 0;
LABEL_21:
              if ( v19 )
              {
LABEL_22:
                v20 = *(__int64 **)(a2 - 32);
LABEL_23:
                v21 = *(unsigned int *)(a2 - 24);
              }
              else
              {
LABEL_29:
                v25 = 8LL * ((v18 >> 2) & 0xF);
LABEL_30:
                v20 = (__int64 *)(a2 - v25 - 16);
                v21 = (*(_WORD *)(a2 - 16) >> 6) & 0xF;
              }
              v26 = (unsigned __int8 **)&v20[v21];
              if ( v26 == (unsigned __int8 **)v20 )
              {
LABEL_42:
                if ( (*(_BYTE *)(a2 + 1) & 0x7F) == 2 )
                {
                  v240 = (const char *)a2;
                  v29 = "Expected no forward declarations!";
                  v243 = 1;
                }
                else
                {
                  if ( !*(_DWORD *)(a2 - 8) )
                    return;
                  v240 = (const char *)a2;
                  v29 = "All nodes should be resolved!";
                  v243 = 1;
                }
                v241[0] = v29;
                v242 = 3;
                sub_BE1BE0((_BYTE *)a1, (__int64)v241, &v240);
                return;
              }
              while ( 1 )
              {
                if ( !*v20 )
                  goto LABEL_34;
                v27 = *(unsigned __int8 *)*v20;
                if ( (_BYTE)v27 == 2 )
                {
                  v231 = (const char *)*v20;
                  v243 = 1;
                  v241[0] = "Invalid operand for global metadata!";
                  v242 = 3;
                  sub_BDBF70((__int64 *)a1, (__int64)v241);
                  if ( !*(_QWORD *)a1 )
                    return;
                  goto LABEL_49;
                }
                if ( a3 != 1 && (_BYTE)v27 == 6 )
                {
                  v231 = (const char *)*v20;
                  v243 = 1;
                  v241[0] = "DILocation not allowed within this metadata node";
                  v242 = 3;
                  sub_BDD6D0((__int64 *)a1, (__int64)v241);
                  if ( !*(_QWORD *)a1 )
                    return;
LABEL_49:
                  sub_BD9900((__int64 *)a1, (const char *)a2);
                  sub_BD9900((__int64 *)a1, v231);
                  return;
                }
                if ( (unsigned __int8)(v27 - 5) <= 0x1Fu )
                {
                  sub_BE3890(a1, *v20, a3);
LABEL_34:
                  if ( v26 == (unsigned __int8 **)++v20 )
                    goto LABEL_42;
                }
                else
                {
                  if ( (unsigned int)(v27 - 1) > 1 )
                    goto LABEL_34;
                  v28 = *v20++;
                  sub_BDC5E0(a1, v28, 0);
                  if ( v26 == (unsigned __int8 **)v20 )
                    goto LABEL_42;
                }
              }
            }
            if ( *v188 != 5 )
            {
              v240 = (const char *)a2;
              v243 = 1;
              v241[0] = "invalid enum list";
              v242 = 3;
              sub_BE2A60(a1, (__int64)v241, &v240, &v239);
              goto LABEL_20;
            }
            v189 = sub_A17150((_BYTE *)(a2 - 16));
            v190 = (const char **)sub_A17150((_BYTE *)(*((_QWORD *)v189 + 4) - 16LL));
            v192 = &v190[v191];
            v193 = v190;
            v236 = v192;
            do
            {
              if ( v236 == v193 )
                goto LABEL_439;
              v70 = *v193;
              v230 = v193;
              if ( !*v193 )
                break;
              if ( *v70 != 14 )
                break;
              v194 = sub_AF18C0((__int64)v70);
              v193 = v230 + 1;
            }
            while ( v194 == 4 );
            v195 = (const char *)*((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 4);
            if ( v195 )
            {
              v243 = 1;
              v241[0] = "invalid enum type";
              v242 = 3;
              sub_BDD6D0((__int64 *)a1, (__int64)v241);
              if ( !*(_QWORD *)a1 )
                goto LABEL_20;
              sub_BD9900((__int64 *)a1, (const char *)a2);
              sub_BD9900((__int64 *)a1, v195);
            }
            else
            {
              v243 = 1;
              v241[0] = "invalid enum type";
              v242 = 3;
              sub_BDD6D0((__int64 *)a1, (__int64)v241);
              if ( !*(_QWORD *)a1 )
                goto LABEL_20;
              sub_BD9900((__int64 *)a1, (const char *)a2);
            }
            if ( !v70 )
              goto LABEL_20;
LABEL_159:
            sub_BD9900((__int64 *)a1, v70);
LABEL_20:
            v18 = *(_BYTE *)(a2 - 16);
            v19 = (v18 & 2) != 0;
            goto LABEL_21;
          }
          v243 = 1;
          v241[0] = "invalid emission kind";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
LABEL_477:
          sub_BD9900((__int64 *)a1, (const char *)a2);
          goto LABEL_20;
        }
        if ( *(_BYTE *)a2 == 16 )
        {
LABEL_434:
          v243 = 1;
          v241[0] = "invalid filename";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
          goto LABEL_435;
        }
LABEL_475:
        v5 = *(const char **)sub_A17150((_BYTE *)(a2 - 16));
        if ( !v5 )
        {
          v243 = 1;
          v241[0] = "invalid filename";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
          goto LABEL_477;
        }
        goto LABEL_434;
      case 0x12:
        sub_BE2DD0((__int64 *)a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x13:
        sub_BDDA40(a1, (const char *)a2);
        if ( !*(_DWORD *)(a2 + 4) )
        {
          if ( *(_WORD *)(a2 + 16) )
          {
            v243 = 1;
            v241[0] = "cannot have column info without line info";
            v242 = 3;
            sub_BDD6D0((__int64 *)a1, (__int64)v241);
            if ( *(_QWORD *)a1 )
              goto LABEL_477;
          }
        }
        goto LABEL_20;
      case 0x14:
        sub_BDDA40(a1, (const char *)a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x15:
        if ( (unsigned __int16)sub_AF18C0(a2) != 57 )
        {
          v149 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v149 )
          {
            sub_CA0E80(v241, v149);
            v150 = *(_BYTE **)(v149 + 32);
            if ( (unsigned __int64)v150 >= *(_QWORD *)(v149 + 24) )
            {
              sub_CB5D20(v149, 10);
            }
            else
            {
              *(_QWORD *)(v149 + 32) = v150 + 1;
              *v150 = 10;
            }
            v151 = *(_QWORD *)a1;
            v152 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v152;
            if ( v151 )
            {
              sub_A62C00((const char *)a2, v151, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v153 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v153 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
                goto LABEL_416;
              *(_QWORD *)(v34 + 32) = v153 + 1;
              *v153 = 10;
            }
          }
          else
          {
            v199 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v199;
          }
          goto LABEL_20;
        }
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        if ( (v18 & 2) != 0 )
        {
          v20 = *(__int64 **)(a2 - 32);
          v40 = (unsigned __int8 *)v20[1];
          if ( !v40 )
            goto LABEL_23;
        }
        else
        {
          v25 = 8LL * ((v18 >> 2) & 0xF);
          v40 = *(unsigned __int8 **)(a2 - v25 - 8);
          if ( !v40 )
            goto LABEL_30;
        }
        v41 = *v40;
        if ( (unsigned __int8)v41 > 0x24u || (v42 = 0x16007FF000LL, !_bittest64(&v42, v41)) )
        {
          v43 = *(_QWORD *)a1;
          v232 = v40;
          v243 = 1;
          v241[0] = "invalid scope ref";
          v242 = 3;
          if ( v43 )
          {
            sub_CA0E80(v241, v43);
            v44 = *(_BYTE **)(v43 + 32);
            v45 = (const char *)v232;
            if ( (unsigned __int64)v44 >= *(_QWORD *)(v43 + 24) )
            {
              sub_CB5D20(v43, 10);
              v46 = *(_QWORD *)a1;
              v45 = (const char *)v232;
            }
            else
            {
              *(_QWORD *)(v43 + 32) = v44 + 1;
              *v44 = 10;
              v46 = *(_QWORD *)a1;
            }
            v233 = v45;
            *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            if ( v46 )
            {
              sub_BD9900((__int64 *)a1, (const char *)a2);
              sub_BD9900((__int64 *)a1, v233);
            }
          }
          else
          {
            v201 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v201;
          }
          goto LABEL_20;
        }
        goto LABEL_21;
      case 0x16:
        if ( (unsigned __int16)sub_AF18C0(a2) != 30 )
        {
          v47 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v47 )
          {
            sub_CA0E80(v241, v47);
            v48 = *(_BYTE **)(v47 + 32);
            if ( (unsigned __int64)v48 >= *(_QWORD *)(v47 + 24) )
            {
              sub_CB5D20(v47, 10);
            }
            else
            {
              *(_QWORD *)(v47 + 32) = v48 + 1;
              *v48 = 10;
            }
            v49 = *(_QWORD *)a1;
            v50 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v50;
            if ( v49 )
            {
              sub_A62C00((const char *)a2, v49, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v51 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v51 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
                goto LABEL_416;
              *(_QWORD *)(v34 + 32) = v51 + 1;
              *v51 = 10;
            }
          }
          else
          {
            v174 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v174;
          }
          goto LABEL_20;
        }
        v113 = *(_BYTE *)(a2 - 16);
        if ( (v113 & 2) != 0 )
          v114 = *(_QWORD *)(a2 - 32);
        else
          v114 = a2 - 16 - 8LL * ((v113 >> 2) & 0xF);
        v115 = *(_QWORD *)(v114 + 16);
        if ( v115 )
        {
          sub_B91420(v115);
          if ( v116 )
            goto LABEL_20;
        }
        v117 = *(_QWORD *)a1;
        v243 = 1;
        v241[0] = "anonymous module";
        v242 = 3;
        if ( v117 )
        {
          sub_CA0E80(v241, v117);
          v118 = *(_BYTE **)(v117 + 32);
          if ( (unsigned __int64)v118 >= *(_QWORD *)(v117 + 24) )
          {
            sub_CB5D20(v117, 10);
          }
          else
          {
            *(_QWORD *)(v117 + 32) = v118 + 1;
            *v118 = 10;
          }
        }
        *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
        v80 = *(_QWORD *)a1 == 0;
        *(_BYTE *)(a1 + 153) = 1;
        if ( v80 )
          goto LABEL_20;
        goto LABEL_477;
      case 0x17:
        sub_BDAE60(a1, (const char *)a2);
        if ( (unsigned __int16)sub_AF18C0(a2) != 47 )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 0x18:
        sub_BDAE60(a1, (const char *)a2);
        if ( (unsigned __int16)sub_AF18C0(a2) != 48
          && (unsigned __int16)sub_AF18C0(a2) != 16646
          && (unsigned __int16)sub_AF18C0(a2) != 16647 )
        {
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( *(_QWORD *)a1 )
            goto LABEL_477;
        }
        goto LABEL_20;
      case 0x19:
        sub_BDDCF0(a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x1A:
        v81 = a2 - 16;
        sub_BDA950(a1, (const char *)a2);
        v82 = *(_BYTE *)(a2 - 16);
        if ( (v82 & 2) != 0 )
          v83 = *(_QWORD *)(a2 - 32);
        else
          v83 = v81 - 8LL * ((v82 >> 2) & 0xF);
        v56 = *(const char **)(v83 + 24);
        if ( v56 )
        {
          v84 = *(unsigned __int8 *)v56;
          if ( (unsigned __int8)v84 > 0x24u || (v85 = 0x140000F000LL, !_bittest64(&v85, v84)) )
          {
            v86 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "invalid type ref";
            v242 = 3;
            if ( !v86 )
            {
              v167 = *(_BYTE *)(a1 + 154);
              *(_BYTE *)(a1 + 153) = 1;
              *(_BYTE *)(a1 + 152) |= v167;
              goto LABEL_20;
            }
            sub_CA0E80(v241, v86);
            v87 = *(_BYTE **)(v86 + 32);
            if ( (unsigned __int64)v87 >= *(_QWORD *)(v86 + 24) )
            {
              sub_CB5D20(v86, 10);
            }
            else
            {
              *(_QWORD *)(v86 + 32) = v87 + 1;
              *v87 = 10;
            }
            v88 = *(_QWORD *)a1;
            v89 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v89;
            if ( !v88 )
              goto LABEL_20;
LABEL_346:
            sub_BD9900((__int64 *)a1, (const char *)a2);
            sub_BD9900((__int64 *)a1, v56);
            goto LABEL_20;
          }
        }
        if ( (unsigned __int16)sub_AF18C0(a2) != 52 )
        {
          v159 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( !v159 )
          {
            v197 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v197;
            goto LABEL_20;
          }
          sub_CA0E80(v241, v159);
          v160 = *(_BYTE **)(v159 + 32);
          if ( (unsigned __int64)v160 >= *(_QWORD *)(v159 + 24) )
          {
            sub_CB5D20(v159, 10);
          }
          else
          {
            *(_QWORD *)(v159 + 32) = v160 + 1;
            *v160 = 10;
          }
          v161 = *(_QWORD *)a1;
          v162 = *(_BYTE *)(a1 + 154);
          *(_BYTE *)(a1 + 153) = 1;
          *(_BYTE *)(a1 + 152) |= v162;
          if ( !v161 )
            goto LABEL_20;
          goto LABEL_477;
        }
        v18 = *(_BYTE *)(a2 - 16);
        if ( (v18 & 2) != 0 )
        {
          v103 = *(_QWORD **)(a2 - 32);
          if ( !*v103 || (unsigned __int8)(*(_BYTE *)*v103 - 18) > 2u )
          {
            v104 = *(const char ***)(a2 - 32);
LABEL_215:
            v98 = *v104;
            v105 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "local variable requires a valid scope";
            v242 = 3;
            if ( v105 )
            {
              sub_CA0E80(v241, v105);
              v106 = *(_BYTE **)(v105 + 32);
              if ( (unsigned __int64)v106 >= *(_QWORD *)(v105 + 24) )
              {
                sub_CB5D20(v105, 10);
              }
              else
              {
                *(_QWORD *)(v105 + 32) = v106 + 1;
                *v106 = 10;
              }
            }
            *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
            v80 = *(_QWORD *)a1 == 0;
            *(_BYTE *)(a1 + 153) = 1;
            if ( v80 )
              goto LABEL_20;
            sub_BD9900((__int64 *)a1, (const char *)a2);
            if ( !v98 )
              goto LABEL_20;
LABEL_198:
            sub_BD9900((__int64 *)a1, v98);
            goto LABEL_20;
          }
          v5 = (const char *)v103[3];
          if ( !v5 || *v5 != 15 )
            goto LABEL_22;
        }
        else
        {
          v154 = (_QWORD *)(v81 - 8LL * ((v18 >> 2) & 0xF));
          if ( !*v154 || (unsigned __int8)(*(_BYTE *)*v154 - 18) > 2u )
          {
            v104 = (const char **)(v81 - 8LL * ((v18 >> 2) & 0xF));
            goto LABEL_215;
          }
          v5 = (const char *)v154[3];
          if ( !v5 || *v5 != 15 )
            goto LABEL_29;
        }
        v243 = 1;
        v241[0] = "invalid type";
        v242 = 3;
        sub_BDD6D0((__int64 *)a1, (__int64)v241);
        if ( !*(_QWORD *)a1 )
          goto LABEL_20;
        goto LABEL_435;
      case 0x1B:
        v90 = *(_BYTE *)(a2 - 16);
        v91 = a2 - 16;
        if ( (v90 & 2) != 0 )
        {
          v92 = *(const char ***)(a2 - 32);
          v5 = *v92;
          if ( !*v92 )
            goto LABEL_186;
        }
        else
        {
          v92 = (const char **)(v91 - 8LL * ((v90 >> 2) & 0xF));
          v5 = *v92;
          if ( !*v92 )
            goto LABEL_186;
        }
        v93 = *(unsigned __int8 *)v5;
        if ( (unsigned __int8)v93 > 0x24u || (v94 = 0x16007FF000LL, !_bittest64(&v94, v93)) )
        {
          v243 = 1;
          v241[0] = "invalid scope";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
          goto LABEL_435;
        }
LABEL_186:
        v56 = v92[2];
        if ( v56 && *v56 != 16 )
        {
          v163 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid file";
          v242 = 3;
          if ( !v163 )
          {
            v184 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v184;
            goto LABEL_20;
          }
          sub_CA0E80(v241, v163);
          v164 = *(_BYTE **)(v163 + 32);
          if ( (unsigned __int64)v164 >= *(_QWORD *)(v163 + 24) )
          {
            sub_CB5D20(v163, 10);
          }
          else
          {
            *(_QWORD *)(v163 + 32) = v164 + 1;
            *v164 = 10;
          }
          v165 = *(_QWORD *)a1;
          v166 = *(_BYTE *)(a1 + 154);
          *(_BYTE *)(a1 + 153) = 1;
          *(_BYTE *)(a1 + 152) |= v166;
          if ( !v165 )
            goto LABEL_20;
          goto LABEL_346;
        }
        v234 = a2 - 16;
        if ( (unsigned __int16)sub_AF18C0(a2) != 10 )
        {
          v176 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( !v176 )
          {
            v180 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v180;
            goto LABEL_20;
          }
          sub_CA0E80(v241, v176);
          v177 = *(_BYTE **)(v176 + 32);
          if ( (unsigned __int64)v177 >= *(_QWORD *)(v176 + 24) )
          {
            sub_CB5D20(v176, 10);
          }
          else
          {
            *(_QWORD *)(v176 + 32) = v177 + 1;
            *v177 = 10;
          }
          v178 = *(_QWORD *)a1;
          v179 = *(_BYTE *)(a1 + 154);
          *(_BYTE *)(a1 + 153) = 1;
          *(_BYTE *)(a1 + 152) |= v179;
          if ( !v178 )
            goto LABEL_20;
          goto LABEL_477;
        }
        v95 = *(_BYTE *)(a2 - 16);
        if ( (v95 & 2) != 0 )
        {
          v20 = *(__int64 **)(a2 - 32);
          if ( *v20 && (unsigned __int8)(*(_BYTE *)*v20 - 18) <= 2u )
            goto LABEL_23;
          v96 = *(const char ***)(a2 - 32);
        }
        else
        {
          v25 = 8LL * ((v95 >> 2) & 0xF);
          v175 = *(_BYTE **)(v234 - v25);
          if ( v175 && (unsigned __int8)(*v175 - 18) <= 2u )
            goto LABEL_30;
          v96 = (const char **)(v234 - 8LL * ((v95 >> 2) & 0xF));
        }
        v97 = *(_QWORD *)a1;
        v98 = *v96;
        v243 = 1;
        v241[0] = "label requires a valid scope";
        v242 = 3;
        if ( v97 )
        {
          sub_CA0E80(v241, v97);
          v99 = *(_BYTE **)(v97 + 32);
          if ( (unsigned __int64)v99 >= *(_QWORD *)(v97 + 24) )
          {
            sub_CB5D20(v97, 10);
          }
          else
          {
            *(_QWORD *)(v97 + 32) = v99 + 1;
            *v99 = 10;
          }
        }
        *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
        v80 = *(_QWORD *)a1 == 0;
        *(_BYTE *)(a1 + 153) = 1;
        if ( v80 )
          goto LABEL_20;
        sub_BD9900((__int64 *)a1, (const char *)a2);
        if ( !v98 )
          goto LABEL_20;
        goto LABEL_198;
      case 0x1C:
        if ( (unsigned __int16)sub_AF18C0(a2) != 16896 )
        {
          v144 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v144 )
          {
            sub_CA0E80(v241, v144);
            v145 = *(_BYTE **)(v144 + 32);
            if ( (unsigned __int64)v145 >= *(_QWORD *)(v144 + 24) )
            {
              sub_CB5D20(v144, 10);
            }
            else
            {
              *(_QWORD *)(v144 + 32) = v145 + 1;
              *v145 = 10;
            }
            v146 = *(_QWORD *)a1;
            v147 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v147;
            if ( v146 )
            {
              sub_A62C00((const char *)a2, v146, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v148 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v148 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
                goto LABEL_416;
              *(_QWORD *)(v34 + 32) = v148 + 1;
              *v148 = 10;
            }
          }
          else
          {
            v204 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v204;
          }
          goto LABEL_20;
        }
        v18 = *(_BYTE *)(a2 - 16);
        if ( (v18 & 2) != 0 )
        {
          v52 = *(_QWORD *)(a2 - 32);
          v5 = *(const char **)(v52 + 32);
          if ( v5 )
          {
            v53 = *(unsigned __int8 *)v5;
            if ( (unsigned __int8)v53 > 0x24u )
              goto LABEL_115;
            v54 = 0x140000F000LL;
            if ( !_bittest64(&v54, v53) )
              goto LABEL_115;
          }
          v5 = *(const char **)(v52 + 8);
          if ( !v5 || *v5 == 16 )
            goto LABEL_22;
        }
        else
        {
          v139 = a2 - 16 - 8LL * ((v18 >> 2) & 0xF);
          v5 = *(const char **)(v139 + 32);
          if ( v5 )
          {
            v140 = *(unsigned __int8 *)v5;
            if ( (unsigned __int8)v140 > 0x24u || (v141 = 0x140000F000LL, !_bittest64(&v141, v140)) )
            {
LABEL_115:
              v243 = 1;
              v241[0] = "invalid type ref";
              v242 = 3;
              sub_BDD6D0((__int64 *)a1, (__int64)v241);
              if ( !*(_QWORD *)a1 )
                goto LABEL_20;
              goto LABEL_435;
            }
          }
          v5 = *(const char **)(v139 + 8);
          if ( !v5 || *v5 == 16 )
            goto LABEL_29;
        }
        v142 = *(_QWORD *)a1;
        v243 = 1;
        v241[0] = "invalid file";
        v242 = 3;
        if ( v142 )
        {
          sub_CA0E80(v241, v142);
          v143 = *(_BYTE **)(v142 + 32);
          if ( (unsigned __int64)v143 >= *(_QWORD *)(v142 + 24) )
          {
            sub_CB5D20(v142, 10);
          }
          else
          {
            *(_QWORD *)(v142 + 32) = v143 + 1;
            *v143 = 10;
          }
        }
        *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
        v80 = *(_QWORD *)a1 == 0;
        *(_BYTE *)(a1 + 153) = 1;
        if ( v80 )
          goto LABEL_20;
        goto LABEL_435;
      case 0x1D:
        if ( (unsigned __int16)sub_AF18C0(a2) != 58 && (unsigned __int16)sub_AF18C0(a2) != 8 )
        {
          v170 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v170 )
          {
            sub_CA0E80(v241, v170);
            v171 = *(_BYTE **)(v170 + 32);
            if ( (unsigned __int64)v171 >= *(_QWORD *)(v170 + 24) )
            {
              sub_CB5D20(v170, 10);
            }
            else
            {
              *(_QWORD *)(v170 + 32) = v171 + 1;
              *v171 = 10;
            }
          }
          *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
          v80 = *(_QWORD *)a1 == 0;
          *(_BYTE *)(a1 + 153) = 1;
          if ( v80 )
            goto LABEL_20;
          goto LABEL_477;
        }
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        if ( (v18 & 2) != 0 )
        {
          v55 = *(const char ***)(a2 - 32);
          v56 = *v55;
          if ( !*v55
            || (v57 = *(unsigned __int8 *)v56, (unsigned __int8)v57 <= 0x24u)
            && (v58 = 0x16007FF000LL, _bittest64(&v58, v57)) )
          {
            v56 = v55[1];
            if ( !v56 )
              goto LABEL_22;
            goto LABEL_124;
          }
        }
        else
        {
          v125 = a2 - 16 - 8LL * ((v18 >> 2) & 0xF);
          v56 = *(const char **)v125;
          if ( !*(_QWORD *)v125
            || (v126 = *(unsigned __int8 *)v56, (unsigned __int8)v126 <= 0x24u)
            && (v127 = 0x16007FF000LL, _bittest64(&v127, v126)) )
          {
            v56 = *(const char **)(v125 + 8);
            if ( !v56 )
              goto LABEL_29;
LABEL_124:
            v59 = *v56;
            if ( *v56 > 0x1Eu )
            {
              if ( (unsigned __int8)(v59 - 33) <= 3u )
                goto LABEL_21;
            }
            else if ( (unsigned __int8)v59 > 8u )
            {
              goto LABEL_21;
            }
            v60 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "invalid imported entity";
            v242 = 3;
            if ( !v60 )
            {
              v183 = *(_BYTE *)(a1 + 154);
              *(_BYTE *)(a1 + 153) = 1;
              *(_BYTE *)(a1 + 152) |= v183;
              goto LABEL_20;
            }
            sub_CA0E80(v241, v60);
            v61 = *(_BYTE **)(v60 + 32);
            if ( (unsigned __int64)v61 >= *(_QWORD *)(v60 + 24) )
            {
              sub_CB5D20(v60, 10);
            }
            else
            {
              *(_QWORD *)(v60 + 32) = v61 + 1;
              *v61 = 10;
            }
            v62 = *(_QWORD *)a1;
            v63 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v63;
            if ( !v62 )
              goto LABEL_20;
            goto LABEL_346;
          }
        }
        v155 = *(_QWORD *)a1;
        v243 = 1;
        v241[0] = "invalid scope for imported entity";
        v242 = 3;
        if ( !v155 )
        {
          v196 = *(_BYTE *)(a1 + 154);
          *(_BYTE *)(a1 + 153) = 1;
          *(_BYTE *)(a1 + 152) |= v196;
          goto LABEL_20;
        }
        sub_CA0E80(v241, v155);
        v156 = *(_BYTE **)(v155 + 32);
        if ( (unsigned __int64)v156 >= *(_QWORD *)(v155 + 24) )
        {
          sub_CB5D20(v155, 10);
        }
        else
        {
          *(_QWORD *)(v155 + 32) = v156 + 1;
          *v156 = 10;
        }
        v157 = *(_QWORD *)a1;
        v158 = *(_BYTE *)(a1 + 154);
        *(_BYTE *)(a1 + 153) = 1;
        *(_BYTE *)(a1 + 152) |= v158;
        if ( !v157 )
          goto LABEL_20;
        goto LABEL_346;
      case 0x1E:
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        if ( (v18 & 2) != 0 )
          v64 = *(_DWORD *)(a2 - 24);
        else
          v64 = (*(_WORD *)(a2 - 16) >> 6) & 0xF;
        if ( v64 )
        {
          v243 = 1;
          v241[0] = "DIAssignID has no arguments";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
        }
        else
        {
          if ( (*(_BYTE *)(a2 + 1) & 0x7F) == 1 )
            goto LABEL_21;
          v243 = 1;
          v241[0] = "DIAssignID must be distinct";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
        }
        goto LABEL_477;
      case 0x1F:
        if ( (unsigned int)*(unsigned __int16 *)(a2 + 2) - 1 > 1 )
        {
          v243 = 1;
          v241[0] = "invalid macinfo type";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
        }
        else
        {
          v100 = *(_QWORD *)sub_A17150((_BYTE *)(a2 - 16));
          if ( v100 )
          {
            sub_B91420(v100);
            if ( v101 )
            {
              v102 = *((_QWORD *)sub_A17150((_BYTE *)(a2 - 16)) + 1);
              if ( !v102 )
                goto LABEL_20;
              sub_B91420(v102);
              v18 = *(_BYTE *)(a2 - 16);
              v19 = (v18 & 2) != 0;
              goto LABEL_21;
            }
          }
          v243 = 1;
          v241[0] = "anonymous macro";
          v242 = 3;
          sub_BDD6D0((__int64 *)a1, (__int64)v241);
          if ( !*(_QWORD *)a1 )
            goto LABEL_20;
        }
        goto LABEL_477;
      case 0x20:
        if ( *(_WORD *)(a2 + 2) != 3 )
        {
          v133 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid macinfo type";
          v242 = 3;
          if ( v133 )
          {
            sub_CA0E80(v241, v133);
            v134 = *(_BYTE **)(v133 + 32);
            if ( (unsigned __int64)v134 >= *(_QWORD *)(v133 + 24) )
            {
              sub_CB5D20(v133, 10);
            }
            else
            {
              *(_QWORD *)(v133 + 32) = v134 + 1;
              *v134 = 10;
            }
            v135 = *(_QWORD *)a1;
            v136 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v136;
            if ( v135 )
            {
              sub_A62C00((const char *)a2, v135, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v137 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v137 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
                goto LABEL_416;
              *(_QWORD *)(v34 + 32) = v137 + 1;
              *v137 = 10;
            }
          }
          else
          {
            v181 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v181;
          }
          goto LABEL_20;
        }
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        if ( (v18 & 2) != 0 )
        {
          v65 = *(const char ***)(a2 - 32);
          v56 = *v65;
          if ( !*v65 || *v56 == 16 )
          {
            v5 = v65[1];
            if ( !v5 )
              goto LABEL_22;
            goto LABEL_148;
          }
        }
        else
        {
          v138 = a2 - 16 - 8LL * ((v18 >> 2) & 0xF);
          v56 = *(const char **)v138;
          if ( !*(_QWORD *)v138 || *v56 == 16 )
          {
            v5 = *(const char **)(v138 + 8);
            if ( !v5 )
              goto LABEL_29;
LABEL_148:
            if ( *v5 != 5 )
            {
              v243 = 1;
              v241[0] = "invalid macro list";
              v242 = 3;
              sub_BDD6D0((__int64 *)a1, (__int64)v241);
              if ( !*(_QWORD *)a1 )
                goto LABEL_20;
              goto LABEL_435;
            }
            v66 = *(v5 - 16);
            if ( (v66 & 2) != 0 )
            {
              v67 = (const char **)*((_QWORD *)v5 - 4);
              v68 = *((unsigned int *)v5 - 6);
            }
            else
            {
              v68 = (*((_WORD *)v5 - 8) >> 6) & 0xF;
              v67 = (const char **)&v5[-8 * ((v66 >> 2) & 0xF) - 16];
            }
            v69 = &v67[v68];
            if ( v67 == v69 )
              goto LABEL_21;
            while ( 1 )
            {
              v70 = *v67;
              if ( !*v67 || (unsigned int)*(unsigned __int8 *)v70 - 31 > 1 )
                break;
              if ( v69 == ++v67 )
                goto LABEL_21;
            }
            v71 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "invalid macro ref";
            v242 = 3;
            if ( !v71 )
            {
              v200 = *(_BYTE *)(a1 + 154);
              *(_BYTE *)(a1 + 153) = 1;
              *(_BYTE *)(a1 + 152) |= v200;
              goto LABEL_20;
            }
            sub_CA0E80(v241, v71);
            v72 = *(_BYTE **)(v71 + 32);
            if ( (unsigned __int64)v72 >= *(_QWORD *)(v71 + 24) )
            {
              sub_CB5D20(v71, 10);
            }
            else
            {
              *(_QWORD *)(v71 + 32) = v72 + 1;
              *v72 = 10;
            }
            v73 = *(_QWORD *)a1;
            v74 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v74;
            if ( !v73 )
              goto LABEL_20;
            sub_BD9900((__int64 *)a1, (const char *)a2);
            if ( !v70 )
              goto LABEL_20;
            goto LABEL_159;
          }
        }
        v172 = *(_QWORD *)a1;
        v243 = 1;
        v241[0] = "invalid file";
        v242 = 3;
        if ( v172 )
        {
          sub_CA0E80(v241, v172);
          v173 = *(_BYTE **)(v172 + 32);
          if ( (unsigned __int64)v173 >= *(_QWORD *)(v172 + 24) )
          {
            sub_CB5D20(v172, 10);
          }
          else
          {
            *(_QWORD *)(v172 + 32) = v173 + 1;
            *v173 = 10;
          }
        }
        *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
        v80 = *(_QWORD *)a1 == 0;
        *(_BYTE *)(a1 + 153) = 1;
        if ( v80 )
          goto LABEL_20;
        goto LABEL_346;
      case 0x21:
        if ( (unsigned __int16)sub_AF18C0(a2) != 26 )
        {
          v128 = *(_QWORD *)a1;
          v243 = 1;
          v241[0] = "invalid tag";
          v242 = 3;
          if ( v128 )
          {
            sub_CA0E80(v241, v128);
            v129 = *(_BYTE **)(v128 + 32);
            if ( (unsigned __int64)v129 >= *(_QWORD *)(v128 + 24) )
            {
              sub_CB5D20(v128, 10);
            }
            else
            {
              *(_QWORD *)(v128 + 32) = v129 + 1;
              *v129 = 10;
            }
            v130 = *(_QWORD *)a1;
            v131 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v131;
            if ( v130 )
            {
              sub_A62C00((const char *)a2, v130, a1 + 16, *(_QWORD *)(a1 + 8));
              v34 = *(_QWORD *)a1;
              v132 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
              if ( (unsigned __int64)v132 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
              {
LABEL_416:
                sub_CB5D20(v34, 10);
              }
              else
              {
                *(_QWORD *)(v34 + 32) = v132 + 1;
                *v132 = 10;
              }
            }
          }
          else
          {
            v182 = *(_BYTE *)(a1 + 154);
            *(_BYTE *)(a1 + 153) = 1;
            *(_BYTE *)(a1 + 152) |= v182;
          }
          goto LABEL_20;
        }
        v18 = *(_BYTE *)(a2 - 16);
        if ( (v18 & 2) != 0 )
        {
          v75 = *(const char ***)(a2 - 32);
          v5 = *v75;
          if ( !*v75
            || (v76 = *(unsigned __int8 *)v5, (unsigned __int8)v76 <= 0x24u)
            && (v77 = 0x16007FF000LL, _bittest64(&v77, v76)) )
          {
            v5 = v75[1];
            if ( !v5 || *v5 == 25 )
              goto LABEL_22;
            goto LABEL_167;
          }
        }
        else
        {
          v22 = a2 - 16 - 8LL * ((v18 >> 2) & 0xF);
          v5 = *(const char **)v22;
          if ( !*(_QWORD *)v22
            || (v23 = *(unsigned __int8 *)v5, (unsigned __int8)v23 <= 0x24u)
            && (v24 = 0x16007FF000LL, _bittest64(&v24, v23)) )
          {
            v5 = *(const char **)(v22 + 8);
            if ( !v5 || *v5 == 25 )
              goto LABEL_29;
LABEL_167:
            v78 = *(_QWORD *)a1;
            v243 = 1;
            v241[0] = "invalid declaration";
            v242 = 3;
            if ( v78 )
            {
              sub_CA0E80(v241, v78);
              v79 = *(_BYTE **)(v78 + 32);
              if ( (unsigned __int64)v79 >= *(_QWORD *)(v78 + 24) )
              {
                sub_CB5D20(v78, 10);
              }
              else
              {
                *(_QWORD *)(v78 + 32) = v79 + 1;
                *v79 = 10;
              }
            }
            *(_BYTE *)(a1 + 152) |= *(_BYTE *)(a1 + 154);
            v80 = *(_QWORD *)a1 == 0;
            *(_BYTE *)(a1 + 153) = 1;
            if ( v80 )
              goto LABEL_20;
LABEL_435:
            sub_BD9900((__int64 *)a1, (const char *)a2);
            sub_BD9900((__int64 *)a1, v5);
            goto LABEL_20;
          }
        }
        v243 = 1;
        v241[0] = "invalid scope ref";
        v242 = 3;
        sub_BDD6D0((__int64 *)a1, (__int64)v241);
        if ( !*(_QWORD *)a1 )
          goto LABEL_20;
        goto LABEL_435;
      case 0x22:
        sub_BDAC80(a1, a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x23:
        sub_BDF4C0(a1, (const char *)a2);
        v18 = *(_BYTE *)(a2 - 16);
        v19 = (v18 & 2) != 0;
        goto LABEL_21;
      case 0x24:
        sub_BDF850((__int64 *)a1, (const char *)a2);
        goto LABEL_20;
      default:
        BUG();
    }
  }
  v13 = *(_QWORD *)a1;
  v243 = 1;
  v241[0] = "MDNode context does not match Module context!";
  v242 = 3;
  if ( v13 )
  {
    sub_CA0E80(v241, v13);
    v14 = *(_BYTE **)(v13 + 32);
    if ( (unsigned __int64)v14 >= *(_QWORD *)(v13 + 24) )
    {
      sub_CB5D20(v13, 10);
    }
    else
    {
      *(_QWORD *)(v13 + 32) = v14 + 1;
      *v14 = 10;
    }
    v15 = *(_QWORD *)a1;
    *(_BYTE *)(a1 + 152) = 1;
    if ( v15 )
    {
      sub_A62C00((const char *)a2, v15, a1 + 16, *(_QWORD *)(a1 + 8));
      v16 = *(_QWORD *)a1;
      v17 = *(_BYTE **)(*(_QWORD *)a1 + 32LL);
      if ( (unsigned __int64)v17 >= *(_QWORD *)(*(_QWORD *)a1 + 24LL) )
      {
        sub_CB5D20(v16, 10);
      }
      else
      {
        *(_QWORD *)(v16 + 32) = v17 + 1;
        *v17 = 10;
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 152) = 1;
  }
}
