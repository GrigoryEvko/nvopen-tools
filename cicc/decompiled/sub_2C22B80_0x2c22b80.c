// Function: sub_2C22B80
// Address: 0x2c22b80
//
__int64 __fastcall sub_2C22B80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // r12
  int v8; // eax
  __int64 v9; // rdx
  char v10; // r13
  __int64 v11; // r14
  __int64 v12; // rax
  int v13; // esi
  __int64 v14; // r14
  char v16; // r13
  __int64 v17; // r14
  _BYTE *v18; // rax
  unsigned int v19; // esi
  __int64 v20; // r13
  __int64 v21; // rbx
  __int64 v22; // rax
  unsigned __int64 v23; // r14
  __int64 v24; // rax
  __int64 v25; // r15
  _QWORD *v26; // rax
  __int64 *v27; // rdi
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 *v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  const char *v35; // rax
  unsigned int v36; // ebx
  __int64 v37; // rax
  __int64 v38; // r14
  __int64 v39; // rsi
  __int64 v40; // r13
  __int64 v41; // rax
  __int64 *v42; // rcx
  __int64 v43; // rdx
  _QWORD *v44; // rax
  unsigned int v45; // edx
  unsigned int v46; // esi
  char v47; // al
  __int64 v48; // rax
  int v49; // eax
  int v50; // r14d
  __int64 v51; // r13
  __int64 v52; // rax
  unsigned int v53; // eax
  __int64 *v54; // rdi
  __int64 v55; // r14
  __int64 v56; // rbx
  __int64 v57; // rax
  int v58; // r15d
  int v59; // eax
  unsigned int v60; // eax
  __int64 *v61; // rax
  __int64 v62; // rax
  int v63; // ecx
  __int64 *v64; // rax
  __int64 v65; // rdx
  __int64 v66; // rdx
  __int64 v67; // rdx
  __int64 v68; // r13
  _BYTE *v69; // rax
  char v70; // r8
  int v71; // r13d
  __int64 *v72; // rax
  __int64 v73; // r15
  _BYTE *v74; // r13
  __int64 v75; // rbx
  __int64 v76; // r13
  __int64 v77; // rax
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 *v80; // r13
  __int64 v81; // rax
  __int64 *v82; // r15
  __int64 *v83; // r12
  __int64 v84; // rax
  __int64 v85; // rdi
  __int64 v86; // r8
  __int64 v87; // r9
  int v88; // ecx
  unsigned int v89; // edx
  __int64 *v90; // rax
  __int64 v91; // r10
  __int64 v92; // rax
  __int64 v93; // r12
  const char *v94; // r13
  __int64 v95; // rax
  __int64 v96; // rax
  __int64 v97; // r12
  __int64 v98; // rax
  __int64 *v99; // rax
  __int64 v100; // rax
  _QWORD *v101; // rax
  __int64 *v102; // rax
  __int64 v103; // r13
  _BYTE *v104; // rax
  __int64 v105; // r13
  _QWORD *v106; // rax
  __int64 v107; // rax
  __int64 *v108; // rax
  _QWORD *v109; // rax
  __int64 *v110; // rax
  __int64 v111; // rax
  __int64 v112; // rax
  _BYTE *v113; // rax
  _BYTE *v114; // r14
  __int64 *v115; // rax
  __int64 v116; // rax
  __int64 v117; // rax
  __int64 v118; // r13
  __int64 v119; // r15
  __int64 v120; // rax
  __int64 v121; // rax
  char v122; // r13
  __int64 v123; // r14
  __int64 v124; // rax
  __int64 v125; // rcx
  __int16 v126; // dx
  unsigned int v127; // ecx
  __int64 v128; // rdx
  int v129; // r14d
  int v130; // r15d
  __int64 v131; // rbx
  __int64 v132; // rcx
  __int64 v133; // rcx
  __int64 v134; // rdx
  __int64 v135; // rax
  bool v136; // zf
  __int64 v137; // rcx
  int v138; // eax
  int v139; // r11d
  __int64 v140; // [rsp+8h] [rbp-108h]
  unsigned int v141; // [rsp+10h] [rbp-100h]
  unsigned int v142; // [rsp+1Ch] [rbp-F4h]
  __int64 v143; // [rsp+28h] [rbp-E8h]
  int v144; // [rsp+30h] [rbp-E0h]
  __int64 v145; // [rsp+30h] [rbp-E0h]
  __int64 v146; // [rsp+38h] [rbp-D8h]
  __int64 v147; // [rsp+40h] [rbp-D0h]
  __int64 v148; // [rsp+48h] [rbp-C8h]
  int v149; // [rsp+48h] [rbp-C8h]
  int v150; // [rsp+48h] [rbp-C8h]
  __int64 *v151; // [rsp+48h] [rbp-C8h]
  const char *v152; // [rsp+48h] [rbp-C8h]
  __int64 v153; // [rsp+48h] [rbp-C8h]
  unsigned int v154; // [rsp+48h] [rbp-C8h]
  __int64 v155; // [rsp+58h] [rbp-B8h]
  _BYTE *v156; // [rsp+60h] [rbp-B0h] BYREF
  __int64 v157; // [rsp+68h] [rbp-A8h]
  _BYTE v158[16]; // [rsp+70h] [rbp-A0h] BYREF
  const char *v159; // [rsp+80h] [rbp-90h] BYREF
  __int64 v160; // [rsp+88h] [rbp-88h]
  __int64 v161; // [rsp+90h] [rbp-80h]
  __int16 v162; // [rsp+98h] [rbp-78h]
  char v163; // [rsp+9Ah] [rbp-76h]
  __int16 v164; // [rsp+A0h] [rbp-70h]
  const char *v165[4]; // [rsp+B0h] [rbp-60h] BYREF
  __int16 v166; // [rsp+D0h] [rbp-40h]

  v6 = a2;
  v7 = *(_QWORD *)(a2 + 904);
  v8 = *(unsigned __int8 *)(a1 + 160);
  v9 = (unsigned int)(v8 - 13);
  if ( (unsigned int)v9 <= 0x11 )
  {
    v10 = sub_2C46C30(a1 + 96);
    v11 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), v10);
    v12 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), v10);
    v13 = *(unsigned __int8 *)(a1 + 160);
    HIDWORD(v159) = 0;
    v166 = 260;
    v165[0] = (const char *)(a1 + 168);
    v14 = sub_2C137C0(v7, v13, v11, v12, (unsigned int)v159, (__int64)v165, 0);
    if ( *(_BYTE *)v14 > 0x1Cu )
      sub_2AAF930(a1, (unsigned __int8 *)v14);
  }
  else
  {
    switch ( (char)v8 )
    {
      case '5':
        v16 = sub_2C46C30(a1 + 96);
        v17 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), v16);
        v18 = (_BYTE *)sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), v16);
        v19 = *(_DWORD *)(a1 + 156);
        v166 = 260;
        v165[0] = (const char *)(a1 + 168);
        if ( v19 > 0xF )
          return sub_92B530((unsigned int **)v7, v19, v17, v18, (__int64)v165);
        HIDWORD(v159) = 0;
        return sub_B35C90(v7, v19, v17, (__int64)v18, (__int64)v165, 0, (unsigned int)v159, 0);
      case '9':
        v122 = sub_2C46C30(a1 + 96);
        v123 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), v122);
        v153 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), v122);
        v124 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16LL), v122);
        v165[0] = (const char *)(a1 + 168);
        v166 = 260;
        return sub_B36550((unsigned int **)v7, v123, v153, v124, (__int64)v165, 0);
      case 'E':
        v14 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 0);
        if ( (unsigned int)*(unsigned __int8 *)(*(_QWORD *)(v14 + 8) + 8LL) - 17 <= 1 )
        {
          v121 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), 0);
          v165[0] = (const char *)(a1 + 168);
          v166 = 260;
          return sub_B37300((unsigned int **)v7, v14, v121, -1, (__int64)v165);
        }
        return v14;
      case 'F':
        v117 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 0);
        v164 = 260;
        v159 = (const char *)(a1 + 168);
        v118 = v117;
        v119 = sub_AD62B0(*(_QWORD *)(v117 + 8));
        v14 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64))(**(_QWORD **)(v7 + 80) + 16LL))(
                *(_QWORD *)(v7 + 80),
                30,
                v118,
                v119);
        if ( v14 )
          return v14;
        v166 = 257;
        v120 = sub_B504D0(30, v118, v119, (__int64)v165, 0, 0);
        v27 = *(__int64 **)(v7 + 88);
        v28 = *(_QWORD *)(v7 + 56);
        v14 = v120;
        v29 = *(_QWORD *)(v7 + 64);
        v30 = *v27;
        goto LABEL_12;
      case 'I':
        v110 = *(__int64 **)(a1 + 48);
        BYTE4(v165[0]) = 0;
        LODWORD(v165[0]) = 0;
        v111 = sub_2BFB120(a2, *v110, (unsigned int *)v165);
        BYTE4(v165[0]) = 0;
        v152 = (const char *)v111;
        v112 = *(_QWORD *)(a1 + 48);
        LODWORD(v165[0]) = 0;
        v113 = (_BYTE *)sub_2BFB120(a2, *(_QWORD *)(v112 + 8), (unsigned int *)v165);
        v114 = v113;
        if ( !*(_BYTE *)(a2 + 12) && *(_DWORD *)(a2 + 8) == 1 )
        {
          v166 = 260;
          v165[0] = (const char *)(a1 + 168);
          return sub_92B530((unsigned int **)v7, 0x24u, (__int64)v152, v113, (__int64)v165);
        }
        else
        {
          v115 = (__int64 *)sub_BCB2A0(*(_QWORD **)(v7 + 72));
          v116 = sub_BCE1B0(v115, *(_QWORD *)(a2 + 8));
          v165[0] = (const char *)(a1 + 168);
          v160 = (__int64)v114;
          v166 = 260;
          v159 = v152;
          BYTE4(v155) = 0;
          v156 = (_BYTE *)v116;
          v157 = *((_QWORD *)v114 + 1);
          return sub_B33D10(v7, 0xB9u, (__int64)&v156, 2, (int)&v159, 2, v155, (__int64)v165);
        }
      case 'J':
        v92 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 1);
        v93 = *(unsigned int *)(a2 + 8);
        v94 = (const char *)v92;
        v95 = sub_BCB2D0(*(_QWORD **)(*(_QWORD *)(a2 + 904) + 72LL));
        v96 = sub_ACD640(v95, v93, 0);
        v97 = *(_QWORD *)(a2 + 904);
        v159 = v94;
        v166 = 257;
        HIDWORD(v156) = 0;
        v160 = v96;
        v161 = sub_ACD6D0(*(__int64 **)(v97 + 72));
        v98 = sub_BCB2D0(*(_QWORD **)(*(_QWORD *)(a2 + 904) + 72LL));
        return sub_B35180(v97, v98, 0x98u, (__int64)&v159, 3u, (unsigned int)v156, (__int64)v165);
      case 'K':
        v166 = 260;
        v165[0] = (const char *)(a1 + 168);
        v78 = sub_2BFD6A0(a2 + 976, a1 + 96);
        v79 = sub_D5C860((__int64 *)v7, v78, 2, (__int64)v165);
        v80 = *(__int64 **)(a1 + 48);
        v14 = v79;
        v81 = *(_QWORD *)(a1 + 80);
        v82 = *(__int64 **)(v81 + 56);
        v151 = &v80[*(unsigned int *)(a1 + 56)];
        v83 = &v82[*(unsigned int *)(v81 + 64)];
        if ( v83 == v82 || v80 == &v80[*(unsigned int *)(a1 + 56)] )
          return v14;
        while ( 1 )
        {
          v84 = sub_2BFB640(a2, *v80, 1);
          v85 = *v82;
          v86 = v84;
          if ( (*(_BYTE *)(a2 + 128) & 1) != 0 )
          {
            v87 = a2 + 136;
            v88 = 3;
          }
          else
          {
            v125 = *(unsigned int *)(a2 + 144);
            v87 = *(_QWORD *)(a2 + 136);
            if ( !(_DWORD)v125 )
              goto LABEL_97;
            v88 = v125 - 1;
          }
          v89 = v88 & (((unsigned int)v85 >> 9) ^ ((unsigned int)v85 >> 4));
          v90 = (__int64 *)(v87 + 16LL * v89);
          v91 = *v90;
          if ( v85 == *v90 )
            goto LABEL_59;
          v138 = 1;
          while ( v91 != -4096 )
          {
            v139 = v138 + 1;
            v89 = v88 & (v138 + v89);
            v90 = (__int64 *)(v87 + 16LL * v89);
            v91 = *v90;
            if ( v85 == *v90 )
              goto LABEL_59;
            v138 = v139;
          }
          if ( (*(_BYTE *)(a2 + 128) & 1) != 0 )
          {
            v137 = 64;
            goto LABEL_98;
          }
          v125 = *(unsigned int *)(a2 + 144);
LABEL_97:
          v137 = 16 * v125;
LABEL_98:
          v90 = (__int64 *)(v87 + v137);
LABEL_59:
          ++v82;
          ++v80;
          sub_F0A850(v14, v86, v90[1]);
          if ( v83 == v82 || v151 == v80 )
            return v14;
        }
      case 'L':
        v71 = **(_DWORD **)(sub_2BF9BD0(*(_QWORD *)(a1 + 80)) + 144);
        v72 = *(__int64 **)(a1 + 48);
        LODWORD(v165[0]) = 0;
        BYTE4(v165[0]) = 0;
        v73 = sub_2BFB120(a2, *v72, (unsigned int *)v165);
        v74 = (_BYTE *)sub_2AB26E0(v7, *(_QWORD *)(v73 + 8), *(_QWORD *)(a2 + 8), v71);
        v166 = 257;
        v75 = sub_929DE0((unsigned int **)v7, (_BYTE *)v73, v74, (__int64)v165, 0, 0);
        v166 = 257;
        v76 = sub_92B530((unsigned int **)v7, 0x22u, v73, v74, (__int64)v165);
        v77 = sub_AD64C0(*(_QWORD *)(v73 + 8), 0, 0);
        v166 = 257;
        return sub_B36550((unsigned int **)v7, v76, v75, v77, (__int64)v165, 0);
      case 'M':
        v63 = 0;
        v64 = *(__int64 **)(a1 + 48);
        if ( *(_DWORD *)(a1 + 56) == 2 )
        {
          v65 = v64[1];
          if ( v65 )
          {
            v66 = *(_QWORD *)(v65 + 40);
            if ( *(_DWORD *)(v66 + 32) <= 0x40u )
              v67 = *(_QWORD *)(v66 + 24);
            else
              v67 = **(_QWORD **)(v66 + 24);
            v63 = v67;
          }
        }
        LODWORD(v165[0]) = 0;
        BYTE4(v165[0]) = 0;
        v150 = v63;
        v68 = sub_2BFB120(a2, *v64, (unsigned int *)v165);
        v69 = (_BYTE *)sub_2AB26E0(v7, *(_QWORD *)(v68 + 8), *(_QWORD *)(a2 + 8), v150);
        v70 = *(_BYTE *)(a1 + 156);
        v165[0] = (const char *)(a1 + 168);
        v166 = 260;
        return sub_929C50((unsigned int **)v7, (_BYTE *)v68, v69, (__int64)v165, v70 & 1, (v70 & 2) != 0);
      case 'N':
        v103 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 1);
        v104 = (_BYTE *)sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), 1);
        v166 = 257;
        v105 = sub_92B530((unsigned int **)v7, 0x20u, v103, v104, (__int64)v165);
        v106 = (_QWORD *)sub_2BF9BD0(*(_QWORD *)(a1 + 80));
        v107 = sub_2BF3F10(v106);
        v165[0] = (const char *)sub_2BF04D0(*(_QWORD *)(v107 + 112));
        v108 = sub_2ACA740(a2 + 120, (__int64 *)v165);
        v14 = sub_F94450((__int64 *)v7, v105, *(_QWORD *)(v7 + 48), *v108, 0, 0);
        sub_AC2B30(v14 - 32, 0);
        v109 = (_QWORD *)sub_986580(*(_QWORD *)(v7 + 48));
        sub_B43D60(v109);
        return v14;
      case 'O':
        v99 = *(__int64 **)(a1 + 48);
        BYTE4(v165[0]) = 0;
        LODWORD(v165[0]) = 0;
        v100 = sub_2BFB120(a2, *v99, (unsigned int *)v165);
        v14 = sub_F94450((__int64 *)v7, v100, *(_QWORD *)(v7 + 48), 0, 0, 0);
        sub_AC2B30(v14 - 32, 0);
        v101 = (_QWORD *)sub_986580(*(_QWORD *)(v7 + 48));
        sub_B43D60(v101);
        if ( sub_2BF0A20(*(_QWORD *)(a1 + 80)) )
        {
          v165[0] = (const char *)sub_2BF04D0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 48LL));
          v102 = sub_2ACA740(a2 + 120, (__int64 *)v165);
          sub_AC2B30(v14 - 64, *v102);
        }
        return v14;
      case 'P':
        v165[0] = "broadcast";
        v61 = *(__int64 **)(a1 + 48);
        v166 = 259;
        v62 = sub_2BFB640(a2, *v61, 1);
        return sub_B37620((unsigned int **)v7, *(_QWORD *)(a2 + 8), v62, (__int64 *)v165);
      case 'Q':
        v48 = **(_QWORD **)(a1 + 48);
        v147 = v48;
        if ( !v48 )
          goto LABEL_106;
        v146 = *(_QWORD *)(v48 + 56);
        v140 = *(_QWORD *)(v48 + 40);
        v144 = *(_DWORD *)(v146 + 40);
        v143 = *(_QWORD *)(v140 + 8);
        v49 = *(_DWORD *)(a1 + 56);
        v156 = v158;
        v149 = v49;
        v157 = 0x200000000LL;
        v50 = v49 - 1;
        v142 = v49 - 1;
        sub_2B3D4E0((__int64)&v156, (unsigned int)(v49 - 1), v9, 0x200000000LL, a5, a6);
        if ( v50 )
        {
          v51 = 8;
          do
          {
            v52 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + v51), *(_BYTE *)(v147 + 64));
            *(_QWORD *)&v156[v51 - 8] = v52;
            v51 += 8;
          }
          while ( 8LL * (unsigned int)(v149 - 2) + 16 != v51 );
        }
        v53 = *(_DWORD *)(a2 + 8);
        if ( *(_BYTE *)(a2 + 12) )
        {
          if ( !v53 )
            goto LABEL_35;
        }
        else if ( v53 <= 1 )
        {
          goto LABEL_35;
        }
        v54 = *(__int64 **)(v146 + 56);
        if ( (__int64 *)v143 != v54 )
        {
          v55 = sub_BCE1B0(v54, *(_QWORD *)(a2 + 8));
          if ( v142 )
          {
            v56 = 0;
            do
            {
              v166 = 257;
              v57 = sub_A82DA0((unsigned int **)v7, *(_QWORD *)&v156[v56], v55, (__int64)v165, 0, 0);
              *(_QWORD *)&v156[v56] = v57;
              v56 += 8;
            }
            while ( 8LL * v142 != v56 );
            v6 = a2;
          }
        }
LABEL_35:
        v58 = 29;
        v14 = *(_QWORD *)v156;
        v59 = sub_1022EF0(*(_DWORD *)(v146 + 40));
        v141 = v144 - 17;
        if ( (unsigned int)(v144 - 17) > 1 )
          v58 = v59;
        if ( *(_BYTE *)(v147 + 65) )
        {
          v14 = *(_QWORD *)&v156[8 * (v149 - 2)];
        }
        else
        {
          v159 = (const char *)v7;
          LODWORD(v160) = *(_DWORD *)(v7 + 104);
          v161 = *(_QWORD *)(v7 + 96);
          v126 = *(_WORD *)(v7 + 108);
          v163 = *(_BYTE *)(v7 + 110);
          v162 = v126;
          *(_DWORD *)(v7 + 104) = *(_DWORD *)(v146 + 44);
          if ( v142 > 1 )
          {
            v127 = v58 - 53;
            v128 = v14;
            v129 = v58;
            v130 = v144;
            v154 = v127;
            v145 = v6;
            v131 = 8;
            do
            {
              if ( v154 <= 1 )
              {
                v132 = *(_QWORD *)&v156[v131];
                if ( (unsigned int)(v130 - 19) <= 1 )
                  v128 = sub_F6F180(v7, 7, v128, v132);
                else
                  v128 = sub_F6F180(v7, v130, v128, v132);
              }
              else
              {
                v133 = v128;
                v134 = *(_QWORD *)&v156[v131];
                v165[0] = "bin.rdx";
                v166 = 259;
                v128 = sub_2C137C0(v7, v129, v134, v133, (unsigned int)v155, (__int64)v165, 0);
              }
              v131 += 8;
            }
            while ( v131 != 8LL * v142 );
            v6 = v145;
            v14 = v128;
          }
          sub_2C135A0(&v159);
        }
        v60 = *(_DWORD *)(v6 + 8);
        if ( (*(_BYTE *)(v6 + 12) && v60 || v60 > 1 || v141 <= 3) && !*(_BYTE *)(v147 + 64) )
        {
          v135 = sub_F703A0(v7, v146, v14, v140);
          v14 = v135;
          if ( v143 != *(_QWORD *)(v146 + 56) )
          {
            v136 = *(_BYTE *)(v146 + 64) == 0;
            v166 = 257;
            if ( v136 )
            {
              v14 = sub_A82F30((unsigned int **)v7, v135, v143, (__int64)v165, 0);
            }
            else
            {
              HIDWORD(v159) = 0;
              v14 = sub_2C13D90(v7, 40, v135, v143, (__int64)v165, 0, (unsigned int)v159);
            }
          }
        }
        if ( v156 != v158 )
          _libc_free((unsigned __int64)v156);
        return v14;
      case 'R':
        v42 = *(__int64 **)(a1 + 48);
        v43 = *(_QWORD *)(v42[1] + 40);
        v44 = *(_QWORD **)(v43 + 24);
        if ( *(_DWORD *)(v43 + 32) > 0x40u )
          v44 = (_QWORD *)*v44;
        v45 = *(_DWORD *)(a2 + 8);
        if ( *(_BYTE *)(a2 + 12) )
        {
          if ( v45 )
          {
            v46 = v45 - (_DWORD)v44;
            v47 = 1;
LABEL_21:
            LODWORD(v165[0]) = v46;
            BYTE4(v165[0]) = v47;
            v14 = sub_2BFB120(v6, *v42, (unsigned int *)v165);
            goto LABEL_22;
          }
        }
        else
        {
          v46 = v45 - (_DWORD)v44;
          v47 = 0;
          if ( v45 > 1 )
            goto LABEL_21;
        }
        v14 = sub_2BFB640(v6, *v42, 0);
LABEL_22:
        if ( *(_BYTE *)v14 == 90 )
        {
          v166 = 260;
          v165[0] = (const char *)(a1 + 168);
          sub_BD6B50((unsigned __int8 *)v14, v165);
        }
        break;
      case 'S':
        v38 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 0);
        v39 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL);
        v165[0] = (const char *)(a1 + 168);
        v166 = 260;
        v40 = sub_2BFB640(v6, v39, 0);
        v41 = sub_AD6530(*(_QWORD *)(v40 + 8), v39);
        return sub_B36550((unsigned int **)v7, v38, v40, v41, (__int64)v165, 0);
      case 'T':
        v32 = *(__int64 **)(a1 + 48);
        BYTE4(v165[0]) = 0;
        LODWORD(v165[0]) = 0;
        v33 = sub_2BFB120(a2, *v32, (unsigned int *)v165);
        BYTE4(v165[0]) = 0;
        v148 = v33;
        v34 = *(_QWORD *)(a1 + 48);
        LODWORD(v165[0]) = 0;
        v35 = (const char *)sub_2BFB120(a2, *(_QWORD *)(v34 + 8), (unsigned int *)v165);
        v36 = *(_DWORD *)(a1 + 156);
        v165[0] = (const char *)(a1 + 168);
        v166 = 260;
        v159 = v35;
        v37 = sub_BCB2B0(*(_QWORD **)(v7 + 72));
        return sub_921130((unsigned int **)v7, v37, v148, (_BYTE **)&v159, 1, (__int64)v165, v36);
      case 'U':
        v31 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 0);
        return sub_B34870(v7, v31);
      case 'V':
        v20 = sub_2BFB640(a2, **(_QWORD **)(a1 + 48), 0);
        v21 = sub_2BFB640(a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL), 0);
        v166 = 259;
        v165[0] = "first.active.lane";
        v22 = sub_BCB2E0(*(_QWORD **)(v7 + 72));
        v159 = (const char *)v21;
        v23 = v22;
        BYTE4(v155) = 0;
        v24 = sub_BCB2A0(*(_QWORD **)(v7 + 72));
        v156 = (_BYTE *)v23;
        v160 = sub_ACD640(v24, 1, 0);
        v157 = *(_QWORD *)(v21 + 8);
        v25 = sub_B33D10(v7, 0x91u, (__int64)&v156, 2, (int)&v159, 2, v155, (__int64)v165);
        v164 = 259;
        v159 = "early.exit.value";
        v14 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(v7 + 80) + 96LL))(
                *(_QWORD *)(v7 + 80),
                v20,
                v25);
        if ( v14 )
          return v14;
        v166 = 257;
        v26 = sub_BD2C40(72, 2u);
        v14 = (__int64)v26;
        if ( v26 )
          sub_B4DE80((__int64)v26, v20, v25, (__int64)v165, 0, 0);
        v27 = *(__int64 **)(v7 + 88);
        v28 = *(_QWORD *)(v7 + 56);
        v29 = *(_QWORD *)(v7 + 64);
        v30 = *v27;
LABEL_12:
        (*(void (__fastcall **)(__int64 *, __int64, const char **, __int64, __int64))(v30 + 16))(
          v27,
          v14,
          &v159,
          v28,
          v29);
        sub_94AAF0((unsigned int **)v7, v14);
        return v14;
      default:
LABEL_106:
        BUG();
    }
  }
  return v14;
}
