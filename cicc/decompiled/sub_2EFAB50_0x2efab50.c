// Function: sub_2EFAB50
// Address: 0x2efab50
//
void __fastcall sub_2EFAB50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v7; // r14
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 *v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rsi
  bool v13; // zf
  _QWORD *v14; // rax
  _QWORD *v15; // rdx
  _QWORD *v16; // rax
  _QWORD *v17; // rdi
  _QWORD *v18; // rax
  __int64 *v19; // rbx
  __int64 v20; // rsi
  _QWORD *v21; // rax
  _QWORD *v22; // rdx
  _QWORD *v23; // rax
  _QWORD *v24; // rdi
  _QWORD *v25; // rax
  _QWORD *v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rax
  int v30; // eax
  __int64 v31; // rdi
  __int64 (*v32)(); // rax
  int v33; // r11d
  _QWORD *v34; // rdi
  __int64 v35; // rax
  unsigned int v36; // esi
  _QWORD *v37; // r12
  __int64 v39; // rdx
  __int64 v40; // r8
  __m128i *v41; // rdx
  __m128i v42; // xmm0
  __int64 v43; // rsi
  _QWORD *v44; // rdi
  __int64 v45; // rdx
  _WORD *v46; // rdx
  __int64 v47; // r8
  __m128i *v48; // rdx
  __m128i si128; // xmm0
  char *v50; // rax
  unsigned int v52; // r10d
  int v53; // ebx
  __int16 *v54; // r12
  unsigned int v55; // esi
  unsigned int v56; // r13d
  __int64 v57; // rdi
  unsigned int v58; // ecx
  _DWORD *v59; // rdx
  int v60; // eax
  int v61; // eax
  unsigned int v62; // eax
  unsigned int v63; // r10d
  unsigned int v64; // esi
  __int64 v65; // rdx
  int v66; // ecx
  unsigned __int64 v67; // r9
  unsigned __int64 v68; // r9
  int v71; // eax
  int v72; // ecx
  __int64 v73; // rdi
  __int64 v74; // rax
  _DWORD *v75; // r9
  int v76; // esi
  int v77; // edx
  int v78; // r11d
  _DWORD *v79; // r8
  int v80; // r11d
  int v81; // eax
  int v82; // eax
  int v83; // eax
  __int64 v84; // rsi
  int v85; // r8d
  __int64 v86; // r14
  _DWORD *v87; // rdi
  int v88; // ecx
  unsigned int *v89; // rbx
  __int64 v90; // rax
  unsigned int *v91; // r11
  unsigned int v92; // r13d
  int v93; // ebx
  __int16 *v94; // r12
  unsigned int n; // esi
  __int64 v96; // rdi
  unsigned int v97; // ecx
  _DWORD *v98; // rdx
  int v99; // eax
  int v100; // eax
  int v101; // eax
  int v102; // ecx
  __int64 v103; // r10
  __int64 v104; // rax
  _DWORD *v105; // r9
  int v106; // edx
  int v107; // esi
  int v108; // r10d
  int v109; // eax
  int v110; // eax
  int v111; // ecx
  __int64 v112; // rdi
  int v113; // r8d
  __int64 v114; // r14
  _DWORD *v115; // rsi
  int v116; // eax
  unsigned int *v117; // r13
  unsigned int *i; // rbx
  __int64 v119; // rax
  unsigned __int64 v120; // rax
  char v121; // bl
  __int64 v122; // rax
  unsigned __int64 v123; // rdi
  int v124; // esi
  int v125; // ecx
  __int64 j; // rdi
  __int64 *v127; // rax
  unsigned __int64 v128; // rdi
  __int64 v129; // rax
  int v130; // edx
  __int64 v131; // rax
  __int64 v132; // rsi
  __int64 v133; // rax
  __int64 *v134; // r13
  __int64 *m; // r12
  __int64 v136; // rax
  __int64 v137; // rdx
  unsigned __int64 v138; // rdi
  unsigned __int64 v139; // rdx
  int v140; // esi
  __int64 v141; // rdx
  char v142; // cl
  unsigned __int64 v143; // rax
  __int64 v144; // rdx
  __int64 *v145; // rdi
  int v146; // ecx
  __int64 v147; // rax
  __int64 v148; // r12
  unsigned int v149; // r10d
  void *v150; // rax
  _BYTE *v151; // rax
  int v152; // esi
  __int64 v153; // rdx
  char v154; // cl
  unsigned __int64 v155; // rax
  __int64 v156; // rdx
  __int64 *v157; // rdi
  int v158; // ecx
  __int64 v159; // rax
  int v160; // r8d
  _DWORD *v161; // rdi
  __int64 k; // rdi
  __int64 v163; // rsi
  unsigned __int64 v164; // rdi
  int v165; // edx
  __int64 v166; // rcx
  int v167; // esi
  __int64 v168; // rax
  __int64 v169; // rdi
  _QWORD *v170; // rax
  __int64 (*v171)(); // rdx
  _QWORD *v172; // rsi
  __int64 v173; // rax
  unsigned __int64 v174; // rax
  unsigned __int64 v175; // [rsp+8h] [rbp-1C8h]
  __int64 v176; // [rsp+18h] [rbp-1B8h]
  __int64 v177; // [rsp+18h] [rbp-1B8h]
  unsigned int v178; // [rsp+18h] [rbp-1B8h]
  unsigned int v179; // [rsp+18h] [rbp-1B8h]
  unsigned int *v180; // [rsp+18h] [rbp-1B8h]
  unsigned __int64 v181; // [rsp+20h] [rbp-1B0h]
  unsigned int *v182; // [rsp+20h] [rbp-1B0h]
  unsigned int *v183; // [rsp+20h] [rbp-1B0h]
  unsigned int *v184; // [rsp+20h] [rbp-1B0h]
  __int64 *v185; // [rsp+28h] [rbp-1A8h]
  __int64 *v186; // [rsp+28h] [rbp-1A8h]
  __int64 v187; // [rsp+28h] [rbp-1A8h]
  unsigned int v188; // [rsp+28h] [rbp-1A8h]
  __int64 v189; // [rsp+30h] [rbp-1A0h] BYREF
  __int64 v190; // [rsp+38h] [rbp-198h] BYREF
  _QWORD v191[2]; // [rsp+40h] [rbp-190h] BYREF
  void (__fastcall *v192)(_QWORD *, _QWORD *, __int64); // [rsp+50h] [rbp-180h]
  void (__fastcall *v193)(_QWORD *, __int64); // [rsp+58h] [rbp-178h]
  __int64 v194; // [rsp+60h] [rbp-170h] BYREF
  char *v195; // [rsp+68h] [rbp-168h]
  __int64 v196; // [rsp+70h] [rbp-160h]
  int v197; // [rsp+78h] [rbp-158h]
  char v198; // [rsp+7Ch] [rbp-154h]
  char v199; // [rsp+80h] [rbp-150h] BYREF
  _QWORD v200[2]; // [rsp+A0h] [rbp-130h] BYREF
  _QWORD v201[6]; // [rsp+B0h] [rbp-120h] BYREF
  int v202; // [rsp+E0h] [rbp-F0h]
  _QWORD *v203; // [rsp+F0h] [rbp-E0h] BYREF
  __int64 v204; // [rsp+F8h] [rbp-D8h]
  _QWORD v205[26]; // [rsp+100h] [rbp-D0h] BYREF

  v7 = a2;
  v8 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  if ( (*(_BYTE *)(v8 + 344) & 2) == 0 && (*(_BYTE *)(**(_QWORD **)(a1 + 64) + 344LL) & 4) != 0 )
  {
    v117 = *(unsigned int **)(a2 + 192);
    for ( i = (unsigned int *)sub_2E33140(a2); v117 != i; i += 6 )
    {
      v119 = *(_QWORD *)(a1 + 56);
      a4 = *i;
      if ( (unsigned int)a4 < *(_DWORD *)(v119 + 16) )
      {
        a3 = *(_QWORD *)(*(_QWORD *)(v119 + 248) + 16LL);
        if ( *(_BYTE *)(a3 + (unsigned int)a4) )
        {
          a3 = (unsigned int)a4 >> 6;
          if ( (*(_QWORD *)(*(_QWORD *)(a1 + 200) + 8 * a3) & (1LL << a4)) == 0
            && !*(_BYTE *)(v7 + 216)
            && v7 != *(_QWORD *)(*(_QWORD *)(v7 + 32) + 328LL)
            && !*(_BYTE *)(v7 + 262) )
          {
            sub_2EF03A0(
              a1,
              "MBB has allocatable live-in, but isn't entry, landing-pad, or inlineasm-br-indirect-target.",
              v7);
            v148 = *(_QWORD *)(a1 + 16);
            v149 = *(unsigned __int16 *)i;
            v150 = *(void **)(v148 + 32);
            if ( *(_QWORD *)(v148 + 24) - (_QWORD)v150 <= 0xEu )
            {
              v188 = *(unsigned __int16 *)i;
              v168 = sub_CB6200(*(_QWORD *)(a1 + 16), "- p. register: ", 0xFu);
              v149 = v188;
              v148 = v168;
            }
            else
            {
              qmemcpy(v150, "- p. register: ", 15);
              *(_QWORD *)(v148 + 32) += 15LL;
            }
            v44 = &v203;
            v43 = v149;
            sub_2FF6320(&v203, v149, *(_QWORD *)(a1 + 56), 0, 0);
            if ( !v205[0] )
LABEL_354:
              sub_4263D6(v44, v43, v45);
            ((void (__fastcall *)(_QWORD **, __int64))v205[1])(&v203, v148);
            v151 = *(_BYTE **)(v148 + 32);
            a6 = &v203;
            if ( (unsigned __int64)v151 >= *(_QWORD *)(v148 + 24) )
            {
              sub_CB5D20(v148, 10);
              a6 = &v203;
            }
            else
            {
              a3 = (__int64)(v151 + 1);
              *(_QWORD *)(v148 + 32) = v151 + 1;
              *v151 = 10;
            }
            if ( v205[0] )
              ((void (__fastcall *)(_QWORD **, _QWORD **, __int64))v205[0])(&v203, &v203, 3);
          }
        }
      }
    }
  }
  v9 = *(_QWORD *)(v7 + 224);
  if ( v9 && (*(_WORD *)(v9 + 2) & 0x7FFF) == 0 )
    sub_2EF03A0(a1, "ir-block-address-taken is associated with basic block not used by a blockaddress.", v7);
  v10 = *(__int64 **)(v7 + 112);
  v194 = 0;
  v195 = &v199;
  v11 = *(unsigned int *)(v7 + 120);
  v196 = 4;
  v198 = 1;
  v197 = 0;
  v185 = &v10[v11];
  if ( v185 != v10 )
  {
    while ( 1 )
    {
      v12 = *v10;
      v13 = *(_BYTE *)(*v10 + 216) == 0;
      v189 = *v10;
      if ( v13 )
        goto LABEL_8;
      if ( !v198 )
        break;
      v50 = v195;
      a3 = (__int64)&v195[8 * HIDWORD(v196)];
      if ( v195 == (char *)a3 )
      {
LABEL_84:
        if ( HIDWORD(v196) >= (unsigned int)v196 )
          break;
        ++HIDWORD(v196);
        *(_QWORD *)a3 = v12;
        v12 = v189;
        ++v194;
      }
      else
      {
        while ( v12 != *(_QWORD *)v50 )
        {
          v50 += 8;
          if ( (char *)a3 == v50 )
            goto LABEL_84;
        }
        v12 = v189;
      }
LABEL_8:
      if ( !*(_BYTE *)(a1 + 132) )
      {
        if ( sub_C8CA60(a1 + 104, v12) )
          goto LABEL_13;
LABEL_77:
        sub_2EF03A0(a1, "MBB has successor that isn't part of the function.", v7);
        goto LABEL_13;
      }
      v14 = *(_QWORD **)(a1 + 112);
      v15 = &v14[*(unsigned int *)(a1 + 124)];
      if ( v14 == v15 )
        goto LABEL_77;
      while ( *v14 != v12 )
      {
        if ( v15 == ++v14 )
          goto LABEL_77;
      }
LABEL_13:
      v16 = sub_2EEFC50(a1 + 600, &v189);
      v17 = v16;
      if ( *((_BYTE *)v16 + 196) )
      {
        v18 = (_QWORD *)v16[22];
        a3 = (__int64)&v18[*((unsigned int *)v17 + 47)];
        if ( v18 != (_QWORD *)a3 )
        {
          while ( v7 != *v18 )
          {
            if ( (_QWORD *)a3 == ++v18 )
              goto LABEL_68;
          }
          goto LABEL_18;
        }
      }
      else if ( sub_C8CA60((__int64)(v16 + 21), v7) )
      {
        goto LABEL_18;
      }
LABEL_68:
      sub_2EF03A0(a1, "Inconsistent CFG", v7);
      v47 = *(_QWORD *)(a1 + 16);
      v48 = *(__m128i **)(v47 + 32);
      if ( *(_QWORD *)(v47 + 24) - (_QWORD)v48 <= 0x33u )
      {
        v47 = sub_CB6200(*(_QWORD *)(a1 + 16), "MBB is not in the predecessor list of the successor ", 0x34u);
      }
      else
      {
        si128 = _mm_load_si128((const __m128i *)&xmmword_4453DD0);
        v48[3].m128i_i32[0] = 544370547;
        *v48 = si128;
        v48[1] = _mm_load_si128((const __m128i *)&xmmword_4453DE0);
        v48[2] = _mm_load_si128((const __m128i *)&xmmword_4453DF0);
        *(_QWORD *)(v47 + 32) += 52LL;
      }
      v43 = v189;
      v177 = v47;
      v44 = v191;
      sub_2E31000(v191, v189);
      if ( !v192 )
        goto LABEL_354;
      v193(v191, v177);
      a5 = v177;
      a6 = v191;
      a3 = *(_QWORD *)(v177 + 32);
      if ( (unsigned __int64)(*(_QWORD *)(v177 + 24) - a3) <= 1 )
      {
        sub_CB6200(v177, (unsigned __int8 *)".\n", 2u);
        a6 = v191;
      }
      else
      {
        *(_WORD *)a3 = 2606;
        *(_QWORD *)(v177 + 32) += 2LL;
      }
      if ( v192 )
      {
        ++v10;
        v192(v191, v191, 3);
        if ( v185 == v10 )
          goto LABEL_19;
      }
      else
      {
LABEL_18:
        if ( v185 == ++v10 )
          goto LABEL_19;
      }
    }
    sub_C8CC70((__int64)&v194, v12, a3, a4, a5, (__int64)a6);
    v12 = v189;
    goto LABEL_8;
  }
LABEL_19:
  v19 = *(__int64 **)(v7 + 64);
  v186 = &v19[*(unsigned int *)(v7 + 72)];
  if ( v19 != v186 )
  {
    while ( 1 )
    {
      v20 = *v19;
      v13 = *(_BYTE *)(a1 + 132) == 0;
      v190 = *v19;
      if ( v13 )
        break;
      v21 = *(_QWORD **)(a1 + 112);
      v22 = &v21[*(unsigned int *)(a1 + 124)];
      if ( v21 == v22 )
        goto LABEL_66;
      while ( v20 != *v21 )
      {
        if ( v22 == ++v21 )
          goto LABEL_66;
      }
LABEL_25:
      v23 = sub_2EEFC50(a1 + 600, &v190);
      v24 = v23;
      if ( *((_BYTE *)v23 + 292) )
      {
        v25 = (_QWORD *)v23[34];
        v26 = &v25[*((unsigned int *)v24 + 71)];
        if ( v25 != v26 )
        {
          while ( v7 != *v25 )
          {
            if ( v26 == ++v25 )
              goto LABEL_57;
          }
          goto LABEL_30;
        }
      }
      else if ( sub_C8CA60((__int64)(v23 + 33), v7) )
      {
        goto LABEL_30;
      }
LABEL_57:
      sub_2EF03A0(a1, "Inconsistent CFG", v7);
      v40 = *(_QWORD *)(a1 + 16);
      v41 = *(__m128i **)(v40 + 32);
      if ( *(_QWORD *)(v40 + 24) - (_QWORD)v41 <= 0x33u )
      {
        v40 = sub_CB6200(*(_QWORD *)(a1 + 16), "MBB is not in the successor list of the predecessor ", 0x34u);
      }
      else
      {
        v42 = _mm_load_si128((const __m128i *)&xmmword_4453DD0);
        v41[3].m128i_i32[0] = 544370547;
        *v41 = v42;
        v41[1] = _mm_load_si128((const __m128i *)&xmmword_4453E00);
        v41[2] = _mm_load_si128((const __m128i *)&xmmword_4453E10);
        *(_QWORD *)(v40 + 32) += 52LL;
      }
      v43 = v190;
      v44 = v200;
      v176 = v40;
      sub_2E31000(v200, v190);
      if ( !v201[0] )
        goto LABEL_354;
      ((void (__fastcall *)(_QWORD *, __int64))v201[1])(v200, v176);
      v46 = *(_WORD **)(v176 + 32);
      if ( *(_QWORD *)(v176 + 24) - (_QWORD)v46 <= 1u )
      {
        sub_CB6200(v176, (unsigned __int8 *)".\n", 2u);
      }
      else
      {
        *v46 = 2606;
        *(_QWORD *)(v176 + 32) += 2LL;
      }
      if ( v201[0] )
      {
        ++v19;
        ((void (__fastcall *)(_QWORD *, _QWORD *, __int64))v201[0])(v200, v200, 3);
        if ( v186 == v19 )
          goto LABEL_31;
      }
      else
      {
LABEL_30:
        if ( v186 == ++v19 )
          goto LABEL_31;
      }
    }
    if ( sub_C8CA60(a1 + 104, v20) )
      goto LABEL_25;
LABEL_66:
    sub_2EF03A0(a1, "MBB has predecessor that isn't part of the function.", v7);
    goto LABEL_25;
  }
LABEL_31:
  if ( (unsigned int)(HIDWORD(v196) - v197) > 1 )
  {
    v27 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 656LL);
    if ( !v27 )
      goto LABEL_35;
    v28 = *(_QWORD *)(v7 + 16);
    if ( *(_DWORD *)(v27 + 336) != 2 || !v28 )
      goto LABEL_35;
    v120 = *(_QWORD *)(v28 + 48) & 0xFFFFFFFFFFFFFFF8LL;
    if ( v120 == v28 + 48 || !v120 || (unsigned int)*(unsigned __int8 *)(v120 - 24) - 30 > 0xA )
      BUG();
    if ( *(_BYTE *)(v120 - 24) != 32 )
    {
LABEL_35:
      v29 = sub_B2E500(**(_QWORD **)(a1 + 32));
      v30 = sub_B2A630(v29);
      if ( v30 > 10 )
      {
        if ( v30 == 12 )
          goto LABEL_38;
      }
      else if ( v30 > 6 )
      {
        goto LABEL_38;
      }
      sub_2EF03A0(a1, "MBB has more than one landing pad successor", v7);
    }
  }
LABEL_38:
  v31 = *(_QWORD *)(a1 + 48);
  v190 = 0;
  v203 = v205;
  v191[0] = 0;
  v204 = 0x400000000LL;
  v32 = *(__int64 (**)())(*(_QWORD *)v31 + 344LL);
  if ( v32 == sub_2DB1AE0 )
    goto LABEL_39;
  v121 = ((__int64 (__fastcall *)(__int64, unsigned __int64, __int64 *, _QWORD *, _QWORD **, _QWORD))v32)(
           v31,
           v7,
           &v190,
           v191,
           &v203,
           0);
  if ( v121 )
    goto LABEL_39;
  if ( v190 )
  {
    v122 = *(_QWORD *)(v7 + 48);
    if ( v191[0] )
    {
      v123 = v122 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v122 & 0xFFFFFFFFFFFFFFF8LL) == v7 + 48 )
      {
        sub_2EF03A0(a1, "MBB exits via conditional branch/branch but doesn't contain any instructions!", v7);
LABEL_251:
        if ( !(_DWORD)v204 )
          sub_2EF03A0(a1, "MBB exits via conditional branch/branch but there's no condition!", v7);
        goto LABEL_203;
      }
      if ( v123 )
      {
        v124 = *(_DWORD *)(v123 + 44);
        LOBYTE(v125) = v124;
        if ( (*(_QWORD *)v123 & 4) != 0 )
        {
          if ( (v124 & 4) != 0 )
          {
LABEL_194:
            if ( (*(_BYTE *)(*(_QWORD *)(v123 + 16) + 25LL) & 1) != 0 )
            {
              v127 = (__int64 *)(v122 & 0xFFFFFFFFFFFFFFF8LL);
              goto LABEL_196;
            }
            goto LABEL_250;
          }
        }
        else if ( (v124 & 4) != 0 )
        {
          for ( j = *(_QWORD *)v123; ; j = *(_QWORD *)v123 )
          {
            v123 = j & 0xFFFFFFFFFFFFFFF8LL;
            v125 = *(_DWORD *)(v123 + 44) & 0xFFFFFF;
            if ( (*(_DWORD *)(v123 + 44) & 4) == 0 )
              break;
          }
        }
        if ( (v125 & 8) == 0 )
          goto LABEL_194;
        if ( !sub_2E88A90(v123, 256, 1) )
        {
LABEL_250:
          sub_2EF03A0(a1, "MBB exits via conditional branch/branch but doesn't end with a barrier instruction!", v7);
          goto LABEL_251;
        }
        v127 = (__int64 *)(*(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL);
        if ( v127 )
        {
LABEL_196:
          v128 = (unsigned __int64)v127;
          v129 = *v127;
          v130 = *(_DWORD *)(v128 + 44);
          if ( (v129 & 4) != 0 )
          {
            if ( (v130 & 4) != 0 )
              goto LABEL_198;
          }
          else if ( (v130 & 4) != 0 )
          {
            for ( k = v129; ; k = *(_QWORD *)v128 )
            {
              v128 = k & 0xFFFFFFFFFFFFFFF8LL;
              v130 = *(_DWORD *)(v128 + 44) & 0xFFFFFF;
              if ( (*(_DWORD *)(v128 + 44) & 4) == 0 )
                break;
            }
          }
          if ( (v130 & 8) != 0 )
          {
            LOBYTE(v131) = sub_2E88A90(v128, 512, 1);
LABEL_199:
            if ( !(_BYTE)v131 )
              sub_2EF03A0(
                a1,
                "MBB exits via conditional branch/branch but the branch isn't a terminator instruction!",
                v7);
            goto LABEL_251;
          }
LABEL_198:
          v131 = (*(_QWORD *)(*(_QWORD *)(v128 + 16) + 24LL) >> 9) & 1LL;
          goto LABEL_199;
        }
      }
LABEL_367:
      BUG();
    }
    v138 = v122 & 0xFFFFFFFFFFFFFFF8LL;
    v139 = v7 + 48;
    if ( !(_DWORD)v204 )
    {
      if ( v138 == v139 )
      {
        sub_2EF03A0(a1, "MBB exits via unconditional branch but doesn't contain any instructions!", v7);
        goto LABEL_203;
      }
      if ( !v138 )
        goto LABEL_367;
      v140 = *(_DWORD *)(v138 + 44);
      v141 = *(_QWORD *)v138;
      v142 = v140;
      if ( (*(_QWORD *)v138 & 4) != 0 )
      {
        if ( (v140 & 4) != 0 )
          goto LABEL_319;
      }
      else if ( (v140 & 4) != 0 )
      {
        while ( 1 )
        {
          v138 = v141 & 0xFFFFFFFFFFFFFFF8LL;
          v142 = *(_DWORD *)((v141 & 0xFFFFFFFFFFFFFFF8LL) + 44);
          if ( (v142 & 4) == 0 )
            break;
          v141 = *(_QWORD *)v138;
        }
      }
      if ( (v142 & 8) != 0 )
      {
        if ( sub_2E88A90(v138, 256, 1) )
        {
          v143 = *(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL;
          if ( !v143 )
            goto LABEL_367;
LABEL_241:
          v144 = *(_QWORD *)v143;
          v145 = (__int64 *)v143;
          v146 = *(_DWORD *)(v143 + 44);
          if ( (*(_QWORD *)v143 & 4) != 0 )
          {
            if ( (v146 & 4) != 0 )
              goto LABEL_325;
          }
          else if ( (v146 & 4) != 0 )
          {
            while ( 1 )
            {
              v145 = (__int64 *)(v144 & 0xFFFFFFFFFFFFFFF8LL);
              v146 = *(_DWORD *)((v144 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 0xFFFFFF;
              if ( (*(_DWORD *)((v144 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 4) == 0 )
                break;
              v144 = *v145;
            }
          }
          if ( (v146 & 8) != 0 )
          {
            LOBYTE(v147) = sub_2E88A90((__int64)v145, 512, 1);
            goto LABEL_248;
          }
LABEL_325:
          v147 = (*(_QWORD *)(v145[2] + 24) >> 9) & 1LL;
LABEL_248:
          if ( !(_BYTE)v147 )
            sub_2EF03A0(a1, "MBB exits via unconditional branch but the branch isn't a terminator instruction!", v7);
          goto LABEL_203;
        }
        goto LABEL_323;
      }
LABEL_319:
      if ( (*(_BYTE *)(*(_QWORD *)(v138 + 16) + 25LL) & 1) != 0 )
      {
        v143 = v122 & 0xFFFFFFFFFFFFFFF8LL;
        goto LABEL_241;
      }
LABEL_323:
      sub_2EF03A0(a1, "MBB exits via unconditional branch but doesn't end with a barrier instruction!", v7);
      goto LABEL_203;
    }
    if ( v138 == v139 )
    {
      sub_2EF03A0(a1, "MBB exits via conditional branch/fall-through but doesn't contain any instructions!", v7);
      goto LABEL_203;
    }
    if ( !v138 )
      goto LABEL_367;
    v152 = *(_DWORD *)(v138 + 44);
    v153 = *(_QWORD *)v138;
    v154 = v152;
    if ( (*(_QWORD *)v138 & 4) != 0 )
    {
      if ( (v152 & 4) != 0 )
        goto LABEL_316;
    }
    else if ( (v152 & 4) != 0 )
    {
      while ( 1 )
      {
        v138 = v153 & 0xFFFFFFFFFFFFFFF8LL;
        v154 = *(_DWORD *)((v153 & 0xFFFFFFFFFFFFFFF8LL) + 44);
        if ( (v154 & 4) == 0 )
          break;
        v153 = *(_QWORD *)v138;
      }
    }
    if ( (v154 & 8) != 0 )
    {
      if ( !sub_2E88A90(v138, 256, 1) )
      {
        v155 = *(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL;
        if ( !v155 )
          goto LABEL_367;
LABEL_277:
        v156 = *(_QWORD *)v155;
        v157 = (__int64 *)v155;
        v158 = *(_DWORD *)(v155 + 44);
        if ( (*(_QWORD *)v155 & 4) != 0 )
        {
          if ( (v158 & 4) != 0 )
            goto LABEL_350;
        }
        else if ( (v158 & 4) != 0 )
        {
          while ( 1 )
          {
            v157 = (__int64 *)(v156 & 0xFFFFFFFFFFFFFFF8LL);
            v158 = *(_DWORD *)((v156 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 0xFFFFFF;
            if ( (*(_DWORD *)((v156 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 4) == 0 )
              break;
            v156 = *v157;
          }
        }
        if ( (v158 & 8) != 0 )
        {
          LOBYTE(v159) = sub_2E88A90((__int64)v157, 512, 1);
          goto LABEL_284;
        }
LABEL_350:
        v159 = (*(_QWORD *)(v157[2] + 24) >> 9) & 1LL;
LABEL_284:
        if ( !(_BYTE)v159 )
          sub_2EF03A0(
            a1,
            "MBB exits via conditional branch/fall-through but the branch isn't a terminator instruction!",
            v7);
        goto LABEL_203;
      }
LABEL_317:
      sub_2EF03A0(a1, "MBB exits via conditional branch/fall-through but ends with a barrier instruction!", v7);
      goto LABEL_203;
    }
LABEL_316:
    v155 = v122 & 0xFFFFFFFFFFFFFFF8LL;
    if ( (*(_BYTE *)(*(_QWORD *)(v138 + 16) + 25LL) & 1) == 0 )
      goto LABEL_277;
    goto LABEL_317;
  }
  if ( v191[0] )
  {
    sub_2EF03A0(a1, "analyzeBranch returned invalid data!", v7);
    goto LABEL_203;
  }
  v164 = *(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v164 == v7 + 48 )
    goto LABEL_313;
  if ( !v164 )
    goto LABEL_367;
  v165 = *(_DWORD *)(v164 + 44);
  v166 = *(_QWORD *)v164;
  LOBYTE(v167) = v165;
  if ( (*(_QWORD *)v164 & 4) == 0 )
  {
    if ( (v165 & 4) != 0 )
    {
      while ( 1 )
      {
        v164 = v166 & 0xFFFFFFFFFFFFFFF8LL;
        v167 = *(_DWORD *)((v166 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 0xFFFFFF;
        if ( (*(_DWORD *)((v166 & 0xFFFFFFFFFFFFFFF8LL) + 44) & 4) == 0 )
          break;
        v166 = *(_QWORD *)v164;
      }
    }
LABEL_311:
    if ( (v167 & 8) != 0 )
    {
      if ( !sub_2E88A90(v164, 256, 1) )
        goto LABEL_313;
      v169 = *(_QWORD *)(a1 + 48);
      v171 = *(__int64 (**)())(*(_QWORD *)v169 + 920LL);
      v170 = (_QWORD *)(*(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL);
      if ( !v170 )
        goto LABEL_367;
LABEL_329:
      v172 = v170;
      v173 = *v170;
      if ( (v173 & 4) == 0 && (*((_BYTE *)v172 + 44) & 4) != 0 )
      {
        while ( 1 )
        {
          v174 = v173 & 0xFFFFFFFFFFFFFFF8LL;
          v172 = (_QWORD *)v174;
          if ( (*(_BYTE *)(v174 + 44) & 4) == 0 )
            break;
          v173 = *(_QWORD *)v174;
        }
      }
      if ( v171 == sub_2DB1B30 || !((unsigned __int8 (__fastcall *)(__int64, _QWORD *))v171)(v169, v172) )
        sub_2EF03A0(a1, "MBB exits via unconditional fall-through but ends with a barrier instruction!", v7);
      goto LABEL_313;
    }
    goto LABEL_327;
  }
  if ( (v165 & 4) == 0 )
    goto LABEL_311;
LABEL_327:
  if ( (*(_BYTE *)(*(_QWORD *)(v164 + 16) + 25LL) & 1) != 0 )
  {
    v169 = *(_QWORD *)(a1 + 48);
    v170 = (_QWORD *)(*(_QWORD *)(v7 + 48) & 0xFFFFFFFFFFFFFFF8LL);
    v171 = *(__int64 (**)())(*(_QWORD *)v169 + 920LL);
    goto LABEL_329;
  }
LABEL_313:
  if ( (_DWORD)v204 )
    sub_2EF03A0(a1, "MBB exits via unconditional fall-through but has a condition!", v7);
LABEL_203:
  if ( !v190 )
  {
    v132 = v191[0];
    if ( !v191[0] )
      goto LABEL_227;
    goto LABEL_207;
  }
  if ( !sub_2E322C0(v7, v190) )
    sub_2EF03A0(a1, "MBB exits via jump or conditional branch, but its target isn't a CFG successor!", v7);
  v132 = v191[0];
  if ( v191[0] )
  {
LABEL_207:
    if ( !sub_2E322C0(v7, v132) )
      sub_2EF03A0(a1, "MBB exits via conditional branch, but its target isn't a CFG successor!", v7);
  }
  if ( v190 )
  {
    if ( (_DWORD)v204 )
    {
      v133 = v191[0];
      v121 = v191[0] == 0;
      goto LABEL_212;
    }
    goto LABEL_213;
  }
LABEL_227:
  v121 = 1;
  if ( (_DWORD)v204 )
  {
    v133 = v191[0];
LABEL_212:
    if ( !v133 )
    {
      v163 = *(_QWORD *)(v7 + 8);
      if ( v163 == *(_QWORD *)(a1 + 32) + 320LL )
      {
        sub_2EF03A0(a1, "MBB conditionally falls through out of function!", v7);
      }
      else if ( !sub_2E322C0(v7, v163) )
      {
        sub_2EF03A0(
          a1,
          "MBB exits via conditional branch/fall-through but the CFG successors don't match the actual successors!",
          v7);
      }
    }
  }
LABEL_213:
  v134 = *(__int64 **)(v7 + 112);
  for ( m = &v134[*(unsigned int *)(v7 + 120)]; m != v134; ++v134 )
  {
    v136 = *v134;
    if ( v190 != *v134 && v191[0] != v136 )
    {
      if ( !v121 )
        goto LABEL_372;
      v137 = *(_QWORD *)(v7 + 8);
      if ( v137 == *(_QWORD *)(v7 + 32) + 320LL )
        v137 = 0;
      if ( v136 != v137 )
      {
LABEL_372:
        if ( !*(_BYTE *)(v136 + 216) && !*(_BYTE *)(v136 + 262) )
          sub_2EF03A0(
            a1,
            "MBB has unexpected successors which are not branch targets, fallthrough, EHPads, or inlineasm_br targets.",
            v7);
      }
    }
  }
LABEL_39:
  v187 = a1 + 272;
  sub_2EF8FC0(a1 + 272);
  if ( (*(_BYTE *)(**(_QWORD **)(a1 + 64) + 344LL) & 4) != 0 )
  {
    v89 = *(unsigned int **)(v7 + 192);
    v180 = v89;
    v90 = sub_2E33140(v7);
    if ( v89 != (unsigned int *)v90 )
    {
      v175 = v7;
      v91 = (unsigned int *)v90;
      while ( 1 )
      {
        v92 = *v91;
        if ( *v91 - 1 > 0x3FFFFFFE )
        {
          v182 = v91;
          sub_2EF03A0(a1, "MBB live-in list contains non-physical register", v175);
          v91 = v182;
        }
        else
        {
          v93 = (unsigned __int16)v92;
          v94 = (__int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL)
                          + 2LL * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL) + 24LL * v92 + 4));
          if ( v94 )
          {
            for ( n = *(_DWORD *)(a1 + 296); n; v93 = (unsigned __int16)v92 )
            {
              v96 = *(_QWORD *)(a1 + 280);
              v97 = (n - 1) & (37 * v93);
              v98 = (_DWORD *)(v96 + 4LL * v97);
              v99 = *v98;
              if ( v93 != *v98 )
              {
                v108 = 1;
                v105 = 0;
                while ( v99 != -1 )
                {
                  if ( v105 || v99 != -2 )
                    v98 = v105;
                  v97 = (n - 1) & (v108 + v97);
                  v99 = *(_DWORD *)(v96 + 4LL * v97);
                  if ( v93 == v99 )
                    goto LABEL_147;
                  ++v108;
                  v105 = v98;
                  v98 = (_DWORD *)(v96 + 4LL * v97);
                }
                v109 = *(_DWORD *)(a1 + 288);
                if ( !v105 )
                  v105 = v98;
                ++*(_QWORD *)(a1 + 272);
                v106 = v109 + 1;
                if ( 4 * (v109 + 1) >= 3 * n )
                  goto LABEL_150;
                if ( n - *(_DWORD *)(a1 + 292) - v106 <= n >> 3 )
                {
                  v184 = v91;
                  sub_2E29BA0(v187, n);
                  v110 = *(_DWORD *)(a1 + 296);
                  if ( !v110 )
                  {
LABEL_369:
                    ++*(_DWORD *)(a1 + 288);
                    BUG();
                  }
                  v111 = v110 - 1;
                  v112 = *(_QWORD *)(a1 + 280);
                  v113 = 1;
                  LODWORD(v114) = (v110 - 1) & (37 * v93);
                  v91 = v184;
                  v106 = *(_DWORD *)(a1 + 288) + 1;
                  v115 = 0;
                  v105 = (_DWORD *)(v112 + 4LL * (unsigned int)v114);
                  v116 = *v105;
                  if ( v93 != *v105 )
                  {
                    while ( v116 != -1 )
                    {
                      if ( v116 == -2 && !v115 )
                        v115 = v105;
                      v114 = v111 & (unsigned int)(v114 + v113);
                      v105 = (_DWORD *)(v112 + 4 * v114);
                      v116 = *v105;
                      if ( v93 == *v105 )
                        goto LABEL_152;
                      ++v113;
                    }
                    if ( v115 )
                      v105 = v115;
                  }
                }
LABEL_152:
                *(_DWORD *)(a1 + 288) = v106;
                if ( *v105 != -1 )
                  --*(_DWORD *)(a1 + 292);
                *v105 = v93;
              }
LABEL_147:
              v100 = *v94++;
              if ( !(_WORD)v100 )
                goto LABEL_142;
              n = *(_DWORD *)(a1 + 296);
              v92 += v100;
            }
            ++*(_QWORD *)(a1 + 272);
LABEL_150:
            v183 = v91;
            sub_2E29BA0(v187, 2 * n);
            v101 = *(_DWORD *)(a1 + 296);
            if ( !v101 )
              goto LABEL_369;
            v102 = v101 - 1;
            v103 = *(_QWORD *)(a1 + 280);
            v91 = v183;
            LODWORD(v104) = (v101 - 1) & (37 * v93);
            v105 = (_DWORD *)(v103 + 4LL * (unsigned int)v104);
            v106 = *(_DWORD *)(a1 + 288) + 1;
            v107 = *v105;
            if ( v93 != *v105 )
            {
              v160 = 1;
              v161 = 0;
              while ( v107 != -1 )
              {
                if ( v107 == -2 && !v161 )
                  v161 = v105;
                v104 = v102 & (unsigned int)(v104 + v160);
                v105 = (_DWORD *)(v103 + 4 * v104);
                v107 = *v105;
                if ( v93 == *v105 )
                  goto LABEL_152;
                ++v160;
              }
              if ( v161 )
                v105 = v161;
            }
            goto LABEL_152;
          }
        }
LABEL_142:
        v91 += 6;
        if ( v180 == v91 )
        {
          v7 = v175;
          break;
        }
      }
    }
  }
  sub_2E76F80((__int64)v200, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48LL), *(_QWORD *)(a1 + 32));
  v33 = v202;
  if ( v202 )
  {
    v34 = (_QWORD *)v200[0];
    v35 = 0;
    v36 = (unsigned int)(v202 - 1) >> 6;
    v37 = (_QWORD *)v200[0];
    while ( 1 )
    {
      _RDX = *(_QWORD *)(v200[0] + 8 * v35);
      if ( v36 == (_DWORD)v35 )
        _RDX = (0xFFFFFFFFFFFFFFFFLL >> -(char)v202) & *(_QWORD *)(v200[0] + 8 * v35);
      if ( _RDX )
        break;
      if ( v36 + 1 == ++v35 )
        goto LABEL_46;
    }
    __asm { tzcnt   rdx, rdx }
    v52 = ((_DWORD)v35 << 6) + _RDX;
    if ( v52 != -1 )
    {
      v181 = v7;
      while ( 1 )
      {
        v53 = (unsigned __int16)v52;
        v54 = (__int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 56LL)
                        + 2LL * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL) + 24LL * v52 + 4));
        if ( v54 )
          break;
LABEL_93:
        v62 = v52 + 1;
        v37 = v34;
        if ( v33 != v52 + 1 )
        {
          v63 = v62 >> 6;
          v64 = (unsigned int)(v33 - 1) >> 6;
          if ( v62 >> 6 <= v64 )
          {
            v65 = v63;
            v66 = 64 - (v62 & 0x3F);
            v67 = 0xFFFFFFFFFFFFFFFFLL >> v66;
            if ( v66 == 64 )
              v67 = 0;
            v68 = ~v67;
            while ( 1 )
            {
              _RAX = v34[v65];
              if ( v63 == (_DWORD)v65 )
                _RAX = v68 & v34[v65];
              if ( (_DWORD)v65 == v64 )
                _RAX &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v33;
              if ( _RAX )
                break;
              if ( v64 < (unsigned int)++v65 )
                goto LABEL_105;
            }
            __asm { tzcnt   rax, rax }
            v52 = ((_DWORD)v65 << 6) + _RAX;
            if ( v52 != -1 )
              continue;
          }
        }
LABEL_105:
        v7 = v181;
        goto LABEL_46;
      }
      v55 = *(_DWORD *)(a1 + 296);
      v56 = v52;
      if ( !v55 )
        goto LABEL_107;
      while ( 1 )
      {
        v57 = *(_QWORD *)(a1 + 280);
        v58 = (v55 - 1) & (37 * v53);
        v59 = (_DWORD *)(v57 + 4LL * v58);
        v60 = *v59;
        if ( v53 != *v59 )
        {
          v80 = 1;
          v75 = 0;
          while ( v60 != -1 )
          {
            if ( v60 != -2 || v75 )
              v59 = v75;
            v58 = (v55 - 1) & (v80 + v58);
            v60 = *(_DWORD *)(v57 + 4LL * v58);
            if ( v53 == v60 )
              goto LABEL_91;
            ++v80;
            v75 = v59;
            v59 = (_DWORD *)(v57 + 4LL * v58);
          }
          v81 = *(_DWORD *)(a1 + 288);
          if ( !v75 )
            v75 = v59;
          ++*(_QWORD *)(a1 + 272);
          v77 = v81 + 1;
          if ( 4 * (v81 + 1) >= 3 * v55 )
            goto LABEL_108;
          if ( v55 - *(_DWORD *)(a1 + 292) - v77 <= v55 >> 3 )
          {
            v179 = v52;
            sub_2E29BA0(v187, v55);
            v82 = *(_DWORD *)(a1 + 296);
            if ( !v82 )
              goto LABEL_369;
            v83 = v82 - 1;
            v84 = *(_QWORD *)(a1 + 280);
            v85 = 1;
            LODWORD(v86) = v83 & (37 * v53);
            v52 = v179;
            v75 = (_DWORD *)(v84 + 4LL * (unsigned int)v86);
            v77 = *(_DWORD *)(a1 + 288) + 1;
            v87 = 0;
            v88 = *v75;
            if ( v53 != *v75 )
            {
              while ( v88 != -1 )
              {
                if ( !v87 && v88 == -2 )
                  v87 = v75;
                v86 = v83 & (unsigned int)(v86 + v85);
                v75 = (_DWORD *)(v84 + 4 * v86);
                v88 = *v75;
                if ( v53 == *v75 )
                  goto LABEL_121;
                ++v85;
              }
              if ( v87 )
                v75 = v87;
            }
          }
LABEL_121:
          *(_DWORD *)(a1 + 288) = v77;
          if ( *v75 != -1 )
            --*(_DWORD *)(a1 + 292);
          *v75 = v53;
        }
LABEL_91:
        v61 = *v54++;
        if ( !(_WORD)v61 )
        {
          v33 = v202;
          v34 = (_QWORD *)v200[0];
          goto LABEL_93;
        }
        v55 = *(_DWORD *)(a1 + 296);
        v56 += v61;
        v53 = (unsigned __int16)v56;
        if ( !v55 )
        {
LABEL_107:
          ++*(_QWORD *)(a1 + 272);
LABEL_108:
          v178 = v52;
          sub_2E29BA0(v187, 2 * v55);
          v71 = *(_DWORD *)(a1 + 296);
          if ( !v71 )
            goto LABEL_369;
          v72 = v71 - 1;
          v73 = *(_QWORD *)(a1 + 280);
          v52 = v178;
          LODWORD(v74) = (v71 - 1) & (37 * v53);
          v75 = (_DWORD *)(v73 + 4LL * (unsigned int)v74);
          v76 = *v75;
          v77 = *(_DWORD *)(a1 + 288) + 1;
          if ( v53 != *v75 )
          {
            v78 = 1;
            v79 = 0;
            while ( v76 != -1 )
            {
              if ( !v79 && v76 == -2 )
                v79 = v75;
              v74 = v72 & (unsigned int)(v74 + v78);
              v75 = (_DWORD *)(v73 + 4 * v74);
              v76 = *v75;
              if ( v53 == *v75 )
                goto LABEL_121;
              ++v78;
            }
            if ( v79 )
              v75 = v79;
          }
          goto LABEL_121;
        }
      }
    }
  }
  else
  {
    v37 = (_QWORD *)v200[0];
  }
LABEL_46:
  v39 = *(_QWORD *)(a1 + 656);
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  if ( v39 )
    *(_QWORD *)(a1 + 592) = *(_QWORD *)(*(_QWORD *)(v39 + 152) + 16LL * *(unsigned int *)(v7 + 24));
  if ( v37 != v201 )
    _libc_free((unsigned __int64)v37);
  if ( v203 != v205 )
    _libc_free((unsigned __int64)v203);
  if ( !v198 )
    _libc_free((unsigned __int64)v195);
}
