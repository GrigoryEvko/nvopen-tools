// Function: sub_165FE30
// Address: 0x165fe30
//
void __fastcall sub_165FE30(__int64 a1, int a2, __int64 a3)
{
  char v3; // cl
  unsigned __int64 v4; // rax
  unsigned __int64 v6; // rdx
  __int64 **v7; // rax
  __int64 *v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // r14
  __int64 v11; // r12
  int v12; // ebx
  const char *v13; // rax
  size_t v14; // rbx
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // r14
  _BYTE *v19; // rax
  __int64 v20; // rax
  const char *v21; // rax
  __int64 v22; // r13
  _BYTE *v23; // rax
  __int64 v24; // rax
  __int64 v25; // r13
  const char *v26; // rax
  _BYTE *v27; // rax
  __int64 v28; // rsi
  __int64 v29; // rdi
  _BYTE *v30; // rax
  unsigned __int64 v31; // rbx
  unsigned __int64 v32; // rcx
  unsigned __int64 v33; // r14
  __int64 v34; // r15
  _BYTE *v35; // r12
  __int64 v36; // r13
  _QWORD *v37; // rax
  char v38; // dl
  _QWORD *v39; // rsi
  unsigned int v40; // edi
  _QWORD *v41; // rcx
  unsigned __int64 v42; // r13
  int v43; // ebx
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 v46; // r14
  int v47; // r14d
  __int64 v48; // rax
  __int64 v49; // rdx
  int v50; // eax
  int v51; // ebx
  __int64 v52; // rdx
  const char *v53; // rax
  __int64 v54; // r14
  _BYTE *v55; // rax
  bool v56; // zf
  unsigned __int64 v57; // rbx
  __int64 v58; // rdx
  __int64 v59; // r14
  unsigned int v60; // ecx
  __int64 v61; // rax
  const char *v62; // rax
  unsigned __int64 v63; // rbx
  _QWORD *v64; // r14
  int v65; // eax
  __int64 v66; // rax
  const char *v67; // rax
  __int64 v68; // rbx
  __int64 v69; // rdx
  _QWORD *v70; // rax
  _QWORD *v71; // rax
  __int64 v72; // rax
  unsigned __int64 v73; // rdi
  _QWORD *v74; // rdi
  __int64 v75; // rax
  __int64 v76; // rdx
  __int64 v77; // rbx
  __int64 v78; // rdx
  __int64 v79; // rax
  unsigned __int64 v80; // rbx
  _QWORD *v81; // r14
  __int64 v82; // rax
  __int64 v83; // rax
  unsigned __int8 v84; // dl
  __int64 v85; // rax
  const char *v86; // rax
  __int64 v87; // rax
  __int64 v88; // r14
  _QWORD *v89; // rbx
  __int64 v90; // rax
  __int64 v91; // rbx
  __int64 v92; // rax
  __int64 v93; // r14
  __int64 v94; // rax
  __int64 v95; // rax
  __int64 v96; // rbx
  _QWORD *v97; // rax
  unsigned int v98; // r13d
  _QWORD *v99; // r12
  unsigned __int64 v100; // rax
  unsigned __int64 v101; // rdx
  unsigned __int64 v102; // rbx
  __int64 v103; // r13
  _BYTE *v104; // rax
  __int64 v105; // r14
  __int64 v106; // r15
  unsigned __int8 *v107; // rax
  int v108; // edx
  unsigned __int8 *i; // rdx
  int v110; // ecx
  __int64 v111; // rax
  __int64 v112; // rbx
  char v113; // al
  __int64 v114; // rax
  __int64 v115; // r14
  unsigned __int8 v116; // al
  __int64 v117; // rbx
  __int64 v118; // rax
  unsigned __int64 v119; // rax
  __int64 *v120; // rdx
  __int64 *v121; // r14
  __int64 *k; // r15
  __int64 v123; // rdi
  __int64 v124; // rax
  int v125; // eax
  const char *v126; // rax
  unsigned __int64 v127; // rdi
  __int64 v128; // r14
  __int64 v129; // rax
  _QWORD *v130; // rbx
  __int64 v131; // r15
  __int64 v132; // rax
  _QWORD *v133; // rdx
  int v134; // r15d
  unsigned __int64 v135; // rcx
  __int64 v136; // rdx
  _QWORD *v137; // rax
  int v138; // esi
  __int64 v139; // rdx
  _QWORD *v140; // rax
  int v141; // r15d
  int v142; // eax
  unsigned __int64 v143; // r14
  __int64 v144; // rax
  __int64 v145; // r14
  _BYTE *v146; // rax
  int v147; // eax
  __int64 v148; // rdx
  unsigned __int64 v149; // rax
  _QWORD *v150; // rdx
  unsigned int v151; // eax
  __int64 v152; // rax
  unsigned int v153; // eax
  __int64 v154; // rax
  __int64 v155; // rbx
  __int64 v156; // rax
  __int64 v157; // rdx
  __int64 v158; // rbx
  __int64 v159; // rdx
  int v160; // eax
  unsigned __int64 v161; // rax
  __int64 v162; // rbx
  unsigned __int64 v163; // rdx
  __int64 v164; // rcx
  __int64 v165; // rax
  __int64 v166; // rax
  __int64 v167; // rax
  __int64 v168; // rbx
  unsigned __int64 v169; // rax
  __int64 v170; // rax
  __int64 v171; // rdx
  __int64 *v172; // r14
  __int64 *v173; // rax
  __int64 v174; // rdx
  unsigned __int64 v175; // r14
  _QWORD *v176; // rdi
  __int64 v177; // rax
  __int64 v178; // rdx
  __int64 v179; // rbx
  __int64 v180; // rdx
  __int64 v181; // rax
  _QWORD *v182; // rdx
  __int64 v183; // rax
  unsigned int v184; // esi
  __int64 *v185; // rax
  __int64 v186; // rax
  __int64 v187; // r14
  __int64 v188; // rsi
  __int64 v189; // rcx
  _QWORD *v190; // rax
  int v191; // ecx
  int v192; // edi
  __int64 v193; // r8
  unsigned __int64 v194; // rax
  unsigned __int64 v195; // rax
  _QWORD *v196; // r8
  __int64 v197; // rsi
  _QWORD *v198; // rax
  int v199; // esi
  __int64 v200; // rax
  _QWORD *v201; // rbx
  __int64 j; // rbx
  _QWORD *v203; // rax
  const char *v204; // rax
  __int64 v205; // rdx
  char v206; // cl
  bool v207; // cl
  __int64 v208; // rax
  const char *v209; // rax
  __int64 v210; // rax
  const char *v211; // rax
  __int64 v212; // rax
  __int64 v213; // rax
  __int64 v214; // rax
  __int64 v215; // rdx
  __int64 *v216; // r14
  __int64 *v217; // rax
  __int64 v218; // rdx
  unsigned __int8 v219; // al
  _QWORD *v220; // rbx
  __int64 v221; // rax
  unsigned __int64 v222; // rdi
  const char *v223; // rax
  __int64 v224; // rbx
  __int64 v225; // rax
  char v226; // dl
  char v227; // cl
  int v228; // [rsp+8h] [rbp-188h]
  bool v229; // [rsp+10h] [rbp-180h]
  unsigned __int8 *v230; // [rsp+10h] [rbp-180h]
  __int64 *v231; // [rsp+18h] [rbp-178h]
  _BYTE *v232; // [rsp+18h] [rbp-178h]
  unsigned __int8 *v233; // [rsp+18h] [rbp-178h]
  int v234; // [rsp+18h] [rbp-178h]
  unsigned int v235; // [rsp+18h] [rbp-178h]
  __int64 v237; // [rsp+30h] [rbp-160h]
  int v238; // [rsp+30h] [rbp-160h]
  __int64 v239; // [rsp+30h] [rbp-160h]
  _QWORD v240[2]; // [rsp+38h] [rbp-158h] BYREF
  __int64 *v241; // [rsp+48h] [rbp-148h] BYREF
  unsigned __int64 v242; // [rsp+50h] [rbp-140h] BYREF
  _QWORD *v243; // [rsp+58h] [rbp-138h] BYREF
  unsigned int *v244; // [rsp+60h] [rbp-130h] BYREF
  __int64 v245; // [rsp+68h] [rbp-128h]
  __int64 v246[2]; // [rsp+70h] [rbp-120h] BYREF
  __int64 *v247; // [rsp+80h] [rbp-110h] BYREF
  const char *v248; // [rsp+88h] [rbp-108h]
  __int16 v249; // [rsp+90h] [rbp-100h]
  void *s1; // [rsp+A0h] [rbp-F0h] BYREF
  size_t n; // [rsp+A8h] [rbp-E8h]
  __int64 v252; // [rsp+B0h] [rbp-E0h] BYREF
  char *v253; // [rsp+C0h] [rbp-D0h] BYREF
  __int64 *v254; // [rsp+C8h] [rbp-C8h]
  _QWORD v255[2]; // [rsp+D0h] [rbp-C0h] BYREF
  __int64 *v256; // [rsp+E0h] [rbp-B0h] BYREF
  __int64 v257; // [rsp+E8h] [rbp-A8h]
  _BYTE v258[32]; // [rsp+F0h] [rbp-A0h] BYREF
  unsigned int *v259; // [rsp+110h] [rbp-80h] BYREF
  __int64 v260; // [rsp+118h] [rbp-78h]
  _BYTE v261[112]; // [rsp+120h] [rbp-70h] BYREF

  v3 = a3;
  v4 = a3 & 0xFFFFFFFFFFFFFFF8LL;
  v240[0] = a3;
  v6 = (a3 & 0xFFFFFFFFFFFFFFF8LL) - 24;
  v7 = (__int64 **)(v4 - 72);
  if ( (v3 & 4) != 0 )
    v7 = (__int64 **)v6;
  v8 = *v7;
  if ( *((_BYTE *)*v7 + 16) )
    v8 = 0;
  v241 = v8;
  v229 = sub_15E4F60((__int64)v8);
  if ( !v229 )
  {
    v261[1] = 1;
    v259 = (unsigned int *)"Intrinsic functions should never be defined!";
    v261[0] = 3;
    sub_164FF40((__int64 *)a1, (__int64)&v259);
    if ( *(_QWORD *)a1 )
      sub_164FA80((__int64 *)a1, (__int64)v241);
    return;
  }
  v9 = v241[3];
  v228 = *(_DWORD *)(v9 + 8) >> 8;
  v259 = (unsigned int *)v261;
  v260 = 0x800000000LL;
  sub_15E1220(a2, (__int64)&v259);
  v244 = v259;
  v245 = (unsigned int)v260;
  v256 = (__int64 *)v258;
  v257 = 0x400000000LL;
  if ( sub_15E2EC0(**(_QWORD **)(v9 + 16), &v244, (__int64 *)&v256) )
  {
    BYTE1(v255[0]) = 1;
    v21 = "Intrinsic has incorrect return type!";
    goto LABEL_24;
  }
  v231 = (__int64 *)a1;
  LODWORD(v10) = 0;
  v11 = v9;
  v12 = *(_DWORD *)(v9 + 12) - 1;
  while ( (_DWORD)v10 != v12 )
  {
    v10 = (unsigned int)(v10 + 1);
    if ( sub_15E2EC0(*(_QWORD *)(*(_QWORD *)(v11 + 16) + 8 * v10), &v244, (__int64 *)&v256) )
    {
      BYTE1(v255[0]) = 1;
      a1 = (__int64)v231;
      v21 = "Intrinsic has incorrect argument type!";
LABEL_24:
      v22 = *(_QWORD *)a1;
      v253 = (char *)v21;
      LOBYTE(v255[0]) = 3;
      if ( v22 )
      {
        sub_16E2CE0(&v253, v22);
        v23 = *(_BYTE **)(v22 + 24);
        if ( (unsigned __int64)v23 >= *(_QWORD *)(v22 + 16) )
        {
          sub_16E7DE0(v22, 10);
        }
        else
        {
          *(_QWORD *)(v22 + 24) = v23 + 1;
          *v23 = 10;
        }
        v24 = *(_QWORD *)a1;
        *(_BYTE *)(a1 + 72) = 1;
        if ( v24 )
          sub_164FA80((__int64 *)a1, (__int64)v241);
        goto LABEL_31;
      }
LABEL_30:
      *(_BYTE *)(a1 + 72) = 1;
      goto LABEL_31;
    }
  }
  a1 = (__int64)v231;
  if ( !v228 )
  {
    if ( !(unsigned __int8)sub_15E3390(0, (__int64 *)&v244) )
      goto LABEL_12;
    BYTE1(v255[0]) = 1;
    v26 = "Callsite was not defined with variable arguments!";
LABEL_37:
    v253 = (char *)v26;
    LOBYTE(v255[0]) = 3;
    sub_165A4A0(v231, (__int64)&v253, (__int64 *)&v241);
    goto LABEL_31;
  }
  if ( (unsigned __int8)sub_15E3390(1u, (__int64 *)&v244) )
  {
    BYTE1(v255[0]) = 1;
    v26 = "Intrinsic was not defined with variable arguments!";
    goto LABEL_37;
  }
LABEL_12:
  if ( v245 )
  {
    v25 = *v231;
    v253 = "Intrinsic has too few arguments!";
    LOWORD(v255[0]) = 259;
    if ( !v25 )
      goto LABEL_30;
    sub_16E2CE0(&v253, v25);
    v27 = *(_BYTE **)(v25 + 24);
    if ( (unsigned __int64)v27 >= *(_QWORD *)(v25 + 16) )
    {
      sub_16E7DE0(v25, 10);
    }
    else
    {
      *(_QWORD *)(v25 + 24) = v27 + 1;
      *v27 = 10;
    }
    v28 = *v231;
    *((_BYTE *)v231 + 72) = 1;
    if ( !v28 || !v241 )
      goto LABEL_31;
    if ( *((_BYTE *)v241 + 16) <= 0x17u )
    {
      sub_1553920(v241, v28, 1, (__int64)(v231 + 2));
      v29 = *v231;
      v30 = *(_BYTE **)(*v231 + 24);
      if ( (unsigned __int64)v30 < *(_QWORD *)(*v231 + 16) )
        goto LABEL_51;
    }
    else
    {
      sub_155BD40((__int64)v241, v28, (__int64)(v231 + 2), 0);
      v29 = *v231;
      v30 = *(_BYTE **)(*v231 + 24);
      if ( (unsigned __int64)v30 < *(_QWORD *)(*v231 + 16) )
      {
LABEL_51:
        *(_QWORD *)(v29 + 24) = v30 + 1;
        *v30 = 10;
        goto LABEL_31;
      }
    }
    sub_16E7DE0(v29, 10);
    goto LABEL_31;
  }
  sub_15E1070((__int64 *)&s1, a2, v256, (unsigned int)v257);
  v13 = sub_1649960((__int64)v241);
  v14 = n;
  if ( n != v15 || n && memcmp(s1, v13, n) )
  {
    v254 = 0;
    LOBYTE(v255[0]) = 0;
    v253 = (char *)v255;
    sub_2240E30(&v253, v14 + 68);
    if ( (unsigned __int64)(0x3FFFFFFFFFFFFFFFLL - (_QWORD)v254) <= 0x43 )
      sub_4262D8((__int64)"basic_string::append");
    sub_2241490(&v253, "Intrinsic name not mangled correctly for type arguments! Should be: ", 68, v16);
    sub_2241490(&v253, s1, n, v17);
    v247 = (__int64 *)&v253;
    v18 = *v231;
    v249 = 260;
    if ( v18 )
    {
      sub_16E2CE0(&v247, v18);
      v19 = *(_BYTE **)(v18 + 24);
      if ( (unsigned __int64)v19 >= *(_QWORD *)(v18 + 16) )
      {
        sub_16E7DE0(v18, 10);
      }
      else
      {
        *(_QWORD *)(v18 + 24) = v19 + 1;
        *v19 = 10;
      }
      v20 = *v231;
      *((_BYTE *)v231 + 72) = 1;
      if ( v20 )
        sub_164FA80(v231, (__int64)v241);
    }
    else
    {
      *((_BYTE *)v231 + 72) = 1;
    }
    if ( v253 != (char *)v255 )
      j_j___libc_free_0(v253, v255[0] + 1LL);
    goto LABEL_43;
  }
  v31 = sub_1389B50(v240);
  v32 = sub_165B7C0(v240);
  v232 = v231 + 41;
  if ( v31 != v32 )
  {
    v33 = v32;
    v34 = a1;
    while ( 1 )
    {
      if ( *(_BYTE *)(*(_QWORD *)v33 + 16LL) == 19 )
      {
        v35 = *(_BYTE **)(*(_QWORD *)v33 + 24LL);
        if ( (unsigned __int8)(*v35 - 4) <= 0x1Eu )
        {
          sub_1656110((_QWORD *)v34, *(_QWORD *)(*(_QWORD *)v33 + 24LL));
        }
        else
        {
          v36 = *(_QWORD *)(*(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 40) + 56LL);
          v37 = *(_QWORD **)(v34 + 336);
          if ( *(_QWORD **)(v34 + 344) == v37 )
          {
            v39 = &v37[*(unsigned int *)(v34 + 356)];
            v40 = *(_DWORD *)(v34 + 356);
            if ( v37 != v39 )
            {
              v41 = 0;
              while ( v35 != (_BYTE *)*v37 )
              {
                if ( *v37 == -2 )
                  v41 = v37;
                if ( v39 == ++v37 )
                {
                  if ( !v41 )
                    goto LABEL_113;
                  *v41 = v35;
                  --*(_DWORD *)(v34 + 360);
                  ++*(_QWORD *)(v34 + 328);
                  goto LABEL_63;
                }
              }
              goto LABEL_58;
            }
LABEL_113:
            if ( v40 < *(_DWORD *)(v34 + 352) )
            {
              *(_DWORD *)(v34 + 356) = v40 + 1;
              *v39 = v35;
              ++*(_QWORD *)(v34 + 328);
LABEL_63:
              if ( (unsigned int)(unsigned __int8)*v35 - 1 <= 1 )
                sub_164FFA0(v34, (__int64)v35, v36);
              goto LABEL_58;
            }
          }
          sub_16CCBA0(v232, *(_QWORD *)(*(_QWORD *)v33 + 24LL));
          if ( v38 )
            goto LABEL_63;
        }
      }
LABEL_58:
      v33 += 24LL;
      if ( v31 == v33 )
      {
        a1 = v34;
        break;
      }
    }
  }
  switch ( a2 )
  {
    case 21:
      v111 = sub_165BE00(v240, 3u);
      v112 = sub_1649C60(v111);
      v113 = *(_BYTE *)(v112 + 16);
      if ( v113 == 15 )
        goto LABEL_43;
      if ( v113 == 3 && (*(_BYTE *)(v112 + 80) & 1) != 0 && !sub_15E4F60(v112) )
        __asm { jmp     rax }
      BYTE1(v255[0]) = 1;
      v67 = "info argument of llvm.coro.begin must refer to an initialized constant";
      goto LABEL_120;
    case 31:
    case 33:
      if ( *(_BYTE *)(sub_165BE00(v240, 1u) + 16) == 13 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "is_zero_undef argument of bit counting intrinsics must be a constant int";
      goto LABEL_96;
    case 35:
      sub_1653200(a1, (__int64)"addr", 4, v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      goto LABEL_43;
    case 36:
      if ( *(_BYTE *)(sub_165BE00(v240, 0) + 16) != 19 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "invalid llvm.dbg.declare intrinsic call 1";
        goto LABEL_96;
      }
      sub_1653200(a1, (__int64)"declare", 7, v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      goto LABEL_43;
    case 37:
      v246[1] = 5;
      v246[0] = (__int64)"label";
      v102 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      v103 = *(_QWORD *)(*(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL)
                                   - 24LL * (*(_DWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF))
                       + 24LL);
      if ( *(_BYTE *)v103 != 26 )
      {
        v145 = *(_QWORD *)a1;
        LOWORD(v255[0]) = 1283;
        v253 = "invalid llvm.dbg.";
        v254 = v246;
        v247 = (__int64 *)&v253;
        v248 = " intrinsic variable";
        v249 = 770;
        if ( v145 )
        {
          sub_16E2CE0(&v247, v145);
          v146 = *(_BYTE **)(v145 + 24);
          if ( (unsigned __int64)v146 >= *(_QWORD *)(v145 + 16) )
          {
            sub_16E7DE0(v145, 10);
          }
          else
          {
            *(_QWORD *)(v145 + 24) = v146 + 1;
            *v146 = 10;
          }
        }
        *(_BYTE *)(a1 + 72) |= *(_BYTE *)(a1 + 74);
        v56 = *(_QWORD *)a1 == 0;
        *(_BYTE *)(a1 + 73) = 1;
        if ( !v56 )
        {
          sub_164FA80((__int64 *)a1, v102);
          sub_164ED40((__int64 *)a1, (unsigned __int8 *)v103);
        }
        goto LABEL_43;
      }
      v104 = *(_BYTE **)(v102 + 48);
      if ( v104 && *v104 != 5 )
        goto LABEL_43;
      v105 = *(_QWORD *)(v102 + 40);
      if ( v105 )
        v237 = *(_QWORD *)(v105 + 56);
      else
        v237 = 0;
      v106 = sub_15C70A0(v102 + 48);
      if ( !v106 )
      {
        LOWORD(v255[0]) = 1283;
        v253 = "llvm.dbg.";
        v254 = v246;
        v247 = (__int64 *)&v253;
        v248 = " intrinsic requires a !dbg attachment";
        v249 = 770;
        sub_164FF40((__int64 *)a1, (__int64)&v247);
        if ( *(_QWORD *)a1 )
        {
          sub_164FA80((__int64 *)a1, v102);
          sub_164FA80((__int64 *)a1, v105);
          sub_164FA80((__int64 *)a1, v237);
        }
        goto LABEL_43;
      }
      v107 = *(unsigned __int8 **)(v103 - 8LL * *(unsigned int *)(v103 + 8));
      while ( 2 )
      {
        if ( v107 )
        {
          v108 = *v107;
          if ( (_BYTE)v108 != 17 )
          {
            if ( (unsigned int)(v108 - 18) <= 1 )
            {
              v107 = *(unsigned __int8 **)&v107[8 * (1LL - *((unsigned int *)v107 + 2))];
              continue;
            }
            v107 = 0;
          }
        }
        break;
      }
      for ( i = *(unsigned __int8 **)(v106 - 8LL * *(unsigned int *)(v106 + 8));
            ;
            i = *(unsigned __int8 **)&i[8 * (1LL - *((unsigned int *)i + 2))] )
      {
        if ( !i )
          goto LABEL_43;
        v110 = *i;
        if ( (_BYTE)v110 == 17 )
          break;
        if ( (unsigned int)(v110 - 18) > 1 )
          goto LABEL_43;
      }
      if ( v107 )
      {
        if ( i != v107 )
        {
          v233 = sub_15B1000(*(unsigned __int8 **)(v106 - 8LL * *(unsigned int *)(v106 + 8)));
          v230 = sub_15B1000(*(unsigned __int8 **)(v103 - 8LL * *(unsigned int *)(v103 + 8)));
          v253 = "mismatched subprogram between llvm.dbg.";
          v254 = v246;
          LOWORD(v255[0]) = 1283;
          v247 = (__int64 *)&v253;
          v248 = " label and !dbg attachment";
          v249 = 770;
          sub_16521E0((__int64 *)a1, (__int64)&v247);
          if ( *(_QWORD *)a1 )
          {
            sub_164FA80((__int64 *)a1, v102);
            sub_164FA80((__int64 *)a1, v105);
            sub_164FA80((__int64 *)a1, v237);
            sub_164ED40((__int64 *)a1, (unsigned __int8 *)v103);
            if ( v230 )
              sub_164ED40((__int64 *)a1, v230);
            sub_164ED40((__int64 *)a1, (unsigned __int8 *)v106);
            if ( v233 )
              sub_164ED40((__int64 *)a1, v233);
          }
        }
      }
      goto LABEL_43;
    case 38:
      sub_1653200(a1, (__int64)"value", 5, v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      goto LABEL_43;
    case 42:
    case 43:
      if ( *(_BYTE *)(sub_165BE00(v240, 0) + 16) == 74 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "eh.exceptionpointer argument must be a catchpad";
      goto LABEL_96;
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
      v42 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      v43 = *(_DWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF;
      if ( *(char *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 23) >= 0 )
        goto LABEL_227;
      v44 = sub_1648A40(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      v46 = v44 + v45;
      if ( *(char *)(v42 + 23) >= 0 )
      {
        if ( (unsigned int)(v46 >> 4) )
          goto LABEL_508;
      }
      else if ( (unsigned int)((v46 - sub_1648A40(v42)) >> 4) )
      {
        if ( *(char *)(v42 + 23) < 0 )
        {
          v47 = *(_DWORD *)(sub_1648A40(v42) + 8);
          if ( *(char *)(v42 + 23) >= 0 )
            BUG();
          v48 = sub_1648A40(v42);
          v50 = *(_DWORD *)(v48 + v49 - 4) - v47;
LABEL_81:
          v51 = v43 - v50;
          switch ( v51 )
          {
            case 6:
              if ( !sub_1602360(v42) )
                goto LABEL_318;
              break;
            case 4:
              if ( !sub_1602320(v42) )
                goto LABEL_318;
              break;
            case 5:
              break;
            default:
LABEL_318:
              BYTE1(v255[0]) = 1;
              v53 = "invalid arguments for constrained FP intrinsic";
              goto LABEL_87;
          }
          v52 = *(_DWORD *)(v42 + 20) & 0xFFFFFFF;
          if ( *(_BYTE *)(*(_QWORD *)(v42 + 24 * ((unsigned int)(v51 - 2) - v52)) + 16LL) == 19 )
          {
            if ( *(_BYTE *)(*(_QWORD *)(v42 + 24 * ((unsigned int)(v51 - 3) - v52)) + 16LL) == 19 )
            {
              if ( (unsigned int)sub_1601F00(v42) )
              {
                if ( (unsigned int)sub_1602170(v42) )
                  goto LABEL_43;
                BYTE1(v255[0]) = 1;
                v126 = "invalid exception behavior argument";
              }
              else
              {
                BYTE1(v255[0]) = 1;
                v126 = "invalid rounding mode argument";
              }
              v253 = (char *)v126;
              LOBYTE(v255[0]) = 3;
              sub_164FF40((__int64 *)a1, (__int64)&v253);
              if ( !*(_QWORD *)a1 )
                goto LABEL_43;
              goto LABEL_91;
            }
            BYTE1(v255[0]) = 1;
            v53 = "invalid rounding mode argument";
          }
          else
          {
            BYTE1(v255[0]) = 1;
            v53 = "invalid exception behavior argument";
          }
LABEL_87:
          v54 = *(_QWORD *)a1;
          v253 = (char *)v53;
          LOBYTE(v255[0]) = 3;
          if ( v54 )
          {
            sub_16E2CE0(&v253, v54);
            v55 = *(_BYTE **)(v54 + 24);
            if ( (unsigned __int64)v55 >= *(_QWORD *)(v54 + 16) )
            {
              sub_16E7DE0(v54, 10);
            }
            else
            {
              *(_QWORD *)(v54 + 24) = v55 + 1;
              *v55 = 10;
            }
          }
          v56 = *(_QWORD *)a1 == 0;
          *(_BYTE *)(a1 + 72) = 1;
          if ( v56 )
            goto LABEL_43;
LABEL_91:
          sub_164FA80((__int64 *)a1, v42);
          goto LABEL_43;
        }
LABEL_508:
        BUG();
      }
LABEL_227:
      v50 = 0;
      goto LABEL_81;
    case 75:
      if ( (v240[0] & 4) == 0 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "experimental_deoptimize cannot be invoked";
        goto LABEL_96;
      }
      if ( (unsigned int)sub_165C060(v240, 0) != 1 )
      {
        BYTE1(v255[0]) = 1;
        v67 = "experimental_deoptimize must have exactly one \"deopt\" operand bundle";
        goto LABEL_120;
      }
      v162 = *(_QWORD *)(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      if ( **(_QWORD **)(*(_QWORD *)(sub_15F2060(v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 24) + 16LL) != v162 )
      {
        BYTE1(v255[0]) = 1;
        v67 = "experimental_deoptimize return type must match caller return type";
        goto LABEL_120;
      }
      if ( (v240[0] & 4) == 0 )
        goto LABEL_43;
      v163 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      v164 = *(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 32);
      if ( v164 == *(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 40) + 40LL || !v164 )
        BUG();
      if ( *(_BYTE *)(v164 - 8) != 25 )
      {
        BYTE1(v255[0]) = 1;
        v67 = "calls to experimental_deoptimize must be followed by a return";
        goto LABEL_120;
      }
      if ( *(_BYTE *)(*(_QWORD *)v163 + 8LL) )
      {
        if ( (*(_DWORD *)(v164 - 4) & 0xFFFFFFF) == 0
          || (v165 = *(_QWORD *)(v164 - 24 * ((*(_DWORD *)(v164 - 4) & 0xFFFFFFF) + 1LL)), v163 != v165)
          || !v165 )
        {
          BYTE1(v255[0]) = 1;
          v67 = "calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize";
          goto LABEL_120;
        }
      }
      goto LABEL_43;
    case 76:
      if ( (unsigned int)sub_14DA610(v240) != 3 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "wrong number of arguments";
        goto LABEL_96;
      }
      v114 = *(_QWORD *)(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      if ( *(_BYTE *)(v114 + 8) == 16 )
        v114 = **(_QWORD **)(v114 + 16);
      if ( *(_BYTE *)(v114 + 8) != 15 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "gc.relocate must return a pointer or a vector of pointers";
        goto LABEL_96;
      }
      v115 = sub_165BE00(v240, 0);
      v116 = *(_BYTE *)(v115 + 16);
      if ( v116 <= 0x17u )
      {
        v247 = (__int64 *)v115;
LABEL_208:
        BYTE1(v255[0]) = 1;
        v86 = "gc relocate is incorrectly tied to the statepoint";
        goto LABEL_158;
      }
      if ( v116 != 88 )
      {
        v247 = (__int64 *)v115;
        if ( !sub_1642D30(v115) )
          goto LABEL_208;
LABEL_242:
        v127 = *(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL)
                         - 24LL * (*(_DWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF));
        if ( *(_BYTE *)(v127 + 16) == 88 )
        {
          v221 = sub_157F120(*(_QWORD *)(v127 + 40));
          v127 = sub_157EBA0(v221);
        }
        v247 = 0;
        v247 = (__int64 *)sub_165C1A0(v127);
        v128 = sub_165BE00(v240, 1u);
        if ( *(_BYTE *)(v128 + 16) != 13 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "gc.relocate operand #2 must be integer offset";
          goto LABEL_96;
        }
        v129 = sub_165BE00(v240, 2u);
        if ( *(_BYTE *)(v129 + 16) != 13 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "gc.relocate operand #3 must be integer offset";
          goto LABEL_96;
        }
        v130 = *(_QWORD **)(v128 + 24);
        if ( *(_DWORD *)(v128 + 32) > 0x40u )
          v130 = (_QWORD *)*v130;
        v131 = *(_QWORD *)(v129 + 24);
        if ( *(_DWORD *)(v129 + 32) > 0x40u )
          v131 = **(_QWORD **)(v129 + 24);
        if ( (int)v130 < 0 || (int)sub_165A000(&v247) <= (int)v130 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "gc.relocate: statepoint base index out of bounds";
          goto LABEL_96;
        }
        v238 = v131;
        if ( (int)v131 < 0 || (int)sub_165A000(&v247) <= (int)v131 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "gc.relocate: statepoint derived index out of bounds";
          goto LABEL_96;
        }
        if ( (unsigned int)sub_165A000(&v247) )
        {
          v132 = *(_QWORD *)(sub_1654960(&v247) + 72);
          if ( *(_BYTE *)(v132 + 16) == 13 )
          {
            v133 = *(_QWORD **)(v132 + 24);
            if ( *(_DWORD *)(v132 + 32) > 0x40u )
              v133 = (_QWORD *)*v133;
            v234 = (int)v133;
            v134 = (int)v133;
            if ( (unsigned int)sub_165A000(&v247) <= (int)v133 + 5 )
            {
              BYTE1(v255[0]) = 1;
              v67 = "gc.statepoint: mismatch in number of call arguments";
            }
            else
            {
              v135 = sub_1654960(&v247);
              v136 = *(_QWORD *)(v135 + 24LL * (unsigned int)(v234 + 5));
              if ( *(_BYTE *)(v136 + 16) == 13 )
              {
                v137 = *(_QWORD **)(v136 + 24);
                if ( *(_DWORD *)(v136 + 32) > 0x40u )
                  v137 = (_QWORD *)*v137;
                v138 = v134 + (_DWORD)v137;
                v139 = *(_QWORD *)(v135 + 24LL * (unsigned int)(v134 + (_DWORD)v137 + 6));
                if ( *(_BYTE *)(v139 + 16) == 13 )
                {
                  v140 = *(_QWORD **)(v139 + 24);
                  if ( *(_DWORD *)(v139 + 32) > 0x40u )
                    v140 = (_QWORD *)*v140;
                  v141 = v138 + (_DWORD)v140 + 7;
                  v142 = sub_165A000(&v247);
                  if ( (int)v130 < v141 || (int)v130 >= v142 )
                  {
                    BYTE1(v255[0]) = 1;
                    v62 = "gc.relocate: statepoint base index doesn't fall within the 'gc parameters' section of the statepoint call";
                  }
                  else if ( v238 < v141 || v238 >= v142 )
                  {
                    BYTE1(v255[0]) = 1;
                    v62 = "gc.relocate: statepoint derived index doesn't fall within the 'gc parameters' section of the statepoint call";
                  }
                  else
                  {
                    v143 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
                    v144 = *(_QWORD *)sub_164F980(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
                    if ( *(_BYTE *)(v144 + 8) == 16 )
                      v144 = **(_QWORD **)(v144 + 16);
                    if ( *(_BYTE *)(v144 + 8) == 15 )
                    {
                      v224 = *(_QWORD *)(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
                      v225 = *(_QWORD *)sub_164F980(v143);
                      v226 = *(_BYTE *)(v224 + 8);
                      v227 = *(_BYTE *)(v225 + 8);
                      if ( (v227 == 16) == (v226 == 16) )
                      {
                        if ( v226 == 16 )
                          v224 = **(_QWORD **)(v224 + 16);
                        if ( v227 == 16 )
                          v225 = **(_QWORD **)(v225 + 16);
                        if ( *(_DWORD *)(v225 + 8) >> 8 == *(_DWORD *)(v224 + 8) >> 8 )
                          goto LABEL_43;
                        BYTE1(v255[0]) = 1;
                        v62 = "gc.relocate: relocating a pointer shouldn't change its address space";
                      }
                      else
                      {
                        BYTE1(v255[0]) = 1;
                        v62 = "gc.relocate: vector relocates to vector and pointer to pointer";
                      }
                    }
                    else
                    {
                      BYTE1(v255[0]) = 1;
                      v62 = "gc.relocate: relocated value must be a gc pointer";
                    }
                  }
LABEL_96:
                  v253 = (char *)v62;
                  LOBYTE(v255[0]) = 3;
                  sub_165BE20((_BYTE *)a1, (__int64)&v253, v240);
                  goto LABEL_43;
                }
                BYTE1(v255[0]) = 1;
                v67 = "gc.statepoint: number of deoptimization arguments must be a constant integer";
              }
              else
              {
                BYTE1(v255[0]) = 1;
                v67 = "gc.statepoint: number of transition arguments must be a constant integer";
              }
            }
          }
          else
          {
            BYTE1(v255[0]) = 1;
            v67 = "gc.statement: number of call arguments must be constant integer";
          }
        }
        else
        {
          BYTE1(v255[0]) = 1;
          v67 = "gc.statepoint: insufficient arguments";
        }
LABEL_120:
        v253 = (char *)v67;
        LOBYTE(v255[0]) = 3;
        sub_164FF40((__int64 *)a1, (__int64)&v253);
        goto LABEL_43;
      }
      v246[0] = sub_157F120(*(_QWORD *)(v115 + 40));
      if ( !v246[0] )
      {
        v247 = *(__int64 **)(v115 + 40);
        v253 = "safepoints should have unique landingpads";
        LOWORD(v255[0]) = 259;
        sub_165AED0((_BYTE *)a1, (__int64)&v253, (__int64 *)&v247);
        goto LABEL_43;
      }
      v222 = sub_157EBA0(v246[0]);
      if ( v222 )
      {
        if ( sub_1642D30(v222) )
          goto LABEL_242;
        BYTE1(v255[0]) = 1;
        v223 = "gc relocate should be linked to a statepoint";
      }
      else
      {
        BYTE1(v255[0]) = 1;
        v223 = "safepoint block should be well formed";
      }
      v253 = (char *)v223;
      LOBYTE(v255[0]) = 3;
      sub_165AA30((_BYTE *)a1, (__int64)&v253, v246);
      goto LABEL_43;
    case 77:
      if ( (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 40) + 56LL) + 19LL) & 0x40) == 0 )
        goto LABEL_104;
      v83 = sub_165BE00(v240, 0);
      v84 = *(_BYTE *)(v83 + 16);
      if ( v84 <= 0x17u )
        goto LABEL_156;
      if ( v84 == 78 )
      {
        v166 = v83 | 4;
      }
      else
      {
        if ( v84 != 29 )
        {
LABEL_156:
          v246[0] = 0;
          goto LABEL_157;
        }
        v166 = v83 & 0xFFFFFFFFFFFFFFFBLL;
      }
      v246[0] = v166;
      if ( (v166 & 0xFFFFFFFFFFFFFFF8LL) != 0 )
      {
        v167 = sub_165B1A0(v246);
        v168 = v167;
        if ( v167 )
        {
          if ( sub_15E4F60(v167) && *(_DWORD *)(v168 + 36) == 78 )
          {
            v169 = sub_165B7C0(v246);
            if ( **(_QWORD **)(*(_QWORD *)(**(_QWORD **)(v169 + 48) + 24LL) + 16LL) == *(_QWORD *)(v240[0]
                                                                                                 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_43;
            BYTE1(v255[0]) = 1;
            v62 = "gc.result result type does not match wrapped callee";
            goto LABEL_96;
          }
        }
      }
LABEL_157:
      v85 = sub_165BE00(v240, 0);
      BYTE1(v255[0]) = 1;
      v247 = (__int64 *)v85;
      v86 = "gc.result operand #1 must be from a statepoint";
LABEL_158:
      v253 = (char *)v86;
      LOBYTE(v255[0]) = 3;
      sub_165BF10((_BYTE *)a1, (__int64)&v253, v240, (__int64 *)&v247);
      goto LABEL_43;
    case 78:
      v73 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v240[0] & 4) != 0 && *(_BYTE *)(*(_QWORD *)(v73 - 24) + 16LL) == 20 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "gc.statepoint support for inline assembly unimplemented";
        goto LABEL_96;
      }
      if ( (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v73 + 40) + 56LL) + 19LL) & 0x40) == 0 )
        goto LABEL_104;
      v242 = sub_165C1A0(v73);
      v42 = v242 & 0xFFFFFFFFFFFFFFF8LL;
      v74 = (_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 56);
      if ( (v242 & 4) == 0 )
      {
        if ( (unsigned __int8)sub_1560260(v74, -1, 36) )
          goto LABEL_151;
        if ( *(char *)(v42 + 23) < 0 )
        {
          v156 = sub_1648A40(v42);
          v158 = v156 + v157;
          v159 = 0;
          if ( *(char *)(v42 + 23) < 0 )
            v159 = sub_1648A40(v42);
          if ( (unsigned int)((v158 - v159) >> 4) )
            goto LABEL_146;
        }
        v79 = *(_QWORD *)(v42 - 72);
        if ( *(_BYTE *)(v79 + 16) )
          goto LABEL_146;
        goto LABEL_145;
      }
      if ( (unsigned __int8)sub_1560260(v74, -1, 36) )
        goto LABEL_151;
      if ( *(char *)(v42 + 23) >= 0 )
        goto LABEL_511;
      v75 = sub_1648A40(v42);
      v77 = v75 + v76;
      v78 = 0;
      if ( *(char *)(v42 + 23) < 0 )
        v78 = sub_1648A40(v42);
      if ( !(unsigned int)((v77 - v78) >> 4) )
      {
LABEL_511:
        v79 = *(_QWORD *)(v42 - 24);
        if ( !*(_BYTE *)(v79 + 16) )
        {
LABEL_145:
          v253 = *(char **)(v79 + 112);
          if ( (unsigned __int8)sub_1560260(&v253, -1, 36) )
            goto LABEL_151;
        }
      }
LABEL_146:
      v80 = v242 & 0xFFFFFFFFFFFFFFF8LL;
      v81 = (_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 56);
      if ( (v242 & 4) != 0 )
      {
        if ( (unsigned __int8)sub_1560260((_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 56), -1, 36) )
          goto LABEL_151;
        if ( !(unsigned int)sub_165C280(v80) )
        {
          v82 = *(_QWORD *)(v80 - 24);
          if ( !*(_BYTE *)(v82 + 16) )
          {
            v253 = *(char **)(v82 + 112);
            if ( (unsigned __int8)sub_1560260(&v253, -1, 36) )
              goto LABEL_151;
          }
        }
        if ( (unsigned __int8)sub_1560260(v81, -1, 37) )
          goto LABEL_151;
        if ( *(char *)(v80 + 23) >= 0 )
        {
          v172 = 0;
          v173 = 0;
        }
        else
        {
          v170 = sub_1648A40(v80);
          v172 = (__int64 *)(v170 + v171);
          if ( *(char *)(v80 + 23) >= 0 )
            v173 = 0;
          else
            v173 = (__int64 *)sub_1648A40(v80);
        }
        while ( v173 != v172 )
        {
          v174 = *v173;
          v173 += 2;
          if ( *(_DWORD *)(v174 + 8) > 1u )
            goto LABEL_361;
        }
        v212 = *(_QWORD *)(v80 - 24);
        if ( *(_BYTE *)(v212 + 16) )
          goto LABEL_361;
      }
      else
      {
        if ( (unsigned __int8)sub_1560260((_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 56), -1, 36) )
          goto LABEL_151;
        if ( !(unsigned int)sub_165C2D0(v80) )
        {
          v213 = *(_QWORD *)(v80 - 72);
          if ( !*(_BYTE *)(v213 + 16) )
          {
            v253 = *(char **)(v213 + 112);
            if ( (unsigned __int8)sub_1560260(&v253, -1, 36) )
              goto LABEL_151;
          }
        }
        if ( (unsigned __int8)sub_1560260(v81, -1, 37) )
          goto LABEL_151;
        if ( *(char *)(v80 + 23) >= 0 )
        {
          v216 = 0;
          v217 = 0;
        }
        else
        {
          v214 = sub_1648A40(v80);
          v216 = (__int64 *)(v214 + v215);
          if ( *(char *)(v80 + 23) >= 0 )
            v217 = 0;
          else
            v217 = (__int64 *)sub_1648A40(v80);
        }
        while ( v217 != v216 )
        {
          v218 = *v217;
          v217 += 2;
          if ( *(_DWORD *)(v218 + 8) > 1u )
            goto LABEL_361;
        }
        v212 = *(_QWORD *)(v80 - 72);
        if ( *(_BYTE *)(v212 + 16) )
          goto LABEL_361;
      }
      v253 = *(char **)(v212 + 112);
      if ( (unsigned __int8)sub_1560260(&v253, -1, 37) )
        goto LABEL_151;
LABEL_361:
      v175 = v242 & 0xFFFFFFFFFFFFFFF8LL;
      v176 = (_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 56);
      if ( (v242 & 4) != 0 )
      {
        if ( !(unsigned __int8)sub_1560260(v176, -1, 4) )
        {
          if ( *(char *)(v175 + 23) < 0 )
          {
            v177 = sub_1648A40(v175);
            v179 = v177 + v178;
            v180 = 0;
            if ( *(char *)(v175 + 23) < 0 )
              v180 = sub_1648A40(v175);
            if ( (unsigned int)((v179 - v180) >> 4) )
              goto LABEL_369;
          }
          v181 = *(_QWORD *)(v175 - 24);
          if ( *(_BYTE *)(v181 + 16) )
            goto LABEL_369;
          goto LABEL_368;
        }
LABEL_151:
        BYTE1(v255[0]) = 1;
        v53 = "gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics";
        goto LABEL_87;
      }
      if ( (unsigned __int8)sub_1560260(v176, -1, 4) )
        goto LABEL_151;
      if ( (unsigned int)sub_165C2D0(v175) )
        goto LABEL_369;
      v181 = *(_QWORD *)(v175 - 72);
      if ( *(_BYTE *)(v181 + 16) )
        goto LABEL_369;
LABEL_368:
      v253 = *(char **)(v181 + 112);
      if ( (unsigned __int8)sub_1560260(&v253, -1, 4) )
        goto LABEL_151;
LABEL_369:
      v182 = (_QWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL)
                      - 24LL * (*(_DWORD *)((v242 & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF));
      if ( *(_BYTE *)(*v182 + 16LL) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint ID must be a constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v183 = v182[3];
      if ( *(_BYTE *)(v183 + 16) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of patchable bytes must be a constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v184 = *(_DWORD *)(v183 + 32);
      v185 = *(__int64 **)(v183 + 24);
      if ( v184 > 0x40 )
        v186 = *v185;
      else
        v186 = (__int64)((_QWORD)v185 << (64 - (unsigned __int8)v184)) >> (64 - (unsigned __int8)v184);
      if ( v186 < 0 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of patchable bytes must be positive";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v187 = v182[6];
      if ( *(_BYTE *)(*(_QWORD *)v187 + 8LL) != 15
        || (v188 = *(_QWORD *)(*(_QWORD *)v187 + 24LL), *(_BYTE *)(v188 + 8) != 12) )
      {
        v253 = "gc.statepoint callee must be of function pointer type";
        LOWORD(v255[0]) = 259;
        sub_164FF40((__int64 *)a1, (__int64)&v253);
        if ( *(_QWORD *)a1 )
        {
          sub_164FA80((__int64 *)a1, v42);
          sub_164FA80((__int64 *)a1, v187);
        }
        goto LABEL_43;
      }
      v189 = v182[9];
      if ( *(_BYTE *)(v189 + 16) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of arguments to underlying call must be constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v190 = *(_QWORD **)(v189 + 24);
      if ( *(_DWORD *)(v189 + 32) > 0x40u )
        v190 = (_QWORD *)*v190;
      v191 = (int)v190;
      if ( (int)v190 < 0 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of arguments to underlying call must be positive";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v192 = *(_DWORD *)(v188 + 12) - 1;
      if ( *(_DWORD *)(v188 + 8) >> 8 )
      {
        if ( (int)v190 < v192 )
        {
          v247 = (__int64 *)v42;
          v211 = "gc.statepoint mismatch in number of vararg call args";
          BYTE1(v255[0]) = 1;
          goto LABEL_405;
        }
        if ( *(_BYTE *)(**(_QWORD **)(v188 + 16) + 8LL) )
        {
          v247 = (__int64 *)v42;
          v211 = "gc.statepoint doesn't support wrapping non-void vararg functions yet";
          BYTE1(v255[0]) = 1;
          goto LABEL_405;
        }
      }
      else if ( (_DWORD)v190 != v192 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint mismatch in number of call args";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v193 = v182[12];
      if ( *(_BYTE *)(v193 + 16) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint flags must be constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v194 = *(_QWORD *)(v193 + 24);
      if ( *(_DWORD *)(v193 + 32) > 0x40u )
        v194 = *(_QWORD *)v194;
      v195 = v194 & 0xFFFFFFFFFFFFFFFCLL;
      if ( v195 )
      {
        v247 = (__int64 *)v42;
        v211 = "unknown flag used in gc.statepoint flags argument";
        BYTE1(v255[0]) = 1;
LABEL_405:
        v253 = (char *)v211;
        LOBYTE(v255[0]) = 3;
        sub_1659F10((_BYTE *)a1, (__int64)&v253, (__int64 *)&v247);
        goto LABEL_43;
      }
      while ( v192 > (int)v195 )
      {
        v196 = (_QWORD *)v182[3 * v195++ + 15];
        if ( *(_QWORD *)(*(_QWORD *)(v188 + 16) + 8 * v195) != *v196 )
        {
          v247 = (__int64 *)v42;
          v211 = "gc.statepoint call argument does not match wrapped function type";
          BYTE1(v255[0]) = 1;
          goto LABEL_405;
        }
      }
      v197 = v182[3 * v191 + 15];
      if ( *(_BYTE *)(v197 + 16) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of transition arguments must be constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v198 = *(_QWORD **)(v197 + 24);
      if ( *(_DWORD *)(v197 + 32) > 0x40u )
        v198 = (_QWORD *)*v198;
      v199 = (int)v198;
      if ( (int)v198 < 0 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of transition arguments must be positive";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v200 = v182[3 * v191 + 18 + 3 * (int)v198];
      if ( *(_BYTE *)(v200 + 16) != 13 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of deoptimization arguments must be constant integer";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      v201 = *(_QWORD **)(v200 + 24);
      if ( *(_DWORD *)(v200 + 32) > 0x40u )
        v201 = (_QWORD *)*v201;
      if ( (int)v201 < 0 )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint number of deoptimization arguments must be positive";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      if ( v191 + v199 + 7 + (int)v201 > (int)sub_165A000(&v242) )
      {
        v247 = (__int64 *)v42;
        v211 = "gc.statepoint too few arguments according to length fields";
        BYTE1(v255[0]) = 1;
        goto LABEL_405;
      }
      for ( j = *(_QWORD *)(v42 + 8); ; j = *(_QWORD *)(j + 8) )
      {
        if ( !j )
          goto LABEL_43;
        v203 = sub_1648700(j);
        v56 = *((_BYTE *)v203 + 16) == 78;
        v243 = v203;
        if ( !v56 )
        {
          v247 = (__int64 *)v42;
          v204 = "illegal use of statepoint token";
          v246[0] = 0;
          BYTE1(v255[0]) = 1;
LABEL_403:
          v253 = (char *)v204;
          LOBYTE(v255[0]) = 3;
          sub_165A1E0((_BYTE *)a1, (__int64)&v253, (__int64 *)&v247, (__int64 *)&v243);
          goto LABEL_43;
        }
        v246[0] = (__int64)v203;
        v205 = *(v203 - 3);
        if ( *(_BYTE *)(v205 + 16) || (v206 = *(_BYTE *)(v205 + 33), (v206 & 0x20) == 0) )
        {
LABEL_411:
          v247 = (__int64 *)v42;
          v204 = "gc.result or gc.relocate are the only value uses of a gc.statepoint";
          BYTE1(v255[0]) = 1;
          goto LABEL_403;
        }
        if ( *(_DWORD *)(v205 + 36) == 76 )
        {
          v207 = v229;
        }
        else
        {
          if ( (v206 & 0x20) == 0 || *(_DWORD *)(v205 + 36) != 77 )
            goto LABEL_411;
          v207 = 0;
        }
        if ( *(_DWORD *)(v205 + 36) == 77 )
          break;
        if ( v207 )
        {
          v208 = v203[-3 * (*((_DWORD *)v203 + 5) & 0xFFFFFFF)];
          if ( !v208 || v208 != v42 )
          {
            v247 = (__int64 *)v42;
            v209 = "gc.relocate connected to wrong gc.statepoint";
            BYTE1(v255[0]) = 1;
            goto LABEL_424;
          }
        }
LABEL_418:
        ;
      }
      v210 = v203[-3 * (*((_DWORD *)v203 + 5) & 0xFFFFFFF)];
      if ( v210 && v210 == v42 )
        goto LABEL_418;
      v247 = (__int64 *)v42;
      v209 = "gc.result connected to wrong gc.statepoint";
      BYTE1(v255[0]) = 1;
LABEL_424:
      v253 = (char *)v209;
      LOBYTE(v255[0]) = 3;
      sub_165A340((_BYTE *)a1, (__int64)&v253, (__int64 *)&v247, v246);
LABEL_43:
      if ( s1 != &v252 )
        j_j___libc_free_0(s1, v252 + 1);
LABEL_31:
      if ( v256 != (__int64 *)v258 )
        _libc_free((unsigned __int64)v256);
      if ( v259 != (unsigned int *)v261 )
        _libc_free((unsigned __int64)v259);
      return;
    case 79:
      if ( (v240[0] & 4) == 0 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "experimental_guard cannot be invoked";
        goto LABEL_96;
      }
      if ( (unsigned int)sub_165C060(v240, 0) == 1 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v67 = "experimental_guard must have exactly one \"deopt\" operand bundle";
      goto LABEL_120;
    case 104:
    case 105:
    case 106:
      if ( a2 != 105 )
        goto LABEL_103;
      v154 = sub_165BE00(v240, 0);
      v155 = sub_1649C60(v154);
      if ( *(_BYTE *)(v155 + 16) == 53 )
      {
        v219 = *(_BYTE *)(sub_165BE00(v240, 1u) + 16);
        if ( v219 > 0x10u )
        {
          BYTE1(v255[0]) = 1;
          v62 = "llvm.gcroot parameter #2 must be a constant.";
        }
        else if ( *(_BYTE *)(*(_QWORD *)(v155 + 56) + 8LL) == 15 || v219 != 15 )
        {
LABEL_103:
          if ( (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 40) + 56LL) + 19LL) & 0x40) != 0 )
            goto LABEL_43;
LABEL_104:
          BYTE1(v255[0]) = 1;
          v62 = "Enclosing function does not use GC.";
        }
        else
        {
          BYTE1(v255[0]) = 1;
          v62 = "llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.";
        }
      }
      else
      {
        BYTE1(v255[0]) = 1;
        v62 = "llvm.gcroot parameter #1 must be an alloca.";
      }
      goto LABEL_96;
    case 109:
      v72 = sub_165BE00(v240, 1u);
      if ( !*(_BYTE *)(sub_1649C60(v72) + 16) )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "llvm.init_trampoline parameter #2 must resolve to a function.";
      goto LABEL_96;
    case 113:
      if ( *(_BYTE *)(sub_165BE00(v240, 1u) + 16) == 13 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "llvm.invariant.end parameter #2 must be a constant integer";
      goto LABEL_96;
    case 114:
    case 116:
    case 117:
      if ( *(_BYTE *)(sub_165BE00(v240, 0) + 16) == 13 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "size argument of memory use markers must be a constant integer";
      goto LABEL_96;
    case 120:
      v117 = *(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 40);
      v118 = *(_QWORD *)(*(_QWORD *)(v117 + 56) + 80LL);
      if ( !v118 || v117 != v118 - 24 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "llvm.localescape used outside of entry block";
        goto LABEL_96;
      }
      if ( *(_BYTE *)(a1 + 720) )
      {
        BYTE1(v255[0]) = 1;
        v62 = "multiple calls to llvm.localescape in one function";
        goto LABEL_96;
      }
      v119 = sub_165BC30(v240);
      v121 = v120;
      for ( k = (__int64 *)v119; v121 != k; k += 3 )
      {
        if ( *(_BYTE *)(*k + 16) != 15 )
        {
          v123 = sub_1649C60(*k);
          if ( *(_BYTE *)(v123 + 16) != 53 || !(unsigned __int8)sub_15F8F00(v123) )
          {
            BYTE1(v255[0]) = 1;
            v62 = "llvm.localescape only accepts static allocas";
            goto LABEL_96;
          }
        }
      }
      v253 = *(char **)(v117 + 56);
      v220 = sub_165FBF0(a1 + 728, (__int64 *)&v253);
      *((_DWORD *)v220 + 2) = sub_14DA610(v240);
      *(_BYTE *)(a1 + 720) = 1;
      goto LABEL_43;
    case 121:
      v94 = sub_165BE00(v240, 0);
      v95 = sub_1649C60(v94);
      if ( *(_BYTE *)(v95 + 16) )
      {
        v247 = 0;
      }
      else
      {
        v247 = (__int64 *)v95;
        if ( !sub_15E4F60(v95) )
        {
          v96 = sub_165BE00(v240, 2u);
          if ( *(_BYTE *)(v96 + 16) != 13 )
          {
            BYTE1(v255[0]) = 1;
            v62 = "idx argument of llvm.localrecover must be a constant int";
            goto LABEL_96;
          }
          v97 = sub_165F9B0(a1 + 728, (__int64 *)&v247);
          v98 = *(_DWORD *)(v96 + 32);
          v99 = v97;
          if ( v98 > 0x40 )
          {
            v160 = sub_16A57B0(v96 + 24);
            LODWORD(v101) = 0;
            if ( v98 - v160 > 0x40 )
              goto LABEL_177;
            v100 = **(_QWORD **)(v96 + 24);
            if ( v100 > 0xFFFFFFFF )
              goto LABEL_177;
          }
          else
          {
            v100 = *(_QWORD *)(v96 + 24);
            LODWORD(v101) = 0;
            if ( v100 > 0xFFFFFFFF )
            {
LABEL_177:
              *((_DWORD *)v99 + 3) = v101;
              goto LABEL_43;
            }
          }
          v101 = *((unsigned int *)v99 + 3);
          v161 = v100 + 1;
          if ( v161 >= v101 )
            LODWORD(v101) = v161;
          goto LABEL_177;
        }
      }
      BYTE1(v255[0]) = 1;
      v62 = "llvm.localrecover first argument must be function defined in this module";
      goto LABEL_96;
    case 129:
      v91 = *(_QWORD *)(v240[0] & 0xFFFFFFFFFFFFFFF8LL);
      if ( *(_BYTE *)(v91 + 8) == 16 )
      {
        v92 = sub_165BE00(v240, 2u);
        v93 = *(_QWORD *)v92;
        if ( *(_BYTE *)(*(_QWORD *)v92 + 8LL) == 16 )
        {
          if ( v91 == *(_QWORD *)(*(_QWORD *)sub_165BE00(v240, 0) + 24LL) )
          {
            if ( v91 == *(_QWORD *)sub_165BE00(v240, 3u) )
            {
              if ( *(_DWORD *)(v91 + 32) == *(_DWORD *)(v93 + 32) )
                goto LABEL_43;
              BYTE1(v255[0]) = 1;
              v62 = "masked_load: vector mask must be same length as data";
            }
            else
            {
              BYTE1(v255[0]) = 1;
              v62 = "masked_load: pass through and data type must match";
            }
          }
          else
          {
            BYTE1(v255[0]) = 1;
            v62 = "masked_load: return must match pointer type";
          }
        }
        else
        {
          BYTE1(v255[0]) = 1;
          v62 = "masked_load: mask must be vector";
        }
      }
      else
      {
        BYTE1(v255[0]) = 1;
        v62 = "masked_load: must return a vector";
      }
      goto LABEL_96;
    case 131:
      v87 = sub_165BE00(v240, 3u);
      v88 = *(_QWORD *)v87;
      if ( *(_BYTE *)(*(_QWORD *)v87 + 8LL) == 16 )
      {
        v89 = (_QWORD *)sub_165BE00(v240, 0);
        v90 = *(_QWORD *)(*(_QWORD *)sub_165BE00(v240, 1u) + 24LL);
        if ( *v89 == v90 )
        {
          if ( *(_DWORD *)(v90 + 32) == *(_DWORD *)(v88 + 32) )
            goto LABEL_43;
          BYTE1(v255[0]) = 1;
          v62 = "masked_store: vector mask must be same length as data";
        }
        else
        {
          BYTE1(v255[0]) = 1;
          v62 = "masked_store: storee must match pointer type";
        }
      }
      else
      {
        BYTE1(v255[0]) = 1;
        v62 = "masked_store: mask must be vector";
      }
      goto LABEL_96;
    case 133:
    case 135:
    case 137:
      v63 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      v64 = (_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 56);
      v65 = sub_15603A0(v64, 0);
      if ( v65 && (v65 & (v65 - 1)) != 0 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "alignment of arg 0 of memory intrinsic must be 0 or a power of 2";
        goto LABEL_96;
      }
      v124 = *(_QWORD *)(v63 - 24);
      if ( !*(_BYTE *)(v124 + 16) )
      {
        if ( (*(_DWORD *)(v124 + 36) & 0xFFFFFFFD) == 0x85
          && v63
          && (v125 = sub_15603A0(v64, 1)) != 0
          && (v125 & (v125 - 1)) != 0 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "alignment of arg 1 of memory intrinsic must be 0 or a power of 2";
        }
        else
        {
          if ( *(_BYTE *)(sub_165BE00(v240, 3u) + 16) == 13 )
            goto LABEL_43;
          BYTE1(v255[0]) = 1;
          v62 = "isvolatile argument of memory intrinsics must be a constant int";
        }
        goto LABEL_96;
      }
      goto LABEL_505;
    case 134:
    case 136:
    case 138:
      v57 = v240[0] & 0xFFFFFFFFFFFFFFF8LL;
      v58 = *(_DWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF;
      v59 = *(_QWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 24 * (3 - v58));
      if ( *(_BYTE *)(v59 + 16) != 13 )
      {
        BYTE1(v255[0]) = 1;
        v62 = "element size of the element-wise unordered atomic memory intrinsic must be a constant int";
        goto LABEL_96;
      }
      v60 = *(_DWORD *)(v59 + 32);
      if ( v60 > 0x40 )
      {
        v235 = *(_DWORD *)(v59 + 32);
        v239 = *(_DWORD *)((v240[0] & 0xFFFFFFFFFFFFFFF8LL) + 20) & 0xFFFFFFF;
        v147 = sub_16A5940(v59 + 24);
        v58 = v239;
        v60 = v235;
        if ( v147 != 1 )
        {
LABEL_95:
          BYTE1(v255[0]) = 1;
          v62 = "element size of the element-wise atomic memory intrinsic must be a power of 2";
          goto LABEL_96;
        }
      }
      else
      {
        v61 = *(_QWORD *)(v59 + 24);
        if ( !v61 || (v61 & (v61 - 1)) != 0 )
          goto LABEL_95;
      }
      v148 = *(_QWORD *)(v57 + 24 * (2 - v58));
      if ( *(_BYTE *)(v148 + 16) == 13 )
      {
        v149 = *(_QWORD *)(v148 + 24);
        if ( *(_DWORD *)(v148 + 32) > 0x40u )
          v149 = *(_QWORD *)v149;
        v150 = *(_QWORD **)(v59 + 24);
        if ( v60 > 0x40 )
          v150 = (_QWORD *)*v150;
        if ( v149 % (unsigned int)v150 )
        {
          BYTE1(v255[0]) = 1;
          v62 = "constant length must be a multiple of the element size in the element-wise atomic memory intrinsic";
          goto LABEL_96;
        }
      }
      v247 = (__int64 *)(v59 + 24);
      v151 = sub_15603A0((_QWORD *)(v57 + 56), 0);
      if ( !(unsigned __int8)sub_164EB20(&v247, v151) )
      {
        BYTE1(v255[0]) = 1;
        v62 = "incorrect alignment of the destination argument";
        goto LABEL_96;
      }
      v152 = *(_QWORD *)(v57 - 24);
      if ( !*(_BYTE *)(v152 + 16) )
      {
        if ( ((*(_DWORD *)(v152 + 36) - 134) & 0xFFFFFFFD) != 0 )
          goto LABEL_43;
        v153 = sub_15603A0((_QWORD *)(v57 + 56), 1);
        if ( (unsigned __int8)sub_164EB20(&v247, v153) )
          goto LABEL_43;
        BYTE1(v255[0]) = 1;
        v62 = "incorrect alignment of the source argument";
        goto LABEL_96;
      }
LABEL_505:
      BUG();
    case 148:
      v68 = sub_165BE00(v240, 1u);
      if ( *(_BYTE *)(v68 + 16) == 13 )
      {
        v69 = sub_165BE00(v240, 2u);
        if ( *(_BYTE *)(v69 + 16) == 13 )
        {
          v70 = *(_QWORD **)(v68 + 24);
          if ( *(_DWORD *)(v68 + 32) > 0x40u )
            v70 = (_QWORD *)*v70;
          if ( (unsigned __int64)v70 <= 1 )
          {
            v71 = *(_QWORD **)(v69 + 24);
            if ( *(_DWORD *)(v69 + 32) > 0x40u )
              v71 = (_QWORD *)*v71;
            if ( (unsigned __int64)v71 <= 3 )
              goto LABEL_43;
          }
        }
      }
      BYTE1(v255[0]) = 1;
      v62 = "invalid arguments to llvm.prefetch";
      goto LABEL_96;
    case 200:
      v66 = sub_165BE00(v240, 1u);
      if ( *(_BYTE *)(sub_1649C60(v66) + 16) == 53 )
        goto LABEL_43;
      BYTE1(v255[0]) = 1;
      v62 = "llvm.stackprotector parameter #2 must resolve to an alloca.";
      goto LABEL_96;
    default:
      goto LABEL_43;
  }
}
