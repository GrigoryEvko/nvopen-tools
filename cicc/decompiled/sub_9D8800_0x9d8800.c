// Function: sub_9D8800
// Address: 0x9d8800
//
__int64 *__fastcall sub_9D8800(__int64 *a1, __int64 a2, __int64 a3, char *a4)
{
  __int64 v4; // r14
  __int64 *v5; // r12
  __int64 v7; // rbx
  __int64 *v8; // r15
  __int64 *v9; // rsi
  char v10; // dl
  unsigned __int64 v11; // rsi
  __int64 v12; // rdx
  unsigned __int64 v13; // r10
  __int64 *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rax
  unsigned __int64 v19; // r10
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 *v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  unsigned int v26; // r13d
  int v27; // ebx
  __int64 v28; // rax
  __int64 v29; // r12
  __int64 v30; // rax
  unsigned __int64 v31; // rdx
  __int64 v32; // rdx
  unsigned __int64 v33; // r10
  __int64 v34; // r9
  unsigned int v35; // ebx
  int v36; // r13d
  unsigned int v37; // eax
  __int64 v38; // rax
  __int64 v39; // rdx
  __int64 v40; // r13
  __int64 v41; // rcx
  __int64 *v42; // r8
  __int64 v43; // r9
  unsigned __int64 v44; // rdx
  _BYTE *v45; // rcx
  __int64 v46; // rax
  unsigned int v47; // ebx
  int v48; // r13d
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // rdx
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // r13
  bool v57; // r8
  __int64 v58; // r9
  __int64 v59; // rax
  unsigned __int64 v60; // rdx
  __int64 v61; // rax
  __int64 v62; // r13
  __int64 v63; // r8
  __int64 v64; // rax
  unsigned __int64 v65; // rdx
  __int64 v66; // rax
  __int64 v67; // rax
  __int64 v68; // rax
  unsigned int v69; // ebx
  int v70; // r13d
  __int64 v71; // rax
  __int64 v72; // rdx
  unsigned int v73; // r13d
  __int64 v74; // rax
  _QWORD *v75; // r8
  __int64 v76; // r9
  __int64 v77; // rax
  unsigned __int64 v78; // rdx
  __int64 v79; // rax
  __int64 v80; // rax
  char *v81; // rax
  __int64 v82; // rax
  __int64 v83; // rax
  __int64 v84; // rax
  __int64 v85; // rdx
  __int64 v86; // rax
  __int64 v87; // rax
  __int64 v88; // rax
  unsigned int v89; // esi
  __int64 v90; // r8
  unsigned int v91; // ecx
  _DWORD *v92; // rax
  unsigned int v93; // edx
  _QWORD *v94; // rdi
  __int64 v95; // r10
  unsigned __int64 v96; // r9
  __int64 v97; // rdx
  __int64 *v98; // r8
  __int64 v99; // r13
  char *v100; // rcx
  __int64 v101; // rax
  __int64 v102; // rax
  __int64 v103; // rdi
  unsigned __int64 v104; // r9
  __int64 *v105; // r8
  char *v106; // rcx
  __int64 v107; // rax
  __int64 v108; // r9
  unsigned __int64 v109; // r9
  __int64 v110; // rdx
  __int64 *v111; // r8
  __int64 v112; // r13
  char *v113; // rcx
  __int64 v114; // rax
  __int64 v115; // rdi
  __int64 v116; // rax
  __int64 v117; // rcx
  unsigned __int64 v118; // r13
  __int64 v119; // rdi
  __int64 v120; // rdx
  __int64 *v121; // r8
  unsigned __int64 v122; // r11
  __int64 v123; // rax
  __int64 v124; // rdi
  unsigned int *v125; // rdi
  int v126; // r11d
  int v127; // eax
  int v128; // edx
  _DWORD *v129; // rax
  char *v130; // rax
  __int64 *v131; // r11
  __int64 v132; // r13
  __int64 *v133; // rax
  unsigned __int64 v134; // r15
  __int64 v135; // r10
  __int64 v136; // r14
  unsigned __int64 v137; // r12
  __int64 *v138; // r8
  __int64 v139; // rax
  unsigned __int64 v140; // rbx
  __int64 v141; // rax
  unsigned __int64 v142; // rdx
  int v143; // ecx
  int v144; // ecx
  __int64 v145; // r8
  __int64 v146; // rsi
  unsigned int v147; // r11d
  unsigned int *v148; // rax
  int v149; // r10d
  __int64 v150; // rdx
  unsigned __int64 v151; // rax
  unsigned __int64 v152; // rax
  int v153; // ecx
  int v154; // ecx
  __int64 v155; // rsi
  __int64 v156; // r13
  unsigned int v157; // r10d
  int v158; // r9d
  char *v159; // rax
  bool v160; // zf
  char *v161; // rax
  unsigned __int64 v162; // rax
  __int64 v163; // rax
  __int64 v164; // rax
  __int64 v165; // [rsp+0h] [rbp-450h]
  __int64 v166; // [rsp+8h] [rbp-448h]
  __int64 v167; // [rsp+20h] [rbp-430h]
  __int64 v168; // [rsp+20h] [rbp-430h]
  __int64 v169; // [rsp+20h] [rbp-430h]
  __int64 v170; // [rsp+28h] [rbp-428h]
  __int64 *v171; // [rsp+28h] [rbp-428h]
  unsigned __int64 v172; // [rsp+28h] [rbp-428h]
  unsigned int v173; // [rsp+30h] [rbp-420h]
  __int64 v174; // [rsp+30h] [rbp-420h]
  unsigned __int64 v175; // [rsp+30h] [rbp-420h]
  __int64 v176; // [rsp+30h] [rbp-420h]
  __int64 v177; // [rsp+30h] [rbp-420h]
  __int64 v178; // [rsp+30h] [rbp-420h]
  __int64 v179; // [rsp+30h] [rbp-420h]
  __int64 v180; // [rsp+30h] [rbp-420h]
  __int64 v181; // [rsp+30h] [rbp-420h]
  unsigned __int64 v182; // [rsp+30h] [rbp-420h]
  __int64 v183; // [rsp+38h] [rbp-418h]
  unsigned __int64 v184; // [rsp+38h] [rbp-418h]
  unsigned __int64 v185; // [rsp+38h] [rbp-418h]
  __int64 *v186; // [rsp+38h] [rbp-418h]
  __int64 *v187; // [rsp+38h] [rbp-418h]
  __int64 *v188; // [rsp+38h] [rbp-418h]
  __int64 v189; // [rsp+40h] [rbp-410h]
  __int64 *v190; // [rsp+40h] [rbp-410h]
  __int64 v191; // [rsp+40h] [rbp-410h]
  __int64 v192; // [rsp+40h] [rbp-410h]
  __int64 v193; // [rsp+40h] [rbp-410h]
  __int64 v194; // [rsp+40h] [rbp-410h]
  unsigned __int64 v195; // [rsp+40h] [rbp-410h]
  __int64 *v196; // [rsp+40h] [rbp-410h]
  __int64 *v197; // [rsp+40h] [rbp-410h]
  __int64 v198; // [rsp+40h] [rbp-410h]
  unsigned __int64 v199; // [rsp+40h] [rbp-410h]
  unsigned __int64 v200; // [rsp+40h] [rbp-410h]
  __int64 v201; // [rsp+40h] [rbp-410h]
  __int64 v202; // [rsp+40h] [rbp-410h]
  __int64 v203; // [rsp+40h] [rbp-410h]
  int v204; // [rsp+40h] [rbp-410h]
  __int64 v205; // [rsp+40h] [rbp-410h]
  __int64 v206; // [rsp+48h] [rbp-408h]
  _QWORD *v207; // [rsp+48h] [rbp-408h]
  __int64 v208; // [rsp+48h] [rbp-408h]
  __int64 v209; // [rsp+48h] [rbp-408h]
  __int64 v210; // [rsp+48h] [rbp-408h]
  __int64 v211; // [rsp+48h] [rbp-408h]
  __int64 *v212; // [rsp+48h] [rbp-408h]
  __int64 v213; // [rsp+48h] [rbp-408h]
  bool v214; // [rsp+48h] [rbp-408h]
  unsigned int v215; // [rsp+7Ch] [rbp-3D4h]
  unsigned __int64 v216; // [rsp+88h] [rbp-3C8h] BYREF
  __int64 v217; // [rsp+90h] [rbp-3C0h] BYREF
  unsigned __int64 v218; // [rsp+98h] [rbp-3B8h]
  __int64 v219; // [rsp+A0h] [rbp-3B0h] BYREF
  char v220; // [rsp+A8h] [rbp-3A8h]
  __int64 v221; // [rsp+B0h] [rbp-3A0h] BYREF
  char v222; // [rsp+B8h] [rbp-398h]
  char *v223; // [rsp+C0h] [rbp-390h] BYREF
  char v224; // [rsp+C8h] [rbp-388h]
  char v225; // [rsp+E0h] [rbp-370h]
  char v226; // [rsp+E1h] [rbp-36Fh]
  __int64 v227; // [rsp+F0h] [rbp-360h] BYREF
  __int64 v228; // [rsp+F8h] [rbp-358h]
  _BYTE v229[16]; // [rsp+100h] [rbp-350h] BYREF
  char v230; // [rsp+110h] [rbp-340h]
  char v231; // [rsp+111h] [rbp-33Fh]
  char *v232; // [rsp+120h] [rbp-330h] BYREF
  __int64 v233; // [rsp+128h] [rbp-328h]
  _BYTE v234[48]; // [rsp+130h] [rbp-320h] BYREF
  const char *v235; // [rsp+160h] [rbp-2F0h] BYREF
  __int64 v236; // [rsp+168h] [rbp-2E8h]
  _BYTE v237[16]; // [rsp+170h] [rbp-2E0h] BYREF
  char v238; // [rsp+180h] [rbp-2D0h]
  char v239; // [rsp+181h] [rbp-2CFh]
  _BYTE *v240; // [rsp+1B0h] [rbp-2A0h] BYREF
  __int64 v241; // [rsp+1B8h] [rbp-298h]
  unsigned __int64 v242; // [rsp+1C0h] [rbp-290h]
  _BYTE v243[72]; // [rsp+1C8h] [rbp-288h] BYREF
  __int64 *v244; // [rsp+210h] [rbp-240h] BYREF
  __int64 v245; // [rsp+218h] [rbp-238h]
  _BYTE v246[560]; // [rsp+220h] [rbp-230h] BYREF

  v4 = a2;
  v5 = a1;
  if ( *(_QWORD *)(a2 + 528) != *(_QWORD *)(a2 + 536) )
  {
    v246[17] = 1;
    v244 = (__int64 *)"Invalid multiple blocks";
    v246[16] = 3;
    sub_9C81F0(a1, a2 + 8, (__int64)&v244);
    return v5;
  }
  v7 = a2 + 32;
  v241 = 0;
  v8 = &v219;
  v244 = (__int64 *)v246;
  v245 = 0x4000000000LL;
  v240 = v243;
  v242 = 64;
  v215 = 0;
  while ( 2 )
  {
    v9 = (__int64 *)v7;
    sub_9CEFB0((__int64)v8, v7, 0, (__int64)a4);
    v10 = v220 & 1;
    v220 = (2 * (v220 & 1)) | v220 & 0xFD;
    if ( v10 )
    {
      v9 = v8;
      sub_9C9090(v5, v8);
      goto LABEL_11;
    }
    if ( (_DWORD)v219 == 1 )
    {
      if ( v215 != (__int64)(*(_QWORD *)(v4 + 536) - *(_QWORD *)(v4 + 528)) >> 3 )
      {
LABEL_10:
        v239 = 1;
        v9 = (__int64 *)(v4 + 8);
        v235 = "Malformed block";
        v238 = 3;
        sub_9C81F0(v5, v4 + 8, (__int64)&v235);
        goto LABEL_11;
      }
      *v5 = 1;
      goto LABEL_13;
    }
    if ( (v219 & 0xFFFFFFFD) == 0 )
      goto LABEL_10;
    v11 = v7;
    v232 = v234;
    v233 = 0xC00000000LL;
    LODWORD(v245) = 0;
    sub_A4B600(&v221, v7, HIDWORD(v219), &v244, 0);
    v12 = v222 & 1;
    v222 = (2 * v12) | v222 & 0xFD;
    if ( (_BYTE)v12 )
    {
      v9 = &v221;
      sub_9C8CD0(v5, &v221);
      goto LABEL_122;
    }
    switch ( (int)v221 )
    {
      case 1:
        if ( !(_DWORD)v245 )
        {
          v239 = 1;
          v81 = "Invalid numentry record";
          goto LABEL_121;
        }
        v11 = *(_QWORD *)(v4 + 528);
        v150 = *v244;
        v151 = (__int64)(*(_QWORD *)(v4 + 536) - v11) >> 3;
        if ( *v244 > v151 )
        {
          v11 = v150 - v151;
          sub_9CBAB0(v4 + 528, v150 - v151);
        }
        else if ( *v244 < v151 )
        {
          v152 = v11 + 8 * v150;
          if ( *(_QWORD *)(v4 + 536) != v152 )
            *(_QWORD *)(v4 + 536) = v152;
        }
LABEL_71:
        sub_9CE2A0(&v221);
        if ( v232 != v234 )
          _libc_free(v232, v11);
        sub_9CEF80(v8);
        continue;
      case 2:
        v84 = sub_BCB120(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v84;
        goto LABEL_34;
      case 3:
        v83 = sub_BCB160(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v83;
        goto LABEL_34;
      case 4:
        v68 = sub_BCB170(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v68;
        goto LABEL_34;
      case 5:
        v67 = sub_BCB130(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v67;
        goto LABEL_34;
      case 6:
        if ( (_DWORD)v245 != 1 )
        {
          v239 = 1;
          v81 = "Invalid opaque type record";
          goto LABEL_121;
        }
        v85 = *(_QWORD *)(v4 + 528);
        if ( v215 >= (unsigned __int64)((*(_QWORD *)(v4 + 536) - v85) >> 3) )
        {
LABEL_167:
          v239 = 1;
          v81 = "Invalid TYPE table";
          goto LABEL_121;
        }
        v11 = (unsigned __int64)v240;
        if ( *(_QWORD *)(v85 + 8LL * v215) )
        {
          v208 = *(_QWORD *)(v85 + 8LL * v215);
          sub_BCB4B0(v208, v240, v241);
          v19 = v215;
          v20 = v208;
          *(_QWORD *)(*(_QWORD *)(v4 + 528) + 8LL * v215) = 0;
        }
        else
        {
          v11 = *(_QWORD *)(v4 + 432);
          v163 = sub_9CB8B0(v4, v11, (__int64)v240, v241);
          v19 = v215;
          v20 = v163;
        }
        v241 = 0;
        goto LABEL_34;
      case 7:
        if ( !(_DWORD)v245 )
        {
          v239 = 1;
          v81 = "Invalid integer record";
          goto LABEL_121;
        }
        v11 = *v244;
        if ( (unsigned __int64)(*v244 - 1) > 0x7FFFFF )
        {
          v239 = 1;
          v81 = "Bitwidth for integer type out of range";
          goto LABEL_121;
        }
        v80 = sub_BCCE00(*(_QWORD *)(v4 + 432), v11);
        v19 = v215;
        v20 = v80;
        goto LABEL_34;
      case 8:
        if ( (_DWORD)v245 )
        {
          v73 = 0;
          if ( (_DWORD)v245 == 2 )
            v73 = *((_DWORD *)v244 + 2);
          v74 = sub_9CAD80((_QWORD *)v4, *v244);
          if ( !v74 || (v207 = (_QWORD *)v74, !(unsigned __int8)sub_BCBD20(v74)) )
          {
LABEL_255:
            v239 = 1;
            v81 = "Invalid type";
            goto LABEL_121;
          }
          v75 = v207;
          v76 = *v244;
          v77 = (unsigned int)v233;
          v78 = (unsigned int)v233 + 1LL;
          if ( v78 > HIDWORD(v233) )
          {
            v203 = *v244;
            sub_C8D5F0(&v232, v234, v78, 4);
            v77 = (unsigned int)v233;
            LODWORD(v76) = v203;
            v75 = v207;
          }
          v11 = v73;
          *(_DWORD *)&v232[4 * v77] = v76;
          LODWORD(v233) = v233 + 1;
          v79 = sub_BCE3C0(*v75, v73);
          v19 = v215;
          v20 = v79;
          goto LABEL_34;
        }
        v239 = 1;
        v81 = "Invalid pointer record";
        goto LABEL_121;
      case 9:
        if ( (unsigned int)v245 <= 2 )
          goto LABEL_265;
        v235 = v237;
        v236 = 0x800000000LL;
        if ( (_DWORD)v245 != 3 )
        {
          v193 = v7;
          v69 = 3;
          v70 = v245;
          do
          {
            v71 = sub_9CAD80((_QWORD *)v4, v244[v69]);
            if ( !v71 )
              break;
            v72 = (unsigned int)v236;
            if ( (unsigned __int64)(unsigned int)v236 + 1 > HIDWORD(v236) )
            {
              v177 = v71;
              sub_C8D5F0(&v235, v237, (unsigned int)v236 + 1LL, 8);
              v72 = (unsigned int)v236;
              v71 = v177;
            }
            ++v69;
            *(_QWORD *)&v235[8 * v72] = v71;
            LODWORD(v236) = v236 + 1;
          }
          while ( v69 != v70 );
          v7 = v193;
        }
        v95 = sub_9CAD80((_QWORD *)v4, v244[2]);
        if ( !v95 || (unsigned __int64)(unsigned int)v245 - 3 > (unsigned int)v236 )
          goto LABEL_263;
        v96 = 8LL * (unsigned int)v245;
        v97 = (unsigned int)v233;
        v98 = v244;
        v99 = (__int64)(v96 - 16) >> 3;
        if ( v99 + (unsigned __int64)(unsigned int)v233 > HIDWORD(v233) )
        {
          v179 = 8LL * (unsigned int)v245;
          v186 = v244;
          v198 = v95;
          sub_C8D5F0(&v232, v234, v99 + (unsigned int)v233, 4);
          v97 = (unsigned int)v233;
          v96 = v179;
          v98 = v186;
          v95 = v198;
        }
        v100 = &v232[4 * v97];
        v101 = 0;
        if ( v96 <= 0x10 )
          goto LABEL_157;
        do
        {
          *(_DWORD *)&v100[4 * v101] = v98[v101 + 2];
          ++v101;
        }
        while ( v99 - v101 > 0 );
        goto LABEL_156;
      case 10:
        v82 = sub_BCB140(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v82;
        goto LABEL_34;
      case 11:
        if ( (unsigned int)v245 <= 1 )
        {
          v239 = 1;
          v81 = "Invalid array type record";
          goto LABEL_121;
        }
        v61 = sub_9CAD80((_QWORD *)v4, v244[1]);
        v62 = v61;
        if ( !v61 || !(unsigned __int8)sub_BCBC60(v61) )
          goto LABEL_255;
        v63 = v244[1];
        v64 = (unsigned int)v233;
        v65 = (unsigned int)v233 + 1LL;
        if ( v65 > HIDWORD(v233) )
        {
          v213 = v244[1];
          sub_C8D5F0(&v232, v234, v65, 4);
          v64 = (unsigned int)v233;
          LODWORD(v63) = v213;
        }
        *(_DWORD *)&v232[4 * v64] = v63;
        LODWORD(v233) = v233 + 1;
        v11 = *v244;
        v66 = sub_BCD420(v62, *v244);
        v19 = v215;
        v20 = v66;
        goto LABEL_34;
      case 12:
        if ( (unsigned int)v245 > 1 )
        {
          if ( !*v244 )
          {
            v239 = 1;
            v81 = "Invalid vector length";
            goto LABEL_121;
          }
          v55 = sub_9CAD80((_QWORD *)v4, v244[1]);
          v56 = v55;
          if ( !v55 || !(unsigned __int8)sub_BCBCB0(v55) )
            goto LABEL_255;
          v57 = 0;
          if ( (unsigned int)v245 > 2 )
            v57 = v244[2] != 0;
          v58 = v244[1];
          v59 = (unsigned int)v233;
          v60 = (unsigned int)v233 + 1LL;
          if ( v60 > HIDWORD(v233) )
          {
            v204 = v244[1];
            v214 = v57;
            sub_C8D5F0(&v232, v234, v60, 4);
            v59 = (unsigned int)v233;
            LODWORD(v58) = v204;
            v57 = v214;
          }
          BYTE4(v218) = v57;
          *(_DWORD *)&v232[4 * v59] = v58;
          LODWORD(v233) = v233 + 1;
          LODWORD(v218) = *v244;
          v11 = v218;
          v20 = sub_BCE1B0(v56, v218);
          goto LABEL_92;
        }
        v239 = 1;
        v81 = "Invalid vector type record";
        goto LABEL_121;
      case 13:
        v54 = sub_BCB1A0(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v54;
        goto LABEL_34;
      case 14:
        v87 = sub_BCB1B0(*(_QWORD *)(v4 + 432), v7, v12, (unsigned int)(2 * v12));
        v19 = v215;
        v20 = v87;
        goto LABEL_34;
      case 15:
        v86 = sub_BCB1C0(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v86;
        goto LABEL_34;
      case 16:
        v88 = sub_BCB180(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v88;
        goto LABEL_34;
      case 17:
        v52 = sub_BCCE00(*(_QWORD *)(v4 + 432), 64);
        v11 = 1;
        v53 = sub_BCDA70(v52, 1);
        v19 = v215;
        v20 = v53;
        goto LABEL_34;
      case 18:
        if ( !(_DWORD)v245 )
        {
          v239 = 1;
          v81 = "Invalid anon struct record";
LABEL_121:
          v9 = (__int64 *)(v4 + 8);
          v235 = v81;
          v238 = 3;
          sub_9C81F0(v5, v4 + 8, (__int64)&v235);
          goto LABEL_122;
        }
        v235 = v237;
        v236 = 0x800000000LL;
        if ( (_DWORD)v245 == 1 )
        {
          v108 = 1;
          goto LABEL_170;
        }
        v192 = v7;
        v47 = 1;
        v48 = v245;
        do
        {
          v50 = sub_9CAD80((_QWORD *)v4, v244[v47]);
          if ( !v50 )
          {
            v7 = v192;
            v49 = (unsigned int)v236;
            goto LABEL_169;
          }
          v51 = (unsigned int)v236;
          if ( (unsigned __int64)(unsigned int)v236 + 1 > HIDWORD(v236) )
          {
            v176 = v50;
            sub_C8D5F0(&v235, v237, (unsigned int)v236 + 1LL, 8);
            v51 = (unsigned int)v236;
            v50 = v176;
          }
          ++v47;
          *(_QWORD *)&v235[8 * v51] = v50;
          v49 = (unsigned int)(v236 + 1);
          LODWORD(v236) = v236 + 1;
        }
        while ( v47 != v48 );
        v7 = v192;
LABEL_169:
        v108 = (unsigned int)v245;
        if ( (unsigned int)v245 - 1LL == v49 )
        {
LABEL_170:
          v109 = 8 * v108;
          v110 = (unsigned int)v233;
          v111 = v244;
          v112 = (__int64)(v109 - 8) >> 3;
          if ( v112 + (unsigned __int64)(unsigned int)v233 > HIDWORD(v233) )
          {
            v185 = v109;
            v197 = v244;
            sub_C8D5F0(&v232, v234, v112 + (unsigned int)v233, 4);
            v110 = (unsigned int)v233;
            v109 = v185;
            v111 = v197;
          }
          v113 = &v232[4 * v110];
          v114 = 0;
          if ( v109 > 8 )
          {
            do
            {
              *(_DWORD *)&v113[4 * v114] = v111[v114 + 1];
              ++v114;
            }
            while ( v112 - v114 > 0 );
            LODWORD(v110) = v233;
          }
          v115 = *(_QWORD *)(v4 + 432);
          LODWORD(v233) = v112 + v110;
          v11 = (unsigned __int64)v235;
          v116 = sub_BD0B90(v115, v235, (unsigned int)v236, *v244 != 0);
          v103 = (__int64)v235;
          v20 = v116;
          if ( v235 != v237 )
          {
LABEL_158:
            v209 = v20;
            _libc_free(v103, v11);
            v20 = v209;
          }
LABEL_92:
          v19 = v215;
          goto LABEL_34;
        }
LABEL_263:
        v9 = (__int64 *)(v4 + 8);
        v231 = 1;
        v227 = (__int64)"Invalid type";
        v230 = 3;
        sub_9C81F0(v5, v4 + 8, (__int64)&v227);
        v119 = (__int64)v235;
        if ( v235 == v237 )
          goto LABEL_122;
        goto LABEL_182;
      case 19:
        v40 = (unsigned int)v245;
        v41 = v241;
        v42 = v244;
        v43 = 8LL * (unsigned int)v245;
        v44 = (unsigned int)v245 + v241;
        if ( v44 > v242 )
        {
          v11 = (unsigned __int64)v243;
          v202 = 8LL * (unsigned int)v245;
          v212 = v244;
          sub_C8D290(&v240, v243, v44, 1);
          v41 = v241;
          v43 = v202;
          v42 = v212;
        }
        v45 = &v240[v41];
        v46 = 0;
        if ( v43 )
        {
          do
          {
            v45[v46] = v42[v46];
            ++v46;
          }
          while ( v40 != v46 );
        }
        v241 += v40;
        goto LABEL_71;
      case 20:
        if ( !(_DWORD)v245 )
        {
          v239 = 1;
          v81 = "Invalid named struct record";
          goto LABEL_121;
        }
        v32 = *(_QWORD *)(v4 + 528);
        if ( v215 >= (unsigned __int64)((*(_QWORD *)(v4 + 536) - v32) >> 3) )
          goto LABEL_167;
        if ( *(_QWORD *)(v32 + 8LL * v215) )
        {
          v206 = *(_QWORD *)(v32 + 8LL * v215);
          sub_BCB4B0(v206, v240, v241);
          v33 = v215;
          v34 = v206;
          *(_QWORD *)(*(_QWORD *)(v4 + 528) + 8LL * v215) = 0;
        }
        else
        {
          v164 = sub_9CB8B0(v4, *(_QWORD *)(v4 + 432), (__int64)v240, v241);
          v33 = v215;
          v34 = v164;
        }
        v241 = 0;
        v235 = v237;
        v236 = 0x800000000LL;
        if ( (_DWORD)v245 == 1 )
        {
          v117 = 0;
        }
        else
        {
          v183 = v7;
          v35 = 1;
          v36 = v245;
          v191 = v34;
          v175 = v33;
          do
          {
            v38 = sub_9CAD80((_QWORD *)v4, v244[v35]);
            if ( !v38 )
            {
              v34 = v191;
              v7 = v183;
              v33 = v175;
              v37 = v236;
              goto LABEL_178;
            }
            v39 = (unsigned int)v236;
            if ( (unsigned __int64)(unsigned int)v236 + 1 > HIDWORD(v236) )
            {
              v168 = v38;
              sub_C8D5F0(&v235, v237, (unsigned int)v236 + 1LL, 8);
              v39 = (unsigned int)v236;
              v38 = v168;
            }
            ++v35;
            *(_QWORD *)&v235[8 * v39] = v38;
            v37 = v236 + 1;
            LODWORD(v236) = v236 + 1;
          }
          while ( v35 != v36 );
          v34 = v191;
          v7 = v183;
          v33 = v175;
LABEL_178:
          v117 = v37;
          if ( (unsigned int)v245 - 1LL != v37 )
          {
            v231 = 1;
            v159 = "Invalid named struct record";
LABEL_237:
            v9 = (__int64 *)(v4 + 8);
            v227 = (__int64)v159;
            v230 = 3;
            sub_9C81F0(v5, v4 + 8, (__int64)&v227);
LABEL_181:
            v119 = (__int64)v235;
            if ( v235 == v237 )
              goto LABEL_122;
            goto LABEL_182;
          }
        }
        v184 = v33;
        v194 = v34;
        sub_BD0A20(&v227, v34, v235, v117, *v244 != 0, v34, v165, v166);
        v118 = v227 & 0xFFFFFFFFFFFFFFFELL;
        if ( (v227 & 0xFFFFFFFFFFFFFFFELL) != 0 )
        {
          *v5 = 0;
          v227 = v118 | 1;
          v9 = &v227;
          sub_9C6670(v5, &v227);
          sub_9C66B0(&v227);
          goto LABEL_181;
        }
        v227 = 0;
        sub_9C66B0(&v227);
        v120 = (unsigned int)v233;
        v121 = v244;
        v122 = 8LL * (unsigned int)v245;
        v20 = v194;
        v19 = v184;
        v123 = (__int64)(v122 - 8) >> 3;
        v11 = v123 + (unsigned int)v233;
        if ( v11 > HIDWORD(v233) )
        {
          v11 = (unsigned __int64)v234;
          v169 = (__int64)(v122 - 8) >> 3;
          v172 = v184;
          v180 = 8LL * (unsigned int)v245;
          v187 = v244;
          sub_C8D5F0(&v232, v234, v123 + (unsigned int)v233, 4);
          v120 = (unsigned int)v233;
          v123 = v169;
          v19 = v172;
          v122 = v180;
          v121 = v187;
          v20 = v194;
        }
        a4 = &v232[4 * v120];
        if ( v122 > 8 )
        {
          do
          {
            *(_DWORD *)&a4[4 * v118] = v121[v118 + 1];
            ++v118;
          }
          while ( (__int64)(v123 - v118) > 0 );
          LODWORD(v120) = v233;
        }
        v124 = (__int64)v235;
        LODWORD(v233) = v120 + v123;
        if ( v235 != v237 )
          goto LABEL_189;
        goto LABEL_34;
      case 21:
        if ( (unsigned int)v245 <= 1 )
        {
LABEL_265:
          v239 = 1;
          v81 = "Invalid function record";
          goto LABEL_121;
        }
        v26 = 2;
        v235 = v237;
        v236 = 0x800000000LL;
        if ( (_DWORD)v245 != 2 )
        {
          v174 = v7;
          v27 = v245;
          v190 = v5;
          do
          {
            v28 = sub_9CAD80((_QWORD *)v4, v244[v26]);
            v29 = v28;
            if ( !v28 )
              break;
            if ( !(unsigned __int8)sub_BCB400(v28) )
            {
              v231 = 1;
              v5 = v190;
              v159 = "Invalid function argument type";
              goto LABEL_237;
            }
            v30 = (unsigned int)v236;
            v31 = (unsigned int)v236 + 1LL;
            if ( v31 > HIDWORD(v236) )
            {
              sub_C8D5F0(&v235, v237, v31, 8);
              v30 = (unsigned int)v236;
            }
            ++v26;
            *(_QWORD *)&v235[8 * v30] = v29;
            LODWORD(v236) = v236 + 1;
          }
          while ( v26 != v27 );
          v7 = v174;
          v5 = v190;
        }
        v95 = sub_9CAD80((_QWORD *)v4, v244[1]);
        if ( !v95 || (unsigned __int64)(unsigned int)v245 - 2 > (unsigned int)v236 )
        {
          v231 = 1;
          v159 = "Invalid type";
          goto LABEL_237;
        }
        v104 = 8LL * (unsigned int)v245;
        v97 = (unsigned int)v233;
        v105 = v244;
        v99 = (__int64)(v104 - 8) >> 3;
        if ( v99 + (unsigned __int64)(unsigned int)v233 > HIDWORD(v233) )
        {
          v181 = 8LL * (unsigned int)v245;
          v188 = v244;
          v201 = v95;
          sub_C8D5F0(&v232, v234, v99 + (unsigned int)v233, 4);
          v97 = (unsigned int)v233;
          v104 = v181;
          v105 = v188;
          v95 = v201;
        }
        v106 = &v232[4 * v97];
        v107 = 0;
        if ( v104 > 8 )
        {
          do
          {
            *(_DWORD *)&v106[4 * v107] = v105[v107 + 1];
            ++v107;
          }
          while ( v99 - v107 > 0 );
LABEL_156:
          LODWORD(v97) = v233;
        }
LABEL_157:
        LODWORD(v233) = v99 + v97;
        v11 = (unsigned __int64)v235;
        v102 = sub_BCF480(v95, v235, (unsigned int)v236, *v244 != 0);
        v103 = (__int64)v235;
        v20 = v102;
        if ( v235 != v237 )
          goto LABEL_158;
        goto LABEL_92;
      case 22:
        v24 = sub_BCB190(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v24;
        goto LABEL_34;
      case 23:
        v23 = sub_BCB150(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v23;
        goto LABEL_34;
      case 24:
        v25 = sub_BCB290(*(_QWORD *)(v4 + 432));
        v19 = v215;
        v20 = v25;
        goto LABEL_34;
      case 25:
        if ( (_DWORD)v245 != 1 )
        {
          v239 = 1;
          v81 = "Invalid opaque pointer record";
          goto LABEL_121;
        }
        v11 = *v244;
        v18 = sub_BCE3C0(*(_QWORD *)(v4 + 432), *v244);
        v19 = v215;
        v20 = v18;
        goto LABEL_34;
      case 26:
        if ( !(_DWORD)v245 )
        {
          v239 = 1;
          v81 = "Invalid target extension type record";
          goto LABEL_121;
        }
        v13 = v215;
        if ( v215 >= (unsigned __int64)((__int64)(*(_QWORD *)(v4 + 536) - *(_QWORD *)(v4 + 528)) >> 3) )
          goto LABEL_167;
        v14 = v244;
        v189 = *v244;
        if ( *v244 >= (unsigned __int64)(unsigned int)v245 )
        {
          v239 = 1;
          v81 = "Too many type parameters";
          goto LABEL_121;
        }
        v227 = (__int64)v229;
        v228 = 0x400000000LL;
        v235 = v237;
        v236 = 0x800000000LL;
        if ( !v189 )
        {
          v173 = 1;
LABEL_209:
          if ( v173 < (unsigned int)v245 )
          {
            v131 = v8;
            v132 = 8LL * v173;
            v133 = v5;
            v134 = v13;
            v135 = v4;
            v136 = v7;
            v137 = 8 * (v173 + (unsigned __int64)(unsigned int)(v245 - 2 - v189) + 1);
            v138 = v133;
            while ( 1 )
            {
              v140 = v244[(unsigned __int64)v132 / 8];
              if ( v140 > 0xFFFFFFFF )
                break;
              v141 = (unsigned int)v236;
              v142 = (unsigned int)v236 + 1LL;
              if ( v142 > HIDWORD(v236) )
              {
                v171 = v131;
                v178 = v135;
                v196 = v138;
                sub_C8D5F0(&v235, v237, v142, 4);
                v141 = (unsigned int)v236;
                v131 = v171;
                v135 = v178;
                v138 = v196;
              }
              v132 += 8;
              *(_DWORD *)&v235[4 * v141] = v140;
              v139 = (unsigned int)(v236 + 1);
              LODWORD(v236) = v236 + 1;
              if ( v137 == v132 )
              {
                v7 = v136;
                v5 = v138;
                v4 = v135;
                v13 = v134;
                v8 = v131;
                goto LABEL_240;
              }
            }
            v226 = 1;
            v5 = v138;
            v4 = v135;
            v8 = v131;
            v130 = "Integer parameter too large";
            goto LABEL_200;
          }
          v139 = (unsigned int)v236;
LABEL_240:
          v166 = v139;
          v11 = *(_QWORD *)(v4 + 432);
          v165 = (__int64)v235;
          v199 = v13;
          sub_BCFB10((unsigned int)&v223, v11, (_DWORD)v240, v241, v227, v228, (__int64)v235, v139);
          v160 = (v224 & 1) == 0;
          v224 &= ~2u;
          if ( v160 )
          {
            v216 = 1;
            v217 = 0;
            sub_9C66B0(&v217);
          }
          else
          {
            v161 = v223;
            v223 = 0;
            v217 = 0;
            v216 = (unsigned __int64)v161 | 1;
            sub_9C8CB0(&v217);
          }
          v162 = v216 & 0xFFFFFFFFFFFFFFFELL;
          if ( (v216 & 0xFFFFFFFFFFFFFFFELL) != 0 )
          {
            *v5 = 0;
            v9 = (__int64 *)&v216;
            v216 = v162 | 1;
            sub_9C6670(v5, &v216);
            sub_9C66B0((__int64 *)&v216);
            if ( (v224 & 2) != 0 )
LABEL_272:
              sub_9D22F0(&v223);
            if ( (v224 & 1) != 0 && v223 )
              (*(void (__fastcall **)(char *))(*(_QWORD *)v223 + 8LL))(v223);
            goto LABEL_201;
          }
          v216 = 0;
          sub_9C66B0((__int64 *)&v216);
          v19 = v199;
          if ( (v224 & 2) != 0 )
            goto LABEL_272;
          v241 = 0;
          v20 = (__int64)v223;
          if ( (v224 & 1) != 0 && v223 )
          {
            v182 = v199;
            v205 = (__int64)v223;
            (*(void (__fastcall **)(char *))(*(_QWORD *)v223 + 8LL))(v223);
            v19 = v182;
            v20 = v205;
          }
          if ( v235 != v237 )
          {
            v200 = v19;
            v211 = v20;
            _libc_free(v235, v11);
            v19 = v200;
            v20 = v211;
          }
          v124 = v227;
          if ( (_BYTE *)v227 != v229 )
          {
LABEL_189:
            v195 = v19;
            v210 = v20;
            _libc_free(v124, v11);
            v20 = v210;
            v19 = v195;
          }
LABEL_34:
          v21 = *(_QWORD *)(v4 + 528);
          if ( (*(_QWORD *)(v4 + 536) - v21) >> 3 <= v19 )
            goto LABEL_167;
          v22 = (__int64 *)(v21 + 8 * v19);
          if ( *v22 )
          {
            v239 = 1;
            v81 = "Invalid TYPE table: Only named structs can be forward referenced";
            goto LABEL_121;
          }
          *v22 = v20;
          if ( (_DWORD)v233 )
          {
            v89 = *(_DWORD *)(v4 + 576);
            if ( v89 )
            {
              v90 = *(_QWORD *)(v4 + 560);
              v91 = (v89 - 1) & (37 * v215);
              v92 = (_DWORD *)(v90 + 32LL * v91);
              v93 = *v92;
              if ( *v92 == v215 )
              {
LABEL_140:
                v94 = v92 + 2;
LABEL_141:
                v11 = (unsigned __int64)&v232;
                sub_9C31C0((__int64)v94, &v232);
                goto LABEL_37;
              }
              v125 = 0;
              v126 = 1;
              while ( v93 != -1 )
              {
                if ( v93 == -2 && !v125 )
                  v125 = v92;
                v91 = (v89 - 1) & (v126 + v91);
                v92 = (_DWORD *)(v90 + 32LL * v91);
                v93 = *v92;
                if ( *v92 == v215 )
                  goto LABEL_140;
                ++v126;
              }
              if ( !v125 )
                v125 = v92;
              v127 = *(_DWORD *)(v4 + 568);
              ++*(_QWORD *)(v4 + 552);
              v128 = v127 + 1;
              if ( 4 * (v127 + 1) < 3 * v89 )
              {
                if ( v89 - *(_DWORD *)(v4 + 572) - v128 > v89 >> 3 )
                  goto LABEL_196;
                sub_9D85E0(v4 + 552, v89);
                v153 = *(_DWORD *)(v4 + 576);
                if ( !v153 )
                {
LABEL_293:
                  ++*(_DWORD *)(v4 + 568);
                  BUG();
                }
                v154 = v153 - 1;
                v155 = *(_QWORD *)(v4 + 560);
                LODWORD(v156) = v154 & (37 * v215);
                v128 = *(_DWORD *)(v4 + 568) + 1;
                v125 = (unsigned int *)(v155 + 32LL * (unsigned int)v156);
                v157 = *v125;
                if ( *v125 == v215 )
                  goto LABEL_196;
                v148 = (unsigned int *)(v155 + 32LL * (unsigned int)v156);
                v158 = 1;
                v125 = 0;
                while ( v157 != -1 )
                {
                  if ( !v125 && v157 == -2 )
                    v125 = v148;
                  v156 = v154 & (unsigned int)(v156 + v158);
                  v148 = (unsigned int *)(v155 + 32 * v156);
                  v157 = *v148;
                  if ( *v148 == v215 )
                    goto LABEL_235;
                  ++v158;
                }
                goto LABEL_220;
              }
            }
            else
            {
              ++*(_QWORD *)(v4 + 552);
            }
            sub_9D85E0(v4 + 552, 2 * v89);
            v143 = *(_DWORD *)(v4 + 576);
            if ( !v143 )
              goto LABEL_293;
            v144 = v143 - 1;
            v145 = *(_QWORD *)(v4 + 560);
            LODWORD(v146) = v144 & (37 * v215);
            v128 = *(_DWORD *)(v4 + 568) + 1;
            v125 = (unsigned int *)(v145 + 32LL * (unsigned int)v146);
            v147 = *v125;
            if ( *v125 == v215 )
              goto LABEL_196;
            v148 = (unsigned int *)(v145 + 32LL * (v144 & (37 * v215)));
            v149 = 1;
            v125 = 0;
            while ( v147 != -1 )
            {
              if ( !v125 && v147 == -2 )
                v125 = v148;
              v146 = v144 & (unsigned int)(v146 + v149);
              v148 = (unsigned int *)(v145 + 32 * v146);
              v147 = *v148;
              if ( *v148 == v215 )
              {
LABEL_235:
                v125 = v148;
                goto LABEL_196;
              }
              ++v149;
            }
LABEL_220:
            if ( !v125 )
              v125 = v148;
LABEL_196:
            *(_DWORD *)(v4 + 568) = v128;
            if ( *v125 != -1 )
              --*(_DWORD *)(v4 + 572);
            *v125 = v215;
            v129 = v125 + 6;
            v94 = v125 + 2;
            *v94 = v129;
            v94[1] = 0x100000000LL;
            goto LABEL_141;
          }
LABEL_37:
          ++v215;
          if ( (v222 & 2) != 0 )
            goto LABEL_144;
          if ( (v222 & 1) != 0 && v221 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v221 + 8LL))(v221);
          if ( v232 != v234 )
            _libc_free(v232, v11);
          if ( (v220 & 2) != 0 )
            goto LABEL_21;
          if ( (v220 & 1) != 0 && v219 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v219 + 8LL))(v219);
          continue;
        }
        v167 = v7;
        v173 = v189 + 1;
        v15 = 1;
        while ( 1 )
        {
          v16 = sub_9CAD80((_QWORD *)v4, v14[v15]);
          if ( !v16 )
            break;
          v17 = (unsigned int)v228;
          if ( (unsigned __int64)(unsigned int)v228 + 1 > HIDWORD(v228) )
          {
            v170 = v16;
            sub_C8D5F0(&v227, v229, (unsigned int)v228 + 1LL, 8);
            v17 = (unsigned int)v228;
            v16 = v170;
          }
          ++v15;
          *(_QWORD *)(v227 + 8 * v17) = v16;
          LODWORD(v228) = v228 + 1;
          if ( (unsigned int)(v189 + 1) == v15 )
          {
            v7 = v167;
            v13 = v215;
            goto LABEL_209;
          }
          v14 = v244;
        }
        v226 = 1;
        v130 = "Invalid type";
LABEL_200:
        v9 = (__int64 *)(v4 + 8);
        v223 = v130;
        v225 = 3;
        sub_9C81F0(v5, v4 + 8, (__int64)&v223);
LABEL_201:
        if ( v235 != v237 )
          _libc_free(v235, v9);
        v119 = v227;
        if ( (_BYTE *)v227 != v229 )
LABEL_182:
          _libc_free(v119, v9);
LABEL_122:
        if ( (v222 & 2) != 0 )
LABEL_144:
          sub_9CE230(&v221);
        if ( (v222 & 1) != 0 && v221 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v221 + 8LL))(v221);
        if ( v232 != v234 )
          _libc_free(v232, v9);
LABEL_11:
        if ( (v220 & 2) != 0 )
LABEL_21:
          sub_9CEF10(v8);
        if ( (v220 & 1) != 0 && v219 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v219 + 8LL))(v219);
LABEL_13:
        if ( v240 != v243 )
          _libc_free(v240, v9);
        if ( v244 != (__int64 *)v246 )
          _libc_free(v244, v9);
        return v5;
      default:
        v239 = 1;
        v81 = "Invalid value";
        goto LABEL_121;
    }
  }
}
